<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Kotlin知识点总结</title>
      <link href="/2020/04/15/android-kotlin/"/>
      <url>/2020/04/15/android-kotlin/</url>
      
        <content type="html"><![CDATA[<p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言 ，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>创建<strong>一种兼容Java的语言</strong></p><p>让它比Java更<strong>安全</strong>，能够静态检测常见的陷阱。如：引用空指针</p><p>让它比Java更<strong>简洁</strong>，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。</p><p>Kotlin，类似 Xtend 一样，<strong>旨在提供一种更好的 Java</strong> 而非重建整个新平台。这两种语言都向下编译为字节码（虽然 Xtend 是首先转换成相应的 Java 代码，再让 Java 编译器完成繁重的工作），而且两者都引入了函数和扩展函数（在某个有限范围内静态地增加一个新方法到某个已有类型的能力）。Xtend 是基于 Eclipse 的，而 Kotlin 是基于 IntelliJ 的，两者都提供无界面构建。</p><h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>调用某个方法实际上将程序执行顺序转移到该方法所存放在内存中某个地址，将方法的程序内容执行完后，再返回到转去执行该方法前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。也就是通常说的压栈和出栈。因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大。 因此<strong>对于这种内容较短却又反复使用的方法我们可以通过使用内联函数来提升运行效率</strong>。</p><p>java中final关键字只是告诉编译器，在编译的时候考虑性能的提升，可以将final函数视为内联函数。但最后编译器会怎么处理，编译器会分析将final函数处理为内联和不处理为内联的性能比较了。（和垃圾处理机制类似，<strong>程序员只有建议权而没有决定权</strong>）</p><p>inline 的工作原理就是<strong>将内联函数的函数体复制到调用处实现内联</strong>。</p><p>inline 修饰符<strong>影响函数本身和传给它的 lambda 表达式：所有这些都将内联到调用处</strong>。</p><p>内联可能导致生成的代码增加；不过如果我们使用得当（即避免内联过大函数），性能上会有所提升，尤其是在循环中的“超多态（megamorphic）”调用处。</p><p>reified: 普通函数（非内联函数），不能包含具体化类型参数；若一个类型没有运行时表示（run-time representation）（如非具体化类型参数（non-reified type parameter）或虚拟类型，比如“Nothing”）不能作为一个具体化类型参数的实参。</p><p>公有 API 内联函数体内不允许使用非公有声明。</p><p><img src="/2020/04/15/android-kotlin/kotlin_inline.png" alt></p><p>在Kotlin中对Java中的一些的接口的回调做了一些优化，可以使用一个lambda函数来代替。可以简化写一些不必要的嵌套回调方法。但是需要注意:在lambda表达式，只支持单抽象方法模型，也就是说设计的接口里面只有一个抽象的方法，才符合lambda表达式的规则，多个回调方法不支持。</p><h3 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h3><blockquote><p>@kotlin.internal.InlineOnly<br>public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</p></blockquote><p>let函数适用的场景<br>场景一: 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。<br>场景二: 然后就是需要去明确一个变量所处特定的作用域范围内可以使用</p><h3 id="With"><a href="#With" class="headerlink" title="With"></a>With</h3><blockquote><p>@kotlin.internal.InlineOnly<br>public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</p></blockquote><p>with函数的适用的场景<br>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//java实现</span><br><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class="line">    ArticleSnippet item = getItem(position);</span><br><span class="line">    if (item == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    holder.tvNewsTitle.setText(StringUtils.trimToEmpty(item.titleEn));</span><br><span class="line">    holder.tvNewsSummary.setText(StringUtils.trimToEmpty(item.summary));</span><br><span class="line">    String gradeInfo = &quot;难度：&quot; + item.gradeInfo;</span><br><span class="line">    String wordCount = &quot;单词数：&quot; + item.length;</span><br><span class="line">    String reviewNum = &quot;读后感：&quot; + item.numReviews;</span><br><span class="line">    String extraInfo = gradeInfo + &quot; | &quot; + wordCount + &quot; | &quot; + reviewNum;</span><br><span class="line">    holder.tvExtraInfo.setText(extraInfo);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//kotlin实现</span><br><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: return</span><br><span class="line"> </span><br><span class="line">   with(item)&#123;</span><br><span class="line">       holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf.text = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><blockquote><p>@kotlin.internal.InlineOnly<br>public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</p></blockquote><p>适用于let,with函数任何场景。因为run函数是let,with两个函数结合体，准确来说它弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样可以省略，直接访问实例的公有属性和方法，另一方面它弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//借助上个例子kotlin代码,使用run函数后的优化</span><br><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line"> </span><br><span class="line">  getItem(position)?.run&#123;</span><br><span class="line">       holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><blockquote><p>@kotlin.internal.InlineOnly<br>public inline fun <t> T.apply(block: T.() -&gt; Unit): T { block(); return this }</t></p></blockquote><p>从结构上来看apply函数和run函数很像，唯一不同点就是它们各自返回的值不一样，<strong>run函数是以闭包形式返回最后一行代码的值，而apply函数的返回的是传入对象的本身</strong>。apply一般用于一个对象实例初始化的时候，需要对对象中的属性进行赋值。或者动态inflate出一个XML的View的时候需要给View绑定数据也会用到，这种情景非常常见。特别是在我们开发中会有一些数据model向View model转化实例化的过程中需要用到。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null).apply&#123;</span><br><span class="line">   course_comment_tv_label.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_score.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_cancel.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_confirm.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_seek_bar.max = 10</span><br><span class="line">   course_comment_seek_bar.progress = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多层级判空示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mSectionMetaData?.apply&#123;</span><br><span class="line"> </span><br><span class="line">//mSectionMetaData不为空的时候操作mSectionMetaData</span><br><span class="line"> </span><br><span class="line">&#125;?.questionnaire?.apply&#123;</span><br><span class="line"> </span><br><span class="line">//questionnaire不为空的时候操作questionnaire</span><br><span class="line"> </span><br><span class="line">&#125;?.section?.apply&#123;</span><br><span class="line"> </span><br><span class="line">//section不为空的时候操作section</span><br><span class="line"> </span><br><span class="line">&#125;?.sectionArticle?.apply&#123;</span><br><span class="line"> </span><br><span class="line">//sectionArticle不为空的时候操作sectionArticle</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Also"><a href="#Also" class="headerlink" title="Also"></a>Also</h3><blockquote><p>@kotlin.internal.InlineOnly<br>@SinceKotlin(“1.1”)<br>public inline fun <t> T.also(block: (T) -&gt; Unit): T { block(this); return this }</t></p></blockquote><p>适用于let函数的任何场景，also函数和let很像，只是唯一的不同点就是<strong>let函数最后的返回值是最后一行的返回值，而also函数的返回值是返回当前的这个对象</strong>。一般可用于多个扩展函数链式调用</p><h2 id="协程Coroutine"><a href="#协程Coroutine" class="headerlink" title="协程Coroutine"></a>协程Coroutine</h2><p>协程就像非常轻量级的线程，<strong>是运行在单线程中的并发程序</strong>。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p><p>线程是由系统调度的，线程切换或线程阻塞的开销都比较大（涉及到同步锁；涉及到线程阻塞状态和可运行状态之间的切换；涉及到线程上下文的切换）。而<strong>协程依赖于线程，但协程挂起时不需要阻塞线程，几乎是无代价的，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）</strong>。因此，协程的开销远远小于线程的开销。</p><p><img src="/2020/04/15/android-kotlin/coroutines.jpeg" alt></p><blockquote><p>对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。协程能保留上一次调用时的状态，不需要像线程一样用回调函数，所以性能上会有提升。<strong>缺点是本质是个单线程，不能利用到单个CPU的多个核。</strong></p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>我们可以使用 <strong>launch</strong> 或 <strong>async</strong> 来启动一个新的 coroutine。</p><p>从概念上讲，async 和 launch 是类似的，区别在于 launch 会返回一个 Job 对象，不会携带任何结果值。而 async 则是返回一个 Deferred - 一个轻量级、非阻塞的 future，代表了之后将会提供结果值的承诺（promise），因此可以使用 .await() 来获得其最终的结果，当然 Deferred 也是一个 Job，如果需要也是可以取消的。</p><p>launch + async (execute task)<br>父协程（The parent coroutine）使用 uiContext 通过 launch 启动。<br>子协程（The child coroutine）使用 CommonPool context 通过 async 启动。</p><p>async + async<br>当通过 async 来启动父协程时，将会忽略掉任何异常。</p><h3 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h3><p>kotlin 中 GlobalScope 类提供了几个构造函数：</p><ul><li>launch - 创建协程</li><li>async - 创建带返回值的协程，返回的是 Deferred 类</li><li>withContext - 不创建新的协程，在指定协程上运行代码块</li><li>runBlocking - 不是 GlobalScope 的 API，可以独立使用，区别是 runBlocking 里面的 delay 会阻塞线程，而 launch 创建的不会</li></ul><p>kotlin 在 1.3 之后要求协程必须由 CoroutineScope 创建，CoroutineScope 不阻塞当前线程，在后台创建一个新协程，也可以指定协程调度器。比如 CoroutineScope.launch{} 可以看成 new Coroutine</p><h3 id="suspend-关键字"><a href="#suspend-关键字" class="headerlink" title="suspend 关键字"></a>suspend 关键字</h3><p>协程天然亲近方法，协程表现为标记、切换方法、代码段，协程里使用 suspend 关键字修饰方法，既该方法可以被协程挂起，没用suspend修饰的方法不能参与协程任务，suspend修饰的方法只能在协程中只能与另一个suspend修饰的方法交流</p><p>suspend 表示挂起的意思，用来修饰方法的，一个协程内有多个 suspend 修饰的方法顺序书写时，代码也是顺序运行的，为什么，suspend 函数会将整个协程挂起，而不仅仅是这个 suspend 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">suspend fun requestToken(): Token &#123; ... &#125;   // 挂起函数</span><br><span class="line">suspend fun createPost(token: Token, item: Item): Post &#123; ... &#125;  // 挂起函数</span><br><span class="line"></span><br><span class="line">fun postItem(item: Item) &#123;</span><br><span class="line">    GlobalScope.launch &#123; // 创建一个新协程</span><br><span class="line">        val token = requestToken()</span><br><span class="line">        val post = createPost(token, item)</span><br><span class="line">        processPost(post)</span><br><span class="line">        // 需要异常处理，直接加上 try/catch 语句即可</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="relay、yield-区别"><a href="#relay、yield-区别" class="headerlink" title="relay、yield 区别"></a>relay、yield 区别</h3><p>relay 和 yield 方法是协程内部的操作，可以挂起协程，区别是 relay 是挂起协程并经过执行时间恢复协程，当线程空闲时就会运行协程；yield 是挂起协程，让协程放弃本次 cpu 执行机会让给别的协程，当线程空闲时再次运行协程。我们只要使用 kotlin 提供的协程上下文类型，线程池是有多个线程的，再次执行的机会很快就会有的。</p><p>除了 main 类型，协程在挂起后都会封装成任务放到协程默认线程池的任务队列里去，有延迟时间的在时间过后会放到队列里去，没有延迟时间的直接放到队列里去</p><h2 id="委托by"><a href="#委托by" class="headerlink" title="委托by"></a>委托by</h2><p>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。</p><h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p><p>以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建接口</span><br><span class="line">interface Base &#123;   </span><br><span class="line">    fun print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现此接口的被委托的类</span><br><span class="line">class BaseImpl(val x: Int) : Base &#123;</span><br><span class="line">    override fun print() &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过关键字 by 建立委托类</span><br><span class="line">class Derived(b: Base) : Base by b</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val b = BaseImpl(10)</span><br><span class="line">    Derived(b).print() // 输出 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p><h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。</p><p>属性委托语法格式：</p><blockquote><p>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</p></blockquote><ul><li>var/val：属性类型(可变/只读)</li><li>属性名：属性名称</li><li>类型：属性的数据类型</li><li>表达式：委托代理类</li></ul><p>by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。<strong>属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。</strong></p><p>该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，prop 为进行委托的属性的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import kotlin.reflect.KProperty</span><br><span class="line">// 定义包含属性委托的类</span><br><span class="line">class Example &#123;</span><br><span class="line">    var p: String by Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 委托的类</span><br><span class="line">class Delegate &#123;</span><br><span class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</span><br><span class="line">        return &quot;$thisRef, 这里委托了 $&#123;property.name&#125; 属性&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;</span><br><span class="line">        println(&quot;$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val e = Example()</span><br><span class="line">    println(e.p)     // 访问该属性，调用 getValue() 函数</span><br><span class="line"></span><br><span class="line">    e.p = &quot;Runoob&quot;   // 调用 setValue() 函数</span><br><span class="line">    println(e.p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">Example@433c675d, 这里委托了 p 属性</span><br><span class="line">Example@433c675d 的 p 属性赋值为 Runoob</span><br><span class="line">Example@433c675d, 这里委托了 p 属性</span><br></pre></td></tr></table></figure></p><h3 id="延迟属性-Lazy"><a href="#延迟属性-Lazy" class="headerlink" title="延迟属性 Lazy"></a>延迟属性 Lazy</h3><p>lazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy <t> 实例的函数，返回的实例可以作为实现延迟属性的委托： <strong>第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val lazyValue: String by lazy &#123;</span><br><span class="line">    println(&quot;computed!&quot;)     // 第一次调用输出，第二次调用不执行</span><br><span class="line">    &quot;Hello&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(lazyValue)   // 第一次执行，执行两次输出表达式</span><br><span class="line">    println(lazyValue)   // 第二次执行，只输出返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行输出结果：</span><br><span class="line">computed!</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></t></p><p>你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun example(computeFoo: () -&gt; Foo) &#123;</span><br><span class="line">    val memoizedFoo by lazy(computeFoo)</span><br><span class="line"></span><br><span class="line">    if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;</span><br><span class="line">        memoizedFoo.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。</p><h3 id="提供委托provideDelegate"><a href="#提供委托provideDelegate" class="headerlink" title="提供委托provideDelegate"></a>提供委托provideDelegate</h3><p>通过定义 provideDelegate 操作符，<strong>可以扩展创建属性实现所委托对象的逻辑</strong>。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。</p><p>provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。</p><p>例如，如果要在绑定之前检查属性名称，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123;</span><br><span class="line">    operator fun provideDelegate(</span><br><span class="line">            thisRef: MyUI,</span><br><span class="line">            prop: KProperty&lt;*&gt;</span><br><span class="line">    ): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">        checkProperty(thisRef, prop.name)</span><br><span class="line">        // 创建委托</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">class MyUI &#123;</span><br><span class="line">    val image by bindResource(ResourceID.image_id)</span><br><span class="line">    val text by bindResource(ResourceID.text_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>provideDelegate 的参数与 getValue 相同：</p><blockquote><p>thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型<br>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。</p></blockquote><p>在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。</p><p>如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 检查属性名称而不使用“provideDelegate”功能</span><br><span class="line">class MyUI &#123;</span><br><span class="line">    val image by bindResource(ResourceID.image_id, &quot;image&quot;)</span><br><span class="line">    val text by bindResource(ResourceID.text_id, &quot;text&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; MyUI.bindResource(</span><br><span class="line">        id: ResourceID&lt;T&gt;,</span><br><span class="line">        propertyName: String</span><br><span class="line">): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">   checkProperty(this, propertyName)</span><br><span class="line">   // 创建委托</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    var prop: Type by MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这段代码是当“provideDelegate”功能可用时</span><br><span class="line">// 由编译器生成的代码：</span><br><span class="line">class C &#123;</span><br><span class="line">    // 调用“provideDelegate”来创建额外的“delegate”属性</span><br><span class="line">    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)</span><br><span class="line">    val prop: Type</span><br><span class="line">        get() = prop$delegate.getValue(this, this::prop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。</p><h2 id="双冒号"><a href="#双冒号" class="headerlink" title="双冒号 ::"></a>双冒号 ::</h2><p>Kotlin 中 双冒号操作符 表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。</p><p>一般情况，我们调用当前类的方法 this 都是可省略的。为了防止作用域混淆 ，:: 调用的函数如果是类的成员函数或者是扩展函数，必须使用限定符,比如this。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/Zachary_46/article/details/80446851" target="_blank" rel="noopener">https://blog.csdn.net/Zachary_46/article/details/80446851</a><br><a href="https://www.runoob.com/kotlin/kotlin-delegated.html" target="_blank" rel="noopener">https://www.runoob.com/kotlin/kotlin-delegated.html</a><br><a href="https://www.jianshu.com/p/76d2f47b900d" target="_blank" rel="noopener">https://www.jianshu.com/p/76d2f47b900d</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack</title>
      <link href="/2020/04/09/android-jetpack/"/>
      <url>/2020/04/09/android-jetpack/</url>
      
        <content type="html"><![CDATA[<p>Google 在2018年推出了 Android Jetpack。Jetpack 是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。</p><p>Android Jetpack 组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用 Kotlin 语言功能帮助您提高工作效率。可全部使用，也可混合搭配！Jetpack 也包含了与平台 API 解除捆绑的 androidx.* 软件包库。</p><p>特点如下：</p><ul><li>加速开发：组件可以单独采用（不过这些组件是为协同工作而构建的），同时利用 Kotlin 语言功能帮助您提高工作效率。</li><li>消除样板代码：Android Jetpack 可管理繁琐的 Activity（如后台任务、导航和生命周期管理），以便您可以专注于如何让自己的应用出类拔萃。</li><li>构建高质量的强大应用：Android Jetpack 组件围绕现代化设计实践构建而成，具有向后兼容性，可以减少崩溃和内存泄漏。</li></ul><h2 id="JetPack的组成"><a href="#JetPack的组成" class="headerlink" title="JetPack的组成"></a>JetPack的组成</h2><p><img src="/2020/04/09/android-jetpack/jetpack-composition.png" alt></p><p>WorkManager很强大，需要的地方可以替代以前的方案。LifeCycles也不错，扩展其他类具有关联生命周期的。还有Room数据库的框架，简单了很多。LiveData和ViewModel的结合基本上就是RxJava和RxAndroid的结合的功能了。</p><h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><p>Navigation是一个可简化Android导航的库和插件</p><p>Navigation是用来<strong>管理Fragment的切换</strong>，并且可以通过可视化的方式，看见App的交互流程。这完美的契合了Jake Wharton大神<strong>单Activity</strong>的建议。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>处理Fragment的切换（上文已说过）</li><li>默认情况下正确处理Fragment的前进和后退</li><li>为过渡和动画提供标准化的资源</li><li>实现和处理深层连接</li><li>可以绑定Toolbar、BottomNavigationView和ActionBar等</li><li>SafeArgs（Gradle插件） 数据传递时提供类型安全性</li><li>ViewModel支持</li></ul><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ol><li><p>Navigation Graph(New XML resource)： 这是一个新的资源文件，用户在可视化界面可以看出他能够到达的Destination(用户能够到达的屏幕界面)，以及流程关系。</p></li><li><p>NavHostFragment(Layout XML view)： 当前Fragment的容器</p></li><li><p>NavController(Kotlin/Java object)： 导航的控制者</p></li></ol><p>可能我这么解释还是有点抽象，做一个不是那么恰当的比喻，我们可以将Navigation Graph看作一个地图，NavHostFragment看作一个车，以及把NavController看作车中的方向盘，Navigation Graph中可以看出各个地点（Destination）和通往各个地点的路径，NavHostFragment可以到达地图中的各个目的地，但是决定到什么目的地还是方向盘NavController，虽然它取决于开车人（用户）。</p><h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><table><thead><tr><th>属性</th><th>解释</th></tr></thead><tbody><tr><td>app:startDestination</td><td>navigation标签: 默认的起始位置</td></tr><tr><td>app:destination</td><td>action标签: 跳转完成到达的fragment的Id</td></tr><tr><td>app:popUpTo</td><td>action标签: 将fragment从栈中弹出，直到某个Id的fragment</td></tr><tr><td>app:argType</td><td>argument标签: 标签的类型</td></tr><tr><td>android:defaultValue</td><td>argument标签: 默认值</td></tr><tr><td>app:navGraph</td><td>fragment标签: 存放的是第二步建好导航的资源文件，也就是确定了Navigation Graph</td></tr><tr><td>app:defaultNavHost=”true”</td><td>fragment标签: 与系统的返回按钮相关联</td></tr></tbody></table><p>导航示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">btnLogin.setOnClickListener &#123;</span><br><span class="line">            // 设置动画参数</span><br><span class="line">            val navOption = navOptions &#123;</span><br><span class="line">                anim &#123;</span><br><span class="line">                    enter = R.anim.slide_in_right</span><br><span class="line">                    exit = R.anim.slide_out_left</span><br><span class="line">                    popEnter = R.anim.slide_in_left</span><br><span class="line">                    popExit = R.anim.slide_out_right</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 参数设置</span><br><span class="line">            val bundle = Bundle()</span><br><span class="line">            bundle.putString(&quot;name&quot;,&quot;TeaOf&quot;)</span><br><span class="line">            findNavController().navigate(R.id.login, bundle,navOption)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不用Safe Args，action可以由Navigation.createNavigateOnClickListener(R.id.next_action, null)方式生成</p><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p><img src="/2020/04/09/android-jetpack/livedata.png" alt></p><p>LiveData有个内部类LifecycleBoundObserver，它实现了GenericLifecycleObserver，而GenericLifecycleObserver继承了LifecycleObserver接口。当组件（Fragment、Activity）生命周期变化时会通过onStateChanged()方法回调过来。</p><p>LiveData主要涉及到的时序有三个：<br>在Fragment/Activity中通过LiveData.observer()添加观察者（observer()方法中的第二个参数）。<br>根据Fragment/Activity生命周期发生变化时，移除观察者或者通知观察者更新数据。<br>当调用LiveData的setValue()、postValue()方法后，通知观察者更新数据(setValue必须发生在主线程,如果当前线程是子线程可以使用postValue)。</p><p>在LiveData.observe()方法中添加了组件（实现了LifecycleOwner接口的Fragment和Activity）生命周期观察者。而这个观察者就是LifecycleBoundObserver对象.</p><p><strong>应用及知识点</strong>：</p><ol><li><p>使用ViewModel在同一个Activity中的Fragment之间共享数据：想要利用ViewModel实现Fragment之间数据共享，前提是Fragment中的FragmentActivity得相同。</p></li><li><p>map是你将你的函数用于你传参的livedata的数据通过函数体中的逻辑改变，然后将结果传到下游。而switchmap，转换跟map差不多，只不过传到下游的是<strong>livedata类型</strong>。</p></li><li><p>MediatorLiveData 是 LiveData 的子类，允许您合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。</p></li><li><p>使用LiveData共享数据：定义一个类然后继承LiveData，并使用单例模式即可。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 登录信息</span><br><span class="line">data class LoginInfo constructor(val account:String, val pwd:String, val email:String)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义单例LiveData</span><br><span class="line"> */</span><br><span class="line">class LoginLiveData:LiveData&lt;LoginInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private lateinit var sInstance: LoginLiveData</span><br><span class="line"></span><br><span class="line">        @MainThread</span><br><span class="line">        fun get(): LoginLiveData &#123;</span><br><span class="line">            sInstance = if (::sInstance.isInitialized) sInstance else LoginLiveData()</span><br><span class="line">            return sInstance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意：您可以使用 observeForever(Observer) 方法来注册未关联 LifecycleOwner 对象的观察者。在这种情况下，观察者会被视为始终处于活跃状态，因此它始终会收到关于修改的通知。您可以通过调用 removeObserver(Observer) 方法来移除这些观察者。</p><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel类是被设计用来以可感知生命周期的方式存储和管理 UI 相关数据，ViewModel中数据会一直存活即使 activity configuration发生变化，比如横竖屏切换的时候。</p><p>由于 ViewModel 生命周期可能长与 activity 生命周期，所以为了避免内存泄漏 Google 禁止在 ViewModel 中持有 Context 或 activity 或 view 的引用。</p><p><img src="/2020/04/09/android-jetpack/viewmodel-lifecycle.webp" alt title="ViewModel生命周期"></p><p>viewmodel初始化：</p><blockquote><p>ViewModelProviders.of(activity，factory).get(MyViewModel.class)</p></blockquote><p>1、初始化了<strong>ViewModelProvider内部维护了 用于创建 VM 的 Factory，和用户存放 VM 的ViewModelStore</strong>；<br>2、初始化了 用来生成 ViewModel 的 Factory（默认为DefaultFactory）；<br>3、通过ViewModelStores的静态方法实例化了 HolderFragment，并实例化了ViewModelStore<br>4、然后是ViewModelProvider的 get 方法</p><p><img src="/2020/04/09/android-jetpack/viewmodel-init.png" alt title="ViewModel初始化"></p><h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><p><img src="/2020/04/09/android-jetpack/room.webp" alt></p><h2 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h2><p><img src="/2020/04/09/android-jetpack/data-binding.webp" alt></p><h2 id="相关应用架构"><a href="#相关应用架构" class="headerlink" title="相关应用架构"></a>相关应用架构</h2><p><img src="/2020/04/09/android-jetpack/jetpack-architecture.png" alt></p><blockquote><p>注意：任何应用编写方式都不可能是每种情况的最佳选择。话虽如此，但推荐的这个架构是个不错的起点，适合大多数情况和工作流。如果您已经有编写 Android 应用的好方法（遵循常见的架构原则），则无需更改。</p></blockquote><h3 id="常见的架构原则"><a href="#常见的架构原则" class="headerlink" title="常见的架构原则"></a>常见的架构原则</h3><p>如果您不应使用应用组件存储应用数据和状态，那么您应该如何设计应用呢？</p><p><strong>分离关注点</strong></p><p>要遵循的最重要的原则是分离关注点。一种常见的错误是在一个 Activity 或 Fragment 中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。您应尽可能使这些类保持精简，这样可以避免许多与生命周期相关的问题。</p><p>请注意，您并非拥有 Activity 和 Fragment 的实现；它们只是表示 Android 操作系统与应用之间关系的粘合类。操作系统可能会根据用户互动或因内存不足等系统条件随时销毁它们。为了提供令人满意的用户体验和更易于管理的应用维护体验，您最好尽量减少对它们的依赖。</p><p><strong>通过模型驱动界面</strong></p><p>另一个重要原则是您应该通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。它们独立于应用中的 View 对象和应用组件，因此不受应用的生命周期以及相关的关注点的影响。</p><p>持久性是理想之选，原因如下：</p><ul><li>如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据。</li><li>当网络连接不稳定或不可用时，应用会继续工作。</li></ul><p>应用所基于的模型类<strong>应明确定义数据管理职责</strong>，这样将使应用更可测试且更一致。</p><h3 id="最佳做法"><a href="#最佳做法" class="headerlink" title="最佳做法"></a>最佳做法</h3><p>编程是一个创造性的领域，构建 Android 应用也不例外。无论是在多个 Activity 或 Fragment 之间传递数据，检索远程数据并将其保留在本地以在离线模式下使用，还是复杂应用遇到的任何其他常见情况，解决问题的方法都会有很多种。</p><p>虽然以下建议不是强制性的，但根据我们的经验，从长远来看，遵循这些建议会使您的代码库更强大、可测试性更高且更易维护：</p><p><strong>避免将应用的入口点（如 Activity、Service 和广播接收器）指定为数据源。</strong></p><p>相反，您应只将其与其他组件协调，以检索与该入口点相关的数据子集。每个应用组件存在的时间都很短暂，具体取决于用户与其设备的交互情况以及系统当前的整体运行状况。</p><p><strong>在应用的各个模块之间设定明确定义的职责界限。</strong></p><p>例如，请勿在代码库中将从网络加载数据的代码散布到多个类或软件包中。同样，也不要将不相关的职责（如数据缓存和数据绑定）定义到同一个类中。</p><p><strong>尽量少公开每个模块中的代码。</strong></p><p>请勿试图创建“就是那一个”快捷方式来呈现一个模块的内部实现细节。短期内，您可能会省点时间，但随着代码库的不断发展，您可能会反复陷入技术上的麻烦。</p><p><strong>考虑如何使每个模块可独立测试。</strong></p><p>例如，如果使用明确定义的 API 从网络获取数据，将会更容易测试在本地数据库中保留该数据的模块。如果您将这两个模块的逻辑混放在一处，或将网络代码分散在整个代码库中，那么即便能够进行测试，难度也会大很多。</p><p><strong>专注于应用的独特核心，以使其从其他应用中脱颖而出。</strong></p><p>不要一次又一次地编写相同的样板代码，这是在做无用功。相反，您应将时间和精力集中放在能让应用与众不同的方面上，并让 Android 架构组件以及建议的其他库处理重复的样板。</p><p><strong>保留尽可能多的相关数据和最新数据。</strong></p><p>这样，即使用户的设备处于离线模式，他们也可以使用您应用的功能。请注意，并非所有用户都能享受到稳定的高速连接。</p><p><strong>将一个数据源指定为单一可信来源。</strong></p><p>每当应用需要访问这部分数据时，这部分数据都应一律源于此单一可信来源。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.google.cn/jetpack?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/jetpack?hl=zh_cn</a><br><a href="https://www.jianshu.com/p/66b93df4b7a6" target="_blank" rel="noopener">https://www.jianshu.com/p/66b93df4b7a6</a><br><a href="https://github.com/googlecodelabs/android-navigation" target="_blank" rel="noopener">android-navigation demo</a><br><a href="https://www.jianshu.com/p/35d143e84d42" target="_blank" rel="noopener">深入了解架构组件之ViewModel</a><br><a href="https://developer.android.google.cn/jetpack/docs/guide?hl=zh_cn#recommended-app-arch" target="_blank" rel="noopener">应用架构指南</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VirtualApp沙盒基本原理</title>
      <link href="/2020/04/07/android-plugin-virtualApp/"/>
      <url>/2020/04/07/android-plugin-virtualApp/</url>
      
        <content type="html"><![CDATA[<p>VirtualApp是一款运行于Android系统的沙盒产品，可以理解为轻量级的“Android虚拟机”。是一个开源的Android App虚拟化引擎，允许在其中创建虚拟空间，并在这个虚拟空间中运行其他应用。</p><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>Android应用隔离是基于Linux系统的多用户机制实现的，即每个应用在安装时被分配了不同的Linux用户uid/gid。而在VirtualApp中，client应用（通过VirtualApp安装的应用）与host应用（即VirtualApp本身）是<strong>具有相同用户uid</strong>的。</p><p>因此，VirtualApp在运行时，包含以下三部分：</p><ul><li>Main Process，进程名io.virtualapp，主要负责VirtualApp用户界面及应用管理</li><li>Server Process，进程名io.virtualapp:x，主要负责系统服务的代理，是通过Content Provider启动的</li><li>VApp Process，进程名io.virtualapp:p[0-…]，作为将来运行client应用的进程，当client应用启动后，其进程名会更新为client应用的包名</li></ul><p>下面是在VirtualApp中运行应用后通过ps命令得到的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generic_x86:/ $ ps |grep u0_a60</span><br><span class="line">u0_a60    2385  1258  996260 54456 SyS_epoll_ 00000000 S io.virtualapp</span><br><span class="line">u0_a60    2412  1258  980940 48272 SyS_epoll_ 00000000 S io.virtualapp:x</span><br><span class="line">u0_a60    3705  1258  993632 54472 SyS_epoll_ 00000000 S org.galaxy.simpleapp</span><br></pre></td></tr></table></figure></p><p>可以看到，以上进程，均是以VirtualApp的用户uid运行的。因此，Android应用隔离此时不再适用，我们可以对client应用进行hook而无需root权限。</p><h2 id="注入逻辑"><a href="#注入逻辑" class="headerlink" title="注入逻辑"></a>注入逻辑</h2><p>要想实现对一个APP的虚拟化，就是不直接把APP安装进系统，同时又要提供APP运行过程中所需的一切，从而可以让它误以为自己是运行在正常系统中。这里就需要实现系统服务的虚拟化和相关路径的虚拟化。</p><p>其中，<strong>系统服务的虚拟化主要靠注入大量framework组件来实现</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@VirtualApp/lib/src/main/java/com/lody/virtual/client/core/InvocationStubManager.java</span><br><span class="line">private void injectInternal() throws Throwable &#123;</span><br><span class="line">  if (VirtualCore.get().isMainProcess()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (VirtualCore.get().isServerProcess()) &#123;</span><br><span class="line">    addInjector(new ActivityManagerStub());</span><br><span class="line">    addInjector(new PackageManagerStub());</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (VirtualCore.get().isVAppProcess()) &#123;</span><br><span class="line">    addInjector(new LibCoreStub());</span><br><span class="line">    addInjector(new ActivityManagerStub());</span><br><span class="line">    addInjector(new PackageManagerStub());</span><br><span class="line">    addInjector(HCallbackStub.getDefault());</span><br><span class="line">    addInjector(new ISmsStub());</span><br><span class="line">    addInjector(new ISubStub());</span><br><span class="line">    addInjector(new DropBoxManagerStub());</span><br><span class="line">    addInjector(new NotificationManagerStub());</span><br><span class="line">    addInjector(new LocationManagerStub());</span><br><span class="line">    addInjector(new WindowManagerStub());</span><br><span class="line">    addInjector(new ClipBoardStub());</span><br><span class="line">    addInjector(new MountServiceStub());</span><br><span class="line">    addInjector(new BackupManagerStub());</span><br><span class="line">    addInjector(new TelephonyStub());</span><br><span class="line">    addInjector(new TelephonyRegistryStub());</span><br><span class="line">    addInjector(new PhoneSubInfoStub());</span><br><span class="line">    addInjector(new PowerManagerStub());</span><br><span class="line">    addInjector(new AppWidgetManagerStub());</span><br><span class="line">    addInjector(new AccountManagerStub());</span><br><span class="line">    addInjector(new AudioManagerStub());</span><br><span class="line">    addInjector(new SearchManagerStub());</span><br><span class="line">    addInjector(new ContentServiceStub());</span><br><span class="line">    addInjector(new ConnectivityStub());</span><br><span class="line"> </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR2) &#123;</span><br><span class="line">      addInjector(new VibratorStub());</span><br><span class="line">      addInjector(new WifiManagerStub());</span><br><span class="line">      addInjector(new BluetoothStub());</span><br><span class="line">      addInjector(new ContextHubServiceStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR1) &#123;</span><br><span class="line">      addInjector(new UserManagerStub());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR1) &#123;</span><br><span class="line">      addInjector(new DisplayStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= LOLLIPOP) &#123;</span><br><span class="line">      addInjector(new PersistentDataBlockServiceStub());</span><br><span class="line">      addInjector(new InputMethodManagerStub());</span><br><span class="line">      addInjector(new MmsStub());</span><br><span class="line">      addInjector(new SessionManagerStub());</span><br><span class="line">      addInjector(new JobServiceStub());</span><br><span class="line">      addInjector(new RestrictionStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= KITKAT) &#123;</span><br><span class="line">      addInjector(new AlarmManagerStub());</span><br><span class="line">      addInjector(new AppOpsManagerStub());</span><br><span class="line">      addInjector(new MediaRouterServiceStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= LOLLIPOP_MR1) &#123;</span><br><span class="line">      addInjector(new GraphicsStatsStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= M) &#123;</span><br><span class="line">      addInjector(new NetworkManagementStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= N) &#123;</span><br><span class="line">              addInjector(new WifiScannerStub());</span><br><span class="line">              addInjector(new ShortcutServiceStub());</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个注入过程是发生在io.virtualapp.VApp.attachBaseContext中，因此，每次启动一个子进程都会执行到这里，这会区分是isMainProcess（io.virtualapp）或者isServerProcess（io.virtualapp:x）或者isVAppProcess（被安装APP）来进行不同的注入，可以看到，注入最多的还是在被安装APP的进程中。</p><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>从启动VirtualApp到运行其中的应用，大致流程如下：</p><h3 id="启动host应用"><a href="#启动host应用" class="headerlink" title="启动host应用"></a>启动host应用</h3><p>我们启动VirtualApp，其Application为io.virtualapp.VApp。<strong>在attachBaseContext()</strong>方法中会调用到com.lody.virtual.client.core.PatchManager#injectInternal，但此时为<strong>Main Process</strong>，不进行系统服务的替换。</p><h3 id="启动Server-Process"><a href="#启动Server-Process" class="headerlink" title="启动Server Process"></a>启动Server Process</h3><p>host应用会进行一些初始化，其中就包括获取全部已安装应用，这会调用到com.lody.virtual.client.core.VirtualCore#getAllApps。而这一方法最终会访问com.lody.virtual.server.BinderProvider。由AndroidManifest.xml可知，该provider会运行在新进程io.virtualapp:x中，即<strong>Server Process</strong>。</p><p>由于在新进程中启动组件，同样会首先创建该应用的Application，因此也会调用到com.lody.virtual.client.core.PatchManager#injectInternal。此时，<strong>会进行相应系统服务(ActivityManager和PackageManager)的代理构造和替换。</strong></p><h3 id="启动VApp-Process"><a href="#启动VApp-Process" class="headerlink" title="启动VApp Process"></a>启动VApp Process</h3><p>点击一个已安装应用，此时会通过替换掉的系统服务访问真实的系统服务（主要是ActivityManager），并在新进程中启动组件com.lody.virtual.client.stub.StubActivity.C0。由AndroidManifest.xml可知，该进程具有后缀:p0。</p><p>同样的，在该Activity组件启动之前会初始化io.virtualapp.VApp，并在com.lody.virtual.client.core.PatchManager#injectInternal中<strong>完成系统服务的代理构造和替换。</strong></p><h3 id="启动client应用"><a href="#启动client应用" class="headerlink" title="启动client应用"></a>启动client应用</h3><p>此时，真正的client应用尚未启动，进程io.virtualapp:p0仅仅是作为一个placeholder。StubActivity会从Intent中获取到client应用的相关信息，并修改自身ActivityThread的handler。随后调用startActivity启动client应用。</p><p>由于之前Server Process和VApp Process都已完成了相关系统服务的替换，这里会完成client应用的bindApplication调用、构造client应用的LoadedApk，并通过反射完成真正的Application和Activity的创建。</p><p>最终，client应用便运行在了我们的VApp Process中。</p><h2 id="系统服务的代理和替换"><a href="#系统服务的代理和替换" class="headerlink" title="系统服务的代理和替换"></a>系统服务的代理和替换</h2><p>VirtualApp之所以能够实现虚拟空间，是因为其对许多系统服务进行了代理和替换。因此，这部分便是整个框架的核心。系统服务运行在system_server中，Android应用调用系统服务，是通过Binder机制进行IPC。因此，<strong>应用所持有的是系统服务的BinderProxy，通过对这些BinderProxer构造代理并替换，便实现了对系统服务的代理和替换。</strong></p><p>具体地，我们以com.lody.virtual.client.hook.patchs.am.ActivityManagerPatch为例，这个类实现了对ActivityManager服务的代理和替换。</p><h3 id="代理的构造"><a href="#代理的构造" class="headerlink" title="代理的构造"></a>代理的构造</h3><p>可以看到，这个类的注记中包含了大量类名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Patch(&#123;StartActivity.class, StartActivityAsCaller.class,</span><br><span class="line">        StartActivityAndWait.class, StartActivityWithConfig.class, StartActivityIntentSender.class,</span><br><span class="line">        StartNextMatchingActivity.class, StartVoiceActivity.class,</span><br><span class="line">        GetIntentSender.class, RegisterReceiver.class, GetContentProvider.class,</span><br><span class="line">        GetContentProviderExternal.class,</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><p>而这些列出的每一个类，对应于一个方法的hook，例如，com.lody.virtual.client.hook.patchs.am.StartActivity是ActivityManager服务的startActivity方法的hook。这些类均继承自com.lody.virtual.client.hook.base.Hook，包含了方法beforeCall(), call(), afterCall()，这些方法便是hook的具体内容。</p><p>ActivityManagerPatch在创建时，会调用到其父类的方法com.lody.virtual.client.hook.base.PatchDelegate#onBindHooks。这里会检查上述注记中列出的hook，并对符合条件的hook调用addHook()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Class&lt;? extends PatchDelegate&gt; clazz = getClass();</span><br><span class="line">Patch patch = clazz.getAnnotation(Patch.class);</span><br><span class="line">int version = Build.VERSION.SDK_INT;</span><br><span class="line">if (patch != null) &#123;</span><br><span class="line">    Class&lt;?&gt;[] hookTypes = patch.value();</span><br><span class="line">    for (Class&lt;?&gt; hookType : hookTypes) &#123;</span><br><span class="line">        ApiLimit apiLimit = hookType.getAnnotation(ApiLimit.class);</span><br><span class="line">        boolean needToAddHook = true;</span><br><span class="line">        if (apiLimit != null) &#123;</span><br><span class="line">            int apiStart = apiLimit.start();</span><br><span class="line">            int apiEnd = apiLimit.end();</span><br><span class="line">            boolean highThanStart = apiStart == -1 || version &gt; apiStart;</span><br><span class="line">            boolean lowThanEnd = apiEnd == -1 || version &lt; apiEnd;</span><br><span class="line">            if (!highThanStart || !lowThanEnd) &#123;</span><br><span class="line">                needToAddHook = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (needToAddHook) &#123;</span><br><span class="line">            addHook(hookType);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>而addHook()最终会调用到com.lody.virtual.client.hook.base.HookDelegate#addHook，其实质便是将这个hook添加至映射表internalHookTable中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Hook addHook(Hook hook) &#123;</span><br><span class="line">    if (hook != null &amp;&amp; !TextUtils.isEmpty(hook.getName())) &#123;</span><br><span class="line">        if (internalHookTable.containsKey(hook.getName())) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;The Hook(%s, %s) you added has been in existence.&quot;, hook.getName(),</span><br><span class="line">                    hook.getClass().getName());</span><br><span class="line">            return hook;</span><br><span class="line">        &#125;</span><br><span class="line">        internalHookTable.put(hook.getName(), hook);</span><br><span class="line">    &#125;</span><br><span class="line">    return hook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>internalHookTable维护了所有的hook，以hook的名称（一般就是所hook的方法的名称）作为key。随后，在com.lody.virtual.client.hook.base.HookDelegate.HookHandler的invoke()方法中，查找表 internalHookTable中是否包含将要执行的方法名；如果有，则依次执行对应hook的beforeCall(), call(), afterCall()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private class HookHandler implements InvocationHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Hook hook = getHook(method.getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            if (hook != null &amp;&amp; hook.isEnable()) &#123;</span><br><span class="line">                if (hook.beforeCall(mBaseInterface, method, args)) &#123;</span><br><span class="line">                    Object res = hook.call(mBaseInterface, method, args);</span><br><span class="line">                    res = hook.afterCall(mBaseInterface, method, args, res);</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return method.invoke(mBaseInterface, args);</span><br></pre></td></tr></table></figure></p><p>而这里的类HookHandler，就是构造的Java代理的Handler：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public HookDelegate(T baseInterface, Class&lt;?&gt;... proxyInterfaces) &#123;</span><br><span class="line">    this.mBaseInterface = baseInterface;</span><br><span class="line">    if (baseInterface != null) &#123;</span><br><span class="line">        if (proxyInterfaces == null) &#123;</span><br><span class="line">            proxyInterfaces = HookUtils.getAllInterface(baseInterface.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        mProxyInterface = (T) Proxy.newProxyInstance(baseInterface.getClass().getClassLoader(), proxyInterfaces, new HookHandler());</span><br></pre></td></tr></table></figure></p><p>对于ActivityManagerPatch来说，这里的baseInterface便是原始的BinderProxy: ActivityManagerProxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ActivityManagerPatch() &#123;</span><br><span class="line">    super(new HookDelegate&lt;IInterface&gt;(ActivityManagerNative.getDefault.call()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>综上，我们根据baseInterface，为其构造了代理mProxyInterface。从而访问mProxyInterface时，便会执行HookHandler的invoke()方法，进而查找internalHookTable，对设置了hook的方法执行hook。</p><h3 id="系统服务的替换"><a href="#系统服务的替换" class="headerlink" title="系统服务的替换"></a>系统服务的替换</h3><p>如之前所说，对系统服务的替换，是通过对应用所持有的系统服务的BinderProxy进行替换的。以上是构造代理的基本过程，那么如何将应用所持有的BinderProxy替换成我们构造的代理呢？回到ActivityManagerPatch，这个类的inject()方法完成了实际的替换工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void inject() throws Throwable &#123;</span><br><span class="line">    if (ActivityManagerNative.gDefault.type() == IActivityManager.TYPE) &#123;</span><br><span class="line">        ActivityManagerNative.gDefault.set(getHookDelegate().getProxyInterface());</span><br><span class="line"></span><br><span class="line">    &#125; else if (ActivityManagerNative.gDefault.type() == Singleton.TYPE) &#123;</span><br><span class="line">        Object gDefault = ActivityManagerNative.gDefault.get();</span><br><span class="line">        Singleton.mInstance.set(gDefault, getHookDelegate().getProxyInterface());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>ActivityManagerNative.gDefault便是应用所持有的原始ActivityManagerProxy对象，通过Java反射，将替换成为getHookDelegate().getProxyInterface()。而替换的内容，便是我们所构造的代理mProxyInterface。</p><p>由此，我们完成了对系统服务进行代理和替换的整个过程。随后，在调用系统服务时，便会执行以下操作：</p><ul><li>访问BinderProxy的代理，即我们设置了hook的代理</li><li>根据hook的具体内容操作，对数据进行处理；需要调用原始系统服务时，访问原始的BinderProxy</li><li>真正的系统服务接收到Binder，进行处理并返回</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上介绍可以看到，VirtualApp在原有系统服务之上构造了代理，进而为其中的应用搭建了一套虚拟环境，应用可以无感知地运行在这其中。更进一步，我们可以设置这套虚拟环境，使其实现应用多开、非侵入式应用hook等高级功能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">https://github.com/asLody/VirtualApp</a><br><a href="http://rk700.github.io/2017/03/15/virtualapp-basic/" target="_blank" rel="noopener">http://rk700.github.io/2017/03/15/virtualapp-basic/</a><br><a href="https://blog.csdn.net/weixin_40581980/article/details/81169266" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40581980/article/details/81169266</a></p>]]></content>
      
      
      <categories>
          
          <category> Android插件化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android插件化方案</title>
      <link href="/2020/04/03/android-plugin-knowledge/"/>
      <url>/2020/04/03/android-plugin-knowledge/</url>
      
        <content type="html"><![CDATA[<p>插件化技术涉及得非常广泛，其中最核心的就是Android的类加载机制和反射机制。下图载自腾讯bugly：</p><p><img src="/2020/04/03/android-plugin-knowledge/plugin_history.jpg" alt title="图1：插件化概要"></p><h2 id="插件化发展历史"><a href="#插件化发展历史" class="headerlink" title="插件化发展历史"></a>插件化发展历史</h2><p>插件化技术最初源于免安装运行apk的想法，这个免安装的apk可以理解为插件。支持插件化的app可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展。想要实现插件化，主要是解决下面三个问题：</p><ul><li>插件中代码的加载和与主工程的互相调用</li><li>插件中资源的加载和与主工程的互相访问</li><li>四大组件生命周期的管理</li></ul><p>下面是比较出名的几个开源的插件化框架，按照出现的时间排序。研究它们的实现原理，可以大致看出插件化技术的发展，根据实现原理可以将这几个框架划分成了三代。</p><p><img src="/2020/04/03/android-plugin-knowledge/plugin_generate.jpg" alt></p><p><strong>第一代</strong>：dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期。该种方式缺点明显，插件中的activity必须继承PluginActivity，开发时要小心处理context。而DroidPlugin通过Hook系统服务的方式启动插件中的Activity，使得开发插件的过程和开发普通的app没有什么区别，但是由于hook过多系统服务，异常复杂且不够稳定。<br><strong>第二代</strong>：为了同时达到<strong>插件开发的低侵入性（像开发普通app一样开发插件）和框架的稳定性</strong>，在实现原理上都是趋近于选择尽量少的hook，并通过在manifest中预埋一些组件实现对四大组件的插件化。另外各个框架根据其设计思想都做了不同程度的扩展，其中Small更是做成了一个跨平台，组件化的开发框架。<br><strong>第三代</strong>：VirtualApp比较厉害，能够完全模拟app的运行环境，能够实现app的免安装运行和双开技术。Atlas是阿里开源出来的一个结合组件化和热修复技术的一个app基础框架，其广泛的应用与阿里系的各个app，其号称是一个容器化框架。</p><h2 id="Atlas-VirtualApk-RePlugin对比"><a href="#Atlas-VirtualApk-RePlugin对比" class="headerlink" title="Atlas/VirtualApk/RePlugin对比"></a>Atlas/VirtualApk/RePlugin对比</h2><p>Atlas是伴随着手机淘宝的不断发展而衍生出来的一个运行于Android系统上的一个容器化框架，我们也叫<strong>动态组件化(Dynamic Bundle)框架</strong>。它主要提供了解耦化、组件化、动态性的支持。覆盖了工程师的工程编码期、Apk运行期以及后续运维期的各种问题。</p><p>VirtualAPK是滴滴出行自研的一款优秀的插件化框架，功能完备。支持几乎所有的Android特性；四大组件均不需要在宿主manifest中预注册，每个组件都有完整的生命周期，入侵性极低。</p><p>RePlugin是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。</p><p>Atlas：<a href="https://github.com/alibaba/atlas/tree/master/atlas-docs" target="_blank" rel="noopener">https://github.com/alibaba/atlas/tree/master/atlas-docs</a><br>VirtualAPK：<a href="https://github.com/didi/VirtualAPK/wiki" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK/wiki</a><br>RePlugin：<a href="https://github.com/Qihoo360/RePlugin/wiki" target="_blank" rel="noopener">https://github.com/Qihoo360/RePlugin/wiki</a></p><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>从定义上说，<strong>Atlas定义为组件化，而VirtualAPK和RePlugin则定义为插件化</strong>。这两种还是有一点点不同的，<strong>组件化偏重于编译期，插件化偏重于运行期</strong>。换句话来说，Atlas在编译的时候是需要把bundle放在一起处理的，而后面两个则可以完全独立开，和开发新的一个apk一样，最后打包的时候配置一下就行。</p><h3 id="二、接入难度"><a href="#二、接入难度" class="headerlink" title="二、接入难度"></a>二、接入难度</h3><p>初次接入Atlas，那真的会有点懵逼，官方文档已经万年没更新的，GitHub上面的demo和文档上的好多都不一样，就算接入了，也会出现一堆问题，简直想死。VirtualAPK，滴滴这个，接入还算简单的了，文档也比较完善。RePlugin，360这个也挺简单的，宿主和插件分得很清楚。所以接入难度：<strong>RePlugin最快，VirtualAPK其次，Atlas最麻烦。</strong></p><h3 id="三、功能"><a href="#三、功能" class="headerlink" title="三、功能"></a>三、功能</h3><p>三者<strong>都有的功能是远程bundle，按需加载</strong>。意思是项目中某个模块，打包的时候不打进apk，等你安装了，需要用到的时候再下载那个模块进行加载显示，从而减少apk的安装体积。<strong>Atlas会把插件打成so的形式，而VirtualAPK和RePlugin会打成apk的形式，都是放在内存卡，然后调用各自的安装加载方法就行</strong>。Atlas安装后，可以把so删掉，但VirtualAPK的apk需要一直在内存卡，否则是打不开的，而RePlugin安装后会自动备份一个apk到缓存目录。除了远程bundle功能，Atlas还有热修复的功能，可以不升级apk就实现宿主和组件的更新。</p><h3 id="四、更新插件方式"><a href="#四、更新插件方式" class="headerlink" title="四、更新插件方式"></a>四、更新插件方式</h3><p>Atlas更新插件的话，必须要和宿主一起，打差异补丁才能更新，而VirtualAPK和RePlugin是可以直接通过下载一个新的插件apk，然后调安装方法就能实现插件的更新。</p><h3 id="五、插件独立性"><a href="#五、插件独立性" class="headerlink" title="五、插件独立性"></a>五、插件独立性</h3><p>Atlas和宿主的依赖还是挺多，毕竟官方也强调是组件化，不是插件化。<strong>而VirtualAPK，它可以是一个独立的app，但插件里面也定义和宿主的关联，就是说这个插件apk并不能给其他宿主用，只能给插件里面声明的那个宿主使用。RePlugin呢，就比较独立了，里面不用声明和宿主的联系，所以你生成一个插件后，这个插件可以给其他宿主调用。</strong></p><h3 id="六、宿主和插件的公共库"><a href="#六、宿主和插件的公共库" class="headerlink" title="六、宿主和插件的公共库"></a>六、宿主和插件的公共库</h3><p>如果宿主和插件都用到一些公共依赖库，比如http库，图片加载库，这个时候怎么处理？Atlas处理就简单了，毕竟是组件化，和宿主的项目都是在一起。可以在项目里面定义一个middleLibrary，这个库里面依赖一些公共的库或者资源，然后宿主和插件都依赖他就行了<strong>。VirtualAPK呢，由于插件里面要声明和宿主的关联，所以他会自动检测，如果插件中依赖的库，在宿主里面也有的话，他会自动去掉一个，不会重复。RePlugin是比较独立的，没有和宿主太多联系，所以目前大家的做法是宿主compile，插件 provided的形式，而共用资源的话，RePlugin是不提倡的了。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你的app需要热更新和插件的功能，推荐使用Atlas；如果你的app仅用到插件，在需要的时候才下载加载的话，你可以选择VirtualAPK和RePlugin；如果你的插件希望其他宿主也能用的话，那就只能RePlugin了，RePlugin就像一个应用市场，你的宿主仅仅是一个壳，然后把需要的插件下载加载使用就行，更新的话也无需更新宿主，直接更新插件就行。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ceded2da7847" target="_blank" rel="noopener">https://www.jianshu.com/p/ceded2da7847</a></p>]]></content>
      
      
      <categories>
          
          <category> Android插件化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ 语言笔记</title>
      <link href="/2020/01/07/c-plus-language/"/>
      <url>/2020/01/07/c-plus-language/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：封装、抽象、继承、多态。</p><p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。C++ 是 C 的一个超集，任何合法的 C 程序都是合法的 C++ 程序。</p><p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</p><p>注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p><p>本章只针对和C语言不同处介绍。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。</p><h3 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// main() 是程序开始执行的地方</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们讲解一下上面这段程序：</p><blockquote><ul><li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <iostream>。</iostream></li><li>下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li><li>下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。</li><li>下一行 int main() 是主函数，程序从这里开始执行。</li><li>下一行 cout &lt;&lt; “Hello World”; 会在屏幕上显示消息 “Hello World”。</li><li>下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。</li></ul></blockquote><h3 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h3><p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p><p>C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。</p><h3 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h3><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。<strong>三字符序列总是以两个问号开头</strong>。</p><p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。<strong>以前为了表示键盘上没有的字符</strong>，这是必不可少的一种方法。三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p><p>g++仍默认支持三字符组，但会给出编译警告。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p><table><thead><tr><th>类型</th><th>关键字</th></tr></thead><tbody><tr><td>布尔型</td><td>bool</td></tr><tr><td>字符型</td><td>char</td></tr><tr><td>整型</td><td>int</td></tr><tr><td>浮点型</td><td>float</td></tr><tr><td>双浮点型</td><td>double</td></tr><tr><td>无类型</td><td>void</td></tr><tr><td>宽字符型</td><td>wchar_t</td></tr></tbody></table><h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p><blockquote><ul><li>true 值代表真。</li><li>false 值代表假。</li></ul></blockquote><p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p><h3 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h3><p>wchar_t为宽字符型    ，占2 或 4 个字节。其实 wchar_t 是这样来的：</p><blockquote><p>typedef short int wchar_t;</p></blockquote><p>所以 wchar_t 实际上的空间是和 short int 一样。</p><h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符提供了变量的额外信息。</p><table><thead><tr><th>限定符</th><th>含义</th></tr></thead><tbody><tr><td>const</td><td>const 类型的对象在程序执行期间不能被修改改变。</td></tr><tr><td>volatile</td><td>修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td></tr><tr><td>restrict</td><td>由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td></tr></tbody></table><h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p><blockquote><ul><li>auto</li><li>register</li><li>static</li><li>extern</li><li>mutable</li><li>thread_local (C++11)</li></ul></blockquote><p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p><h3 id="mutable-存储类"><a href="#mutable-存储类" class="headerlink" title="mutable 存储类"></a>mutable 存储类</h3><p>mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p><h3 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h3><p>使用 thread_local 说明符声明的变量<strong>仅可在它在其上创建的线程上访问</strong>。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p><p>thread_local 说明符可以与 static 或 extern 合并。</p><p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p><p>以下演示了可以被声明为 thread_local 的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread_local int x;  // 命名空间下的全局变量</span><br><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">    static thread_local std::string s; // 类的static成员变量</span><br><span class="line">&#125;;</span><br><span class="line">static thread_local std::string X::s;  // X::s 是需要定义的</span><br><span class="line"> </span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    thread_local std::vector&lt;int&gt; v;  // 本地变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</p><p>Cast：强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><p>当您定义一个函数，您<strong>可以为参数列表中后边的每一个参数指定默认值</strong>。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p><p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int sum(int a, int b=20)</span><br><span class="line">&#123;</span><br><span class="line">  int result;</span><br><span class="line"> </span><br><span class="line">  result = a + b;</span><br><span class="line">  </span><br><span class="line">  return (result);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   // 局部变量声明</span><br><span class="line">   int a = 100;</span><br><span class="line">   int b = 200;</span><br><span class="line">   int result;</span><br><span class="line"> </span><br><span class="line">   // 调用函数来添加值</span><br><span class="line">   result = sum(a, b);</span><br><span class="line">   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 再次调用函数</span><br><span class="line">   result = sum(a);</span><br><span class="line">   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Total value is :300</span><br><span class="line">Total value is :120</span><br></pre></td></tr></table></figure></p><h3 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h3><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p><p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p><p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p><blockquote><p>[capture](parameters)-&gt;return-type{body}<br>[capture](parameters){body}</p></blockquote><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[](int x, int y)&#123; return x &lt; y ; &#125;</span><br><span class="line"></span><br><span class="line">[]&#123; ++global_x; &#125; </span><br><span class="line"></span><br><span class="line">[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125;</span><br></pre></td></tr></table></figure></p><p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p><p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p><blockquote><p>[]      // 沒有定义任何变量。使用未定义变量会引发错误。<br>[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。<br>[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。<br>[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。<br>[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。<br>[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</p></blockquote><p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p><blockquote><p>[this]() { this-&gt;someFunc(); }();</p></blockquote><h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h2><p>C++ 提供了以下两种类型的字符串表示形式：</p><blockquote><ul><li>C 风格字符串</li><li>C++ 引入的 string 类类型</li></ul></blockquote><p>C++ 标准库提供了 string 类类型，支持C 风格字符串所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   string str1 = &quot;Hello&quot;;</span><br><span class="line">   string str2 = &quot;World&quot;;</span><br><span class="line">   string str3;</span><br><span class="line">   int  len ;</span><br><span class="line"> </span><br><span class="line">   // 复制 str1 到 str3</span><br><span class="line">   str3 = str1;</span><br><span class="line">   cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 连接 str1 和 str2</span><br><span class="line">   str3 = str1 + str2;</span><br><span class="line">   cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 连接后，str3 的总长度</span><br><span class="line">   len = str3.size();</span><br><span class="line">   cout &lt;&lt; &quot;str3.size() :  &quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">str3 : Hello</span><br><span class="line">str1 + str2 : HelloWorld</span><br><span class="line">str3.size() :  10</span><br></pre></td></tr></table></figure></p><h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++ 引用"></a>C++ 引用</h2><p>引用变量是一个<strong>别名</strong>，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。引用通常用于函数参数列表和函数返回值。</p><h3 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h3><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><blockquote><ul><li><strong>不存在空引用</strong>。引用必须连接到一块合法的内存。</li><li><strong>一旦引用被初始化为一个对象，就不能被指向到另一个对象</strong>。指针可以在任何时候指向到另一个对象。</li><li><strong>引用必须在创建时被初始化</strong>。指针可以在任何时间被初始化。</li></ul></blockquote><h3 id="C-中创建引用"><a href="#C-中创建引用" class="headerlink" title="C++ 中创建引用"></a>C++ 中创建引用</h3><p>试想<strong>变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签</strong>。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p><blockquote><p>int i = 17;</p></blockquote><p>我们可以为 i 声明引用变量，如下所示：</p><blockquote><p>int&amp;  r = i;<br>double&amp; s = d;</p></blockquote><p>在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   // 声明简单的变量</span><br><span class="line">   int    i;</span><br><span class="line">   double d;</span><br><span class="line"> </span><br><span class="line">   // 声明引用变量</span><br><span class="line">   int&amp;    r = i;</span><br><span class="line">   double&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = 5;</span><br><span class="line">   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = 11.7;</span><br><span class="line">   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of i : 5</span><br><span class="line">Value of i reference : 5</span><br><span class="line">Value of d : 11.7</span><br><span class="line">Value of d reference : 11.7</span><br></pre></td></tr></table></figure><h2 id="C-输入输出"><a href="#C-输入输出" class="headerlink" title="C++ 输入输出"></a>C++ 输入输出</h2><h3 id="I-O-库头文件"><a href="#I-O-库头文件" class="headerlink" title="I/O 库头文件"></a>I/O 库头文件</h3><p>下列的头文件在 C++ 编程中很重要：</p><table><thead><tr><th>头文件</th><th>函数和描述</th></tr></thead><tbody><tr><td>&lt;iostream></td><td>该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td></tr><tr><td>&lt;iomanip></td><td>该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。</td></tr><tr><td>&lt;fstream></td><td>该文件为用户控制的文件处理声明服务。</td></tr></tbody></table><h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h3><p>预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char str[] = &quot;Hello C++&quot;;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。</p><p>cerr、clog类似。但良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p><h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h3><p>预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char name[50];</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;请输入您的名称： &quot;;</span><br><span class="line">   cin &gt;&gt; name;</span><br><span class="line">   cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p><blockquote><p>cin &gt;&gt; name &gt;&gt; age;</p></blockquote><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。</p><p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p><blockquote><p>void open(const char *filename, ios::openmode mode);</p></blockquote><p>在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式:</p><p>模式标志     | 描述<br>| - | - |<br>ios::app     | 追加模式。所有写入都追加到文件末尾。<br>ios::ate     | 文件打开后定位到文件末尾。<br>ios::in     | 打开文件用于读取。<br>ios::out     | 打开文件用于写入。<br>ios::trunc     | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</p><p>您可以把以上两种或两种以上的模式结合使用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法</span><br><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc );</span><br><span class="line"></span><br><span class="line">//类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</span><br><span class="line">ifstream  afile;</span><br><span class="line">afile.open(&quot;file.dat&quot;, ios::out | ios::in );</span><br></pre></td></tr></table></figure></p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p><p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p><blockquote><p>void close();</p></blockquote><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息或流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 、 fstream  或 ifstream 、 fstream 对象，而不是 cout 对象或 cin 对象。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   char data[100];</span><br><span class="line"> </span><br><span class="line">   // 以写模式打开文件</span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.open(&quot;afile.dat&quot;);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Enter your name: &quot;; </span><br><span class="line">   cin.getline(data, 100);</span><br><span class="line"> </span><br><span class="line">   // 向文件写入用户输入的数据</span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Enter your age: &quot;; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.ignore();</span><br><span class="line">   </span><br><span class="line">   // 再次向文件写入用户输入的数据</span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 关闭打开的文件</span><br><span class="line">   outfile.close();</span><br><span class="line"> </span><br><span class="line">   // 以读模式打开文件</span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.open(&quot;afile.dat&quot;); </span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line"> </span><br><span class="line">   // 在屏幕上写入数据</span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   // 再次从文件读取数据，并显示它</span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   // 关闭打开的文件</span><br><span class="line">   infile.close();</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列输入和输出：</span><br><span class="line">$./a.out</span><br><span class="line">Writing to the file</span><br><span class="line">Enter your name: Zara</span><br><span class="line">Enter your age: 9</span><br><span class="line">Reading from the file</span><br><span class="line">Zara</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p><h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><p>istream 和 ostream 都提供了用于<strong>重新定位文件位置指针</strong>的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。</p><p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。</p><p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span><br><span class="line">fileObject.seekg( n );</span><br><span class="line"> </span><br><span class="line">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::cur );</span><br><span class="line"> </span><br><span class="line">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::end );</span><br><span class="line"> </span><br><span class="line">// 定位到 fileObject 的末尾</span><br><span class="line">fileObject.seekg( 0, ios::end );</span><br></pre></td></tr></table></figure></p><h2 id="C-类和继承"><a href="#C-类和继承" class="headerlink" title="C++ 类和继承"></a>C++ 类和继承</h2><p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p><h3 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h3><p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p><p>类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      double length;   // 盒子的长度</span><br><span class="line">      double breadth;  // 盒子的宽度</span><br><span class="line">      double height;   // 盒子的高度</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected。</p><h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。继承代表了 is a 关系。</p><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><blockquote><p>class derived-class: access-specifier base-class</p></blockquote><p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p><h3 id="继承类型access-specifier"><a href="#继承类型access-specifier" class="headerlink" title="继承类型access-specifier"></a>继承类型access-specifier</h3><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p><p>我们几乎不使用 protected 或 private 继承，<strong>通常使用 public 继承</strong>。当使用不同类型的继承时，遵循以下几个规则：</p><ul><li>公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li><li>保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。</li><li>私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p><p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p><blockquote><p>Box operator+(const Box&amp;);</p></blockquote><p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p><blockquote><p>Box operator+(const Box&amp;, const Box&amp;);</p></blockquote><p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line"> </span><br><span class="line">      double getVolume(void)</span><br><span class="line">      &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">          length = len;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      void setBreadth( double bre )</span><br><span class="line">      &#123;</span><br><span class="line">          breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      void setHeight( double hei )</span><br><span class="line">      &#123;</span><br><span class="line">          height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      // 重载 + 运算符，用于把两个 Box 对象相加</span><br><span class="line">      Box operator+(const Box&amp; b)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box;</span><br><span class="line">         box.length = this-&gt;length + b.length;</span><br><span class="line">         box.breadth = this-&gt;breadth + b.breadth;</span><br><span class="line">         box.height = this-&gt;height + b.height;</span><br><span class="line">         return box;</span><br><span class="line">      &#125;</span><br><span class="line">   private:</span><br><span class="line">      double length;      // 长度</span><br><span class="line">      double breadth;     // 宽度</span><br><span class="line">      double height;      // 高度</span><br><span class="line">&#125;;</span><br><span class="line">// 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Box Box1;                // 声明 Box1，类型为 Box</span><br><span class="line">   Box Box2;                // 声明 Box2，类型为 Box</span><br><span class="line">   Box Box3;                // 声明 Box3，类型为 Box</span><br><span class="line">   double volume = 0.0;     // 把体积存储在该变量中</span><br><span class="line"> </span><br><span class="line">   // Box1 详述</span><br><span class="line">   Box1.setLength(6.0); </span><br><span class="line">   Box1.setBreadth(7.0); </span><br><span class="line">   Box1.setHeight(5.0);</span><br><span class="line"> </span><br><span class="line">   // Box2 详述</span><br><span class="line">   Box2.setLength(12.0); </span><br><span class="line">   Box2.setBreadth(13.0); </span><br><span class="line">   Box2.setHeight(10.0);</span><br><span class="line"> </span><br><span class="line">   // Box1 的体积</span><br><span class="line">   volume = Box1.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   // Box2 的体积</span><br><span class="line">   volume = Box2.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   // 把两个对象相加，得到 Box3</span><br><span class="line">   Box3 = Box1 + Box2;</span><br><span class="line"> </span><br><span class="line">   // Box3 的体积</span><br><span class="line">   volume = Box3.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Volume of Box1 : 210</span><br><span class="line">Volume of Box2 : 1560</span><br><span class="line">Volume of Box3 : 5400</span><br></pre></td></tr></table></figure></p><h3 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h3><p>下面是可重载的运算符列表：</p><table><thead><tr><th>运算符</th><th>符号</th></tr></thead><tbody><tr><td>双目算术运算符</td><td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td></tr><tr><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td>逻辑运算符</td><td>&#124;&#124;(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td>自增自减运算符</td><td>++(自增)，–(自减)</td></tr><tr><td>位运算符</td><td>&#124; (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)`</td></tr><tr><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, &#124;=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td>空间申请与释放</td><td>new, delete, new[ ] , delete[]</td></tr><tr><td>其他运算符</td><td>()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标)</td></tr></tbody></table><p>下面是不可重载的运算符列表：</p><ul><li>.：成员访问运算符</li><li>.<em>, -&gt;</em>：成员指针访问运算符</li><li>::：域运算符</li><li>sizeof：长度运算符</li><li>?:：条件运算符</li><li>#： 预处理符号</li></ul><h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++ 多态"></a>C++ 多态</h2><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      int area()</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Rectangle: public Shape&#123;</span><br><span class="line">   public:</span><br><span class="line">      Rectangle( int a=0, int b=0):Shape(a, b) &#123; &#125;</span><br><span class="line">      int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Triangle: public Shape&#123;</span><br><span class="line">   public:</span><br><span class="line">      Triangle( int a=0, int b=0):Shape(a, b) &#123; &#125;</span><br><span class="line">      int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         cout &lt;&lt; &quot;Triangle class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return (width * height / 2); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   Rectangle rec(10,7);</span><br><span class="line">   Triangle  tri(10,5);</span><br><span class="line"> </span><br><span class="line">   // 存储矩形的地址</span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   // 调用矩形的求面积函数 area</span><br><span class="line">   shape-&gt;area();</span><br><span class="line"> </span><br><span class="line">   // 存储三角形的地址</span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   // 调用三角形的求面积函数 area</span><br><span class="line">   shape-&gt;area();</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Parent class area</span><br><span class="line">Parent class area</span><br></pre></td></tr></table></figure><p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态或静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p><p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      virtual int area()</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">修改后，当编译和执行前面的实例代码时，它会产生以下结果：</span><br><span class="line">Rectangle class area</span><br><span class="line">Triangle class area</span><br></pre></td></tr></table></figure></p><p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p><p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会<strong>告诉编译器不要静态链接到该函数</strong>。</p><p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接或后期绑定</strong>。</p><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p><p>我们可以把基类中的虚函数 area() 改写如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      // pure virtual function</span><br><span class="line">      virtual int area() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>= 0 告诉编译器，<strong>函数没有主体</strong>，上面的虚函数是纯虚函数。</p><h2 id="C-动态内存"><a href="#C-动态内存" class="headerlink" title="C++ 动态内存"></a>C++ 动态内存</h2><p>C++ 程序中的内存分为两个部分：</p><blockquote><ul><li>栈：在函数内部声明的所有变量都将占用栈内存。</li><li>堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li></ul></blockquote><p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p><p>在 C++ 中，这种运算符即 new 运算符。如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。</p><h3 id="new-和-delete-运算符"><a href="#new-和-delete-运算符" class="headerlink" title="new 和 delete 运算符"></a>new 和 delete 运算符</h3><p>通用语法：</p><blockquote><p>new data-type;<br>delete member; </p></blockquote><p>在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double* pvalue  = NULL; // 初始化为 null 的指针</span><br><span class="line">pvalue  = new double;   // 为变量请求内存</span><br></pre></td></tr></table></figure></p><p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double* pvalue  = NULL;</span><br><span class="line">if( !(pvalue  = new double ))</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;Error: out of memory.&quot; &lt;&lt;endl;</span><br><span class="line">   exit(1);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pvalue = 29494.99;     // 在分配的地址存储值</span><br><span class="line">cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">delete pvalue;        // 释放 pvalue 所指向的内存</span><br></pre></td></tr></table></figure></p><p>malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p><h2 id="C-命名空间"><a href="#C-命名空间" class="headerlink" title="C++ 命名空间"></a>C++ 命名空间</h2><p>命名空间可作为附加信息来<strong>区分不同库中相同名称的函数、类、变量等</strong>。使用了命名空间即定义了<strong>上下文</strong>。本质上，命名空间就是定义了一个范围。</p><h3 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h3><p>命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示：</p><blockquote><p>namespace namespace_name {<br>   // 代码声明<br>}</p></blockquote><p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p><blockquote><p>name::code;  // code 可以是变量或函数</p></blockquote><p>让我们来看看命名空间如何为变量或函数等实体定义范围：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 第一个命名空间</span><br><span class="line">namespace first_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二个命名空间</span><br><span class="line">namespace second_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   // 调用第一个命名空间中的函数</span><br><span class="line">   first_space::func();</span><br><span class="line">   </span><br><span class="line">   // 调用第二个命名空间中的函数</span><br><span class="line">   second_space::func(); </span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Inside first_space</span><br><span class="line">Inside second_space</span><br></pre></td></tr></table></figure></p><h3 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h3><p>您可以使用 using namespace 指令，这样在使用命名空间时就<strong>可以不用在前面加上命名空间的名称</strong>。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 第一个命名空间</span><br><span class="line">namespace first_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二个命名空间</span><br><span class="line">namespace second_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">using namespace first_space;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   // 调用第一个命名空间中的函数</span><br><span class="line">   func();</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Inside first_space</span><br></pre></td></tr></table></figure></p><p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p><blockquote><p>using std::cout;</p></blockquote><p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;std::endl is used with std!&quot; &lt;&lt; std::endl;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">std::endl is used with std!</span><br></pre></td></tr></table></figure></p><p>using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p><h3 id="不连续的命名空间"><a href="#不连续的命名空间" class="headerlink" title="不连续的命名空间"></a>不连续的命名空间</h3><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。<strong>一个命名空间的各个组成部分可以分散在多个文件中</strong>。</p><p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素。</p><h3 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h3><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name1 &#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">   namespace namespace_name2 &#123;</span><br><span class="line">      // 代码声明</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 访问 namespace_name2 中的成员</span><br><span class="line">using namespace namespace_name1::namespace_name2;</span><br><span class="line"> </span><br><span class="line">// 访问 namespace:name1 中的成员</span><br><span class="line">using namespace namespace_name1;</span><br></pre></td></tr></table></figure></p><p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的</p><h2 id="C-模板"><a href="#C-模板" class="headerlink" title="C++ 模板"></a>C++ 模板</h2><p>模板是<strong>泛型</strong>编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p><p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>模板函数定义的一般形式如下所示：</p><blockquote><p>template <class type> ret-type func-name(parameter list)<br>{<br>   // 函数的主体<br>}</class></p></blockquote><p>在这里，<strong>type 是函数所使用的数据类型的占位符名称</strong>。这个名称可以在函数定义中使用。</p><p>下面是函数模板的实例，返回两个数中的最大值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline T const&amp; Max (T const&amp; a, T const&amp; b) </span><br><span class="line">&#123; </span><br><span class="line">    return a &lt; b ? b:a; </span><br><span class="line">&#125; </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    int i = 39;</span><br><span class="line">    int j = 20;</span><br><span class="line">    cout &lt;&lt; &quot;Max(i, j): &quot; &lt;&lt; Max(i, j) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    double f1 = 13.5; </span><br><span class="line">    double f2 = 20.7; </span><br><span class="line">    cout &lt;&lt; &quot;Max(f1, f2): &quot; &lt;&lt; Max(f1, f2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    string s1 = &quot;Hello&quot;; </span><br><span class="line">    string s2 = &quot;World&quot;; </span><br><span class="line">    cout &lt;&lt; &quot;Max(s1, s2): &quot; &lt;&lt; Max(s1, s2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p><blockquote><p>template <class type> class class-name {<br>.<br>.<br>.<br>}</class></p></blockquote><p>在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您<strong>可以使用一个逗号分隔的列表来定义多个泛型数据类型</strong>。</p><p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Stack &#123; </span><br><span class="line">  private: </span><br><span class="line">    vector&lt;T&gt; elems;     // 元素 </span><br><span class="line"> </span><br><span class="line">  public: </span><br><span class="line">    void push(T const&amp;);  // 入栈</span><br><span class="line">    void pop();               // 出栈</span><br><span class="line">    T top() const;            // 返回栈顶元素</span><br><span class="line">    bool empty() const&#123;       // 如果为空则返回真。</span><br><span class="line">        return elems.empty(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Stack&lt;T&gt;::push (T const&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    // 追加传入元素的副本</span><br><span class="line">    elems.push_back(elem);    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Stack&lt;T&gt;::pop () </span><br><span class="line">&#123; </span><br><span class="line">    if (elems.empty()) &#123; </span><br><span class="line">        throw out_of_range(&quot;Stack&lt;&gt;::pop(): empty stack&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 删除最后一个元素</span><br><span class="line">    elems.pop_back();         </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T Stack&lt;T&gt;::top () const </span><br><span class="line">&#123; </span><br><span class="line">    if (elems.empty()) &#123; </span><br><span class="line">        throw out_of_range(&quot;Stack&lt;&gt;::top(): empty stack&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 返回最后一个元素的副本 </span><br><span class="line">    return elems.back();      </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        Stack&lt;int&gt;         intStack;  // int 类型的栈 </span><br><span class="line">        Stack&lt;string&gt; stringStack;    // string 类型的栈 </span><br><span class="line"> </span><br><span class="line">        // 操作 int 类型的栈 </span><br><span class="line">        intStack.push(7); </span><br><span class="line">        cout &lt;&lt; intStack.top() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        // 操作 string 类型的栈 </span><br><span class="line">        stringStack.push(&quot;hello&quot;); </span><br><span class="line">        cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.pop(); </span><br><span class="line">        stringStack.pop(); </span><br><span class="line">    &#125; </span><br><span class="line">    catch (exception const&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; ex.what() &lt;&lt;endl; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">7</span><br><span class="line">hello</span><br><span class="line">Exception: Stack&lt;&gt;::pop(): empty stack</span><br></pre></td></tr></table></figure></p><h2 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h2><p># 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌<strong>转换</strong>为用引号引起来的字符串。</p><p>请看下面的宏定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define MKSTR( x ) #x</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">HELLO C++</span><br></pre></td></tr></table></figure><p>## 运算符用于连接两个令牌。下面是一个实例：</p><blockquote><p>#define CONCAT( x, y )  x ## y</p></blockquote><p>当 CONCAT 出现在程序中时，它的参数会被<strong>连接</strong>起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define concat(a, b) a ## b</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int xy = 100;</span><br><span class="line">   </span><br><span class="line">   cout &lt;&lt; concat(x, y);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">100</span><br></pre></td></tr></table></figure><h2 id="C-友元"><a href="#C-友元" class="headerlink" title="C++ 友元"></a>C++ 友元</h2><p>友元机制<strong>允许一个类将对其非公有成员的访问权授予指定的函数或者类</strong>，友元的声明以friend开始，它只能出现在类定义的内部，友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受其声明出现部分的访问控制影响。通常，将友元声明成组地放在类定义的开始或结尾是个好主意。</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数是指某些虽然不是类成员函数却能够访问类的所有成员的函数。类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend void set_show(int x, A &amp;a);      //该函数是友元函数的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void set_show(int x, A &amp;a)  //友元函数定义，为了访问类A中的成员</span><br><span class="line">&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line"></span><br><span class="line">    set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。</p><p>关于友元类的注意事项：<br>(1) 友元关系不能被继承。<br>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。<br>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend class C;                         //这是友元类的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C             //友元类定义，为了访问类A中的成员</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void set_show(int x, A &amp;a) &#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line">    class C c;</span><br><span class="line"></span><br><span class="line">    c.set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h3><p>使类B中的成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员了。</p><p>当用到友元成员函数时，需注意友元声明和友元定义之间的相互依赖，在该例子中，类B必须先定义，否则类A就不能将一个B的函数指定为友元。然而，只有在定义了类A之后，才能定义类B的该成员函数。更一般的讲，必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A;    //当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。这是类A的声明</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void set_show(int x, A &amp;a);             //该函数是类A的友元函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend void B::set_show(int x, A &amp;a);   //该函数是友元成员函数的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">    void show() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void B::set_show(int x, A &amp;a)       //只有在定义类A后才能定义该函数，毕竟，它被设为友元是为了访问类A的成员</span><br><span class="line">&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line">    class B b;</span><br><span class="line"></span><br><span class="line">    b.set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-信号处理"><a href="#C-信号处理" class="headerlink" title="C++ 信号处理"></a>C++ 信号处理</h2><p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。</p><p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。</csignal></p><table><thead><tr><th>信号</th><th>描述</th></tr></thead><tbody><tr><td>SIGABRT</td><td>程序的异常终止，如调用 abort。</td></tr><tr><td>SIGFPE</td><td>错误的算术运算，比如除以零或导致溢出的操作。</td></tr><tr><td>SIGILL</td><td>检测非法指令。</td></tr><tr><td>SIGINT</td><td>接收到交互注意信号。</td></tr><tr><td>SIGSEGV</td><td>非法访问内存。</td></tr><tr><td>SIGTERM</td><td>发送到程序的终止请求。</td></tr></tbody></table><h3 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal() 函数"></a>signal() 函数</h3><p>C++ 信号处理库提供了 signal 函数，用来<strong>捕获突发事件</strong>。以下是 signal() 函数的语法：</p><blockquote><p>void (*signal (int sig, void (*func)(int)))(int); </p></blockquote><p>这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;csignal&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void signalHandler( int signum )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\n&quot;;</span><br><span class="line"> </span><br><span class="line">    // 清理并关闭</span><br><span class="line">    // 终止程序  </span><br><span class="line"> </span><br><span class="line">   exit(signum);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    // 注册信号 SIGINT 和信号处理程序</span><br><span class="line">    signal(SIGINT, signalHandler);  </span><br><span class="line"> </span><br><span class="line">    while(1)&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;</span><br><span class="line">       sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line"></span><br><span class="line">现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure><h3 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise() 函数"></a>raise() 函数</h3><p>您可以使用函数 raise() <strong>生成信号</strong>，该函数带有一个整数信号编号作为参数，语法如下：</p><blockquote><p>int raise (signal sig);</p></blockquote><p>在这里，sig 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;csignal&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void signalHandler( int signum )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\n&quot;;</span><br><span class="line"> </span><br><span class="line">    // 清理并关闭</span><br><span class="line">    // 终止程序 </span><br><span class="line"> </span><br><span class="line">   exit(signum);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    // 注册信号 SIGINT 和信号处理程序</span><br><span class="line">    signal(SIGINT, signalHandler);  </span><br><span class="line"> </span><br><span class="line">    while(++i)&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;</span><br><span class="line">       if( i == 3 )&#123;</span><br><span class="line">          raise( SIGINT);</span><br><span class="line">       &#125;</span><br><span class="line">       sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure></p><h2 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++ 多线程"></a>C++ 多线程</h2><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>pthread_t：线程ID<br>pthread_attr_t：线程属性</p><ol><li><p>操纵函数<br>pthread_create()：创建一个线程<br>pthread_exit()：终止当前线程<br>pthread_cancel()：中断另外一个线程的运行，Android中没有<br>pthread_join()：阻塞当前的线程，直到另外一个线程运行结束<br>pthread_attr_init()：初始化线程的属性<br>pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）<br>pthread_attr_getdetachstate()：获取脱离状态的属性<br>pthread_attr_destroy()：删除线程的属性<br>pthread_kill()：向线程发送一个信号</p></li><li><p>同步函数<br>pthread_mutex_init() 初始化互斥锁<br>pthread_mutex_destroy() 删除互斥锁<br>pthread_mutex_lock()：占有互斥锁（阻塞操作）<br>pthread_mutex_trylock()：试图占有互斥锁（不阻塞操作）。即，当互斥锁空闲时，将占有该锁；否则，立即返回。<br>pthread_mutex_unlock(): 释放互斥锁<br>pthread_cond_init()：初始化条件变量<br>pthread_cond_destroy()：销毁条件变量<br>pthread_cond_signal(): 唤醒第一个调用pthread_cond_wait()而进入睡眠的线程<br>pthread_cond_wait(): 等待条件变量的特殊条件发生<br>Thread-local storage（或者以Pthreads术语，称作线程特有数据）：<br>pthread_key_create(): 分配用于标识进程中线程特定数据的键<br>pthread_setspecific(): 为指定线程特定数据键设置线程特定绑定<br>pthread_getspecific(): 获取调用线程的键绑定，并将该绑定存储在 value 指向的位置中<br>pthread_key_delete(): 销毁现有线程特定数据键<br>pthread_attr_getschedparam();获取线程优先级<br>pthread_attr_setschedparam();设置线程优先级</p></li><li><p>工具函数<br>pthread_equal(): 对两个线程的线程标识号进行比较<br>pthread_detach(): 分离线程<br>pthread_self(): 查询线程自身线程标识号</p></li></ol><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p><blockquote><p>#include &lt;pthread.h&gt;<br>pthread_create (thread, attr, start_routine, arg) </p></blockquote><p>在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>thread</td><td>指向线程标识符指针。</td></tr><tr><td>attr</td><td>一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td></tr><tr><td>start_routine</td><td>线程运行函数起始地址，一旦线程被创建就会执行。</td></tr><tr><td>arg</td><td>运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td></tr></tbody></table><p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p><blockquote><p>#include &lt;pthread.h&gt;<br>pthread_exit (status) </p></blockquote><p>在这里，pthread_exit 用于显式地退出一个线程。通常情况下，<strong>pthread_exit() 函数是在线程完成工作后无需继续存在时被调用</strong>。</p><p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS     5</span><br><span class="line"> </span><br><span class="line">struct thread_data&#123;</span><br><span class="line">   int  thread_id;</span><br><span class="line">   char *message;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void *PrintHello(void *threadarg)</span><br><span class="line">&#123;</span><br><span class="line">   struct thread_data *my_data;</span><br><span class="line"> </span><br><span class="line">   my_data = (struct thread_data *) threadarg;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Thread ID : &quot; &lt;&lt; my_data-&gt;thread_id ;</span><br><span class="line">   cout &lt;&lt; &quot; Message : &quot; &lt;&lt; my_data-&gt;message &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   pthread_t threads[NUM_THREADS];</span><br><span class="line">   struct thread_data td[NUM_THREADS];</span><br><span class="line">   int rc;</span><br><span class="line">   int i;</span><br><span class="line"> </span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt;&quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      td[i].thread_id = i;</span><br><span class="line">      td[i].message = (char*)&quot;This is message&quot;;</span><br><span class="line">      rc = pthread_create(&amp;threads[i], NULL,</span><br><span class="line">                          PrintHello, (void *)&amp;td[i]);</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Wno-write-strings test.cpp -lpthread -o test.o</span><br><span class="line">$ ./test.o</span><br><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">Thread ID : 0 Message : This is message</span><br><span class="line">main() : creating thread, Thread ID : 21</span><br><span class="line"> Message : This is message</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">Thread ID : 2 Message : This is message</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Thread ID : 3 Message : This is message</span><br><span class="line">Thread ID : 4 Message : This is message</span><br></pre></td></tr></table></figure></p><h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><p>我们可以使用以下两个函数来连接或分离线程：</p><blockquote><p>pthread_join (threadid, status)<br>pthread_detach (threadid) </p></blockquote><p><strong>pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止</strong>。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p><p>一个线程默认的状态是joinable，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符。只有当你<strong>调用了pthread_join之后这些资源才会被释放</strong>。</p><p>这个实例演示了如何使用 pthread_join() 函数来等待线程的完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS     5</span><br><span class="line"> </span><br><span class="line">void *wait(void *t)</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   long tid;</span><br><span class="line"> </span><br><span class="line">   tid = (long)t;</span><br><span class="line"> </span><br><span class="line">   sleep(1);</span><br><span class="line">   cout &lt;&lt; &quot;Sleeping in thread &quot; &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Thread with id : &quot; &lt;&lt; tid &lt;&lt; &quot;  ...exiting &quot; &lt;&lt; endl;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int rc;</span><br><span class="line">   int i;</span><br><span class="line">   pthread_t threads[NUM_THREADS];</span><br><span class="line">   pthread_attr_t attr;</span><br><span class="line">   void *status;</span><br><span class="line"> </span><br><span class="line">   // 初始化并设置线程为可连接的（joinable）</span><br><span class="line">   pthread_attr_init(&amp;attr);</span><br><span class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"> </span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt; &quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      rc = pthread_create(&amp;threads[i], NULL, wait, (void *)&amp;i );</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // 删除属性，并等待其他线程</span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = pthread_join(threads[i], &amp;status);</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to join,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; &quot;Main: completed thread id :&quot; &lt;&lt; i ;</span><br><span class="line">      cout &lt;&lt; &quot;  exiting with status :&quot; &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Main: program exiting.&quot; &lt;&lt; endl;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">main() : creating thread, 2</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 4  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 3  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 2  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 1  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Main: completed thread id :0  exiting with status :0</span><br><span class="line">Main: completed thread id :1  exiting with status :0</span><br><span class="line">Main: completed thread id :2  exiting with status :0</span><br><span class="line">Main: completed thread id :3  exiting with status :0</span><br><span class="line">Main: completed thread id :4  exiting with status :0</span><br><span class="line">Main: program exiting.</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-tutorial.html</a><br><a href="https://www.jianshu.com/p/34d88df0cfe0" target="_blank" rel="noopener">https://www.jianshu.com/p/34d88df0cfe0</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JNI 的调用</title>
      <link href="/2020/01/03/android-ndk-jni-invoke/"/>
      <url>/2020/01/03/android-ndk-jni-invoke/</url>
      
        <content type="html"><![CDATA[<h2 id="注册native函数"><a href="#注册native函数" class="headerlink" title="注册native函数"></a>注册native函数</h2><p>JNI有两种注册native方法的途径：</p><blockquote><ul><li>静态注册：<br>先由Java得到本地方法的声明，然后再通过JNI实现该声明方法</li><li>动态注册：<br>先通过JNI重载JNI_OnLoad()实现本地方法，然后直接在Java中调用本地方法。</li></ul></blockquote><h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册就是根据函数名来遍历Java和JNI函数之间的关联，而且要求JNI层函数的名字必须遵循特定的格式。具体的实现很简单，首先在Java代码中声明native函数，然后通过javah来生成native函数的具体形式，接下来在JNI代码中实现这些函数即可。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class JniDemo1&#123;</span><br><span class="line">       static &#123;</span><br><span class="line">             System.loadLibrary(&quot;samplelib_jni&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private native void nativeMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接来下通过javah来产生jni代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -d ./jni/ -classpath /Users/YOUR_NAME/Library/Android/sdk/platforms/android-21/android.jar:../../build/intermediates/classes/debug/ com.xxxpackagename.JniDemo1</span><br></pre></td></tr></table></figure></p><p>然后就会得到一个JNI的.h文件，里面包含这几个native函数的声明，观察一下文件名以及函数名。JNI方法名的规范：</p><blockquote><p>返回值 + Java前缀+全路径类名+方法名+参数1JNIEnv+参数2jobject+其他参数</p></blockquote><p>注意事项：</p><blockquote><ul><li>注意分隔符：<br>Java前缀与类名以及类名之间的包名和方法名之间使用”_”进行分割；</li><li>注意静态：<br>如果在Java中声明的方法是”静态的”，则native方法也是static。否则不是。</li></ul></blockquote><h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册，也就是通过RegisterNatives方法把C/C++中的方法映射到Java中的native方法，而无需遵循特定的方法命名格式。</p><p>当我们使用System.loadLibarary()方法加载so库的时候，Java虚拟机就会找到这个<strong>JNI_OnLoad</strong>函数并调用该函数，<strong>这个函数的作用是告诉Dalvik虚拟机此C库使用的是哪一个JNI版本</strong>，如果你的库里面没有写明JNI_OnLoad()函数，VM会默认该库使用最老的JNI 1.1版本。由于最新版本的JNI做了很多扩充，也优化了一些内容，如果需要使用JNI新版本的功能，就必须在JNI_OnLoad()函数声明JNI的版本，同时也可以在该函数中做一些初始化的动作。该函数前面也有三个关键字分别是JNIEXPORT，JNICALL ，jint。其中JNIEXPORT和JNICALL是两个宏定义，用于指定该函数时JNI函数。jint是JNI定义的数据类型，因为Java层和C/C++的数据类型或者对象不能直接相互的引用或者使用，JNI层定义了自己的数据类型，用于衔接Java层和JNI层。与JNI_OnLoad()函数相对应的有JNI_OnUnload()函数，当虚拟机释放的该C库的时候，则会调用JNI_OnUnload()函数来进行善后清除工作。</p><p>该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义一下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DestroyJavaVM</span><br><span class="line">AttachCurrentThread</span><br><span class="line">DetachCurrentThread</span><br><span class="line">GetEnv</span><br></pre></td></tr></table></figure></p><p>举例说明，首先是加载so库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class JniDemo1&#123;</span><br><span class="line">       static &#123;</span><br><span class="line">             System.loadLibrary(&quot;samplelib_jni&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在jni中的实现，并且在这个函数里面去动态的注册native方法，完整的参考代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &quot;Log4Android.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static const char *className = &quot;com/gebilaolitou/jnidemo/JNIDemo2&quot;;</span><br><span class="line"></span><br><span class="line">static void sayHello(JNIEnv *env, jobject, jlong handle) &#123;</span><br><span class="line">    LOGI(&quot;JNI&quot;, &quot;native: say hello ###&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static JNINativeMethod gJni_Methods_table[] = &#123;</span><br><span class="line">    &#123;&quot;sayHello&quot;, &quot;(J)V&quot;, (void*)sayHello&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int jniRegisterNativeMethods(JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;JNI&quot;,&quot;Registering %s natives\n&quot;, className);</span><br><span class="line">    clazz = (env)-&gt;FindClass( className);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;Native registration unable to find class &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    if ((env)-&gt;RegisterNatives(clazz, gJni_Methods_table, numMethods) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;RegisterNatives failed for &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (env)-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jint JNI_OnLoad(JavaVM* vm, void* reserved)&#123;</span><br><span class="line">    LOGI(&quot;JNI&quot;, &quot;enter jni_onload&quot;);</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = NULL;</span><br><span class="line">    jint result = -1;</span><br><span class="line"></span><br><span class="line">    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jniRegisterNativeMethods(env, className, gJni_Methods_table, sizeof(gJni_Methods_table) / sizeof(JNINativeMethod));</span><br><span class="line"></span><br><span class="line">    return JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>我们一个个来说，首先看JNI_OnLoad函数的实现，里面代码很简单，主要就是两个代码块，一个是if语句，一个是jniRegisterNativeMethods函数的实现。那我们一个一个来分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">    return result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里调用了GetEnv函数时为了<strong>获取JNIEnv结构体指针</strong>，其实JNIEnv结构体指向了一个函数表，该函数表指向了对应的JNI函数，我们通过这些JNI函数实现JNI编程。</p><p>然后就调用了jniRegisterNativeMethods函数来实现注册，这里面注意一个静态变量gJni_Methods_table。它其实代表了一个native方法的数组，如果你在一个Java类中有一个native方法，这里它的size就是1，如果是两个native方法，它的size就是2，大家看下这个gJni_Methods_table变量的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod gJni_Methods_table[] = &#123;</span><br><span class="line">    &#123;&quot;sayHello&quot;, &quot;(J)V&quot;, (void*)sayHello&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们看到他的类型是JNINativeMethod ，那我们就来研究下JNINativeMethod</p><p>JNI允许我们提供一个<strong>函数映射表</strong>，注册给Java虚拟机，这样JVM就可以用函数映射表来调用相应的函数。这样就可以不必通过函数名来查找需要调用的函数了。Java与JNI通过JNINativeMethod的结构来建立联系，它被定义在jni.h中，其结构内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123; </span><br><span class="line">    const char* name; </span><br><span class="line">    const char* signature; </span><br><span class="line">    void* fnPtr; </span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure></p><p>这里面有3个变量，那我们就依次来讲解下：<br>第一个变量name，代表的是Java中的函数名<br>第二个变量signature，代表的是Java中的参数和返回值<br>第三个变量fnPtr，代表的是的指向C函数的函数指针</p><p>下面我们再来看下jniRegisterNativeMethods函数内部的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int jniRegisterNativeMethods(JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;JNI&quot;,&quot;Registering %s natives\n&quot;, className);</span><br><span class="line">    clazz = (env)-&gt;FindClass( className);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;Native registration unable to find class &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    if ((env)-&gt;RegisterNatives(clazz, gJni_Methods_table, numMethods) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;RegisterNatives failed for &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (env)-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先通过clazz = (env)-&gt;FindClass( className);找到声明native方法的类<br>然后通过调用<strong>RegisterNatives</strong>函数将注册函数的Java类，以及注册函数的数组，以及个数注册在一起，这样就实现了绑定。</p><p>上面在讲解JNINativeMethod结构体的时候，提到一个概念，就是”signature”即签名，我们下面就来讲解下。</p><h2 id="JNI中的签名"><a href="#JNI中的签名" class="headerlink" title="JNI中的签名"></a>JNI中的签名</h2><p>Java是支持函数重载的。但如果JNI仅仅是根据函数名，是没有办法找到重载的函数的，所以为了解决这个问题，JNI就衍生了一个概念——“签名”，即<strong>参数类型和返回值类型的组合</strong>。如果拥有一个该函数的签名信息和这个函数的函数名，我们就可以顺序的找到对应的Java层中的函数了。</p><h3 id="查看类中的方法的签名"><a href="#查看类中的方法的签名" class="headerlink" title="查看类中的方法的签名"></a>查看类中的方法的签名</h3><p>可以使用 java -p命令(建议使用该命令来对比签名)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">javap -s -p MainActivity.class</span><br><span class="line"></span><br><span class="line">Compiled from &quot;MainActivity.java&quot;</span><br><span class="line">public class com.example.hellojni.MainActivity extends android.app.Activity &#123;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Signature: ()V</span><br><span class="line"></span><br><span class="line">  public com.example.hellojni.MainActivity();</span><br><span class="line">    Signature: ()V</span><br><span class="line"></span><br><span class="line">  protected void onCreate(android.os.Bundle);</span><br><span class="line">    Signature: (Landroid/os/Bundle;)V</span><br><span class="line"></span><br><span class="line">  public boolean onCreateOptionsMenu(android.view.Menu);</span><br><span class="line">    Signature: (Landroid/view/Menu;)Z</span><br><span class="line"></span><br><span class="line">  public native java.lang.String stringFromJNI(); //native 方法</span><br><span class="line">    Signature: ()Ljava/lang/String;  //签名</span><br><span class="line"></span><br><span class="line">  public native int max(int, int); //native 方法</span><br><span class="line">    Signature: (II)I    //签名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到上面有()V ，(Landroid/os/Bundle;)V，(Landroid/view/Menu;)Z，(II)I我们一脸懵逼，这是什么鬼，所以我们要来研究下签名的格式</p><h3 id="JNI定义的函数签名信息"><a href="#JNI定义的函数签名信息" class="headerlink" title="JNI定义的函数签名信息"></a>JNI定义的函数签名信息</h3><blockquote><p>(参数1类型标示；参数2类型标示；参数3类型标示…)返回值类型标示</p></blockquote><p>当参数为引用类型的时候，参数类型的标示的根式为”L包名”，其中包名的.(点)要换成”/“，看我上面的例子就差不多，比如String就是Ljava/lang/String，Menu为Landroid/view/Menu。</p><p>如果是基本类类型，其签名如下：</p><table><thead><tr><th>类型标示</th><th>Java类型</th></tr></thead><tbody><tr><td>Z</td><td>boolean</td></tr><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>S</td><td>short</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>F</td><td>float</td></tr><tr><td>D</td><td>double</td></tr></tbody></table><p>除了boolean和long，其他都是首字母大写。如果返回值是void，对应的签名是<strong>V</strong>。</p><p>这里重点说1个特殊的类型，一个是数组及Array:</p><table><thead><tr><th>类型标示</th><th>Java类型</th></tr></thead><tbody><tr><td>[签名</td><td>数组</td></tr><tr><td>[i</td><td>int[]</td></tr><tr><td>[Ljava/lang/Object</td><td>String[]</td></tr></tbody></table><h2 id="Native调用Java代码"><a href="#Native调用Java代码" class="headerlink" title="Native调用Java代码"></a>Native调用Java代码</h2><p>上面讲解了如何从JNI中调用Java类中的方法，其实在jni.h中已经定义了一系列函数来实现这一目的，下面我们就以此举例说明：</p><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>为了能够在C/C++中调用Java中的类，jni.h的头文件专门定义了jclass类型表示Java中Class类。JNIEnv中有3个函数可以获取jclass。</p><blockquote><ul><li>jclass FindClass(const char* clsName)：<br>通过类的名称来获取jclass。</li><li>jclass GetObjectClass(jobject obj)：<br>通过对象实例来获取jclass，相当于Java中的getClass()函数</li><li>jclass getSuperClass(jclass obj)：<br>通过jclass可以获取其父类的jclass对象</li></ul></blockquote><p>通过类的名称获取jclass(类的全名，这时候包名不是用’”.”点号而是用”/“来区分的)。比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取Java中的String对象的class对象</span><br><span class="line">jclass jcl_string=env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="获取属性方法"><a href="#获取属性方法" class="headerlink" title="获取属性方法"></a>获取属性方法</h3><p>为了在C/C++获取Java层的属性和方法，JNI在jni.h头文件中定义了jfieldID和jmethodID这两种类型来分别代表Java端的属性和方法。</p><p>常见的调用Java层的方法如下，一般是使用JNIEnv来进行操作：</p><blockquote><p>GetFieldID/GetMethodID：获取某个属性/某个方法<br>GetStaticFieldID/GetStaticMethodID：获取某个静态属性/静态方法</p></blockquote><p>方法的具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jfieldID GetFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jfieldID GetStaticFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jmethodID GetStaticMethodID(JNIEnv *env, jclass clazz,const char *name, const char *sig);</span><br></pre></td></tr></table></figure></p><p>他们都是4个入参，并且都一样。JNIEnv代表一个JNI环境接口，jclass上面也说了代表Java层中的”类”，name则代表方法名或者属性名，那最后一个char *sig代表签名。</p><h3 id="构造一个对象"><a href="#构造一个对象" class="headerlink" title="构造一个对象"></a>构造一个对象</h3><p>常用的JNI中创建对象的方法如下：</p><blockquote><p>jobject NewObject(jclass clazz, jmethodID methodID, …)</p></blockquote><p>比如有我们知道Java类中可能有多个构造函数，当我们要指定调用某个构造函数的时候，会调用下面这个方法，即把指定的构造函数传入进去即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">obj = (*env)-&gt;NewObject(env, cls, mid);</span><br></pre></td></tr></table></figure></p><p>现在我们来看下他上面的二个主要参数</p><blockquote><p>clazz：是需要创建的Java对象的Class对象<br>methodID：是传递一个方法ID，想一想Java对象创建的时候，需要执行什么操作？就是执行构造函数。</p></blockquote><p>有人会说这要走两行代码，有没有一行代码的，是有的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobject NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);</span><br></pre></td></tr></table></figure></p><p>这里多了一个参数，即jvalue *args，这里是args代表的是对应构造函数的所有参数的，我们可以应将传递给构造函数的所有参数放在jvalues类型的数组args中，该数组紧跟着放在methodID参数的后面。NewObject()收到数组中的这些参数后，将把它们传给所要调用的Java方法。</p><p>上面说到，参数是个数组，如果参数不是数组怎么处理，jni.h同样也提供了一个方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobject NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);</span><br></pre></td></tr></table></figure></p><p>这个方法和上面不同在于，这里将构造函数的所有参数放到在va_list类型的参数args中，该参数紧跟着放在methodID参数的后面。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>JNI获取类的成员变量的ID调用GetFieldID获取，通过Set[类型]Field修改变量值。</li><li>JNI获取类的静态变量的ID调用GetStaticFieldID获取，通过SetStatic[类型]Field修改变量值。</li><li>JNI获取类的方法的ID调用GetMethodID获取，通过Call[类型]Method调用方法。</li><li>JNI获取类的静态方法的ID调用GetStaticMethodID获取，通过CallStatic[类型]Method调用方法。</li><li>JNI获取类的构造方法的ID调用GetMethodID获取，通过NewObject构造，构造函数名为”<init>“。</init></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/b71aeb4ed13d" target="_blank" rel="noopener">https://www.jianshu.com/p/b71aeb4ed13d</a><br><a href="https://www.jianshu.com/p/0f34c097028a" target="_blank" rel="noopener">JNI学习Demo</a><br><a href="https://www.jianshu.com/p/83f3ec4f3ac1" target="_blank" rel="noopener">JNI访问Java变量和方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Android NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JNI 详解</title>
      <link href="/2020/01/02/android-ndk-jni/"/>
      <url>/2020/01/02/android-ndk-jni/</url>
      
        <content type="html"><![CDATA[<p>JNI，全称为Java Native Interface，即Java本地接口，JNI是Java调用Native 语言的一种特性。通过JNI可以使得Java与C/C++机型交互。即可以在Java代码中调用C/C++等语言的代码或者在C/C++代码中调用Java代码。由于JNI是JVM规范的一部分，因此可以将我们写的JNI的程序在任何实现了JNI规范的Java虚拟机中运行。</p><p>JNI的主要竞争优势在于：它在设计之初就确保了二进制的兼容性，JNI编写的应用程序兼容性以及其在某些具体平台上的Java虚拟机兼容性(当谈及JNI时，这里并不特比针对Davik虚拟机，JNI适用于所有JVM虚拟机)。这就是为什么C/C++编译后的代码无论在任何平台上都能执行。不过，一些早期版本并不支持二进制兼容。二进制兼容性是一种程序兼容性类型，允许一个程序在不改变其可执行文件的条件下在不同的编译环境中工作。</p><p>JNI下一共涉及到三个角色：C/C++代码、本地方法接口类、Java层中具体业务类。</p><h2 id="JNI的命名规则"><a href="#JNI的命名规则" class="headerlink" title="JNI的命名规则"></a>JNI的命名规则</h2><p>举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNIExport jstring JNICALL Java_com_example_hellojni_MainActivity_stringFromJNI( JNIEnv* env,jobject thiz )</span><br></pre></td></tr></table></figure></p><p>jstring 是返回值类型<br>Java_com_example_hellojni 是包名<br>MainActivity 是类名<br>stringFromJNI 是方法名</p><p>其中JNIExport和JNICALL是不固定保留的关键字不要修改</p><h2 id="如何实现JNI"><a href="#如何实现JNI" class="headerlink" title="如何实现JNI"></a>如何实现JNI</h2><p>JNI开发流程的步骤：</p><blockquote><ul><li>第1步：在Java中先声明一个native方法</li><li>第2步：编译Java源文件javac得到.class文件</li><li>第3步：通过javah -jni命令导出JNI的.h头文件</li><li>第4步：使用Java需要交互的本地代码，实现在Java中声明的Native方法（如果Java需要与C++交互，那么就用C++实现Java的Native方法。）</li><li>第5步：将本地代码编译成动态库(Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib)</li><li>第6步：通过Java命令执行Java程序，最终实现Java调用本地代码。</li></ul></blockquote><p>PS：javah 是JDK自带的一个命令，-jni参数表示将class 中用到native 声明的函数生成JNI 规则的函数</p><p><img src="/2020/01/02/android-ndk-jni/jni-flow.webp" alt title="JNI开发流程"></p><h2 id="JNI结构"><a href="#JNI结构" class="headerlink" title="JNI结构"></a>JNI结构</h2><p><img src="/2020/01/02/android-ndk-jni/jni-struct.webp" alt title="JNI结构"><br>这张JNI函数表的组成就像C++的虚函数表。虚拟机可以运行多张函数表，举例来说，一张调试函数表，另一张是调用函数表。JNI接口指针仅在当前线程中起作用。这意味着指针不能从一个线程进入另一个线程。然而，可以在不同的线程中调用本地方法。</p><p><img src="/2020/01/02/android-ndk-jni/jni-interface.webp" alt title="JNI接口"></p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (JNIEnv *env, jobject obj, jint i, jstring s)</span><br><span class="line">&#123;</span><br><span class="line">     const char *str = (*env)-&gt;GetStringUTFChars(env, s, 0); </span><br><span class="line">     (*env)-&gt;ReleaseStringUTFChars(env, s, str); </span><br><span class="line">     return 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>里面的方法有三个入参，我们就依次来看下：</p><blockquote><ul><li>*env：一个接口指针</li><li>obj：在本地方法中声明的对象引用</li><li>i和s：用于传递的参数</li></ul></blockquote><p>关于obj、i和s的类型大家可以参考下面的JNI数据类型，JNI有自己的原始数据类型和数据引用类型如下：</p><p><img src="/2020/01/02/android-ndk-jni/jni-type.webp" alt></p><h2 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h2><p>Java语言的执行环境是Java虚拟机(JVM)，JVM其实是主机环境中的一个进程，每个JVM虚拟机都在本地环境中有一个JavaVM结构体，该结构体在创建Java虚拟机时被返回，在JNI环境中创建JVM的函数为JNI_CreateJavaVM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNI_CreateJavaVM(JavaVM **pvm, void **penv, void*args);</span><br></pre></td></tr></table></figure></p><h3 id="JavaVM"><a href="#JavaVM" class="headerlink" title="JavaVM"></a>JavaVM</h3><p>JavaVM是Java虚拟机在JNI层的代表，<strong>JNI全局仅仅有一个JavaVM结构中封装了一些函数指针（或叫函数表结构）</strong>，JavaVM中封装的这些函数指针主要是对JVM操作接口。另外，在C和C++中的JavaVM的定义有所不同，在C中JavaVM是JNIInvokeInterface_类型指针，而在C++中有对JNIInvokeInterface_进行了一次封装，比C中少了一个参数，这也是为什么JNI代码更推荐使用C++来编写的原因。</p><h3 id="JNIEnv"><a href="#JNIEnv" class="headerlink" title="JNIEnv"></a>JNIEnv</h3><p>JNIEnv是一个线程相关的结构体，该结构体代表了Java在本线程的执行环境。该 JNIEnv 将用于线程本地存储。因此，您<strong>无法在线程之间共享 JNIEnv</strong>。</p><p>一个JVM对应一个JavaVM结构，而一个JVM中可能创建多个Java线程，每个线程对应一个JNIEnv结构，它们保存在线程本地存储TLS中。因此，不同的线程的JNIEnv是不同，也不能相互共享使用。JNIEnv结构也是一个函数表，在本地代码中通过JNIEnv的函数表来操作Java数据或者调用Java方法。也就是说，只要在本地代码中拿到了JNIEnv结构，就可以在本地代码中调用Java代码。</p><h4 id="JNIEnv的作用"><a href="#JNIEnv的作用" class="headerlink" title="JNIEnv的作用"></a>JNIEnv的作用</h4><ul><li>调用Java 函数：JNIEnv代表了Java执行环境，能够使用JNIEnv调用Java中的代码</li><li>操作Java代码：Java对象传入JNI层就是jobject对象，需要使用JNIEnv来操作这个Java对象</li></ul><h4 id="JNIEnv的创建"><a href="#JNIEnv的创建" class="headerlink" title="JNIEnv的创建"></a>JNIEnv的创建</h4><p>JNIEnv 创建与释放：从JavaVM获得，这里面又分为C与C++，我们就依次来看下：</p><ul><li>C 中——JNIInvokeInterface：JNIInvokeInterface是C语言环境中的JavaVM结构体，调用 (*AttachCurrentThread)(JavaVM*, JNIEnv*, void) 方法，能够获得JNIEnv结构体</li><li>C++中 ——_JavaVM：_JavaVM是C++中JavaVM结构体，调用jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) 方法，能够获取JNIEnv结构体；</li></ul><h4 id="JNIEnv的释放"><a href="#JNIEnv的释放" class="headerlink" title="JNIEnv的释放"></a>JNIEnv的释放</h4><ul><li>C 中释放：调用JavaVM结构体JNIInvokeInterface中的(*DetachCurrentThread)(JavaVM*)方法，能够释放本线程的JNIEnv</li><li>C++ 中释放：调用JavaVM结构体_JavaVM中的jint DetachCurrentThread(){ return functions-&gt;DetachCurrentThread(this); } 方法，就可以释放 本线程的JNIEnv</li></ul><h4 id="JNIEnv与线程"><a href="#JNIEnv与线程" class="headerlink" title="JNIEnv与线程"></a>JNIEnv与线程</h4><p>JNIEnv是线程相关的，即在每一个线程中都有一个JNIEnv指针，每个JNIEnv都是线程专有的，其他线程不能使用本线程中的JNIEnv，即线程A不能调用线程B的JNIEnv。所以JNIEnv不能跨线程。</p><h4 id="JNIEnv结构"><a href="#JNIEnv结构" class="headerlink" title="JNIEnv结构"></a>JNIEnv结构</h4><p>JNIEnv是一个指针，指向一个线程相关的结构，线程相关结构指向JNI函数指针数组，这个数组中存放了大量的JNI函数指针，这些指针指向了详细的JNI函数：</p><p><img src="/2020/01/02/android-ndk-jni/jnienv-struct.webp" alt title="JNIEnv结构图"></p><h4 id="与JNIEnv相关的常用函数"><a href="#与JNIEnv相关的常用函数" class="headerlink" title="与JNIEnv相关的常用函数"></a>与JNIEnv相关的常用函数</h4><h5 id="创建Java中的对象"><a href="#创建Java中的对象" class="headerlink" title="创建Java中的对象"></a>创建Java中的对象</h5><blockquote><ul><li>jobject NewObject(JNIEnv *env, jclass clazz,jmethodID methodID, …)：</li><li>jobject NewObjectA(JNIEnv *env, jclass clazz,jmethodID methodID, const jvalue *args)：</li><li>jobject NewObjectV(JNIEnv *env, jclass clazz,jmethodID methodID, va_list args)：</li></ul></blockquote><p>第一个参数jclass class 代表的你要创建哪个类的对象，第二个参数,jmethodID methodID代表你要使用那个构造方法ID来创建这个对象。只要有jclass和jmethodID，我们就可以在本地方法创建这个Java类的对象。</p><h5 id="创建Java类中的String对象"><a href="#创建Java类中的String对象" class="headerlink" title="创建Java类中的String对象"></a>创建Java类中的String对象</h5><blockquote><p>jstring NewString(JNIEnv *env, const jchar *unicodeChars, jsize len)：</p></blockquote><p>通过Unicode字符的数组来创建一个新的String对象。<br>env是JNI接口指针；unicodeChars是指向Unicode字符串的指针；len是Unicode字符串的长度。返回值是Java字符串对象，如果无法构造该字符串，则为null。</p><p>那有没有一个直接直接new一个utf-8的字符串的方法呢？答案是有的，就是jstring NewStringUTF(JNIEnv *env, const char *bytes)这个方法就是直接new一个编码为utf-8的字符串。</p><h5 id="创建类型为基本类型PrimitiveType的数组"><a href="#创建类型为基本类型PrimitiveType的数组" class="headerlink" title="创建类型为基本类型PrimitiveType的数组"></a>创建类型为基本类型PrimitiveType的数组</h5><blockquote><p>ArrayType New<primitivetype>Array(JNIEnv *env, jsize length)</primitivetype></p></blockquote><p>指定一个长度然后返回相应的Java基本类型的数组。用于构造一个新的数组对象，类型是原始类型。基本的原始类型如下：</p><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>New<primitivetype>Array Routines</primitivetype></td><td>Array Type</td></tr><tr><td>NewBooleanArray()</td><td>jbooleanArray</td></tr><tr><td>NewByteArray()</td><td>jbyteArray</td></tr><tr><td>NewCharArray()</td><td>jcharArray</td></tr><tr><td>NewShortArray()</td><td>jshortArray</td></tr><tr><td>NewIntArray()</td><td>jintArray</td></tr><tr><td>NewLongArray()</td><td>jlongArray</td></tr><tr><td>NewFloatArray()</td><td>jfloatArray</td></tr><tr><td>NewDoubleArray()</td><td>jdoubleArray</td></tr></tbody></table><h5 id="创建类型为elementClass的数组"><a href="#创建类型为elementClass的数组" class="headerlink" title="创建类型为elementClass的数组"></a>创建类型为elementClass的数组</h5><blockquote><p>jobjectArray NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement);</p></blockquote><p>造一个新的数据组，类型是elementClass，所有类型都被初始化为initialElement。</p><h5 id="获取数组中某个位置的元素"><a href="#获取数组中某个位置的元素" class="headerlink" title="获取数组中某个位置的元素"></a>获取数组中某个位置的元素</h5><blockquote><p>jobject GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index);</p></blockquote><p>返回Object数组的一个元素</p><h5 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h5><blockquote><p>jsize GetArrayLength(JNIEnv *env, jarray array);</p></blockquote><p>获取array数组的长度.</p><h5 id="GetArrayElements"><a href="#GetArrayElements" class="headerlink" title="GetArrayElements"></a>GetArrayElements</h5><blockquote><p>NativeType *Get<primitivetype>ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy);</primitivetype></p></blockquote><p>返回指向数组元素的指针，如果操作失败则返回NULL。</p><p>这是用来<strong>返回原生数据类型数组体的家族函数</strong>。函数返回的指针在调用对应的ReleaseArrayElements()函数之前都是有效的（就是指针指向的区域没有被释放，是可以使用的）。因为这个函数返回的数组可能是Java数组的一份拷贝，所以直到调用ReleaseArrayElements()方法，对返回的数组所做的修改才会反映到原始数组中。</p><p>GetArrayElements()函数的返回值是和JVM相关的，如果JVM的GC支持pin操作，那么返回值就是指向原始数组的指针；否则返回的就是原始数组的一份拷贝的首地址。</p><p>如果isCopy不为NULL，如果进行了复制，则*isCopy设置为JNI_TRUE; 如果没有复制，则设置为JNI_FALSE。</p><p>下表描述了特定的原始数组元素访问器。您应该进行以下替换：</p><blockquote><ul><li>将GetArrayElements替换为下表中的一个实际原始元素访问器例程名称。</li><li>将ArrayType替换为相应的数组类型。</li><li>将NativeType替换为该例程的相应本地类型。</li></ul></blockquote><p>无论如何在JVM中表示布尔数组，GetBooleanArrayElements()始终返回指向jbooleans的指针，每个字节表示一个元素（解包表示）。其他类型的所有数组都保证在内存中是连续的。</p><table><thead><tr><th>GetArrayElements例程</th><th>数组类型</th><th>本地类型</th></tr></thead><tbody><tr><td>GetBooleanArrayElements()</td><td>jbooleanArray</td><td>jboolean</td></tr><tr><td>GetByteArrayElements()</td><td>jbyteArray</td><td>jbyte</td></tr><tr><td>GetCharArrayElements()    jcharArray</td><td>jchar</td></tr><tr><td>GetShortArrayElements()</td><td>jshortArray</td><td>jshort</td></tr><tr><td>GetIntArrayElements()</td><td>jintArray</td><td>jint</td></tr><tr><td>GetLongArrayElements()</td><td>jlongArray</td><td>jlong</td></tr><tr><td>GetFloatArrayElements()</td><td>jfloatArray</td><td>jfloat</td></tr><tr><td>GetDoubleArrayElements()</td><td>jdoubleArray</td><td>jdouble</td></tr></tbody></table><h5 id="ReleaseArrayElements"><a href="#ReleaseArrayElements" class="headerlink" title="ReleaseArrayElements"></a>ReleaseArrayElements</h5><blockquote><p>void Release<primitivetype>ArrayElements(JNIEnv *env, ArrayType array, NativeType *elems, jint mode);</primitivetype></p></blockquote><p>一系列函数，通知VM本地代码不再需要访问elems。elems参数是使用相应的GetArrayElements()函数从数组派生的指针。<strong>如有必要，此函数会将对elems所做的所有更改复制回原始数组</strong>。</p><p>mode参数提供有关如何释放数组缓冲区的信息。如果elems不是数组中元素的副本，则mode无效。否则，模式会产生以下影响，如下表所示：</p><table><thead><tr><th>模式</th><th>行为</th></tr></thead><tbody><tr><td>0</td><td>复制回内容并释放elems缓冲区</td></tr><tr><td>JNI_COMMIT</td><td>复制回内容，但不释放elems缓冲区</td></tr><tr><td>JNI_ABORT</td><td>释放缓冲区而不复制回可能的更改</td></tr></tbody></table><p>在大多数情况下，程序员<strong>将“0”传递给mode参数，以确保固定和复制数组的一致行为</strong>。其他选项使程序员可以更好地控制内存管理，并且应该非常谨慎地使用。</p><p>关于更多JNI的常用方法，文档可以参考 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp9502" target="_blank" rel="noopener">JNI Functions</a></p><h2 id="JNI的引用"><a href="#JNI的引用" class="headerlink" title="JNI的引用"></a>JNI的引用</h2><p>在JNI规范中定义了三种引用：局部引用（Local Reference）、全局引用（Global Reference）、弱全局引用（Weak Global Reference）。</p><h3 id="局部引用-Local-Reference"><a href="#局部引用-Local-Reference" class="headerlink" title="局部引用(Local Reference)"></a>局部引用(Local Reference)</h3><p>局部引用，也成本地引用，通常是在函数中创建并使用。会阻止GC回收所有引用对象。</p><p>最常见的引用类型，基本上通过JNI返回来的引用都是局部引用，例如使用NewObject，就会返回创建出来的实例的局部引用，局部引用值在该native函数有效，所有在该函数中产生的局部引用，都会<strong>在函数返回的时候自动释放(freed)，也可以使用DeleteLocalRef函数手动释放该应用</strong>。之所以使用DeleteLocalRef函数：实际上局部引用存在，就会防止其指向对象被垃圾回收期回收，尤其是当一个局部变量引用指向一个很庞大的对象，或是在一个循环中生成一个局部引用，最好的做法就是在使用完该对象后，或在该循环尾部把这个引用是释放掉，以确保在垃圾回收器被触发的时候被回收。在局部引用的有效期中，可以传递到别的本地函数中，要强调的是它的有效期仍然只是在第一次的Java本地函数调用中，所以千万不能用C++全部变量保存它或是把它定义为C++静态局部变量。</p><h3 id="全局引用-Global-Reference"><a href="#全局引用-Global-Reference" class="headerlink" title="全局引用(Global Reference)"></a>全局引用(Global Reference)</h3><p>全局引用可以跨方法、跨线程使用，直到被开发者<strong>显式释放</strong>。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。能创建全部引用的函数只有NewGlobalRef，而释放它需要使用ReleaseGlobalRef函数</p><h3 id="弱全局引用-Weak-Global-Reference"><a href="#弱全局引用-Weak-Global-Reference" class="headerlink" title="弱全局引用(Weak Global Reference)"></a>弱全局引用(Weak Global Reference)</h3><p>与全局引用类似，创建跟删除都需要由编程人员来进行，不一样的是，弱引用将不会阻止垃圾回收期回收这个引用所指向的对象，所以在使用时需要多加小心，它所引用的对象可能是不存在的或者已经被回收。</p><p>通过使用NewWeakGlobalRef、ReleaseWeakGlobalRef来产生和解除引用。</p><h3 id="引用比较"><a href="#引用比较" class="headerlink" title="引用比较"></a>引用比较</h3><p>在给定两个引用，不管是什么引用，我们只需要调用IsSameObject函数来判断他们是否是指向相同的对象。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*env)-&gt;IsSameObject(env, obj1, obj2)</span><br></pre></td></tr></table></figure></p><p>如果obj1和obj2指向相同的对象，则返回JNI_TRUE(或者1)，否则返回JNI_FALSE(或者0),</p><p>PS：有一个特殊的引用需要注意：NULL，JNI中的NULL引用指向JVM中的null对象，如果obj是一个全局或者局部引用，使用(*env)-&gt;IsSameObject(env, obj, NULL)或者obj == NULL用来判断obj是否指向一个null对象即可。但是需要注意的是，IsSameObject用于弱全局引用与NULL比较时，返回值的意义是不同于局部引用和全局引用的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobject local_obj_ref = (*env)-&gt;NewObject(env, xxx_cls,xxx_mid);</span><br><span class="line">jobject g_obj_ref = (*env)-&gt;NewWeakGlobalRef(env, local_ref);</span><br><span class="line">// ... 业务逻辑处理</span><br><span class="line">jboolean isEqual = (*env)-&gt;IsSameObject(env, g_obj_ref, NULL);</span><br></pre></td></tr></table></figure></p><h2 id="UTF-8-和-UTF-16-字符串"><a href="#UTF-8-和-UTF-16-字符串" class="headerlink" title="UTF-8 和 UTF-16 字符串"></a>UTF-8 和 UTF-16 字符串</h2><p>Java 编程语言使用的是 UTF-16。为方便起见，JNI 还提供了使用修改后的 UTF-8 的方法。修改后的编码对 C 代码非常有用，因为它将 \u0000 编码为 0xc0 0x80，而不是 0x00。这样做的好处是，您可以依靠以零终止的 C 样式字符串，非常适合与标准 libc 字符串函数配合使用。但缺点是，您<strong>无法将任意 UTF-8 数据传递给 JNI 并期望它能够正常工作</strong>。</p><p>如果可能，使用 UTF-16 字符串执行操作通常会更快。Android 目前不需要 GetStringChars 的副本，而 GetStringUTFChars 需要分配和转换为 UTF-8。请注意，UTF-16 字符串不是以零终止的，并且允许使用 \u0000，因此您需要保留字符串长度和 jchar 指针。</p><p><strong>不要忘记 Release 您 Get 的字符串</strong>。字符串函数会返回 jchar* 或 jbyte*，它们是指向原始数据而非局部引用的 C 样式指针。这些指针在调用 Release 之前保证有效，这意味着在原生方法返回时不会释放这些指针。</p><p><strong>传递给 NewStringUTF 的数据必须采用修改后的 UTF-8 格式</strong>。一种常见的错误就是从文件或网络数据流中读取字符数据，并在未过滤的情况下将其传递给 NewStringUTF。除非您确定数据是有效的 MUTF-8（或 7 位 ASCII，这是一个兼容子集），否则您需要剔除无效字符或将它们转换为适当的修改后的 UTF-8 格式。如果不这样做，UTF-16 转换可能会产生意外的结果。CheckJNI 默认状态下为模拟器启用，它会扫描字符串并且在收到无效输入时会中止虚拟机。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/87ce6f565d37" target="_blank" rel="noopener">https://www.jianshu.com/p/87ce6f565d37</a><br><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp9502" target="_blank" rel="noopener">JNI Functions</a><br><a href="https://www.jianshu.com/p/67081d9b0a9c" target="_blank" rel="noopener">JNI的常用方法的中文API</a><br><a href="https://developer.android.google.cn/training/articles/perf-jni#%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">JNI 提示</a><br><a href="https://blog.csdn.net/afei__/article/details/81290711" target="_blank" rel="noopener">Android NDK 从入门到精通（汇总篇）</a></p>]]></content>
      
      
      <categories>
          
          <category> Android NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JNI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C 语言笔记</title>
      <link href="/2019/12/24/c-language/"/>
      <url>/2019/12/24/c-language/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p><p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p><ul><li>易于学习。</li><li>结构化语言。</li><li>它产生高效率的程序。</li><li>它可以处理底层的活动。</li><li>它可以在多种计算机平台上编译。</li></ul><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>C 程序主要包括以下部分：<br>1、预处理器指令<br>2、函数<br>3、变量<br>4、语句 &amp; 表达式<br>5、注释</p><p>让我们看一段简单的代码，可以输出单词 “Hello World”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   /* 我的第一个 C 程序 */</span><br><span class="line">   printf(&quot;Hello, World! \n&quot;);</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译 &amp; 执行 C 程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure></p><p>a.out 为可执行文件，如果是多个 c 代码的源码文件，编译方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test1.c test2.c -o main.out</span><br><span class="line">$ ./main.out</span><br></pre></td></tr></table></figure></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="C-的令牌（Tokens）"><a href="#C-的令牌（Tokens）" class="headerlink" title="C 的令牌（Tokens）"></a>C 的令牌（Tokens）</h3><p>C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Hello, World! \n&quot;);</span><br></pre></td></tr></table></figure></p><p>这五个令牌分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf</span><br><span class="line">(</span><br><span class="line">&quot;Hello, World! \n&quot;</span><br><span class="line">)</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p><p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是<strong>区分大小写</strong>的编程语言。因此，在 C 中，Manpower 和 manpower 是两个不同的标识符。下面列出几个有效的标识符：</p><blockquote><p>mohd       zara    abc   move_name  a_123<br>myname50   _temp   j     a23b9      retVal</p></blockquote><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p><table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>auto</td><td>声明自动变量</td></tr><tr><td>break</td><td>跳出当前循环</td></tr><tr><td>case</td><td>开关语句分支</td></tr><tr><td>char</td><td>声明字符型变量或函数返回值类型</td></tr><tr><td>const</td><td>声明只读变量</td></tr><tr><td>continue</td><td>结束当前循环，开始下一轮循环</td></tr><tr><td>default</td><td>开关语句中的”其它”分支</td></tr><tr><td>do</td><td>循环语句的循环体</td></tr><tr><td>double</td><td>声明双精度浮点型变量或函数返回值类型</td></tr><tr><td>else</td><td>条件语句否定分支（与 if 连用）</td></tr><tr><td>enum</td><td>声明枚举类型</td></tr><tr><td>extern</td><td>声明变量或函数是在其它文件或本文件的其他位置定义</td></tr><tr><td>float</td><td>声明浮点型变量或函数返回值类型</td></tr><tr><td>for</td><td>一种循环语句</td></tr><tr><td>goto</td><td>无条件跳转语句</td></tr><tr><td>if</td><td>条件语句</td></tr><tr><td>int</td><td>声明整型变量或函数</td></tr><tr><td>long</td><td>声明长整型变量或函数返回值类型</td></tr><tr><td>register</td><td>声明寄存器变量</td></tr><tr><td>return</td><td>子程序返回语句（可以带参数，也可不带参数）</td></tr><tr><td>short</td><td>声明短整型变量或函数</td></tr><tr><td>signed</td><td>声明有符号类型变量或函数</td></tr><tr><td>sizeof</td><td>计算数据类型或变量长度（即所占字节数）</td></tr><tr><td>static</td><td>声明静态变量</td></tr><tr><td>struct</td><td>声明结构体类型</td></tr><tr><td>switch</td><td>用于开关语句</td></tr><tr><td>typedef</td><td>用以给数据类型取别名</td></tr><tr><td>unsigned</td><td>声明无符号类型变量或函数</td></tr><tr><td>union</td><td>声明共用体类型</td></tr><tr><td>void</td><td>声明函数无返回值或无参数，声明无类型指针</td></tr><tr><td>volatile</td><td>说明变量在程序执行中可被隐含地改变</td></tr><tr><td>while</td><td>循环语句的循环条件</td></tr></tbody></table><p>C99 新增关键字：<br>_Bool    _Complex    _Imaginary    inline    restrict</p><p>C11 新增关键字：<br>_Alignas    _Alignof    _Atomic    _Generic    _Noreturn<br>_Static_assert    _Thread_local          </p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p><p>C 中的类型可分为以下几种：</p><style>table th:nth-of-type(1) {    width: 100px;}</style><table><thead><tr><th>序号</th><th>类型与描述</th></tr></thead><tbody><tr><td>1</td><td>基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。</td></tr><tr><td>2</td><td>枚举类型：它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td></tr><tr><td>3</td><td>void 类型：类型说明符 void 表明没有可用的值。</td></tr><tr><td>4</td><td>派生类型：它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td></tr></tbody></table><p>数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。     </p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p><table><thead><tr><th>类型</th><th>存储大小</th><th>值范围</th></tr></thead><tbody><tr><td>char</td><td>1 字节</td><td>-128 到 127 或 0 到 255</td></tr><tr><td>unsigned char</td><td>1 字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1 字节</td><td>-128 到 127</td></tr><tr><td>int</td><td>2 或 4 字节</td><td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned int</td><td>2 或 4 字节</td><td>0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td>short</td><td>2 字节</td><td>-32,768 到 32,767</td></tr><tr><td>unsigned short</td><td>2 字节</td><td>0 到 65,535</td></tr><tr><td>long</td><td>4 字节</td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td>unsigned long</td><td>4 字节</td><td>0 到 4,294,967,295</td></tr></tbody></table><p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p><table><thead><tr><th>类型</th><th>存储大小</th><th>值范围</th><th>精度</th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>1.2E-38 到 3.4E+38</td><td>6 位小数</td></tr><tr><td>double</td><td>8 字节</td><td>2.3E-308 到 1.7E+308</td><td>15 位小数</td></tr><tr><td>long double</td><td>16 字节</td><td>3.4E-4932 到 1.1E+4932</td><td>19 位小数</td></tr></tbody></table><h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><table><thead><tr><th>序号</th><th>类型与描述</th></tr></thead><tbody><tr><td>1</td><td>函数返回为空：C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);</td></tr><tr><td>2</td><td>函数参数为空：C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);</td></tr><tr><td>3</td><td>指针指向 void：类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p><blockquote><p>type variable_list;</p></blockquote><p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p><p>变量的声明有两种情况：<br>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。<br>2、另一种是<strong>不需要建立存储空间</strong>的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</p><p>除非有extern关键字，否则都是变量的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i; //声明，不是定义</span><br><span class="line">int i; //声明，也是定义</span><br></pre></td></tr></table></figure></p><p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p><p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p><p>以下是各种类型的整数常量的实例：</p><pre><code>85         /* 十进制 */0213       /* 八进制 */0x4b       /* 十六进制 */30         /* 整数 */30u        /* 无符号整数 */30l        /* 长整数 */30ul       /* 无符号长整数 */</code></pre><h3 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h3><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p><p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p><p>下面列举几个浮点常量的实例：</p><pre><code>3.14159       /* 合法的 */314159E-5L    /* 合法的 */510E          /* 非法的：不完整的指数 */210f          /* 非法的：没有小数或指数 */.e55          /* 非法的：缺少整数或分数 */</code></pre><h3 id="字符常量-字符串常量"><a href="#字符常量-字符串常量" class="headerlink" title="字符常量/字符串常量"></a>字符常量/字符串常量</h3><p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p><p>在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。</p><p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p><h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>在 C 中，有两种简单的定义常量的方式：<br>1、使用 #define 预处理器。<br>2、使用 const 关键字。</p><p><strong>#define 预处理器</strong><br>下面是使用 #define 预处理器定义常量的形式：</p><blockquote><p>#define identifier value</p></blockquote><p><strong>const 关键字</strong><br>您可以使用 const 前缀声明指定类型的常量，如下所示：</p><blockquote><p>const type variable = value;</p></blockquote><h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p><ul><li>auto</li><li>register</li><li>static</li><li>extern</li></ul><h3 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h3><p>auto 存储类是所有局部变量默认的存储类。</p><pre><code>{   int mount;   auto int month;}</code></pre><p>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</p><h3 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h3><p>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p><pre><code>{   register int  miles;}</code></pre><p><strong>寄存器只用于需要快速访问的变量，比如计数器</strong>。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着<strong>变量可能存储在寄存器中</strong>，这取决于硬件和实现的限制。</p><h3 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h3><p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p><p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p><p>以下实例演示了 static 修饰全局变量和局部变量的应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void func1(void);</span><br><span class="line"> </span><br><span class="line">static int count=10;        /* 全局变量 - static 是默认的 */</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  while (count--) &#123;</span><br><span class="line">      func1();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void func1(void)</span><br><span class="line">&#123;</span><br><span class="line">/* &apos;thingy&apos; 是 &apos;func1&apos; 的局部变量 - 只初始化一次</span><br><span class="line"> * 每次调用函数 &apos;func1&apos; &apos;thingy&apos; 值不会被重置。</span><br><span class="line"> */                </span><br><span class="line">  static int thingy=5;</span><br><span class="line">  thingy++;</span><br><span class="line">  printf(&quot; thingy 为 %d ， count 为 %d\n&quot;, thingy, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"> thingy 为 6 ， count 为 9</span><br><span class="line"> thingy 为 7 ， count 为 8</span><br><span class="line"> thingy 为 8 ， count 为 7</span><br><span class="line"> thingy 为 9 ， count 为 6</span><br><span class="line"> thingy 为 10 ， count 为 5</span><br><span class="line"> thingy 为 11 ， count 为 4</span><br><span class="line"> thingy 为 12 ， count 为 3</span><br><span class="line"> thingy 为 13 ， count 为 2</span><br><span class="line"> thingy 为 14 ， count 为 1</span><br><span class="line"> thingy 为 15 ， count 为 0</span><br></pre></td></tr></table></figure></p><h3 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h3><p>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p><p>当您有<strong>多个文件</strong>且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，<strong>extern 是用来在另一个文件中声明一个全局变量或函数。</strong></p><p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//第一个文件：main.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count = 5;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二个文件：support.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">extern int count;</span><br><span class="line"> </span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;count is %d\n&quot;, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：</span><br><span class="line"> $ gcc main.c support.c</span><br><span class="line">//这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：</span><br><span class="line">count is 5</span><br></pre></td></tr></table></figure></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>杂项运算符</li></ul><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>if…else 语句<br>switch 语句<br>? : 运算符(三元运算符)</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>while 循环<br>do…while 循环<br>for 循环</p><p>控制语句包括：break 语句、continue 语句、goto 语句    </p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C 语言中的函数定义的一般形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name( parameter list )</span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><p>函数声明包括以下几个部分：</p><blockquote><p>return_type function_name( parameter list );</p></blockquote><p>针对上面定义的函数 max()，以下是函数声明：</p><blockquote><p>int max(int num1, int num2);</p></blockquote><p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p><blockquote><p>int max(int, int);</p></blockquote><p>当您<strong>在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的</strong>。在这种情况下，您应该在调用函数的文件顶部声明函数。</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量，这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p><p>当调用函数时，有两种向函数传递参数的方式：</p><table><thead><tr><th>调用类型</th><th>描述</th></tr></thead><tbody><tr><td>传值调用</td><td>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td></tr><tr><td>引用调用</td><td>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td></tr></tbody></table><p><strong>默认情况下，C 使用传值调用来传递参数</strong>。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>全局变量与局部变量在内存中的区别：<br>1、全局变量保存在内存的全局存储区中，占用静态的存储单元；<br>2、局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p><p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化。</p><p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p><p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p><blockquote><p>type arrayName [ arraySize ];</p></blockquote><h2 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h2><p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的。</p><p>枚举语法定义格式为：</p><blockquote><p>enum　枚举名　{枚举元素1,枚举元素2,……};</p></blockquote><p>使用枚举的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p><p>可以在定义枚举类型时改变枚举元素的值：</p><blockquote><p>enum season {spring, summer=3, autumn, winter};</p></blockquote><p>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p><h3 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h3><p>前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。</p><p>我们可以通过以下三种方式来定义枚举变量</p><p>1、先定义枚举类型，再定义枚举变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line">enum DAY day;</span><br></pre></td></tr></table></figure></p><p>2、定义枚举类型的同时定义枚举变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure></p><p>3、省略枚举名称，直接定义枚举变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>按照 C 语言规范是没有办法遍历枚举类型的。不过在一些特殊的情况下，枚举类型<strong>必须连续</strong>是可以实现有条件的遍历。</p><p>也可以将整数转换为枚举。</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。</p><p>请看下面的实例，它将输出定义的变量地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int  var1;</span><br><span class="line">   char var2[10];</span><br><span class="line"> </span><br><span class="line">   printf(&quot;var1 变量的地址： %p\n&quot;, &amp;var1  );</span><br><span class="line">   printf(&quot;var2 变量的地址： %p\n&quot;, &amp;var2  );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">var1 变量的地址： 0x7fff5cc109d4</span><br><span class="line">var2 变量的地址： 0x7fff5cc109de</span><br></pre></td></tr></table></figure></p><h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><p>指针<strong>是一个变量，其值为另一个变量的地址，即内存位置的直接地址</strong>。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p><blockquote><p>type *var-name;</p></blockquote><p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应<strong>指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数</strong>。</p><p>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p><h3 id="如何使用指针？"><a href="#如何使用指针？" class="headerlink" title="如何使用指针？"></a>如何使用指针？</h3><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int  var = 20;   /* 实际变量的声明 */</span><br><span class="line">   int  *ip;        /* 指针变量的声明 */</span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */</span><br><span class="line"> </span><br><span class="line">   printf(&quot;Address of var variable: %p\n&quot;, &amp;var  );</span><br><span class="line"> </span><br><span class="line">   /* 在指针变量中存储的地址 */</span><br><span class="line">   printf(&quot;Address stored in ip variable: %p\n&quot;, ip );</span><br><span class="line"> </span><br><span class="line">   /* 使用指针访问值 */</span><br><span class="line">   printf(&quot;Value of *ip variable: %d\n&quot;, *ip );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Address of var variable: bffd8b3c</span><br><span class="line">Address stored in ip variable: bffd8b3c</span><br><span class="line">Value of *ip variable: 20</span><br></pre></td></tr></table></figure></p><h3 id="C-中的-NULL-指针"><a href="#C-中的-NULL-指针" class="headerlink" title="C 中的 NULL 指针"></a>C 中的 NULL 指针</h3><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。</p><p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int  *ptr = NULL;</span><br><span class="line"> </span><br><span class="line">   printf(&quot;ptr 的地址是 %p\n&quot;, ptr  );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">ptr 的地址是 0x0</span><br></pre></td></tr></table></figure></p><p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p><p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p><pre><code>if(ptr)     /* 如果 p 非空，则完成 */if(!ptr)    /* 如果 p 为空，则完成 */</code></pre><h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p><p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：</p><blockquote><p>int **var;</p></blockquote><h2 id="函数指针与回调函数"><a href="#函数指针与回调函数" class="headerlink" title="函数指针与回调函数"></a>函数指针与回调函数</h2><p>函数指针是指向函数的指针变量。</p><p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参数。</p><p>函数指针变量的声明：</p><blockquote><p>typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型</p></blockquote><p>以下实例声明了函数指针变量 p，指向函数 max：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* p 是函数指针 */</span><br><span class="line">    int (* p)(int, int) = &amp; max; // &amp;可以省略</span><br><span class="line">    int a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;请输入三个数字:&quot;);</span><br><span class="line">    scanf(&quot;%d %d %d&quot;, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    /* 与直接调用函数等价，d = max(max(a, b), c) */</span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    printf(&quot;最大的数字是: %d\n&quot;, d);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">请输入三个数字:1 2 3</span><br><span class="line">最大的数字是: 3</span><br></pre></td></tr></table></figure></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数指针作为某个函数的参数，回调函数就是一个通过函数指针调用的函数。</p><p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p><p>实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">// 回调函数</span><br><span class="line">void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i=0; i&lt;arraySize; i++)</span><br><span class="line">        array[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 获取随机值</span><br><span class="line">int getNextRandomValue(void)</span><br><span class="line">&#123;</span><br><span class="line">    return rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int myarray[10];</span><br><span class="line">    populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line">    for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709</span><br></pre></td></tr></table></figure></p><h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h2><p>在 C 语言中，<strong>字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组</strong>。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p><blockquote><p>char greeting[6] = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘\0’};</p></blockquote><p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p><blockquote><p>char greeting[] = “Hello”;</p></blockquote><p>其实，您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。</p><p>C 中有大量操作字符串的函数：</p><table><thead><tr><th>函数</th><th>目的</th></tr></thead><tbody><tr><td>strcpy(s1, s2)</td><td>复制字符串 s2 到字符串 s1。</td></tr><tr><td>strcat(s1, s2)</td><td>连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td>strlen(s1)</td><td>返回字符串 s1 的长度。</td></tr><tr><td>strcmp(s1, s2)</td><td>如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。</s2></td></tr><tr><td>strchr(s1, ch)</td><td>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td>strstr(s1, s2)</td><td>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构是 C 编程中一种用户自定义的可用的数据类型，它允许您<strong>存储不同类型的数据项</strong>。</p><p>为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct tag &#123; </span><br><span class="line">    member-list</span><br><span class="line">    member-list </span><br><span class="line">    member-list  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-list ;</span><br></pre></td></tr></table></figure></p><p>tag 是结构体标签。<br>member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。<br>variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125; book;</span><br></pre></td></tr></table></figure></p><p>在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//同时又声明了结构体变量s1</span><br><span class="line">//这个结构体并没有标明其标签</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125; s1;</span><br><span class="line"> </span><br><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//结构体的标签被命名为SIMPLE,没有声明变量</span><br><span class="line">struct SIMPLE</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125;;</span><br><span class="line">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span><br><span class="line">struct SIMPLE t1, t2[20], *t3;</span><br><span class="line"> </span><br><span class="line">//也可以用typedef创建新类型</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line">//现在可以用Simple2作为类型声明新的结构体变量</span><br><span class="line">Simple2 u1, u2[20], *u3;</span><br></pre></td></tr></table></figure></p><p>在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&amp;s1，则是非法的。</p><p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//此结构体的声明包含了其他的结构体</span><br><span class="line">struct COMPLEX</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct SIMPLE a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//此结构体的声明包含了指向自己类型的指针</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct NODE *next_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果<strong>两个结构体互相包含，则需要对其中一个结构体进行不完整声明</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct B;    //对结构体B进行不完整声明</span><br><span class="line"> </span><br><span class="line">//结构体A中包含指向结构体B的指针</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    struct B *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span><br><span class="line">struct B</span><br><span class="line">&#123;</span><br><span class="line">    struct A *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h3><p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125; book = &#123;&quot;C 语言&quot;, &quot;RUNOOB&quot;, &quot;编程语言&quot;, 123456&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行输出结果为：</span><br><span class="line">title : C 语言</span><br><span class="line">author: RUNOOB</span><br><span class="line">subject: 编程语言</span><br><span class="line">book_id: 123456</span><br></pre></td></tr></table></figure></p><h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p><blockquote><p>struct Books *struct_pointer;</p></blockquote><p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p><blockquote><p>struct_pointer = &Book1;</p></blockquote><p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p><blockquote><p>struct_pointer-&gt;title;</p></blockquote><p>实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void printBook( struct Books *book );</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   struct Books Book1;        /* 声明 Book1，类型为 Books */</span><br><span class="line">   struct Books Book2;        /* 声明 Book2，类型为 Books */</span><br><span class="line"> </span><br><span class="line">   /* Book1 详述 */</span><br><span class="line">   strcpy( Book1.title, &quot;C Programming&quot;);</span><br><span class="line">   strcpy( Book1.author, &quot;Nuha Ali&quot;); </span><br><span class="line">   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);</span><br><span class="line">   Book1.book_id = 6495407;</span><br><span class="line"> </span><br><span class="line">   /* Book2 详述 */</span><br><span class="line">   strcpy( Book2.title, &quot;Telecom Billing&quot;);</span><br><span class="line">   strcpy( Book2.author, &quot;Zara Ali&quot;);</span><br><span class="line">   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);</span><br><span class="line">   Book2.book_id = 6495700;</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book1 的地址来输出 Book1 信息 */</span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book2 的地址来输出 Book2 信息 */</span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">void printBook( struct Books *book )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;Book title : %s\n&quot;, book-&gt;title);</span><br><span class="line">   printf( &quot;Book author : %s\n&quot;, book-&gt;author);</span><br><span class="line">   printf( &quot;Book subject : %s\n&quot;, book-&gt;subject);</span><br><span class="line">   printf( &quot;Book book_id : %d\n&quot;, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>有些信息在存储时，<strong>并不需要占用一个完整的字节，而只需占几个或一个二进制位</strong>。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。</p><p>所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p><p>典型的实例：<br>1、用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。<br>2、读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</p><p>位域定义与结构定义相仿，其形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  type [member_name] : width ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>type：只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。<br>member_name：位域的名称。<br>width：位域中位的数量。宽度必须小于或等于指定类型的位宽度。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</span><br><span class="line">struct bs&#123;</span><br><span class="line">    int a:8;</span><br><span class="line">    int b:2;</span><br><span class="line">    int c:6;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure></p><h3 id="位域说明"><a href="#位域说明" class="headerlink" title="位域说明"></a>位域说明</h3><p>1、一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</span><br><span class="line">struct bs&#123;</span><br><span class="line">    unsigned a:4;</span><br><span class="line">    unsigned  :4;    /* 空域 */</span><br><span class="line">    unsigned b:4;    /* 从下一单元开始存放 */</span><br><span class="line">    unsigned c:4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、由于<strong>位域不允许跨两个字节</strong>，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。</p><p>3、位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct k&#123;</span><br><span class="line">    int a:1;</span><br><span class="line">    int  :2;    /* 该 2 位不能使用 */</span><br><span class="line">    int b:3;</span><br><span class="line">    int c:2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>从以上分析可以看出，<strong>位域在本质上就是一种结构类型，不过其成员是按二进位分配的</strong>。</p><h3 id="位域的使用"><a href="#位域的使用" class="headerlink" title="位域的使用"></a>位域的使用</h3><p>位域的使用和结构成员的使用相同，其一般形式为：</p><blockquote><p>位域变量名.位域名<br>位域变量名-&gt;位域名</p></blockquote><p>位域允许用各种格式输出。</p><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体是一种特殊的数据类型，<strong>允许您在相同的内存位置存储不同的数据类型，但任何时候只能有一个成员带有值</strong>。共用体提供了一种使用相同的内存位置的有效方式。</p><p>共用体占用的内存应足够存储共用体中最大的成员。</p><p>为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union [union tag]</span><br><span class="line">&#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one or more union variables];</span><br></pre></td></tr></table></figure></p><p>union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。</p><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">union Data</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char  str[20];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   union Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = 10;</span><br><span class="line">   data.f = 220.5;</span><br><span class="line">   strcpy( data.str, &quot;C Programming&quot;);</span><br><span class="line"> </span><br><span class="line">   printf( &quot;data.i : %d\n&quot;, data.i);</span><br><span class="line">   printf( &quot;data.f : %f\n&quot;, data.f);</span><br><span class="line">   printf( &quot;data.str : %s\n&quot;, data.str);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">data.i : 1917853763</span><br><span class="line">data.f : 4122360580327794860452759994368.000000</span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure></p><p>在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">union Data</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char  str[20];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   union Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = 10;</span><br><span class="line">   printf( &quot;data.i : %d\n&quot;, data.i);</span><br><span class="line">   </span><br><span class="line">   data.f = 220.5;</span><br><span class="line">   printf( &quot;data.f : %f\n&quot;, data.f);</span><br><span class="line">   </span><br><span class="line">   strcpy( data.str, &quot;C Programming&quot;);</span><br><span class="line">   printf( &quot;data.str : %s\n&quot;, data.str);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">data.i : 10</span><br><span class="line">data.f : 220.500000</span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure></p><p>在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>C 语言提供了 typedef 关键字，您可以使用它来<strong>为类型取一个新的名字</strong>。下面的实例为单字节数字定义了一个术语 BYTE(按照惯例定义时会大写字母，但也可以使用小写字母)：</p><blockquote><p>typedef unsigned char BYTE;</p></blockquote><p>在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：</p><blockquote><p>BYTE  b1, b2;</p></blockquote><p>也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">typedef struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125; Book;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Book book;</span><br><span class="line"> </span><br><span class="line">   strcpy( book.title, &quot;C 教程&quot;);</span><br><span class="line">   strcpy( book.author, &quot;Runoob&quot;); </span><br><span class="line">   strcpy( book.subject, &quot;编程语言&quot;);</span><br><span class="line">   book.book_id = 12345;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;书标题 : %s\n&quot;, book.title);</span><br><span class="line">   printf( &quot;书作者 : %s\n&quot;, book.author);</span><br><span class="line">   printf( &quot;书类目 : %s\n&quot;, book.subject);</span><br><span class="line">   printf( &quot;书 ID : %d\n&quot;, book.book_id);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="typedef-vs-define"><a href="#typedef-vs-define" class="headerlink" title="typedef vs #define"></a>typedef vs #define</h3><p>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p><ul><li>typedef 仅限于为类型定义符号名称，<strong>#define 不仅可以为类型定义别名，也能为数值定义别名</strong>，比如您可以定义 1 为 ONE。</li><li>typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。</li></ul><p>下面是 #define 的最简单的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">#define TRUE  1</span><br><span class="line">#define FALSE 0</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;TRUE 的值: %d\n&quot;, TRUE);</span><br><span class="line">   printf( &quot;FALSE 的值: %d\n&quot;, FALSE);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">TRUE 的值: 1</span><br><span class="line">FALSE 的值: 0</span><br></pre></td></tr></table></figure></p><h2 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数(inline)"></a>内联函数(inline)</h2><p>在c/c++中，<strong>为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题</strong>，特别的引入了inline修饰符，表示为内联函数。</p><p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p><p>在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p><p>下面我们来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//函数定义为inline即:内联函数</span><br><span class="line">inline char* dbtest(int a) &#123;</span><br><span class="line">    return (i % 2 &gt; 0) ? &quot;奇&quot; : &quot;偶&quot;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int i = 0;</span><br><span class="line">   for (i=1; i &lt; 100; i++) &#123;</span><br><span class="line">       printf(&quot;i:%d    奇偶性:%s /n&quot;, i, dbtest(i));    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个for<strong>循环的内部任何调用dbtest(i)的地方都换成了(i%2&gt;0)?”奇”:”偶”</strong>，这样就<strong>避免了频繁调用函数对栈内存重复开辟所带来的消耗</strong>。</p><h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>inline的使用是有所限制的，inline<strong>只适合函数体内代码简单的涵数使用</strong>，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。</p><h3 id="对编译器的建议"><a href="#对编译器的建议" class="headerlink" title="对编译器的建议"></a>对编译器的建议</h3><p>inline函数仅仅是一个<strong>对编译器的建议</strong>，所以最后<strong>能否真正内联要看编译器的意思</strong>，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p><h3 id="类中的成员函数与inline"><a href="#类中的成员函数与inline" class="headerlink" title="类中的成员函数与inline"></a>类中的成员函数与inline</h3><p><strong>定义在类中的成员函数缺省都是内联的</strong>，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public:void Foo(int x, int y) &#123;  &#125; // 自动地成为内联函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 头文件</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    void Foo(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义文件</span><br><span class="line">inline void A::Foo(int x, int y)&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="inline-是一种“用于实现的关键字”"><a href="#inline-是一种“用于实现的关键字”" class="headerlink" title="inline 是一种“用于实现的关键字”"></a>inline 是一种“用于实现的关键字”</h3><p>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。</p><p>如下风格的函数Foo 不能成为内联函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline void Foo(int x, int y); // inline 仅与函数声明放在一起</span><br><span class="line"></span><br><span class="line">void Foo(int x, int y)&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>而如下风格的函数Foo 则成为内联函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void Foo(int x, int y);</span><br><span class="line"></span><br><span class="line">inline void Foo(int x, int y) &#123;&#125; // inline 与函数定义体放在一起</span><br></pre></td></tr></table></figure></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.建议：inline函数的定义放在头文件中<br>2.慎用inline：内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。<br>3.最令人烦恼的还是当编译器拒绝内联的时候。如果内联函数不能增强性能，就避免使用它！</p><h2 id="输入-amp-输出"><a href="#输入-amp-输出" class="headerlink" title="输入 &amp; 输出"></a>输入 &amp; 输出</h2><p>C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p><table><thead><tr><th>标准文件</th><th>文件指针</th><th>设备</th></tr></thead><tbody><tr><td>标准输入</td><td>stdin</td><td>键盘</td></tr><tr><td>标准输出</td><td>stdout</td><td>屏幕</td></tr><tr><td>标准错误</td><td>stderr</td><td>屏幕</td></tr></tbody></table><h3 id="getchar-amp-putchar-函数"><a href="#getchar-amp-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h3><p>int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p><p>int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p><p>请看下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   int c;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;Enter a value :&quot;);</span><br><span class="line">   c = getchar( );</span><br><span class="line"> </span><br><span class="line">   printf( &quot;\nYou entered: &quot;);</span><br><span class="line">   putchar( c );</span><br><span class="line">   printf( &quot;\n&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：</span><br><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: r</span><br></pre></td></tr></table></figure></p><h3 id="gets-amp-puts-函数"><a href="#gets-amp-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h3><p>char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。</p><p>int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char str[100];</span><br><span class="line"> </span><br><span class="line">   printf( &quot;Enter a value :&quot;);</span><br><span class="line">   gets( str );</span><br><span class="line"> </span><br><span class="line">   printf( &quot;\nYou entered: &quot;);</span><br><span class="line">   puts( str );</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</span><br><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: runoob</span><br></pre></td></tr></table></figure><h3 id="scanf-和-printf-函数"><a href="#scanf-和-printf-函数" class="headerlink" title="scanf() 和 printf() 函数"></a>scanf() 和 printf() 函数</h3><p>int scanf(const char *format, …) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。</p><p>int printf(const char *format, …) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。</p><p>format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p><p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main( ) &#123;</span><br><span class="line"> </span><br><span class="line">   char str[100];</span><br><span class="line">   int i;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;Enter a value :&quot;);</span><br><span class="line">   scanf(&quot;%s %d&quot;, str, &amp;i);</span><br><span class="line"> </span><br><span class="line">   printf( &quot;\nYou entered: %s %d &quot;, str, i);</span><br><span class="line">   printf(&quot;\n&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：</span><br><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob 123</span><br><span class="line"></span><br><span class="line">You entered: runoob 123</span><br></pre></td></tr></table></figure></p><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。原型为：</p><blockquote><p>FILE *fopen( const char * filename, const char * mode );</p></blockquote><p>在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>打开一个已有的文本文件，允许读取文件。</td></tr><tr><td>w</td><td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td>a</td><td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td>r+</td><td>打开一个文本文件，允许读写文件。</td></tr><tr><td>w+</td><td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td>a+</td><td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p><blockquote><p>“rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b”</p></blockquote><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：</p><blockquote><p>int fclose( FILE *fp );</p></blockquote><p>如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。</p><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。下面是把字符写入到流中的最简单的函数：</p><blockquote><p>int fputc( int c, FILE *fp );</p></blockquote><p>函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：</p><blockquote><p>int fputs( const char *s, FILE *fp );</p></blockquote><p>您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中。尝试下面的实例：</p><p>注意：请确保您有可用的 tmp 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。/tmp 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: C:\tmp、D:\tmp等。</p><p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line">   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">   fprintf(fp, &quot;This is testing for fprintf...\n&quot;);</span><br><span class="line">   fputs(&quot;This is testing for fputs...\n&quot;, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。下面是从文件读取单个字符的最简单的函数：</p><blockquote><p>int fgetc( FILE * fp );</p></blockquote><p>函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。下面的函数允许您从流中读取一个字符串：</p><blockquote><p>char *fgets( char *buf, int n, FILE *fp );</p></blockquote><p>您也可以使用 int fscanf(FILE *fp, const char *format, …) 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line">   char buff[255];</span><br><span class="line"> </span><br><span class="line">   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;r&quot;);</span><br><span class="line">   fscanf(fp, &quot;%s&quot;, buff);</span><br><span class="line">   printf(&quot;1: %s\n&quot;, buff );</span><br><span class="line"> </span><br><span class="line">   fgets(buff, 255, (FILE*)fp);</span><br><span class="line">   printf(&quot;2: %s\n&quot;, buff );</span><br><span class="line">   </span><br><span class="line">   fgets(buff, 255, (FILE*)fp);</span><br><span class="line">   printf(&quot;3: %s\n&quot;, buff );</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：</span><br><span class="line">1: This</span><br><span class="line">2: is testing for fprintf...</span><br><span class="line"></span><br><span class="line">3: This is testing for fputs...</span><br></pre></td></tr></table></figure><p>首先，fscanf() 方法只读取了 This，因为它在后边遇到了一个空格。其次，调用 fgets() 读取剩余的部分，直到行尾。最后，调用 fgets() 完整地读取第二行。</p><h3 id="二进制-I-O-函数"><a href="#二进制-I-O-函数" class="headerlink" title="二进制 I/O 函数"></a>二进制 I/O 函数</h3><p>下面两个函数用于二进制输入和输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size_of_elements, </span><br><span class="line">             size_t number_of_elements, FILE *a_file);</span><br><span class="line">              </span><br><span class="line">size_t fwrite(const void *ptr, size_t size_of_elements, </span><br><span class="line">             size_t number_of_elements, FILE *a_file);</span><br></pre></td></tr></table></figure></p><p>这两个函数都是用于存储块的读写 - 通常是数组或结构体。</p><h2 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h2><p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p><p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>#define</td><td>定义宏</td></tr><tr><td>#include</td><td>包含一个源代码文件</td></tr><tr><td>#undef</td><td>取消已定义的宏</td></tr><tr><td>#ifdef</td><td>如果宏已经定义，则返回真</td></tr><tr><td>#ifndef</td><td>如果宏没有定义，则返回真</td></tr><tr><td>#if</td><td>如果给定条件为真，则编译下面代码</td></tr><tr><td>#else</td><td>#if 的替代方案</td></tr><tr><td>#elif</td><td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td></tr><tr><td>#endif</td><td>结束一个 #if……#else 条件编译块</td></tr><tr><td>#error</td><td>当遇到标准错误时，输出错误消息</td></tr><tr><td>#pragma</td><td>使用标准化方法，向编译器发布特殊的命令到编译器中</td></tr></tbody></table><h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td>__DATE__</td><td>当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td></tr><tr><td>__TIME__</td><td>当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td></tr><tr><td>__FILE__</td><td>这会包含当前文件名，一个字符串常量。</td></tr><tr><td>__LINE__</td><td>这会包含当前行号，一个十进制常量。</td></tr><tr><td>__STDC__</td><td>当编译器以 ANSI 标准编译时，则定义为 1。</td></tr></tbody></table><h3 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h3><p>C 预处理器提供了下列的运算符来帮助您创建宏：</p><h4 id="宏延续运算符（-）"><a href="#宏延续运算符（-）" class="headerlink" title="宏延续运算符（\）"></a>宏延续运算符（\）</h4><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define  message_for(a, b)  \</span><br><span class="line">    printf(#a &quot; and &quot; #b &quot;: We love you!\n&quot;)</span><br></pre></td></tr></table></figure></p><h4 id="字符串常量化运算符（-）"><a href="#字符串常量化运算符（-）" class="headerlink" title="字符串常量化运算符（#）"></a>字符串常量化运算符（#）</h4><p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define  message_for(a, b)  \</span><br><span class="line">    printf(#a &quot; and &quot; #b &quot;: We love you!\n&quot;)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   message_for(Carole, Debra);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Carole and Debra: We love you!</span><br></pre></td></tr></table></figure></p><h4 id="标记粘贴运算符（-）"><a href="#标记粘贴运算符（-）" class="headerlink" title="标记粘贴运算符（##）"></a>标记粘贴运算符（##）</h4><p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define tokenpaster(n) printf (&quot;token&quot; #n &quot; = %d&quot;, token##n)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int token34 = 40;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(34);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">token34 = 40</span><br></pre></td></tr></table></figure></p><p>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p><blockquote><p>printf (“token34 = %d”, token34);</p></blockquote><p>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。</p><h4 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined() 运算符"></a>defined() 运算符</h4><p>预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#if !defined (MESSAGE)</span><br><span class="line">   #define MESSAGE &quot;You wish!&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Here is the message: %s\n&quot;, MESSAGE);  </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Here is the message: You wish!</span><br></pre></td></tr></table></figure></p><h3 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h3><p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，计算一个数的平方，我们可以使用宏重写上面的代码，如下：</p><blockquote><p>#define square(x) ((x) * (x))</p></blockquote><p>在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Max between 20 and 10 is %d\n&quot;, MAX(10, 20));  </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Max between 20 and 10 is 20</span><br></pre></td></tr></table></figure></p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：编译器自带的头文件和程序员编写的头文件（如下）。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p><blockquote><p>#include &lt;file></p><p>#include “file”</p></blockquote><p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p><h3 id="只引用一次头文件"><a href="#只引用一次头文件" class="headerlink" title="只引用一次头文件"></a>只引用一次头文件</h3><p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HEADER_FILE</span><br><span class="line">#define HEADER_FILE</span><br><span class="line"></span><br><span class="line">the entire header file file</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。</p><h3 id="有条件引用"><a href="#有条件引用" class="headerlink" title="有条件引用"></a>有条件引用</h3><p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if SYSTEM_1</span><br><span class="line">   # include &quot;system_1.h&quot;</span><br><span class="line">#elif SYSTEM_2</span><br><span class="line">   # include &quot;system_2.h&quot;</span><br><span class="line">#elif SYSTEM_3</span><br><span class="line">   ...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SYSTEM_H &quot;system_1.h&quot;</span><br><span class="line">...</span><br><span class="line">#include SYSTEM_H</span><br></pre></td></tr></table></figure></p><p>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</p><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换是把变量从一种类型转换为另一种数据类型。您可以使用强制类型转换运算符来把值显式地从一种类型转换为另一种类型，如下所示：</p><blockquote><p>(type_name) expression</p></blockquote><p>在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</p><h3 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h3><p>整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。请看下面的实例，在 int 中添加一个字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int  i = 17;</span><br><span class="line">   char c = &apos;c&apos;; /* ascii 值是 99 */</span><br><span class="line">   int sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   printf(&quot;Value of sum : %d\n&quot;, sum );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of sum : 116</span><br></pre></td></tr></table></figure></p><p>在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 ‘c’ 的值转换为对应的 ascii 值。</p><h3 id="常用的算术转换"><a href="#常用的算术转换" class="headerlink" title="常用的算术转换"></a>常用的算术转换</h3><p>常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：</p><p><img src="/2019/12/24/c-language/usual_arithmetic_conversion.png" alt><br>让我们看看下面的实例来理解这个概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int  i = 17;</span><br><span class="line">   char c = &apos;c&apos;; /* ascii 值是 99 */</span><br><span class="line">   float sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   printf(&quot;Value of sum : %f\n&quot;, sum );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of sum : 116.000000</span><br></pre></td></tr></table></figure></p><p>在这里，c 首先被转换为整数，但是由于最后的值是 float 型的，所以会应用常用的算术转换，编译器会把 i 和 c 转换为浮点型，并把它们相加得到一个浮点数。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>C 语言<strong>不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据</strong>。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p><p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p><h3 id="errno、perror-和-strerror"><a href="#errno、perror-和-strerror" class="headerlink" title="errno、perror() 和 strerror()"></a>errno、perror() 和 strerror()</h3><p>C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。</p><ul><li>perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li><li>strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li></ul><p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">extern int errno ;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   FILE * pf;</span><br><span class="line">   int errnum;</span><br><span class="line">   pf = fopen (&quot;unexist.txt&quot;, &quot;rb&quot;);</span><br><span class="line">   if (pf == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      errnum = errno;</span><br><span class="line">      fprintf(stderr, &quot;错误号: %d\n&quot;, errno);</span><br><span class="line">      perror(&quot;通过 perror 输出错误&quot;);</span><br><span class="line">      fprintf(stderr, &quot;打开文件错误: %s\n&quot;, strerror( errnum ));</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      fclose (pf);</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">错误号: 2</span><br><span class="line">通过 perror 输出错误: No such file or directory</span><br><span class="line">打开文件错误: No such file or directory</span><br></pre></td></tr></table></figure></p><h3 id="程序退出状态"><a href="#程序退出状态" class="headerlink" title="程序退出状态"></a>程序退出状态</h3><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p><p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   int dividend = 20;</span><br><span class="line">   int divisor = 5;</span><br><span class="line">   int quotient;</span><br><span class="line"> </span><br><span class="line">   // 在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。</span><br><span class="line">   if( divisor == 0)&#123;</span><br><span class="line">      fprintf(stderr, &quot;除数为 0 退出运行...\n&quot;);</span><br><span class="line">      exit(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   quotient = dividend / divisor;</span><br><span class="line">   fprintf(stderr, &quot;quotient 变量的值为: %d\n&quot;, quotient );</span><br><span class="line"> </span><br><span class="line">   exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">quotient 变量的值为 : 4</span><br></pre></td></tr></table></figure></p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int func(int, ... ) </span><br><span class="line">&#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   func(2, 2, 3);</span><br><span class="line">   func(3, 2, 3, 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意，函数 func() 最后一个参数写成省略号，即三个点号（…），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p><ul><li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li><li>在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</li><li>使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li><li>使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。</li><li>使用宏 va_end 来清理赋予 va_list 变量的内存。</li></ul><p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"> </span><br><span class="line">double average(int num,...)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    double sum = 0.0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    /* 为 num 个参数初始化 valist */</span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    /* 访问所有赋给 valist 的参数 */</span><br><span class="line">    for (i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, int);</span><br><span class="line">    &#125;</span><br><span class="line">    /* 清理为 valist 保留的内存 */</span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    return sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Average of 2, 3, 4, 5 = %f\n&quot;, average(4, 2,3,4,5));</span><br><span class="line">   printf(&quot;Average of 5, 10, 15 = %f\n&quot;, average(3, 5,10,15));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Average of 2, 3, 4, 5 = 3.500000</span><br><span class="line">Average of 5, 10, 15 = 10.000000</span><br></pre></td></tr></table></figure></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>语言为内存的分配和管理提供了几个函数。这些函数可以在 &lt;stdlib.h&gt; 头文件中找到。</p><table><thead><tr><th>序号</th><th>函数和描述</th></tr></thead><tbody><tr><td>1</td><td>void *calloc(int num, int size)  <br>在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td></tr><tr><td>2</td><td>void free(void *address) <br> 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td></tr><tr><td>3</td><td>void *malloc(int num) <br> 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td></tr><tr><td>4</td><td>void *realloc(void *address, int newsize) <br> 该函数重新分配内存，把内存扩展到 newsize。</td></tr></tbody></table><p>注意：void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p><h3 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h3><p>如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要<strong>定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 200 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student in class 10th</span><br></pre></td></tr></table></figure></p><p>上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p><blockquote><p>calloc(200, sizeof(char));</p></blockquote><p>当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些<strong>预先定义了大小的数组，一旦定义则无法改变大小</strong>。</p><h3 id="重新调整内存的大小和释放内存"><a href="#重新调整内存的大小和释放内存" class="headerlink" title="重新调整内存的大小和释放内存"></a>重新调整内存的大小和释放内存</h3><p>当程序退出时，<strong>操作系统会自动释放所有分配给程序的内存</strong>，但是，<strong>建议您在不需要内存时，都应该调用函数 free() 来释放内存</strong>。</p><p>或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 30 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /* 假设您想要存储更大的描述信息 */</span><br><span class="line">   description = (char *) realloc( description, 100 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcat( description, &quot;She is in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line"> </span><br><span class="line">   /* 使用 free() 函数释放内存 */</span><br><span class="line">   free(description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student.She is in class 10th</span><br></pre></td></tr></table></figure></p><p>您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main( int argc, char *argv[] )  </span><br><span class="line">&#123;</span><br><span class="line">   if( argc == 2 )</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;The argument supplied is %s\n&quot;, argv[1]);</span><br><span class="line">   &#125;</span><br><span class="line">   else if( argc &gt; 2 )</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;Too many arguments supplied.\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;One argument expected.\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用一个参数，编译并执行上面的代码，它会产生下列结果：</span><br><span class="line">$./a.out testing</span><br><span class="line">The argument supplied is testing</span><br><span class="line"></span><br><span class="line">使用两个参数，编译并执行上面的代码，它会产生下列结果：</span><br><span class="line">$./a.out testing1 testing2</span><br><span class="line">Too many arguments supplied.</span><br><span class="line"></span><br><span class="line">不传任何参数，编译并执行上面的代码，它会产生下列结果：</span><br><span class="line">$./a.out</span><br><span class="line">One argument expected</span><br></pre></td></tr></table></figure></p><p>应当指出的是，<strong>argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针</strong>，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。</p><p>多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 “” 或单引号 ‘’ 内部。</p><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><h3 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h3><p>C 库函数 int printf(const char *format, …) 发送格式化输出到标准输出 stdout。</p><p>规定符:</p><ul><li>%d 十进制有符号整数</li><li>%u 十进制无符号整数</li><li>%f 浮点数</li><li>%s 字符串</li><li>%c 单个字符</li><li>%p 指针的值</li><li>%e 指数形式的浮点数</li><li>%x, %X 无符号以十六进制表示的整数</li><li>%o 无符号以八进制表示的整数</li><li>%g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出</li><li>%p 输出地址符</li><li>%lu 32位无符号整数</li><li>%llu 64位无符号整数</li></ul><h2 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h2><p>C11（也被称为C1X）指ISO标准ISO/IEC 9899:2011，是当前最新的C语言标准。在它之前的C语言标准为C99。</p><p>新特性：</p><ul><li><p>对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及&lt;stdalign.h&gt;头文件）。</p></li><li><p>_Noreturn 函数标记，类似于 gcc 的 <strong>attribute</strong>((noreturn))。</p></li><li><p>_Generic 关键字。</p></li><li><p>多线程（Multithreading）支持，包括：<br>_Thread_local存储类型标识符，&lt;threads.h&gt;头文件，里面包含了线程的创建和管理函数。<br>_Atomic类型修饰符和&lt;stdatomic.h&gt;头文件。</p></li><li><p>增强的Unicode的支持。基于C Unicode技术报告ISO/IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16/UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件&lt;uchar.h&gt;。</p></li><li><p>删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。</p></li><li><p>增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。</p></li><li><p>增加了更多浮点处理宏(宏)。</p></li><li><p>匿名结构体/联合体支持。这个在gcc早已存在，C11将其引入标准。</p></li><li><p>静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。</p></li><li><p>新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。</p></li><li><p>新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。</p></li></ul><h2 id="重入函数"><a href="#重入函数" class="headerlink" title="重入函数"></a>重入函数</h2><p>在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。所谓<strong>可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会 出错</strong>。不可重入函数在实时系统设计中被视为不安全函数。</p><p>可重入函数可以被一个以上的任务调用，而不必担心数据被破坏。可重入函数任何时候都可以被中断，一段时间以后又可以运行，而相应的数据不会丢失。可重入函数或者只使用局部变量，即保存在CPU寄存器中或堆栈中；或者使用全局变量，则要对全局变量予以保护。而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等等，所以他如果被中断的话，可能出现问题，所以这类函数是 不能运行在多任务环境下的。</p><p>满足下列条件的函数多数是不可重入的：<br>（1）函数体内使用了静态的数据结构；<br>（2）函数体内调用了malloc()或者free()函数；<br>（3）函数体内调用了标准I/O函数。</p><p>如何写出可重入的函数？<br>在函数体内不访问那些全局变量，不使用静态局部变量，坚持只使用缺省态（auto）局部变量，写出的函数就将是可重入的。如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断。</p><p>把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写他。只要遵守以下几条很容易理解的规则：<br>第一，不要使用全局变量。因为别的代码很可能覆盖这些变量值。<br>第二，在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”或者用OS_ENTER_KERNAL/OS_EXIT_KERNAL来描述。<br>第三，不能调用任何不可重入的函数。<br>第四，谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL。<br>还有一些规则，都是很好理解的，总之，时刻记住一句话：<strong>保证中断是安全的</strong>！<br>通俗的来讲吧：由于中断是可能随时发生的，断点位置也是无法预期的。所以必须保证每个函数都具有不被中断发生，压栈，转向ISR，弹栈后继续执行影响的稳定性。也就是说具有不会被中断影响的能力。既然有这个要求，你提供和编写的每个函数就不能拿公共的资源或者是变量来使用，因为该函数使用的同时，ISR（中断服务程序）也可那会去修改或者是获取这个资源，从而有可能使中断返回之后，这部分公用的资源已经面目全非。</p><p>案例：<br>相信很多人都看过下面这个面试题<br>中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 <strong>interrupt。下面的代码就使用了</strong>interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__interrupt double compute_area (double radius) </span><br><span class="line">&#123;</span><br><span class="line">    double area = PI * radius * radius;</span><br><span class="line">    printf(&quot;\nArea = %f&quot;, area);</span><br><span class="line">    return area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数有太多的错误了，以至让人不知从何说起了：<br>1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。<br>2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。<br>3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。<br>4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/cprogramming/c-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-tutorial.html</a><br><a href="https://www.cnblogs.com/AlwaysOnLines/p/3912680.html" target="_blank" rel="noopener">C语言之可重入函数 &amp;&amp; 不可重入函数</a></p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GoF 的 23 种设计模式总结</title>
      <link href="/2019/11/28/design-pattern-summary/"/>
      <url>/2019/11/28/design-pattern-summary/</url>
      
        <content type="html"><![CDATA[<p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p><p>1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。</p><p>直到今天，狭义的设计模式还是 GoF 的 23 种经典设计模式。</p><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点：<br>1、可以提高程序员的思维能力、编程能力和设计能力。<br>2、使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。<br>3、使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</p><p>当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，可能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。</p><p>1、根据作用范围来分</p><p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种：</p><ul><li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</li><li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</li></ul><p>2、根据目的来分</p><p>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种：</p><ul><li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li><li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li><li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li></ul><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的主要关注点是“<strong>怎样创建对象？</strong>”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p><p>创建型模式分为以下几种：</p><ul><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li></ul><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式<strong>描述如何将类或对象按某种布局组成更大的结构</strong>。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ul><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li></ul><p>以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式。</p><h2 id="行为性模式"><a href="#行为性模式" class="headerlink" title="行为性模式"></a>行为性模式</h2><p>行为型模式用于描述程序在运行时复杂的流程控制，即<strong>描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务</strong>，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式：</p><ul><li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ul><p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/2019/11/27/design-pattern-bridge/"/>
      <url>/2019/11/27/design-pattern-bridge/</url>
      
        <content type="html"><![CDATA[<p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是<strong>用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</strong>。</p><p>桥接模式的优点是：<br>1、由于抽象与实现分离，所以扩展能力强；<br>2、其实现细节对客户透明。</p><p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。<br>2、当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。<br>3、当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</p><h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p><p><img src="/2019/11/27/design-pattern-bridge/bridge.jpg" alt></p><p>桥接（Bridge）模式包含以下主要角色：<br>1、抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。<br>2、扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。<br>3、实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。<br>4、具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//实现化角色</span><br><span class="line">interface Implementor</span><br><span class="line">&#123;</span><br><span class="line">    public void OperationImpl();</span><br><span class="line">&#125;</span><br><span class="line">//具体实现化角色</span><br><span class="line">class ConcreteImplementorA implements Implementor</span><br><span class="line">&#123;</span><br><span class="line">    public void OperationImpl()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体实现化(Concrete Implementor)角色被访问&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象化角色</span><br><span class="line">abstract class Abstraction</span><br><span class="line">&#123;</span><br><span class="line">   protected Implementor imple;</span><br><span class="line">   protected Abstraction(Implementor imple)</span><br><span class="line">   &#123;</span><br><span class="line">       this.imple=imple;</span><br><span class="line">   &#125;</span><br><span class="line">   public abstract void Operation();   </span><br><span class="line">&#125;</span><br><span class="line">//扩展抽象化角色</span><br><span class="line">class RefinedAbstraction extends Abstraction</span><br><span class="line">&#123;</span><br><span class="line">   protected RefinedAbstraction(Implementor imple)</span><br><span class="line">   &#123;</span><br><span class="line">       super(imple);</span><br><span class="line">   &#125;</span><br><span class="line">   public void Operation()</span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(&quot;扩展抽象化(Refined Abstraction)角色被访问&quot; );</span><br><span class="line">       imple.OperationImpl();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class BridgeTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Implementor imple=new ConcreteImplementorA();</span><br><span class="line">        Abstraction abs=new RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果如下：</span><br><span class="line">扩展抽象化(Refined Abstraction)角色被访问</span><br><span class="line">具体实现化(Concrete Implementor)角色被访问</span><br></pre></td></tr></table></figure></p><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>在软件开发中，有时桥接（Bridge）模式可与适配器模式联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如下：</p><p><img src="/2019/11/27/design-pattern-bridge/bridge-adaptee.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/2019/11/27/design-pattern-facade/"/>
      <url>/2019/11/27/design-pattern-facade/</url>
      
        <content type="html"><![CDATA[<p>外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点：<br>1、降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。<br>2、对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。<br>3、降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</p><p>外观（Facade）模式的主要缺点如下：<br>1、不能很好地限制客户使用子系统类。<br>2、增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。<br>2、当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。<br>3、当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</p><h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。</p><p><img src="/2019/11/27/design-pattern-facade/facade.jpg" alt></p><p>外观（Facade）模式包含以下主要角色:<br>1、外观（Facade）角色：为多个子系统对外提供一个共同的接口。<br>2、子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。<br>3、客户（Client）角色：通过一个外观角色访问各个子系统的功能。</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//外观角色</span><br><span class="line">class Facade</span><br><span class="line">&#123;</span><br><span class="line">    private SubSystem01 obj1=new SubSystem01();</span><br><span class="line">    private SubSystem02 obj2=new SubSystem02();</span><br><span class="line">    private SubSystem03 obj3=new SubSystem03();</span><br><span class="line">    public void method()</span><br><span class="line">    &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem01</span><br><span class="line">&#123;</span><br><span class="line">    public  void method1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统01的method1()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem02</span><br><span class="line">&#123;</span><br><span class="line">    public  void method2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统02的method2()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem03</span><br><span class="line">&#123;</span><br><span class="line">    public  void method3()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统03的method3()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class FacadePattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Facade f=new Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序运行结果如下：</span><br><span class="line">子系统01的method1()被调用！</span><br><span class="line">子系统02的method2()被调用！</span><br><span class="line">子系统03的method3()被调用！</span><br></pre></td></tr></table></figure></p><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题，其结构图如下：</p><p><img src="/2019/11/27/design-pattern-facade/facade-abs.jpg" alt></p><h2 id="与装饰模式区别"><a href="#与装饰模式区别" class="headerlink" title="与装饰模式区别"></a>与装饰模式区别</h2><p>装饰者听名字就知道他是对某个东西进行装饰，但是外观听上去也是对某个东西的外表进行装饰封装？那他们之间到底是有什么区别呢？<br>区别如下：外观是对一系列的接口进行封装，而装饰模式，是对某样东西进行内容的附加，从而得到新的东西。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2019/11/26/design-pattern-flyweight/"/>
      <url>/2019/11/26/design-pattern-flyweight/</url>
      
        <content type="html"><![CDATA[<p>享元（Flyweight）模式的定义：运用共享技术来有效地支持<strong>大量细粒度对象的复用</strong>。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p><p>享元模式的主要优点是：<br>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><p>其主要缺点是：<br>1、为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。<br>2、读取享元模式的外部状态会使得运行时间稍微变长。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。<br>2、大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。<br>3、由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</p><h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>享元模式中存在以下两种状态：<br>1、内部状态，即不会随着环境的改变而改变的可共享部分；<br>2、外部状态，指随环境改变而改变的不可以共享的部分。<br>享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</p><p><img src="/2019/11/26/design-pattern-flyweight/flyweight.jpg" alt></p><p>享元模式的主要角色有如下：<br>1、抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。<br>2、具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。<br>3、非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。<br>4、享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</p><p>实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">//非享元角色</span><br><span class="line">class UnsharedConcreteFlyweight</span><br><span class="line">&#123;</span><br><span class="line">    private String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        this.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getInfo()</span><br><span class="line">    &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setInfo(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        this.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象享元角色</span><br><span class="line">interface Flyweight</span><br><span class="line">&#123;</span><br><span class="line">    public void operation(UnsharedConcreteFlyweight state);</span><br><span class="line">&#125;</span><br><span class="line">//具体享元角色</span><br><span class="line">class ConcreteFlyweight implements Flyweight</span><br><span class="line">&#123;</span><br><span class="line">    private String key;</span><br><span class="line">    ConcreteFlyweight(String key)</span><br><span class="line">    &#123;</span><br><span class="line">        this.key=key;</span><br><span class="line">        System.out.println(&quot;具体享元&quot;+key+&quot;被创建！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void operation(UnsharedConcreteFlyweight outState)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(&quot;具体享元&quot;+key+&quot;被调用，&quot;);</span><br><span class="line">        System.out.println(&quot;非享元信息是:&quot;+outState.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//享元工厂角色</span><br><span class="line">class FlyweightFactory</span><br><span class="line">&#123;</span><br><span class="line">    private HashMap&lt;String, Flyweight&gt; flyweights=new HashMap&lt;String, Flyweight&gt;();</span><br><span class="line">    public Flyweight getFlyweight(String key)</span><br><span class="line">    &#123;</span><br><span class="line">        Flyweight flyweight=(Flyweight)flyweights.get(key);</span><br><span class="line">        if(flyweight!=null)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;具体享元&quot;+key+&quot;已经存在，被成功获取！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            flyweight=new ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        return flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class FlyweightPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FlyweightFactory factory=new FlyweightFactory();</span><br><span class="line">        Flyweight f01=factory.getFlyweight(&quot;a&quot;);</span><br><span class="line">        Flyweight f02=factory.getFlyweight(&quot;a&quot;);</span><br><span class="line">        Flyweight f03=factory.getFlyweight(&quot;a&quot;);</span><br><span class="line">        Flyweight f11=factory.getFlyweight(&quot;b&quot;);</span><br><span class="line">        Flyweight f12=factory.getFlyweight(&quot;b&quot;);       </span><br><span class="line">        f01.operation(new UnsharedConcreteFlyweight(&quot;第1次调用a。&quot;));       </span><br><span class="line">        f02.operation(new UnsharedConcreteFlyweight(&quot;第2次调用a。&quot;));       </span><br><span class="line">        f03.operation(new UnsharedConcreteFlyweight(&quot;第3次调用a。&quot;));       </span><br><span class="line">        f11.operation(new UnsharedConcreteFlyweight(&quot;第1次调用b。&quot;));       </span><br><span class="line">        f12.operation(new UnsharedConcreteFlyweight(&quot;第2次调用b。&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序运行结果如下：</span><br><span class="line">具体享元a被创建！</span><br><span class="line">具体享元a已经存在，被成功获取！</span><br><span class="line">具体享元a已经存在，被成功获取！</span><br><span class="line">具体享元b被创建！</span><br><span class="line">具体享元b已经存在，被成功获取！</span><br><span class="line">具体享元a被调用，非享元信息是:第1次调用a。</span><br><span class="line">具体享元a被调用，非享元信息是:第2次调用a。</span><br><span class="line">具体享元a被调用，非享元信息是:第3次调用a。</span><br><span class="line">具体享元b被调用，非享元信息是:第1次调用b。</span><br><span class="line">具体享元b被调用，非享元信息是:第2次调用b。</span><br></pre></td></tr></table></figure></p><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>在前面介绍的享元模式中，其结构图通常包含可以共享的部分和不可以共享的部分。在实际使用过程中，有时候会稍加改变，即存在两种特殊的享元模式：单纯享元模式和复合享元模式，下面分别对它们进行简单介绍。</p><p>(1) 单纯享元模式，这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类，其结构图如下图：</p><p><img src="/2019/11/26/design-pattern-flyweight/flyweight-simple.jpg" alt></p><p>(2) 复合享元模式，这种享元模式中的有些享元对象是由一些单纯享元对象组合而成的，它们就是复合享元对象。虽然复合享元对象本身不能共享，但它们可以分解成单纯享元对象再被共享，其结构图如下图：</p><p><img src="/2019/11/26/design-pattern-flyweight/flyweight-composite.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="/2019/11/21/design-pattern-decorator/"/>
      <url>/2019/11/21/design-pattern-decorator/</url>
      
        <content type="html"><![CDATA[<p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，<strong>动态</strong>地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p><p>主要优点有：<br>1、采用装饰模式扩展对象的功能<strong>比采用继承方式更加灵活</strong>。<br>2、可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</p><p>主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。<br>2、当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。<br>3、当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。</p><p><img src="/2019/11/21/design-pattern-decorator/decorator.jpg" alt></p><p>装饰模式主要包含以下角色:<br>1、抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。<br>2、具体构件（Concrete    Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。<br>3、抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。<br>4、具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</p><p>装饰模式的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//抽象构件角色</span><br><span class="line">interface  Component</span><br><span class="line">&#123;</span><br><span class="line">    public void operation();</span><br><span class="line">&#125;</span><br><span class="line">//具体构件角色</span><br><span class="line">class ConcreteComponent implements Component</span><br><span class="line">&#123;</span><br><span class="line">    public ConcreteComponent()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;创建具体构件角色&quot;);       </span><br><span class="line">    &#125;   </span><br><span class="line">    public void operation()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;调用具体构件角色的方法operation()&quot;);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象装饰角色</span><br><span class="line">class Decorator implements Component</span><br><span class="line">&#123;</span><br><span class="line">    private Component component;   </span><br><span class="line">    public Decorator(Component component)</span><br><span class="line">    &#123;</span><br><span class="line">        this.component=component;</span><br><span class="line">    &#125;   </span><br><span class="line">    public void operation()</span><br><span class="line">    &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体装饰角色</span><br><span class="line">class ConcreteDecorator extends Decorator</span><br><span class="line">&#123;</span><br><span class="line">    public ConcreteDecorator(Component component)</span><br><span class="line">    &#123;</span><br><span class="line">        super(component);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void operation()</span><br><span class="line">    &#123;</span><br><span class="line">        super.operation();</span><br><span class="line">        addedFunction();</span><br><span class="line">    &#125;</span><br><span class="line">    public void addedFunction()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;为具体构件角色增加额外的功能addedFunction()&quot;);           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class DecoratorPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Component p=new ConcreteComponent();</span><br><span class="line">        p.operation();</span><br><span class="line">        System.out.println(&quot;---------------------------------&quot;);</span><br><span class="line">        Component d=new ConcreteDecorator(p);</span><br><span class="line">        d.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序运行结果如下：</span><br><span class="line">创建具体构件角色</span><br><span class="line">调用具体构件角色的方法operation()</span><br><span class="line">---------------------------------</span><br><span class="line">调用具体构件角色的方法operation()</span><br><span class="line">为具体构件角色增加额外的功能addedFunction()</span><br></pre></td></tr></table></figure></p><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>装饰模式所包含的 4 个角色不是任何时候都要存在的，在有些应用环境下模式是可以简化的，如以下两种情况。</p><p>(1) 如果只有一个具体构件而没有抽象构件时，可以让抽象装饰继承具体构件，其结构图如图所示：</p><p><img src="/2019/11/21/design-pattern-decorator/decorator-simple1.jpg" alt></p><p>(2) 如果只有一个具体装饰时，可以将抽象装饰和具体装饰合并，其结构图如图所示：</p><p><img src="/2019/11/21/design-pattern-decorator/decorator-simple2.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2019/11/18/design-pattern-adapter/"/>
      <url>/2019/11/18/design-pattern-adapter/</url>
      
        <content type="html"><![CDATA[<p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。<br>2、使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>该模式的主要优点如下：<br>1、客户端通过适配器可以透明地调用目标接口。<br>2、复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。<br>3、将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</p><p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p><p>适配器模式（Adapter）包含以下主要角色。<br>1、目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。<br>2、适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。<br>3、适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</p><p>类适配器模式的结构图如下图：</p><p><img src="/2019/11/18/design-pattern-adapter/adapter-class.jpg" alt></p><p>对象适配器模式的结构图如下图：</p><p><img src="/2019/11/18/design-pattern-adapter/adapter-object.jpg" alt></p><p>(1) 类适配器模式的代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//目标接口</span><br><span class="line">interface Target</span><br><span class="line">&#123;</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br><span class="line">//适配者</span><br><span class="line">class Adaptee</span><br><span class="line">&#123;</span><br><span class="line">    public void specificRequest()</span><br><span class="line">    &#123;       </span><br><span class="line">        System.out.println(&quot;适配者中的业务代码被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//类适配器类</span><br><span class="line">class ClassAdapter extends Adaptee implements Target</span><br><span class="line">&#123;</span><br><span class="line">    public void request()</span><br><span class="line">    &#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端代码</span><br><span class="line">public class ClassAdapterTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;类适配器模式测试：&quot;);</span><br><span class="line">        Target target = new ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2)对象适配器模式的代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//适配者</span><br><span class="line">class Adaptee</span><br><span class="line">&#123;</span><br><span class="line">    public void specificRequest()</span><br><span class="line">    &#123;       </span><br><span class="line">        System.out.println(&quot;适配者中的业务代码被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//对象适配器类</span><br><span class="line">class ObjectAdapter implements Target</span><br><span class="line">&#123;</span><br><span class="line">    private Adaptee adaptee;</span><br><span class="line">    public ObjectAdapter(Adaptee adaptee)</span><br><span class="line">    &#123;</span><br><span class="line">        this.adaptee=adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    public void request()</span><br><span class="line">    &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//客户端代码</span><br><span class="line">public class ObjectAdapterTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;对象适配器模式测试：&quot;);</span><br><span class="line">        Adaptee adaptee = new Adaptee();</span><br><span class="line">        Target target = new ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口，其结构图如下图：</p><p><img src="/2019/11/18/design-pattern-adapter/adapter-bothway.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/2019/11/18/design-mode-composite/"/>
      <url>/2019/11/18/design-mode-composite/</url>
      
        <content type="html"><![CDATA[<p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，<strong>使用户对单个对象和组合对象具有一致的访问性</strong>。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、在需要表示一个对象整体与部分的层次结构的场合。<br>2、要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>组合模式的主要优点有：<br>1、组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；<br>2、更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</p><p>其主要缺点是：<br>1、设计较复杂，客户端需要花更多时间理清类之间的层次关系；<br>2、不容易限制容器中的构件；<br>3、不容易用继承的方法来增加构件的新功能；</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>组合模式包含以下主要角色：<br>1、抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。<br>2、树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。<br>3、树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。</p><p>组合模式分为透明式的组合模式和安全式的组合模式。</p><p>(1) 透明方式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。其结构图如下图：</p><p><img src="/2019/11/18/design-mode-composite/composite-transparent.jpg" alt></p><p>(2) 安全方式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。其结构图如下图：</p><p><img src="/2019/11/18/design-mode-composite/composite-safe.jpg" alt></p><p>下面给出透明式的组合模式的实现代码，与安全式的组合模式的实现代码类似，只要对其做简单修改就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//抽象构件</span><br><span class="line">interface Component</span><br><span class="line">&#123;</span><br><span class="line">    public void add(Component c);</span><br><span class="line">    public void remove(Component c);</span><br><span class="line">    public Component getChild(int i);</span><br><span class="line">    public void operation();</span><br><span class="line">&#125;</span><br><span class="line">//树叶构件</span><br><span class="line">class Leaf implements Component</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public Leaf(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void add(Component c)&#123; &#125;           </span><br><span class="line">    public void remove(Component c)&#123; &#125;   </span><br><span class="line">    public Component getChild(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;   </span><br><span class="line">    public void operation()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;树叶&quot;+name+&quot;：被访问！&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//树枝构件</span><br><span class="line">class Composite implements Component</span><br><span class="line">&#123;</span><br><span class="line">    private ArrayList&lt;Component&gt; children=new ArrayList&lt;Component&gt;();   </span><br><span class="line">    public void add(Component c)</span><br><span class="line">    &#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void remove(Component c)</span><br><span class="line">    &#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    public Component getChild(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        return children.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void operation()</span><br><span class="line">    &#123;</span><br><span class="line">        for(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Component)obj).operation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class CompositePattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Component c0=new Composite(); </span><br><span class="line">        Component c1=new Composite(); </span><br><span class="line">        Component leaf1=new Leaf(&quot;1&quot;); </span><br><span class="line">        Component leaf2=new Leaf(&quot;2&quot;); </span><br><span class="line">        Component leaf3=new Leaf(&quot;3&quot;);          </span><br><span class="line">        c0.add(leaf1); </span><br><span class="line">        c0.add(c1);</span><br><span class="line">        c1.add(leaf2); </span><br><span class="line">        c1.add(leaf3);          </span><br><span class="line">        c0.operation(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序运行结果如下：</span><br><span class="line">树叶1：被访问！</span><br><span class="line">树叶2：被访问！</span><br><span class="line">树叶3：被访问！</span><br></pre></td></tr></table></figure></p><h2 id="组合模式的扩展"><a href="#组合模式的扩展" class="headerlink" title="组合模式的扩展"></a>组合模式的扩展</h2><p>如果对前面介绍的组合模式中的树叶节点和树枝节点进行抽象，也就是说树叶节点和树枝节点还有子节点，这时组合模式就扩展成复杂的组合模式了，如 Java AWT/Swing 中的简单组件 JTextComponent 有子类 JTextField、JTextArea，容器组件 Container 也有子类 Window、Panel。复杂的组合模式的结构图如图所示:</p><p><img src="/2019/11/18/design-mode-composite/composite-complex.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2019/11/15/design-mode-proxy/"/>
      <url>/2019/11/15/design-mode-proxy/</url>
      
        <content type="html"><![CDATA[<p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问：</p><p><img src="/2019/11/15/design-mode-proxy/proxy.jpg" alt></p><p>代理模式的主要角色如下:<br>1、抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。<br>2、真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。<br>3、代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它<strong>可以访问、控制或扩展真实主题</strong>的功能。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>代理模式的主要优点有：<br>1、代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；<br>2、代理对象可以扩展目标对象的功能；<br>3、代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</p><p>其主要缺点是：<br>1、在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；<br>2、增加了系统的复杂度；</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。<br>2、虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。<br>3、安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。<br>4、智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。<br>5、延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</p><h2 id="结构代码实现"><a href="#结构代码实现" class="headerlink" title="结构代码实现"></a>结构代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//抽象主题</span><br><span class="line">interface Subject</span><br><span class="line">&#123;</span><br><span class="line">    void Request();</span><br><span class="line">&#125;</span><br><span class="line">//真实主题</span><br><span class="line">class RealSubject implements Subject</span><br><span class="line">&#123;</span><br><span class="line">    public void Request()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;访问真实主题方法...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//代理</span><br><span class="line">class Proxy implements Subject</span><br><span class="line">&#123;</span><br><span class="line">    private RealSubject realSubject;</span><br><span class="line">    public void Request()</span><br><span class="line">    &#123;</span><br><span class="line">        if (realSubject==null)</span><br><span class="line">        &#123;</span><br><span class="line">            realSubject=new RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.Request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    public void preRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;访问真实主题之前的预处理。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void postRequest()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;访问真实主题之后的后续处理。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class ProxyPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Proxy proxy=new Proxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点：<br>1、真实主题与代理主题一一对应，增加真实主题也要增加代理。<br>2、设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如SpringAOP，结构图如下图所示：</p><p><img src="/2019/11/15/design-mode-proxy/proxy-dynamic.jpg" alt title="动态代理模式结构图"></p><h3 id="java中的动态代理"><a href="#java中的动态代理" class="headerlink" title="java中的动态代理"></a>java中的动态代理</h3><p>java动态代理机制中有两个重要的类和接口InvocationHandler（接口）和Proxy（类），这一个类Proxy和接口InvocationHandler是我们实现动态代理的核心：</p><p>1.InvocationHandler接口是proxy代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。</p><p>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用，看如下invoke方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * proxy:代理类代理的真实代理对象com.sun.proxy.$Proxy0</span><br><span class="line">  * method:我们所要调用某个对象真实的方法的Method对象</span><br><span class="line">  * args:指代代理对象方法传递的参数</span><br><span class="line">  */</span><br><span class="line">  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;</span><br></pre></td></tr></table></figure></p><p>2.Proxy类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是newProxyInstance方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, </span><br><span class="line">                                            Class&lt;?&gt;[] interfaces, </span><br><span class="line">                                            InvocationHandler h)</span><br></pre></td></tr></table></figure></p><p>这个方法的作用就是创建一个代理类对象，它接收三个参数，我们来看下几个参数的含义：<br>1）loader：一个classloader对象，定义了由哪个classloader对象对生成的代理类进行加载<br>2）interfaces：一个interface对象数组，表示我们将要给我们的代理对象提供一组什么样的接口，如果我们提供了这样一个接口对象数组，那么也就是声明了代理类实现了这些接口，代理类就可以调用接口中声明的所有方法。<br>3）h：一个InvocationHandler对象，表示的是当动态代理对象调用方法的时候会关联到哪一个InvocationHandler对象上，并最终由其调用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/2019/11/15/design-mode-mediator/"/>
      <url>/2019/11/15/design-mode-mediator/</url>
      
        <content type="html"><![CDATA[<p>中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="/2019/11/15/design-mode-mediator/media.jpg" alt></p><p>中介者模式包含以下主要角色:<br>1、抽象中介者（Mediator）角色：它是中介者的接口，提供了<strong>同事对象注册与转发同事对象信息</strong>的抽象方法。<br>2、具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。<br>3、抽象同事类（Colleague）角色：定义同事类的接口，<strong>保存中介者对象，提供同事对象交互的抽象方法</strong>，实现所有相互影响的同事类的公共功能。<br>4、具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。<br>2、当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>中介者模式是一种对象行为型模式，其主要优点如下：<br>1、降低了对象之间的耦合性，使得对象易于独立地被复用。<br>2、将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</p><p>其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p><h2 id="结构代码实现"><a href="#结构代码实现" class="headerlink" title="结构代码实现"></a>结构代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//抽象中介者</span><br><span class="line">abstract class Mediator</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void register(Colleague colleague);</span><br><span class="line">    public abstract void relay(Colleague cl); //转发</span><br><span class="line">&#125;</span><br><span class="line">//具体中介者</span><br><span class="line">class ConcreteMediator extends Mediator</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;Colleague&gt; colleagues=new ArrayList&lt;Colleague&gt;();</span><br><span class="line">    public void register(Colleague colleague)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!colleagues.contains(colleague))</span><br><span class="line">        &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">            colleague.setMedium(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void relay(Colleague cl)</span><br><span class="line">    &#123;</span><br><span class="line">        for(Colleague ob:colleagues)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!ob.equals(cl))</span><br><span class="line">            &#123;</span><br><span class="line">                ((Colleague)ob).receive();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象同事类</span><br><span class="line">abstract class Colleague</span><br><span class="line">&#123;</span><br><span class="line">    protected Mediator mediator;</span><br><span class="line">    public void setMedium(Mediator mediator)</span><br><span class="line">    &#123;</span><br><span class="line">        this.mediator=mediator;</span><br><span class="line">    &#125;   </span><br><span class="line">    public abstract void receive();   </span><br><span class="line">    public abstract void send();</span><br><span class="line">&#125;</span><br><span class="line">//具体同事类</span><br><span class="line">class ConcreteColleague1 extends Colleague</span><br><span class="line">&#123;</span><br><span class="line">    public void receive()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类1收到请求。&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void send()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类1发出请求。&quot;);</span><br><span class="line">        mediator.relay(this); //请中介者转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体同事类</span><br><span class="line">class ConcreteColleague2 extends Colleague</span><br><span class="line">&#123;</span><br><span class="line">    public void receive()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类2收到请求。&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void send()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体同事类2发出请求。&quot;);</span><br><span class="line">        mediator.relay(this); //请中介者转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class MediatorPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Mediator md=new ConcreteMediator();</span><br><span class="line">        Colleague c1,c2;</span><br><span class="line">        c1=new ConcreteColleague1();</span><br><span class="line">        c2=new ConcreteColleague2();</span><br><span class="line">        md.register(c1);</span><br><span class="line">        md.register(c2);</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(&quot;-------------&quot;);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果如下：</span><br><span class="line">具体同事类1发出请求。</span><br><span class="line">具体同事类2收到请求。</span><br><span class="line">-------------</span><br><span class="line">具体同事类2发出请求。</span><br><span class="line">具体同事类1收到请求。</span><br></pre></td></tr></table></figure><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>在实际开发中，通常采用以下两种方法来简化中介者模式，使开发变得更简单：<br>1、不定义中介者接口，把具体中介者对象实现成为单例。<br>2、同事对象不持有中介者，而是在需要时直接获取中介者对象并调用。</p><p><img src="/2019/11/15/design-mode-mediator/mediator-singleton.jpg" alt title="简化中介者模式的结构图"></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//简单单例中介者</span><br><span class="line">class SimpleMediator</span><br><span class="line">&#123;</span><br><span class="line">    private static SimpleMediator smd=new SimpleMediator();   </span><br><span class="line">    private List&lt;SimpleColleague&gt; colleagues=new ArrayList&lt;SimpleColleague&gt;();   </span><br><span class="line">    private SimpleMediator()&#123;&#125;   </span><br><span class="line">    public static SimpleMediator getMedium()</span><br><span class="line">    &#123;    return(smd);   &#125;</span><br><span class="line">    public void register(SimpleColleague colleague)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!colleagues.contains(colleague))</span><br><span class="line">        &#123;</span><br><span class="line">            colleagues.add(colleague);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void relay(SimpleColleague scl)</span><br><span class="line">    &#123;       </span><br><span class="line">        for(SimpleColleague ob:colleagues)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!ob.equals(scl))</span><br><span class="line">            &#123;</span><br><span class="line">                ((SimpleColleague)ob).receive();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象同事类</span><br><span class="line">interface SimpleColleague</span><br><span class="line">&#123;</span><br><span class="line">    void receive();   </span><br><span class="line">    void send();</span><br><span class="line">&#125;</span><br><span class="line">//具体同事类</span><br><span class="line">class SimpleConcreteColleague1 implements SimpleColleague</span><br><span class="line">&#123;</span><br><span class="line">    SimpleConcreteColleague1()&#123;</span><br><span class="line">        SimpleMediator smd=SimpleMediator.getMedium();</span><br><span class="line">        smd.register(this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void receive()</span><br><span class="line">    &#123;    System.out.println(&quot;具体同事类1：收到请求。&quot;);    &#125;   </span><br><span class="line">    public void send()</span><br><span class="line">    &#123;</span><br><span class="line">        SimpleMediator smd=SimpleMediator.getMedium();</span><br><span class="line">        System.out.println(&quot;具体同事类1：发出请求...&quot;);</span><br><span class="line">        smd.relay(this); //请中介者转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体同事类</span><br><span class="line">class SimpleConcreteColleague2 implements SimpleColleague</span><br><span class="line">&#123;</span><br><span class="line">    SimpleConcreteColleague2()&#123;</span><br><span class="line">        SimpleMediator smd=SimpleMediator.getMedium();</span><br><span class="line">        smd.register(this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void receive()</span><br><span class="line">    &#123;    System.out.println(&quot;具体同事类2：收到请求。&quot;);    &#125;   </span><br><span class="line">    public void send()</span><br><span class="line">    &#123;</span><br><span class="line">        SimpleMediator smd=SimpleMediator.getMedium();</span><br><span class="line">        System.out.println(&quot;具体同事类2：发出请求...&quot;);</span><br><span class="line">        smd.relay(this); //请中介者转发</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class SimpleMediatorPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        SimpleColleague c1,c2;</span><br><span class="line">        c1=new SimpleConcreteColleague1();</span><br><span class="line">        c2=new SimpleConcreteColleague2();</span><br><span class="line">        c1.send();</span><br><span class="line">        System.out.println(&quot;-----------------&quot;);</span><br><span class="line">        c2.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="/2019/11/11/design-mode-visitor/"/>
      <url>/2019/11/11/design-mode-visitor/</url>
      
        <content type="html"><![CDATA[<p>访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将<strong>对数据的操作与数据结构进行分离</strong>，是行为类模式中最复杂的一种模式。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>访问者模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类：</p><p><img src="/2019/11/11/design-mode-visitor/visitor.jpg" alt></p><p>访问者模式包含以下主要角色：<br>1、抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。<br>2、具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。<br>3、抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。<br>4、具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。<br>5、对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、对象结构相对稳定，但其操作算法经常变化的程序。<br>2、对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。<br>3、对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>访问者（Visitor）模式是一种对象行为型模式，其主要优点如下：<br>1、扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。<br>2、复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。<br>3、灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。<br>4、符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</p><p>访问者（Visitor）模式的主要缺点如下：<br>1、增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。<br>2、破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。<br>3、违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</p><h2 id="结构代码实现"><a href="#结构代码实现" class="headerlink" title="结构代码实现"></a>结构代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">//抽象访问者</span><br><span class="line">interface Visitor</span><br><span class="line">&#123;</span><br><span class="line">    void visit(ConcreteElementA element);</span><br><span class="line">    void visit(ConcreteElementB element);</span><br><span class="line">&#125;</span><br><span class="line">//具体访问者A类</span><br><span class="line">class ConcreteVisitorA implements Visitor</span><br><span class="line">&#123;</span><br><span class="line">    public void visit(ConcreteElementA element)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体访问者A访问--&gt;&quot;+element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    public void visit(ConcreteElementB element)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体访问者A访问--&gt;&quot;+element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体访问者B类</span><br><span class="line">class ConcreteVisitorB implements Visitor</span><br><span class="line">&#123;</span><br><span class="line">    public void visit(ConcreteElementA element)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体访问者B访问--&gt;&quot;+element.operationA());</span><br><span class="line">    &#125;</span><br><span class="line">    public void visit(ConcreteElementB element)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体访问者B访问--&gt;&quot;+element.operationB());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象元素类</span><br><span class="line">interface Element</span><br><span class="line">&#123;</span><br><span class="line">    void accept(Visitor visitor);</span><br><span class="line">&#125;</span><br><span class="line">//具体元素A类</span><br><span class="line">class ConcreteElementA implements Element</span><br><span class="line">&#123;</span><br><span class="line">    public void accept(Visitor visitor)</span><br><span class="line">    &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">    public String operationA()</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;具体元素A的操作。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体元素B类</span><br><span class="line">class ConcreteElementB implements Element</span><br><span class="line">&#123;</span><br><span class="line">    public void accept(Visitor visitor)</span><br><span class="line">    &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">    public String operationB()</span><br><span class="line">    &#123;</span><br><span class="line">        return &quot;具体元素B的操作。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//对象结构角色</span><br><span class="line">class ObjectStructure</span><br><span class="line">&#123;   </span><br><span class="line">    private List&lt;Element&gt; list=new ArrayList&lt;Element&gt;();   </span><br><span class="line">    public void accept(Visitor visitor)</span><br><span class="line">    &#123;</span><br><span class="line">        Iterator&lt;Element&gt; i=list.iterator();</span><br><span class="line">        while(i.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            ((Element) i.next()).accept(visitor);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    public void add(Element element)</span><br><span class="line">    &#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove(Element element)</span><br><span class="line">    &#123;</span><br><span class="line">        list.remove(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class VisitorPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        ObjectStructure os=new ObjectStructure();</span><br><span class="line">        os.add(new ConcreteElementA());</span><br><span class="line">        os.add(new ConcreteElementB());</span><br><span class="line">        Visitor visitor=new ConcreteVisitorA();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">        System.out.println(&quot;------------------------&quot;);</span><br><span class="line">        visitor=new ConcreteVisitorB();</span><br><span class="line">        os.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果如下：</span><br><span class="line">具体访问者A访问--&gt;具体元素A的操作。</span><br><span class="line">具体访问者A访问--&gt;具体元素B的操作。</span><br><span class="line">------------------------</span><br><span class="line">具体访问者B访问--&gt;具体元素A的操作。</span><br><span class="line">具体访问者B访问--&gt;具体元素B的操作。</span><br></pre></td></tr></table></figure><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用。</p><p>(1)与“迭代器模式”联用。因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。如上例中的对象结构是用 List 实现的，它通过 List 对象的 Itemtor() 方法获取迭代器。如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。</p><p>(2)访问者（Visitor）模式同“组合模式”联用。因为访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式，其结构图如图所示:</p><p><img src="/2019/11/11/design-mode-visitor/visitor-group.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/2019/11/11/design-mode-template/"/>
      <url>/2019/11/11/design-mode-template/</url>
      
        <content type="html"><![CDATA[<p>　　模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p><p>　　通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。</p><p><img src="/2019/11/11/design-mode-template/template.png" alt></p><p>1、抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。<br>① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。<br>② 基本方法：是整个算法中的一个步骤，包含以下几种类型。<br>　 抽象方法：在抽象类中申明，由具体子类实现。<br>　 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。<br>　 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>2、具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。<br>2、当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。<br>3、当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>该模式的主要优点如下：<br>1、它<strong>封装了不变部分，扩展可变部分</strong>。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。<br>2、它在父类中提取了公共的部分代码，便于代码复用。<br>3、部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</p><p>该模式的主要缺点如下：<br>1、对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。<br>2、父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</p><h2 id="结构代码实现"><a href="#结构代码实现" class="headerlink" title="结构代码实现"></a>结构代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class TemplateMethodPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        AbstractClass tm=new ConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象类</span><br><span class="line">abstract class AbstractClass</span><br><span class="line">&#123;</span><br><span class="line">    public void TemplateMethod() //模板方法</span><br><span class="line">    &#123;</span><br><span class="line">        SpecificMethod();</span><br><span class="line">        abstractMethod1();          </span><br><span class="line">         abstractMethod2();</span><br><span class="line">    &#125;  </span><br><span class="line">    public void SpecificMethod() //具体方法</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;抽象类中的具体方法被调用...&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public abstract void abstractMethod1(); //抽象方法1</span><br><span class="line">    public abstract void abstractMethod2(); //抽象方法2</span><br><span class="line">&#125;</span><br><span class="line">//具体子类</span><br><span class="line">class ConcreteClass extends AbstractClass</span><br><span class="line">&#123;</span><br><span class="line">    public void abstractMethod1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;抽象方法1的实现被调用...&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void abstractMethod2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;抽象方法2的实现被调用...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>在模板方法模式中，基本方法包含：抽象方法、具体方法和钩子方法，正确使用“钩子方法”可以使得子类控制父类的行为。如下面例子中，可以通过在具体子类中重写钩子方法 HookMethod1() 和 HookMethod2() 来改变抽象父类中的运行结果，其结构图如图 3 所示：</p><p><img src="/2019/11/11/design-mode-template/template-hook.jpg" alt></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class HookTemplateMethod</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        HookAbstractClass tm=new HookConcreteClass();</span><br><span class="line">        tm.TemplateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//含钩子方法的抽象类</span><br><span class="line">abstract class HookAbstractClass</span><br><span class="line">&#123;</span><br><span class="line">    public void TemplateMethod() //模板方法</span><br><span class="line">    &#123;</span><br><span class="line">        abstractMethod1();</span><br><span class="line">        HookMethod1();</span><br><span class="line">        if(HookMethod2())</span><br><span class="line">        &#123;</span><br><span class="line">            SpecificMethod();   </span><br><span class="line">        &#125;</span><br><span class="line">         abstractMethod2();</span><br><span class="line">    &#125;  </span><br><span class="line">    public void SpecificMethod() //具体方法</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;抽象类中的具体方法被调用...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void HookMethod1()&#123;&#125;  //钩子方法1</span><br><span class="line">    public boolean HookMethod2() //钩子方法2</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void abstractMethod1(); //抽象方法1</span><br><span class="line">    public abstract void abstractMethod2(); //抽象方法2</span><br><span class="line">&#125;</span><br><span class="line">//含钩子方法的具体子类</span><br><span class="line">class HookConcreteClass extends HookAbstractClass</span><br><span class="line">&#123;</span><br><span class="line">    public void abstractMethod1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;抽象方法1的实现被调用...&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void abstractMethod2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;抽象方法2的实现被调用...&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void HookMethod1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;钩子方法1被重写...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean HookMethod2()</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果如下：</span><br><span class="line">抽象方法1的实现被调用...</span><br><span class="line">钩子方法1被重写...</span><br><span class="line">抽象方法2的实现被调用...</span><br></pre></td></tr></table></figure></p><p>如果钩子方法 HookMethod1() 和钩子方法 HookMethod2() 的代码改变，则程序的运行结果也会改变。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://c.biancheng.net/view/1376.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1376.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/2019/11/11/desigin-mode-iterator/"/>
      <url>/2019/11/11/desigin-mode-iterator/</url>
      
        <content type="html"><![CDATA[<p>迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。是一种对象行为型模式。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>迭代器模式是<strong>通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现</strong>的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。</p><p><img src="/2019/11/11/desigin-mode-iterator/iterator.jpg" alt></p><p>迭代器模式主要包含以下角色。<br>1、抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。<br>2、具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。<br>3、抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。<br>4、具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p><h2 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h2><p>1、当需要为聚合对象提供多种遍历方式时。<br>2、当需要为遍历不同的聚合结构提供一个统一的接口时。<br>3、当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</p><p>由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>主要优点如下：<br>1、访问一个聚合对象的内容而无须暴露它的内部表示。<br>2、遍历任务交由迭代器完成，这简化了聚合类。<br>3、它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。<br>4、增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br>5、封装性良好，为遍历不同的聚合结构提供一个统一的接口。</p><p>其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。</p><h2 id="结构代码实现"><a href="#结构代码实现" class="headerlink" title="结构代码实现"></a>结构代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">//抽象聚合</span><br><span class="line">interface Aggregate</span><br><span class="line">&#123; </span><br><span class="line">    public void add(Object obj); </span><br><span class="line">    public void remove(Object obj); </span><br><span class="line">    public Iterator getIterator(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体聚合</span><br><span class="line">class ConcreteAggregate implements Aggregate</span><br><span class="line">&#123; </span><br><span class="line">    private List&lt;Object&gt; list=new ArrayList&lt;Object&gt;(); </span><br><span class="line"></span><br><span class="line">    public void add(Object obj)</span><br><span class="line">    &#123; </span><br><span class="line">        list.add(obj); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove(Object obj)</span><br><span class="line">    &#123; </span><br><span class="line">        list.remove(obj); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator getIterator()</span><br><span class="line">    &#123; </span><br><span class="line">        return(new ConcreteIterator(list)); </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象迭代器</span><br><span class="line">interface Iterator</span><br><span class="line">&#123;</span><br><span class="line">    Object first();</span><br><span class="line">    Object next();</span><br><span class="line">    boolean hasNext();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体迭代器</span><br><span class="line">class ConcreteIterator implements Iterator</span><br><span class="line">&#123; </span><br><span class="line">    private List&lt;Object&gt; list=null; </span><br><span class="line">    private int index=-1; </span><br><span class="line"></span><br><span class="line">    public ConcreteIterator(List&lt;Object&gt; list)</span><br><span class="line">    &#123; </span><br><span class="line">        this.list=list; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public boolean hasNext()</span><br><span class="line">    &#123; </span><br><span class="line">        if(index&lt;list.size()-1)</span><br><span class="line">        &#123; </span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object first()</span><br><span class="line">    &#123;</span><br><span class="line">        index=0;</span><br><span class="line">        Object obj=list.get(index);;</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object next()</span><br><span class="line">    &#123; </span><br><span class="line">        Object obj=null; </span><br><span class="line">        if(this.hasNext())</span><br><span class="line">        &#123; </span><br><span class="line">            obj=list.get(++index); </span><br><span class="line">        &#125; </span><br><span class="line">        return obj; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Client</span><br><span class="line">public class IteratorPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Aggregate ag=new ConcreteAggregate(); </span><br><span class="line">        ag.add(&quot;中山大学&quot;); </span><br><span class="line">        ag.add(&quot;华南理工&quot;); </span><br><span class="line">        ag.add(&quot;韶关学院&quot;);</span><br><span class="line">        System.out.print(&quot;聚合的内容有：&quot;);</span><br><span class="line">        Iterator it=ag.getIterator(); </span><br><span class="line">        while(it.hasNext())</span><br><span class="line">        &#123; </span><br><span class="line">            Object ob=it.next(); </span><br><span class="line">            System.out.print(ob.toString()+&quot;\t&quot;); </span><br><span class="line">        &#125;</span><br><span class="line">        Object ob=it.first();</span><br><span class="line">        System.out.println(&quot;\nFirst：&quot;+ob.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android插件化原理</title>
      <link href="/2019/11/06/android-plugin-principle/"/>
      <url>/2019/11/06/android-plugin-principle/</url>
      
        <content type="html"><![CDATA[<p>插件化技术，实际上要解决的就是两个问题：<br>1、代码加载<br>2、资源加载</p><h2 id="代码加载"><a href="#代码加载" class="headerlink" title="代码加载"></a>代码加载</h2><p>类的加载可以使用Java的ClassLoader机制，但是对于Android来说，并不是说类加载进来就可以用了，很多组件都是有“生命”的；因此对于这些有血有肉的类，必须给它们注入活力，也就是所谓的<strong>组件生命周期管理</strong>；</p><p>另外，如何管理加载进来的类也是一个问题。假设多个插件依赖了相同的类，是抽取公共依赖进行管理还是插件单独依赖？这就是<strong>ClassLoader的管理</strong>问题。</p><p>ClassLoader详细可参考：<a href="https://zhaoshuming.github.io/2019/05/10/android-dex/" target="_blank" rel="noopener">类加载器ClassLoader及Dex/Class</a></p><h3 id="Context的处理"><a href="#Context的处理" class="headerlink" title="Context的处理"></a>Context的处理</h3><p>通常我们通过Context对象访问资源，光创建出Resource对象还不够，因此还需要一些额外的工作。 对资源访问的不同实现方式也需要不同的额外工作。以VirtualAPK的处理方式为例：</p><p>第一步：创建Resource<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (Constants.COMBINE_RESOURCES) &#123;</span><br><span class="line">    //插件和主工程资源合并时需要hook住主工程的资源</span><br><span class="line">    Resources resources = ResourcesManager.createResources(context, apk.getAbsolutePath());</span><br><span class="line">    ResourcesManager.hookResources(context, resources);  </span><br><span class="line">      return resources;</span><br><span class="line">&#125; else &#123;  </span><br><span class="line">    //插件资源独立，该resource只能访问插件自己的资源</span><br><span class="line">    Resources hostResources = context.getResources();</span><br><span class="line">    AssetManager assetManager = createAssetManager(context, apk);  </span><br><span class="line">    return new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二步：hook主工程的Resource<br>对于合并式的资源访问方式，需要替换主工程的Resource，下面是具体替换的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void hookResources(Context base, Resources resources) &#123; </span><br><span class="line">   try &#123;</span><br><span class="line">//替换了主工程context中LoadedApk的mResource对象。</span><br><span class="line">        ReflectUtil.setField(base.getClass(), base, &quot;mResources&quot;, resources);</span><br><span class="line">        Object loadedApk = ReflectUtil.getPackageInfo(base);</span><br><span class="line">        ReflectUtil.setField(loadedApk.getClass(), loadedApk, &quot;mResources&quot;, resources);</span><br><span class="line"></span><br><span class="line">//将新的Resource添加到主工程ActivityThread的mResourceManager中</span><br><span class="line">        Object activityThread = ReflectUtil.getActivityThread(base);</span><br><span class="line">        Object resManager = ReflectUtil.getField(activityThread.getClass(), activityThread, &quot;mResourcesManager&quot;);       </span><br><span class="line"> if (Build.VERSION.SDK_INT &lt; 24) &#123;</span><br><span class="line">            Map&lt;Object, WeakReference&lt;Resources&gt;&gt; map = (Map&lt;Object, WeakReference&lt;Resources&gt;&gt;) ReflectUtil.getField(resManager.getClass(), resManager, &quot;mActiveResources&quot;);</span><br><span class="line">            Object key = map.keySet().iterator().next();</span><br><span class="line">            map.put(key, new WeakReference&lt;&gt;(resources));</span><br><span class="line">        &#125; else &#123;                </span><br><span class="line">// still hook Android N Resources, even though it&apos;s unnecessary, then nobody will be strange.</span><br><span class="line">            Map map = (Map) ReflectUtil.getFieldNoException(resManager.getClass(), resManager, &quot;mResourceImpls&quot;);</span><br><span class="line">            Object key = map.keySet().iterator().next();</span><br><span class="line">            Object resourcesImpl = ReflectUtil.getFieldNoException(Resources.class, resources, &quot;mResourcesImpl&quot;);</span><br><span class="line">            map.put(key, new WeakReference&lt;&gt;(resourcesImpl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意下上述代码hook了几个地方，包括以下几个hook点：<br>1.替换了主工程context中LoadedApk的mResource对象。<br>2.将新的Resource添加到主工程ActivityThread的mResourceManager中，并且根据Android版本做了不同处理。</p><p>第三步：关联resource和Activity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);</span><br><span class="line">activity.setIntent(intent);</span><br><span class="line">//设置Activity的mResources属性，Activity中访问资源时都通过mResources</span><br><span class="line">ReflectUtil.setField(ContextThemeWrapper.class, activity, &quot;mResources&quot;, plugin.getResources());</span><br></pre></td></tr></table></figure></p><p>上述代码是在Activity创建时被调用的（后面会介绍如何hook Activity的创建过程），在activity被构造出来后，需要替换其中的mResources为插件的Resource。由于独立式时主工程的Resource不能访问插件的资源，所以如果不做替换，会产生资源访问错误。</p><p>做完以上工作后，则可以在插件的Activity中放心的使用setContentView，inflater等方法加载布局了。</p><h3 id="四大组件支持"><a href="#四大组件支持" class="headerlink" title="四大组件支持"></a>四大组件支持</h3><p>Android开发中有一些特殊的类，是由系统创建的，并且由系统管理生命周期。如常用的四大组件，Activity，Service，BroadcastReceiver和ContentProvider。 仅仅构造出这些类的实例是没用的，还需要管理组件的生命周期。其中以Activity最为复杂，不同框架采用的方法也不尽相同。下面以Activity为例详细介绍插件化如何支持组件生命周期的管理。 大致分为两种方式：</p><ul><li>ProxyActivity代理</li><li>预埋StubActivity，hook系统启动Activity的过程</li></ul><h4 id="ProxyActivity代理"><a href="#ProxyActivity代理" class="headerlink" title="ProxyActivity代理"></a>ProxyActivity代理</h4><p>ProxyActivity代理的方式最早是由dynamic-load-apk提出的，其思想很简单，<strong>在主工程中放一个ProxyActivy，启动插件中的Activity时会先启动ProxyActivity，在ProxyActivity中创建插件Activity，并同步生命周期</strong>。下图展示了启动插件Activity的过程：</p><p><img src="/2019/11/06/android-plugin-principle/proxy-activity.jpg" alt></p><p>具体的过程如下：</p><ol><li>首先需要通过统一的入口（如图中的PluginManager）启动插件Activity，其内部会将启动的插件Activity信息保存下来，并将intent替换为启动ProxyActivity的intent。</li><li>ProxyActivity根据插件的信息拿到该插件的ClassLoader和Resource，通过反射创建PluginActivity并调用其onCreate方法。</li><li>PluginActivty调用的setContentView被重写了，会去调用ProxyActivty的setContentView。由于ProxyActivity重写了getResource返回的是插件的Resource，所以setContentView能够访问到插件中的资源。同样findViewById也是调用ProxyActivity的。<br>4.ProxyActivity中的其他生命周期回调函数中调用相应PluginActivity的生命周期。</li></ol><p>理解ProxyActivity代理方式主要注意两点：</p><ul><li>ProxyActivity中需要重写getResouces，getAssets，getClassLoader方法返回插件的相应对象。生命周期函数以及和用户交互相关函数，如onResume，onStop，onBackPressedon，KeyUponWindow，FocusChanged等需要转发给插件。</li><li>PluginActivity中所有调用context的相关的方法，如setContentView，getLayoutInflater，getSystemService等都需要调用ProxyActivity的相应方法。</li></ul><p>缺点：</p><ol><li><strong>插件中的Activity必须继承PluginActivity，开发侵入性强</strong>。</li><li>如果想支持Activity的singleTask，singleInstance等launchMode时，需要自己管理Activity栈，实现起来很繁琐。</li><li>插件中需要小心处理Context，容易出错。</li><li>如果想把之前的模块改造成插件需要很多额外的工作。</li></ol><p>该方式虽然能够很好的实现启动插件Activity的目的，但是由于开发式侵入性很强，dynamic-load-apk之后的插件化方案很少继续使用该方式，而是通过hook系统启动Activity的过程，让启动插件中的Activity像启动主工程的Activity一样简单。</p><h4 id="hook方式"><a href="#hook方式" class="headerlink" title="hook方式"></a>hook方式</h4><p>在介绍hook方式之前，先用一张图简要的介绍下系统是如何启动一个Activity的：</p><p><img src="/2019/11/06/android-plugin-principle/hook-activity.jpg" alt title="图2"></p><p>上图列出的是启动一个Activity的主要过程，具体步骤如下：</p><ol><li>Activity1调用startActivity，实际会调用Instrumentation类的execStartActivity方法，Instrumentation是系统用来监控Activity运行的一个类，Activity的整个生命周期都有它的影子。</li><li>通过跨进程的binder调用，进入到ActivityManagerService中，其内部会处理Activity栈。之后又通过跨进程调用进入到Activity2所在的进程中。</li><li>ApplicationThread是一个binder对象，其运行在binder线程池中，内部包含一个H类，该类继承于类Handler。ApplicationThread将启动Activity2的信息通过H对象发送给主线程。</li><li>主线程拿到Activity2的信息后，调用Instrumentation类的newActivity方法，其内通过ClassLoader创建Activity2实例。</li></ol><p>下面介绍如何通过hook的方式启动插件中的Activity，需要解决以下两个问题：</p><ul><li>插件中的Activity没有在AndroidManifest中注册，如何绕过检测。</li><li>如何构造Activity实例，同步生命周期</li></ul><p>解决方法有很多种，以VirtualAPK为例，核心思路如下：</p><ol><li>先在Manifest中预埋StubActivity，启动时hook上图第1步，将Intent替换成StubActivity。</li><li>hook第10步，通过插件的ClassLoader反射创建插件Activity</li><li>之后Activity的所有生命周期回调都会通知给插件Activity</li></ol><h5 id="替换系统Instrumentation"><a href="#替换系统Instrumentation" class="headerlink" title="替换系统Instrumentation"></a>替换系统Instrumentation</h5><p>VirtualAPK在初始化时会调用hookInstrumentationAndHandler，该方法hook了系统的Instrumentaiton类，由上文可知该类和Activity的启动息息相关。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void hookInstrumentationAndHandler() &#123; </span><br><span class="line">   try &#123;  </span><br><span class="line">         //获取Instrumentation对象</span><br><span class="line">        Instrumentation baseInstrumentation = ReflectUtil.getInstrumentation(this.mContext);   </span><br><span class="line">        //构造自定义的VAInstrumentation</span><br><span class="line">        final VAInstrumentation instrumentation = new VAInstrumentation(this, baseInstrumentation); </span><br><span class="line">        //设置ActivityThread的mInstrumentation和mCallBack</span><br><span class="line">        Object activityThread = ReflectUtil.getActivityThread(this.mContext);</span><br><span class="line">        ReflectUtil.setInstrumentation(activityThread, instrumentation);</span><br><span class="line">        ReflectUtil.setHandlerCallback(this.mContext, instrumentation); </span><br><span class="line">         this.mInstrumentation = instrumentation;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>该段代码将主线程中的Instrumentation对象替换成了自定义的VAInstrumentation类。在启动和创建插件activity时，该类都会偷偷做一些手脚。</p><h5 id="hook-activity启动过程"><a href="#hook-activity启动过程" class="headerlink" title="hook activity启动过程"></a>hook activity启动过程</h5><p>VAInstrumentation类重写了execStartActivity方法，相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public ActivityResult execStartActivity(</span><br><span class="line">    //省略了无关参数</span><br><span class="line">    Intent intent) &#123;</span><br><span class="line">//转换隐式intent</span><br><span class="line">    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent); </span><br><span class="line">    if (intent.getComponent() != null) &#123;  </span><br><span class="line">        //替换intent中启动Activity为StubActivity</span><br><span class="line">        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//调用父类启动Activity的方法&#125;</span><br><span class="line">public void markIntentIfNeeded(Intent intent) &#123; </span><br><span class="line">   if (intent.getComponent() == null) &#123;  </span><br><span class="line">         return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String targetPackageName = intent.getComponent().getPackageName();</span><br><span class="line">    String targetClassName = intent.getComponent().getClassName();    // search map and return specific launchmode stub activity</span><br><span class="line">    if (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != null) &#123;</span><br><span class="line">        intent.putExtra(Constants.KEY_IS_PLUGIN, true);</span><br><span class="line">        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);</span><br><span class="line">        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);</span><br><span class="line">        dispatchStubActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>execStartActivity中会先去处理隐式intent，如果该隐式intent匹配到了插件中的Activity，将其转换成显式。之后通过markIntentIfNeeded将待启动的的插件Activity替换成了预先在AndroidManifest中占坑的StubActivity，并将插件Activity的信息保存到该intent中。其中有个dispatchStubActivity函数，会根据Activity的launchMode选择具体启动哪个StubActivity。<strong>VirtualAPK为了支持Activity的launchMode在主工程的AndroidManifest中对于每种启动模式的Activity都预埋了多个坑位</strong>。</p><h5 id="hook-Activity的创建过程"><a href="#hook-Activity的创建过程" class="headerlink" title="hook Activity的创建过程"></a>hook Activity的创建过程</h5><p>上一步欺骗了系统，让系统以为自己启动的是一个正常的Activity。当来到图的第10步时，再将插件的Activity换回来。此时调用的是VAInstrumentation类的newActivity方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Activity newActivity(ClassLoader cl, String className, Intent intent)&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        cl.loadClass(className);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        //通过LoadedPlugin可以获取插件的ClassLoader和Resource</span><br><span class="line">        LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);</span><br><span class="line">        //获取插件的主Activity</span><br><span class="line">        String targetClassName = PluginUtil.getTargetActivity(intent);</span><br><span class="line">        if (targetClassName != null) &#123; </span><br><span class="line">            //传入插件的ClassLoader构造插件Activity</span><br><span class="line">            Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);</span><br><span class="line">            activity.setIntent(intent);</span><br><span class="line">            //设置插件的Resource，从而可以支持插件中资源的访问</span><br><span class="line">            try &#123;</span><br><span class="line">                ReflectUtil.setField(ContextThemeWrapper.class, activity, &quot;mResources&quot;, plugin.getResources());</span><br><span class="line">            &#125; catch (Exception ignored) &#123; </span><br><span class="line">                // ignored.</span><br><span class="line">            &#125;  </span><br><span class="line">          return activity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"> return mBase.newActivity(cl, className, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于AndroidManifest中预埋的StubActivity并没有具体的实现类，所以此时会发生ClassNotFoundException。之后在处理异常时取出插件Activity的信息，通过插件的ClassLoader反射构造插件的Activity。</p><h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><p>插件Activity构造出来后，为了能够保证其正常运行还要做些额外的工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void callActivityOnCreate(Activity activity, Bundle icicle) &#123; </span><br><span class="line">   final Intent intent = activity.getIntent();</span><br><span class="line">       if (PluginUtil.isIntentFromPlugin(intent)) &#123;</span><br><span class="line">        Context base = activity.getBaseContext();</span><br><span class="line">               try &#123;</span><br><span class="line">            LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);</span><br><span class="line">            ReflectUtil.setField(base.getClass(), base, &quot;mResources&quot;, plugin.getResources());</span><br><span class="line">            ReflectUtil.setField(ContextWrapper.class, activity, &quot;mBase&quot;, plugin.getPluginContext());</span><br><span class="line">            ReflectUtil.setField(Activity.class, activity, &quot;mApplication&quot;, plugin.getApplication());</span><br><span class="line">            ReflectUtil.setFieldNoException(ContextThemeWrapper.class, activity, &quot;mBase&quot;, plugin.getPluginContext());</span><br><span class="line">               // set screenOrientation</span><br><span class="line">            ActivityInfo activityInfo = plugin.getActivityInfo(PluginUtil.getComponent(intent)); </span><br><span class="line">              if (activityInfo.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) &#123;</span><br><span class="line">                activity.setRequestedOrientation(activityInfo.screenOrientation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mBase.callActivityOnCreate(activity, icicle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码主要是将Activity中的Resource，Context等对象替换成了插件的相应对象，保证插件Activity在调用涉及到Context的方法时能够正确运行。</p><p>经过上述步骤后，便实现了插件Activity的启动，并且该插件Activity中并不需要什么额外的处理，和常规的Activity一样。那问题来了，之后的onResume，onStop等生命周期怎么办呢？答案是所有和Activity相关的生命周期函数，系统都会调用插件中的Activity。原因在于AMS在处理Activity时，通过一个token表示具体Activity对象，而这个token正是和启动Activity时创建的对象对应的，而这个Activity被我们替换成了插件中的Activity，所以之后AMS的所有调用都会传给插件中的Activity。</p><h4 id="其他组件"><a href="#其他组件" class="headerlink" title="其他组件"></a>其他组件</h4><p>四大组件中Activity的支持是最复杂的，其他组件的实现原理要简单很多，简要概括如下：</p><ul><li>Service：Service和Activity的差别在于，Activity的生命周期是由用户交互决定的，而Service的生命周期是我们通过代码主动调用的，且Service实例和manifest中注册的是一一对应的。实现Service插件化的思路是通过在manifest中预埋StubService，hook系统startService等调用替换启动的Service，之后在StubService中创建插件Service，并手动管理其生命周期。</li><li>BroadCastReceiver：解析插件的manifest，将静态注册的广播转为动态注册。</li><li>ContentProvider：类似于Service的方式，对插件ContentProvider的所有调用都会通过一个在manifest中占坑的ContentProvider分发。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>VirtualAPK通过替换了系统的Instrumentation，hook了Activity的启动和创建，省去了手动管理插件Activity生命周期的繁琐，让插件Activity像正常的Activity一样被系统管理，并且插件Activity在开发时和常规一样，即能独立运行又能作为插件被主工程调用。</p><p>其他<strong>插件框架在处理Activity时思想大都差不多，无非是这两种方式之一或者两者的结合。在hook时，不同的框架可能会选择不同的hook点。</strong>如360的RePlugin框架选择hook了系统的ClassLoader，即图2中构造Activity2的ClassLoader，在判断出待启动的Activity是插件中的时，会调用插件的ClassLoader构造相应对象。另外RePlugin为了系统稳定性，选择了尽量少的hook，因此它并没有选择hook系统的startActivity方法来替换intent，而是通过重写Activity的startActivity，因此其插件Activity是需要继承一个类似PluginActivity的基类的。不过RePlugin提供了一个Gradle插件将插件中的Activity的基类换成了PluginActivity，用户在开发插件Activity时也是没有感知的。</p><h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><p>资源加载方案大家使用的原理都差不多，<strong>都是用AssetManager的隐藏方法addAssetPath</strong>；但是，不同插件的资源如何管理？是公用一套资源还是插件独立资源？共用资源如何避免资源冲突？对于资源加载，有的方案共用一套资源并采用资源分段机制解决冲突（要么修改aapt要么添加编译插件）；有的方案选择独立资源，不同插件管理自己的资源。</p><p>Android系统通过Resource对象加载资源，下面代码展示了该对象的生成过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//创建AssetManager对象 </span><br><span class="line">AssetManager assets = new AssetManager();</span><br><span class="line"> //将apk路径添加到AssetManager中</span><br><span class="line">  if (assets.addAssetPath(resDir) == 0)&#123;              </span><br><span class="line">    return null;  </span><br><span class="line">&#125;</span><br><span class="line"> //创建Resource对象</span><br><span class="line">r = new Resources(assets, metrics, getConfiguration(), compInfo);</span><br></pre></td></tr></table></figure></p><p>因此，只要将插件apk的路径加入到AssetManager中，便能够实现对插件资源的访问。具体实现时，由于AssetManager并不是一个public的类，需要通过反射去创建，并且部分Rom对创建的Resource类进行了修改，所以需要考虑不同Rom的兼容性。</p><h3 id="资源路径的处理"><a href="#资源路径的处理" class="headerlink" title="资源路径的处理"></a>资源路径的处理</h3><p>和代码加载相似，插件和主工程的资源关系也有两种处理方式：<br>合并式：addAssetPath时加入所有插件和主工程的路径；<br>独立式：各个插件只添加自己apk路径</p><table><thead><tr><th>方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>合并式</td><td>插件和主工程能够直接相互访问资源</td><td>会引入资源冲突</td></tr><tr><td>独立式</td><td>资源隔离，不存在资源冲突</td><td>资源共享比较麻烦</td></tr></tbody></table><p>合并式由于AssetManager中加入了所有插件和主工程的路径，因此生成的Resource可以同时访问插件和主工程的资源。但是由于主工程和各个插件都是独立编译的，生成的资源id会存在相同的情况，在访问时会产生资源冲突。</p><p>独立式时，各个插件的资源是互相隔离的，不过如果想要实现资源的共享，必须拿到对应的Resource对象。</p><h3 id="解决资源冲突"><a href="#解决资源冲突" class="headerlink" title="解决资源冲突"></a>解决资源冲突</h3><p>合并式的资源处理方式，会引入资源冲突，原因在于不同插件中的资源id可能相同，所以解决方法就是使得不同的插件资源拥有不同的资源id。</p><p>资源id是由8位16进制数表示，表示为0xPPTTNNNN。PP段用来区分包空间，默认只区分了应用资源和系统资源，TT段为资源类型，NNNN段在同一个APK中从0000递增。</p><p>所以思路是修改资源ID的PP段，对于不同的插件使用不同的PP段，从而区分不同插件的资源。具体实现方式有两种：<br>1.修改aapt源码，编译期修改PP段。<br>2.修改resources.arsc文件，该文件列出了资源id到具体资源路径的映射。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>apk被安装之后，apk的文件代码以及资源会被系统存放在固定的目录比如/data/app/package_name/xxx.apk)中，系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类。</p><p>但是要知道插件apk是不会被安装的，那么系统也就不会讲我们的代理及资源存在在这个目录下，换句话说系统并不知道我们插件apk中的任何信息，也就根本不可能加载我们插件中的类。我们之前分析过应用的启动过程，其实就是启动了我们的主Activity，然后在ActivityThread的performLaunchActivity方法中创建的Activity对象并回调了attch和onCreate方法。系统通过待启动的Activity的类名className，然后使用ClassLoader对象cl把这个类加载，最后使用反射创建了这个Activity类的实例对象。</p><p>有两种实现方法：</p><ol><li><p>首先如果我们想要加载我们的插件apk我们需要一个Classloader，那么我们知道系统的Classloader是通过LoadedApk对象获得的，而如果我们想要加载我们自己的插件apk，就需要我们自己构建一个LoadedApk对象，然后修改其中的Classloader对象，因为系统的并不知道我们的插件apk的信息，所有我们就要<strong>创建自己的ClassLoader对象</strong>，然后全盘接管加载的过程，然后通过hook的思想将我们构建的这个LoadedApk对象存入那个叫mPackages的map中，这样的话每次在获取LoadedApk对象时就可以在map中得到了。然后在到创建Activity的时候得到的Classloader对象就是我们自己改造过的cl了，这样就可以加载我们的外部插件了。这种方案需要我们hook掉系统系统的n多个类或者方法，因为创建LoadedApk对象时还需要一个ApplicationInfo的对象，这个对象就是解析AndroidManifest清单得来的，所以还需要我们自己手动解析插件中的AndroidManifest清单，这个过程及其复杂，不过360的DroidPlugin就使用了这种方法。</p></li><li><p>既然我们知道如果想启动插件apk就需一个Classloader，那么我们换一种想法，能不能我们将我们的插件apk的信息告诉系统的这个Classloader，然后<strong>让系统的Classloader来帮我们加载及创建</strong>呢？答案是肯定，之前我们说过讲过android中的Classloader主要分析PathClassLoader和DexClassLoader，系统通过PathClassLoader来加载系统类和主dex中的类。而DexClassLoader则用于加载其他dex文件中的类。他们都是继承自BaseDexClassLoader。（如果没有看过的建议先看看：<a href="https://zhaoshuming.github.io/2019/05/10/android-dex/" target="_blank" rel="noopener">类加载器ClassLoader及Dex/Class</a>）</p></li></ol><p>回顾一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//这个类中维护这一个dexElements的数组，在findClass的时候会遍历数组来查找</span><br><span class="line">public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123;</span><br><span class="line">   for (Element element : dexElements) &#123;</span><br><span class="line">       DexFile dex = element.dexFile;</span><br><span class="line"></span><br><span class="line">       if (dex != null) &#123;</span><br><span class="line">           Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);</span><br><span class="line">           if (clazz != null) &#123;</span><br><span class="line">               return clazz;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   if (dexElementsSuppressedExceptions != null) &#123;</span><br><span class="line">       suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">   &#125;</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类在被加载的时候是通过BaseDexClassLoader的findClass的方法，其实最终调用了DexPathList类的findClass，DexPathList类中维护着dexElements的数组，这个数组就是存放我们dex文件的数组，我们只要想办法<strong>将我们插件apk的dex文件插入到这个dexElements中系统就可以知道我们的插件apk信息了</strong>，也自然就可以帮我们加载并创建对应的类。但是到这里还有一个问题，那就是<strong>Activity必须要在AndroidManifest注册才行</strong>，这个检查过程是在系统底层的，我们无法干涉，可是我们的插件apk是动态灵活的，宿主中并不固定的写死注册哪几个Activity，如果写死也就失去了插件的动态灵活性。</p><p>但是我们可以换一种方式，我们使用hook思想代理startActivity这个方法，使用<strong>占坑</strong>的方式，也就是说我们可以提前在AndroidManifest中固定写死一个Activity，这个Activity只不过是一个傀儡，我们在启动我们插件apk的时候使用它去系统层校检合法性，然后等真正创建Activity的时候再通过hook思想拦截Activity的创建方法，提前将信息更换回来创建真正的插件apk。</p><p>总结下分析结果：</p><pre><code>1.startActivity的时候最终会走到AMS的startActivity方法2.系统会检查一堆的信息验证这个Activity是否合法3.然后会回调ActivityThread的Handler里的 handleLaunchActivity4.在这里走到了performLaunchActivity方法去创建Activity并回调一系列生命周期的方法5.创建Activity的时候会创建一个LoaderApk对象，然后使用这个对象的getClassLoader来创建Activity6.我们查看getClassLoader()方法发现返回的是PathClassLoader，然后他继承自BaseDexClassLoader7.然后我们查看BaseDexClassLoader发现他创建时创建了一个DexPathList类型的pathList对象，然后在findClass时调用了pathList.findClass的方法8.然后我们查看DexPathList类中的findClass发现他内部维护了一个Element[] dexElements的dex数组，findClass时是从数组中遍历查找的</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yulong0809/article/details/59113935" target="_blank" rel="noopener">https://blog.csdn.net/yulong0809/article/details/59113935</a><br><a href="https://yq.aliyun.com/articles/361233?utm_content=m_40296" target="_blank" rel="noopener">深入理解Android插件化技术</a></p>]]></content>
      
      
      <categories>
          
          <category> Android插件化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/2019/11/04/design-mode-memento/"/>
      <url>/2019/11/04/design-mode-memento/</url>
      
        <content type="html"><![CDATA[<p>　　备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类，结构图如下：</p><p><img src="/2019/11/04/design-mode-memento/memento.jpg" alt></p><p>备忘录模式的主要角色如下:<br>1、发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。<br>2、备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。<br>3、管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p><p>2、需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>备忘录模式是一种对象行为型模式，其主要优点如下：<br>　● 提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。<br>　● 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。<br>　● 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</p><p>其主要缺点是：<br>　● 资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">//备忘录</span><br><span class="line">class Memento</span><br><span class="line">&#123; </span><br><span class="line">    private String state; </span><br><span class="line">    public Memento(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;     </span><br><span class="line">    public void setState(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    public String getState()</span><br><span class="line">    &#123; </span><br><span class="line">        return state; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发起人</span><br><span class="line">class Originator</span><br><span class="line">&#123; </span><br><span class="line">    private String state;     </span><br><span class="line">    public void setState(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    public String getState()</span><br><span class="line">    &#123; </span><br><span class="line">        return state; </span><br><span class="line">    &#125;</span><br><span class="line">    public Memento createMemento()</span><br><span class="line">    &#123; </span><br><span class="line">        return new Memento(state); </span><br><span class="line">    &#125; </span><br><span class="line">    public void restoreMemento(Memento m)</span><br><span class="line">    &#123; </span><br><span class="line">        this.setState(m.getState()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//管理者</span><br><span class="line">class Caretaker</span><br><span class="line">&#123; </span><br><span class="line">    private Memento memento;       </span><br><span class="line">    public void setMemento(Memento m)</span><br><span class="line">    &#123; </span><br><span class="line">        memento=m; </span><br><span class="line">    &#125;</span><br><span class="line">    public Memento getMemento()</span><br><span class="line">    &#123; </span><br><span class="line">        return memento; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Client</span><br><span class="line">public class MementoPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Originator or=new Originator();</span><br><span class="line">        Caretaker cr=new Caretaker();       </span><br><span class="line">        or.setState(&quot;S0&quot;); </span><br><span class="line">        System.out.println(&quot;初始状态:&quot;+or.getState());           </span><br><span class="line">        cr.setMemento(or.createMemento()); //保存状态      </span><br><span class="line">        or.setState(&quot;S1&quot;); </span><br><span class="line">        System.out.println(&quot;新的状态:&quot;+or.getState());        </span><br><span class="line">        or.restoreMemento(cr.getMemento()); //恢复状态</span><br><span class="line">        System.out.println(&quot;恢复状态:&quot;+or.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//程序运行的结果如下：</span><br><span class="line">初始状态:S0</span><br><span class="line">新的状态:S1</span><br><span class="line">恢复状态:S0</span><br></pre></td></tr></table></figure><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>下面介绍备忘录模式如何同原型模式混合使用。在备忘录模式中，通过定义“备忘录”来备份“发起人”的信息，而原型模式的 clone() 方法具有自备份功能，所以，如果让发起人实现 Cloneable 接口就有备份自己的功能，这时<strong>可以删除备忘录类</strong>，其结构图如下所示：</p><p><img src="/2019/11/04/design-mode-memento/single-memento.jpg" alt></p><p>代码实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//发起人原型</span><br><span class="line">class OriginatorPrototype  implements Cloneable</span><br><span class="line">&#123; </span><br><span class="line">    private String state;     </span><br><span class="line">    public void setState(String state)</span><br><span class="line">    &#123; </span><br><span class="line">        this.state=state; </span><br><span class="line">    &#125;</span><br><span class="line">    public String getState()</span><br><span class="line">    &#123; </span><br><span class="line">        return state; </span><br><span class="line">    &#125;</span><br><span class="line">    public OriginatorPrototype createMemento()</span><br><span class="line">    &#123; </span><br><span class="line">        return this.clone(); </span><br><span class="line">    &#125; </span><br><span class="line">    public void restoreMemento(OriginatorPrototype opt)</span><br><span class="line">    &#123; </span><br><span class="line">        this.setState(opt.getState()); </span><br><span class="line">    &#125;</span><br><span class="line">    public OriginatorPrototype clone()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            return (OriginatorPrototype) super.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        catch(CloneNotSupportedException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//原型管理者</span><br><span class="line">class PrototypeCaretaker</span><br><span class="line">&#123; </span><br><span class="line">    private OriginatorPrototype opt;       </span><br><span class="line">    public void setMemento(OriginatorPrototype opt)</span><br><span class="line">    &#123; </span><br><span class="line">        this.opt=opt; </span><br><span class="line">    &#125;</span><br><span class="line">    public OriginatorPrototype getMemento()</span><br><span class="line">    &#123; </span><br><span class="line">        return opt; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Client</span><br><span class="line">public class PrototypeMemento</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        OriginatorPrototype or=new OriginatorPrototype();</span><br><span class="line">        PrototypeCaretaker cr=new PrototypeCaretaker();       </span><br><span class="line">        or.setState(&quot;S0&quot;); </span><br><span class="line">        System.out.println(&quot;初始状态:&quot;+or.getState());           </span><br><span class="line">        cr.setMemento(or.createMemento()); //保存状态      </span><br><span class="line">        or.setState(&quot;S1&quot;); </span><br><span class="line">        System.out.println(&quot;新的状态:&quot;+or.getState());        </span><br><span class="line">        or.restoreMemento(cr.getMemento()); //恢复状态</span><br><span class="line">        System.out.println(&quot;恢复状态:&quot;+or.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外，还可以和命令模式组合使用：<br>命令模式实现中，在实现命令的撤销和重做的时候，可以使用备忘录模式，在命令操作的时候记录下操作前后的状态，然后在命令撤销和重做的时候，直接使用相应的备忘录对象来恢复状态就可以了。<br>在这种撤销的执行顺序和重做执行顺序可控的情况下，备忘录对象还可以采用增量式记录的方式，可以减少缓存的数据量。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2019/11/04/design-mode-observer/"/>
      <url>/2019/11/04/design-mode-observer/</url>
      
        <content type="html"><![CDATA[<p>　　观察者（Observer）模式的定义：指<strong>多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。</p><p><img src="/2019/11/04/design-mode-observer/observer.jpg" alt title="观察者结构图"></p><p>观察者模式的主要角色如下：</p><p>1、抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</p><p>2、具体主题（Concrete    Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</p><p>3、抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</p><p>4、具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</p><p>2、当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>观察者模式是一种对象行为型模式，其主要优点如下：<br>1、降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。<br>2、目标与观察者之间建立了一套触发机制。</p><p>它的主要缺点如下：<br>1、目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。<br>2、当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//抽象目标</span><br><span class="line">abstract class Subject</span><br><span class="line">&#123;</span><br><span class="line">    protected List&lt;Observer&gt; observers=new ArrayList&lt;Observer&gt;();   </span><br><span class="line">    //增加观察者方法</span><br><span class="line">    public void add(Observer observer)</span><br><span class="line">    &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;    </span><br><span class="line">    //删除观察者方法</span><br><span class="line">    public void remove(Observer observer)</span><br><span class="line">    &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;   </span><br><span class="line">    public abstract void notifyObserver(); //通知观察者方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体目标</span><br><span class="line">class ConcreteSubject extends Subject</span><br><span class="line">&#123;</span><br><span class="line">    public void notifyObserver()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体目标发生改变...&quot;);</span><br><span class="line">        System.out.println(&quot;--------------&quot;);       </span><br><span class="line">       </span><br><span class="line">        for(Object obs:observers)</span><br><span class="line">        &#123;</span><br><span class="line">            ((Observer)obs).response();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象观察者</span><br><span class="line">interface Observer</span><br><span class="line">&#123;</span><br><span class="line">    void response(); //反应</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体观察者1</span><br><span class="line">class ConcreteObserver1 implements Observer</span><br><span class="line">&#123;</span><br><span class="line">    public void response()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体观察者1作出反应！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//具体观察者2</span><br><span class="line">class ConcreteObserver2 implements Observer</span><br><span class="line">&#123;</span><br><span class="line">    public void response()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体观察者2作出反应！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Client</span><br><span class="line">public class ObserverPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Subject subject=new ConcreteSubject();</span><br><span class="line">        Observer obs1=new ConcreteObserver1();</span><br><span class="line">        Observer obs2=new ConcreteObserver2();</span><br><span class="line">        subject.add(obs1);</span><br><span class="line">        subject.add(obs2);</span><br><span class="line">        subject.notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2019/11/04/design-mode-command/"/>
      <url>/2019/11/04/design-mode-command/</url>
      
        <content type="html"><![CDATA[<p>命令（Command）模式的定义如下：<strong>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开</strong>。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p><p>优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。 3、可以比较容易地设计一个组合命令(宏命令)。</p><p>缺点：使用命令模式可能会导致某些系统有过多的具体命令类。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>1.命令的发送者和命令执行者有不同的生命周期。命令发送了并不是立即执行。<br>2.命令需要进行各种管理逻辑（当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能）。<br>3.需要支持撤消\重做操作，可以将命令对象存储起来，采用备忘录模式来实现。</p><h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。</p><p>每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p><p><img src="/2019/11/04/design-mode-command/command.png" alt title="结构图"></p><p>命令模式涉及到五个角色，它们分别是：<br>1、客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。<br>2、命令(Command)角色：声明了一个给所有具体命令类的抽象接口。<br>3、具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。<br>4、请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。<br>5、接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">//接收者角色类</span><br><span class="line">public class Receiver &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 真正执行命令相应的操作</span><br><span class="line">     */</span><br><span class="line">    public void action()&#123;</span><br><span class="line">        System.out.println(&quot;执行操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象命令角色类</span><br><span class="line">public interface Command &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 执行方法</span><br><span class="line">     */</span><br><span class="line">    void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体命令角色类</span><br><span class="line">public class ConcreteCommand implements Command &#123;</span><br><span class="line">    //持有相应的接收者对象</span><br><span class="line">    private Receiver receiver = null;</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     */</span><br><span class="line">    public ConcreteCommand(Receiver receiver)&#123;</span><br><span class="line">        this.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        //通常会转调接收者对象的相应方法，让接收者来真正执行功能</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//请求者角色类</span><br><span class="line">public class Invoker &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 持有命令对象</span><br><span class="line">     */</span><br><span class="line">    private Command command = null;</span><br><span class="line">    /**</span><br><span class="line">     * 构造方法</span><br><span class="line">     */</span><br><span class="line">    public Invoker(Command command)&#123;</span><br><span class="line">        this.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 行动方法</span><br><span class="line">     */</span><br><span class="line">    public void action()&#123;</span><br><span class="line">        </span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户端角色类</span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建接收者</span><br><span class="line">        Receiver receiver = new Receiver();</span><br><span class="line">        //创建命令对象，设定它的接收者</span><br><span class="line">        Command command = new ConcreteCommand(receiver);</span><br><span class="line">        //创建请求者，把命令对象设置进去</span><br><span class="line">        Invoker invoker = new Invoker(command);</span><br><span class="line">        //执行方法</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="组合命令模式"><a href="#组合命令模式" class="headerlink" title="组合命令模式"></a>组合命令模式</h2><p>在软件开发中，有时<strong>将命令模式与组合模式联合使用，这就构成了宏命令模式</strong>，也叫组合命令模式。宏命令包含了一组命令，它充当了具体命令与调用者的双重角色，执行它时将递归调用它所包含的所有命令，其具体结构图如图：</p><p><img src="/2019/11/04/design-mode-command/composite-command.jpg" alt></p><p>程序代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//抽象命令</span><br><span class="line">interface AbstractCommand</span><br><span class="line">&#123;</span><br><span class="line">    public abstract void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//树叶构件: 具体命令1</span><br><span class="line">class ConcreteCommand1 implements AbstractCommand</span><br><span class="line">&#123;</span><br><span class="line">    private CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand1()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver=new CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    public void execute()</span><br><span class="line">    &#123;       </span><br><span class="line">        receiver.action1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//树叶构件: 具体命令2</span><br><span class="line">class ConcreteCommand2 implements AbstractCommand</span><br><span class="line">&#123;</span><br><span class="line">    private CompositeReceiver receiver;</span><br><span class="line">    ConcreteCommand2()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver=new CompositeReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">    public void execute()</span><br><span class="line">    &#123;       </span><br><span class="line">        receiver.action2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//树枝构件: 调用者</span><br><span class="line">class CompositeInvoker implements AbstractCommand</span><br><span class="line">&#123;</span><br><span class="line">    private ArrayList&lt;AbstractCommand&gt; children = new ArrayList&lt;AbstractCommand&gt;();   </span><br><span class="line">    public void add(AbstractCommand c)</span><br><span class="line">    &#123;</span><br><span class="line">        children.add(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void remove(AbstractCommand c)</span><br><span class="line">    &#123;</span><br><span class="line">        children.remove(c);</span><br><span class="line">    &#125;   </span><br><span class="line">    public AbstractCommand getChild(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        return children.get(i);</span><br><span class="line">    &#125;   </span><br><span class="line">    public void execute()</span><br><span class="line">    &#123;</span><br><span class="line">        for(Object obj:children)</span><br><span class="line">        &#123;</span><br><span class="line">            ((AbstractCommand)obj).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//接收者</span><br><span class="line">class CompositeReceiver</span><br><span class="line">&#123;</span><br><span class="line">    public void action1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;接收者的action1()方法被调用...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void action2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;接收者的action2()方法被调用...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Client</span><br><span class="line">public class CompositeCommandPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        AbstractCommand cmd1=new ConcreteCommand1();</span><br><span class="line">        AbstractCommand cmd2=new ConcreteCommand2();</span><br><span class="line">        CompositeInvoker ir=new CompositeInvoker();</span><br><span class="line">        ir.add(cmd1);</span><br><span class="line">        ir.add(cmd2);</span><br><span class="line">        System.out.println(&quot;客户访问调用者的execute()方法...&quot;);</span><br><span class="line">        ir.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果如下：</span><br><span class="line">客户访问调用者的execute()方法...</span><br><span class="line">接收者的action1()方法被调用...</span><br><span class="line">接收者的action2()方法被调用...</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解释器模式</title>
      <link href="/2019/10/30/design-mode-interpreter/"/>
      <url>/2019/10/30/design-mode-interpreter/</url>
      
        <content type="html"><![CDATA[<p>　　解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>解释器模式包含以下主要角色：<br>1、抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。<br>2、终结符表达式（Terminal    Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。<br>3、非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。<br>4、环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。<br>5、客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的<strong>抽象语法树</strong>，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p><p><img src="/2019/10/30/design-mode-interpreter/interpreter.jpg" alt title="解释器模式结构图"></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、当语言的文法较为简单，且执行效率不是关键问题时。<br>2、当问题重复出现，且可以用一种简单的语言来进行表达时。<br>3、当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>解释器模式是一种类行为型模式，其主要优点如下：<br>1、扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。<br>2、容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</p><p>解释器模式的主要缺点如下：<br>1、执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。<br>2、会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。<br>3、可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">public interface Expression &#123;</span><br><span class="line">   public boolean interpret(String context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TerminalExpression implements Expression &#123;</span><br><span class="line">   </span><br><span class="line">   private String data;</span><br><span class="line"> </span><br><span class="line">   public TerminalExpression(String data)&#123;</span><br><span class="line">      this.data = data; </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public boolean interpret(String context) &#123;</span><br><span class="line">      if(context.contains(data))&#123;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OrExpression implements Expression &#123;</span><br><span class="line">    </span><br><span class="line">   private Expression expr1 = null;</span><br><span class="line">   private Expression expr2 = null;</span><br><span class="line"> </span><br><span class="line">   public OrExpression(Expression expr1, Expression expr2) &#123; </span><br><span class="line">      this.expr1 = expr1;</span><br><span class="line">      this.expr2 = expr2;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public boolean interpret(String context) &#123;      </span><br><span class="line">      return expr1.interpret(context) || expr2.interpret(context);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AndExpression implements Expression &#123;</span><br><span class="line">    </span><br><span class="line">   private Expression expr1 = null;</span><br><span class="line">   private Expression expr2 = null;</span><br><span class="line"> </span><br><span class="line">   public AndExpression(Expression expr1, Expression expr2) &#123; </span><br><span class="line">      this.expr1 = expr1;</span><br><span class="line">      this.expr2 = expr2;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public boolean interpret(String context) &#123;      </span><br><span class="line">      return expr1.interpret(context) &amp;&amp; expr2.interpret(context);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterpreterPatternDemo &#123;</span><br><span class="line"> </span><br><span class="line">   //规则：Robert 和 John 是男性</span><br><span class="line">   public static Expression getMaleExpression()&#123;</span><br><span class="line">      Expression robert = new TerminalExpression(&quot;Robert&quot;);</span><br><span class="line">      Expression john = new TerminalExpression(&quot;John&quot;);</span><br><span class="line">      return new OrExpression(robert, john);    </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   //规则：Julie 是一个已婚的女性</span><br><span class="line">   public static Expression getMarriedWomanExpression()&#123;</span><br><span class="line">      Expression julie = new TerminalExpression(&quot;Julie&quot;);</span><br><span class="line">      Expression married = new TerminalExpression(&quot;Married&quot;);</span><br><span class="line">      return new AndExpression(julie, married);    </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Expression isMale = getMaleExpression();</span><br><span class="line">      Expression isMarriedWoman = getMarriedWomanExpression();</span><br><span class="line"> </span><br><span class="line">      System.out.println(&quot;John is male? &quot; + isMale.interpret(&quot;John&quot;));</span><br><span class="line">      System.out.println(&quot;Julie is a married women? &quot; </span><br><span class="line">      + isMarriedWoman.interpret(&quot;Married Julie&quot;));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/2019/10/28/design-mode-cor/"/>
      <url>/2019/10/28/design-mode-cor/</url>
      
        <content type="html"><![CDATA[<p>　　责任链（Chain of Responsibility）是一种对象的行为模式：很多对象由每一个对象对其下家的引用而连接起来形成一条链，请求在这个链上传递，直到链上的某一个对象决定处理此请求；发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>在责任链模式中，<strong>客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程</strong>，所以责任链将请求的发送者和请求的处理者解耦了。</p><p><img src="/2019/10/28/design-mode-cor/chain.jpg" alt></p><p>职责链模式主要包含以下角色:<br>1.抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。<br>2.具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。<br>3.客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1.有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。<br>2.可动态指定一组对象处理请求，或添加新的处理者。<br>3.在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>责任链模式是一种对象行为型模式，其主要优点如下：<br>1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。<br>2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。<br>3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。<br>4.责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。<br>5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p><p>其主要缺点如下：<br>1.不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。<br>2.对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。<br>3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</p><h2 id="纯与不纯"><a href="#纯与不纯" class="headerlink" title="纯与不纯"></a>纯与不纯</h2><p>职责链模式存在以下两种情况：<br>1.纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。<br>2.不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。<br>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class ChainOfResponsibilityPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        //组装责任链 </span><br><span class="line">        Handler handler1=new ConcreteHandler1(); </span><br><span class="line">        Handler handler2=new ConcreteHandler2(); </span><br><span class="line">        handler1.setNext(handler2); </span><br><span class="line">        //提交请求 </span><br><span class="line">        handler1.handleRequest(&quot;two&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象处理者角色</span><br><span class="line">abstract class Handler</span><br><span class="line">&#123;</span><br><span class="line">    private Handler next;</span><br><span class="line">    public void setNext(Handler next)</span><br><span class="line">    &#123;</span><br><span class="line">        this.next=next; </span><br><span class="line">    &#125;</span><br><span class="line">    public Handler getNext()</span><br><span class="line">    &#123; </span><br><span class="line">        return next; </span><br><span class="line">    &#125;   </span><br><span class="line">    //处理请求的方法</span><br><span class="line">    public abstract void handleRequest(String request);       </span><br><span class="line">&#125;</span><br><span class="line">//具体处理者角色1</span><br><span class="line">class ConcreteHandler1 extends Handler</span><br><span class="line">&#123;</span><br><span class="line">    public void handleRequest(String request)</span><br><span class="line">    &#123;</span><br><span class="line">        if(request.equals(&quot;one&quot;)) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;具体处理者1负责处理该请求！&quot;);       </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(getNext()!=null) </span><br><span class="line">            &#123;</span><br><span class="line">                getNext().handleRequest(request);             </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;没有人处理该请求！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">//具体处理者角色2</span><br><span class="line">class ConcreteHandler2 extends Handler</span><br><span class="line">&#123;</span><br><span class="line">    public void handleRequest(String request)</span><br><span class="line">    &#123;</span><br><span class="line">        if(request.equals(&quot;two&quot;)) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;具体处理者2负责处理该请求！&quot;);       </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if(getNext()!=null) </span><br><span class="line">            &#123;</span><br><span class="line">                getNext().handleRequest(request);             </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(&quot;没有人处理该请求！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/2019/10/28/design-mode-state/"/>
      <url>/2019/10/28/design-mode-state/</url>
      
        <content type="html"><![CDATA[<p>状态模式定义：对象行为的变化是由于状态的变化引入，那么即当内部状态发生变化的时候，就会改变对象的行为，而这种改变视乎就改变了整个类。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>很多人在说状态模式的时候总拿策略模式来进行对比，可能他们的类图会有一点类似。最根本的差异在于策略模式是在求解同一个问题的多种解法，这些不同解法之间毫无关联；状态模式则不同，<strong>状态模式要求各个状态之间有所关联，以便实现状态转移</strong>。</p><p><img src="/2019/10/28/design-mode-state/state.png" alt></p><p>1、Context<br>  定义客户感兴趣的接口。维护一个ConcreteState子类的实例，这个实例定义当前状态。<br>2、State<br>  定义一个接口以封装与Context的一个特定状态相关的行为。<br>3、ConcreteStatesubclasses<br>   每一子类实现一个与Context的一个状态相关的行为。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为。<br>2、一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。 这个状态通常用一个或多个枚举常量表示。通常,有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况<strong>将对象的状态作为一个对象</strong>，这一对象可以不依赖于其他对象而独立变化。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：<br>1、降低程序的复杂度；<br>2、提高程序的可维护性；<br>3、状态机模式体现了开闭原则和单一职责原则。每个状态都是一个子类，增加状态就要增加子类；修改状态只要修改一个类就行了。</p><p>缺点：<br>使用状态机子类会增多，也就是类膨胀，这点需要程序员在开发中自己衡量。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>定义State<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义和Context中的状态相对应的行为</span><br><span class="line"> public interface State &#123;</span><br><span class="line">     //获取天气情况</span><br><span class="line">     String getState();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>定义ConcreteStatesubclasses<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Sunshine implements State&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String getState() &#123;</span><br><span class="line">         </span><br><span class="line">        return &quot;晴天&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">class Rain implements State&#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String getState() &#123;</span><br><span class="line">         </span><br><span class="line">        return &quot;下雨&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义Context<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//定义当前的状态</span><br><span class="line"> public class Context &#123;</span><br><span class="line">  </span><br><span class="line">    private State state;</span><br><span class="line">  </span><br><span class="line">    public State getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void setState(State state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    public String stateMessage()&#123;</span><br><span class="line">        return state.getState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StateTest &#123;</span><br><span class="line">  </span><br><span class="line">     public static void main(String args[])&#123;</span><br><span class="line">         Context context=new Context();</span><br><span class="line">         context.setState(new Rain());</span><br><span class="line"> </span><br><span class="line">         System.out.println(context.stateMessage());</span><br><span class="line"> </span><br><span class="line">         context.setState(new Sunshine());</span><br><span class="line">         System.out.println(context.stateMessage());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="和策略模式的区别和联系"><a href="#和策略模式的区别和联系" class="headerlink" title="和策略模式的区别和联系"></a>和策略模式的区别和联系</h2><p>区别：<br>状态模式将各个状态所对应的操作分离开来，即对于不同的状态，由不同的子类实现具体操作，不同状态的切换由子类实现，当发现传入参数不是自己这个状态所对应的参数，则自己给Context类切换状态；而策略模式是直接依赖注入到Context类的参数进行选择策略，不存在切换状态的操作联系。</p><p>联系：<br>状态模式和策略模式都是为具有多种可能情形设计的模式，把不同的处理情形抽象为一个相同的接口，符合对扩展开放，对修改封闭的原则。还有就是，<strong>策略模式更具有一般性一些</strong>，在实践中，可以用策略模式来封装几乎任何类型的规则，只要在分析过程中听到需要在不同实践应用不同的业务规则，就可以考虑使用策略模式处理，在这点上策略模式是包含状态模式的功能的，策略模式是一个重要的设计模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2019/10/28/design-mode-strategy/"/>
      <url>/2019/10/28/design-mode-strategy/</url>
      
        <content type="html"><![CDATA[<p>策略模式（Strategy Pattern），将各种算法封装到具体的类中，作为一个抽象策略类的子类，使得它们可以互换。客户端可以自行决定使用哪种算法。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>策略模式是<strong>对算法的包装</strong>，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“<strong>准备一组算法，并将每一个算法封装起来，使得它们可以互换</strong>”。下面就以一个示意性的实现讲解策略模式实例的结构。</p><p><img src="/2019/10/28/design-mode-strategy/strategy.png" alt></p><p>这个模式涉及到三个角色：<br>　　●　环境(Context)角色：持有一个Strategy的引用。<br>　　●　抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。<br>　　●　具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。</p><h2 id="认识策略模式"><a href="#认识策略模式" class="headerlink" title="认识策略模式"></a>认识策略模式</h2><p>1、策略模式的重心<br>　　策略模式的重心不是如何实现算法，而是<strong>如何组织、调用这些算法</strong>，从而让程序结构更灵活，具有更好的维护性和扩展性。</p><p>2、算法的平等性<br>　　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。<br>　　所以可以这样描述这一系列策略算法：<strong>策略算法是相同行为的不同实现</strong>。</p><p>3、运行时策略的唯一性<br>　　运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p><p>4、公有的行为<br>　　经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。<br>　　这其实也是典型的将代码向继承等级结构的上方集中的标准做法。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>　　（1）策略模式<strong>提供了管理相关的算法族的办法</strong>。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。<br>　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。<br>　　（3）策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法（策略），并且可以灵活地增加新的算法（策略）。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。<br>　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>环境角色类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    //持有一个具体策略的对象</span><br><span class="line">    private Strategy strategy;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构造函数，传入一个具体策略对象</span><br><span class="line">     * @param strategy    具体策略对象</span><br><span class="line">     */</span><br><span class="line">    public Context(Strategy strategy)&#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 策略方法</span><br><span class="line">     */</span><br><span class="line">    public void contextInterface()&#123;</span><br><span class="line">        </span><br><span class="line">        strategy.strategyInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象策略类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 策略方法</span><br><span class="line">     */</span><br><span class="line">    public void strategyInterface();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体策略类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteStrategyA implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void strategyInterface() &#123;</span><br><span class="line">        //相关的业务</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyB implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void strategyInterface() &#123;</span><br><span class="line">        //相关的业务</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategyC implements Strategy &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void strategyInterface() &#123;</span><br><span class="line">        //相关的业务</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端调用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleClient &#123;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">//选择并创建需要使用的策略对象</span><br><span class="line">    Strategy strategy = new ConcreteStrategyA();</span><br><span class="line">//创建环境</span><br><span class="line">    Context context = new Context(strategy);</span><br><span class="line">//执行</span><br><span class="line">    context.contextInterface();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的示例可以看出，策略模式仅仅封装算法，提供新的算法插入到已有系统中，以及老算法从系统中“退休”的方法，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。</p><h2 id="和工厂模式的区别"><a href="#和工厂模式的区别" class="headerlink" title="和工厂模式的区别"></a>和工厂模式的区别</h2><p>在模式结构上，两者很相似。</p><p>差异：<br>1.用途不一样<br>工厂是<strong>创建型模式</strong>,它的作用就是创建对象；<br>策略是<strong>行为型模式</strong>,它的作用是让一个对象在许多行为中选择一种行为;</p><p>2.关注点不一样<br>一个关注对象创建<br>一个关注行为的封装</p><p>3.解决不同的问题<br>工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；它主要解决的是资源的统一分发，将对象的创建完全独立出来，让对象的创建和具体的使用客户无关。主要应用在多数据库选择，类库文件加载等。<br>策略模式是为了解决的是策略的切换与扩展，更简洁的说是定义策略族，分别封装起来，让他们之间可以相互替换，策略模式让策略的变化独立于使用策略的客户。</p><p>4.工厂相当于黑盒子，策略相当于白盒子；</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三种工厂模式</title>
      <link href="/2019/10/23/design-mode-factory/"/>
      <url>/2019/10/23/design-mode-factory/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。</p><p><img src="/2019/10/23/design-mode-factory/factory.jpg" alt></p><p>工厂方法使一个类的<strong>实例化延迟到其子类</strong>。如图所示，Product抽象类负责定义产品的共性，实现对事物最抽象的定义，Creator为抽象工厂类，具体如何创建产品类由具体的实现工厂ConcreteCreator来完成。</p><h3 id="通用模板代码"><a href="#通用模板代码" class="headerlink" title="通用模板代码"></a>通用模板代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Product &#123;</span><br><span class="line"></span><br><span class="line">public void method() &#123; //产品类的公共方法，已经实现</span><br><span class="line">//实现了公共的逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void method2(); //非公共方法，需要子类具体实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类可以有多个，都继承与抽象类Product，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreateProduct1 extends Product &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void method2() &#123;</span><br><span class="line">//product1的业务逻辑</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ConcreateProduct2 extends Product &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void method2() &#123;</span><br><span class="line">//product2的业务逻辑</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象工厂类负责定义产品对象的产生，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Creator &#123;</span><br><span class="line">//创建一个产品对象，其输入参数类型可以自行设置</span><br><span class="line">public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里用的是泛型，传入的对象必须是Product抽象类的实现类。具体如何产生一个产品的对象，是由具体工厂类实现的，具体工厂类继承这个抽象工厂类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteCreator extends Creator &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">Product product = null;</span><br><span class="line">try &#123;</span><br><span class="line">product = (Product) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">&#125; catch (Exception e) &#123; //异常处理</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return (T) product;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这样的设计，我们就可以在测试类中随意生产产品了，看下面的测试类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryTest &#123;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Creator factory = new ConcreteCreator();</span><br><span class="line">Product product1 = factory.createProduct(ConcreteProduct1.class); //通过不同的类创建不同的产品</span><br><span class="line"> Product product2 = factory.createProduct(ConcreteProduct2.class);</span><br><span class="line"> /*</span><br><span class="line">  * 下面继续其他业务处理</span><br><span class="line">  */</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="多个工厂模式"><a href="#多个工厂模式" class="headerlink" title="多个工厂模式"></a>多个工厂模式</h3><p>每个具体的工厂都已经非常明确自己的职责：<strong>创建自己负责的产品类对象</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Creator &#123;</span><br><span class="line">public abstract Product createProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意抽象方法中已经不需要再传递相关类的参数了，因为每个具体的工厂都已经非常明确自己的职责：创建自己负责的产品类对象。所以不同的工厂实现自己的createProduct方法即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Concrete1Creator extends Creator &#123;</span><br><span class="line">public Product createProduct() &#123;</span><br><span class="line">return new ConcreteProduct1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Concrete2Creator extends Creator &#123;</span><br><span class="line">public Product createProduct() &#123;</span><br><span class="line">return new ConcreteProduct2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样多个不同的工厂就产生了，每个工厂对应只生产自己对应的产品，分工协作，各不影响了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Human blackMan = new ConcreteCreator1().createProduct(); </span><br><span class="line"> Human yellowMan = new ConcreteCreator2().createProduct();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种工厂模式的好处是职责清晰，结构简单，但是给扩扩展性和可维护性带来了一定的影响，因为如果要扩展一个产品类，就需要建立一个相应的工厂类，这样就增加了扩展的难度。因为工厂类和产品类的数量是相同的，维护时也需要考虑两个对象之间的关系。但是这种模式还是很常用的。</p><h3 id="替代单例模式"><a href="#替代单例模式" class="headerlink" title="替代单例模式"></a>替代单例模式</h3><p>可以使用静态工厂加反射实现单例模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonFactory &#123;</span><br><span class="line">private static Singleton instance;</span><br><span class="line">static &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Class clazz = Class.forName(Singleton.class.getName());</span><br><span class="line">//获取无参构造方法</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor();</span><br><span class="line">//设置无参构造方法可访问</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">//产生一个实例对象</span><br><span class="line">instance = (Singleton) constructor.newInstance();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">//异常处理</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static Singleton getInstance() &#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>1.工厂模式具有良好的封装性，代码结构清晰，也有利于扩展。在增加产品类的情况下，只需要适当地修改具体的工厂类或扩展一个工厂类，就可以完成“拥抱变化”。<br>2.工厂模式可以屏蔽产品类。这一点非常重要，产品类的实现如何变化，调用者都不用关系，只需要关心产品的接口，只要接口保持不变，系统的上层模块就不需要发生变化。<br>3.工厂模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心。</p><h2 id="简单-静态工厂模式"><a href="#简单-静态工厂模式" class="headerlink" title="简单/静态工厂模式"></a>简单/静态工厂模式</h2><p>如果<strong>只需要一个工厂</strong>就可以把Product生产出来，我干嘛要具体的工厂对象呢？只要使用静态方法就好了。这样一想，把Creator抽象类去掉了，只保留了ConcreteCreator类，同时把method2方法设置成了static类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteCreator &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public static &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">Product product = null;</span><br><span class="line">try &#123;</span><br><span class="line">product = (Product) Class.forName(clazz.getName()).newInstance();</span><br><span class="line">&#125; catch (Exception e) &#123; //异常处理</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return (T) product;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在实际项目中，根据需求可以设置成静态工厂类，但是缺点是扩展比较困难。如果就一个工厂，不需要扩展，可以这么设计，仍然是很常用的。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p><p><img src="/2019/10/23/design-mode-factory/factory-abstract.png" alt></p><h3 id="抽象工厂模式与工厂方法模式的区别"><a href="#抽象工厂模式与工厂方法模式的区别" class="headerlink" title="抽象工厂模式与工厂方法模式的区别"></a>抽象工厂模式与工厂方法模式的区别</h3><p>抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是<strong>针对的是多个产品等级结构</strong>。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而<strong>抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类</strong>。</p><p>在抽象工厂模式中，有一个<strong>产品族</strong>的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。此外还具有工厂方法模式的优点。</p><p>缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p>适用场景：<br>当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>cpu接口和实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface Cpu &#123;</span><br><span class="line">    void run();</span><br><span class="line"></span><br><span class="line">    class Cpu650 implements Cpu &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //625 也厉害</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Cpu825 implements Cpu &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            //825 处理更强劲</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>屏幕接口和实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public interface Screen &#123;</span><br><span class="line"></span><br><span class="line">    void size();</span><br><span class="line"></span><br><span class="line">    class Screen5 implements Screen &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void size() &#123;</span><br><span class="line">            //5寸</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Screen6 implements Screen &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void size() &#123;</span><br><span class="line">            //6寸</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>工厂接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface PhoneFactory &#123;</span><br><span class="line"></span><br><span class="line">    Cpu getCpu();//使用的cpu</span><br><span class="line"></span><br><span class="line">    Screen getScreen();//使用的屏幕</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体工厂实现类：小米手机工厂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class XiaoMiFactory implements PhoneFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Cpu getCpu() &#123;</span><br><span class="line">        return new Cpu.Cpu825();//高性能处理器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Screen getScreen() &#123;</span><br><span class="line">        return new Screen.Screen6();//6寸大屏</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体工厂实现类：红米手机工厂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HongMiFactory implements PhoneFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Cpu getCpu() &#123;</span><br><span class="line">        return new Cpu.Cpu650();//高效处理器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Screen getScreen() &#123;</span><br><span class="line">        return new Screen.Screen5();//小屏手机</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上例子可以看出，<strong>抽象工厂可以解决一系列的产品生产的需求</strong>，对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。</p><p>所以，在使用工厂模式时，只需要关心<strong>降低耦合度的目的</strong>是否达到了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/eson_15/article/details/51223124" target="_blank" rel="noopener">https://blog.csdn.net/eson_15/article/details/51223124</a><br><a href="https://www.jianshu.com/p/38493eb4ffbd" target="_blank" rel="noopener">https://www.jianshu.com/p/38493eb4ffbd</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法(Java实现)</title>
      <link href="/2019/10/21/ds-sort/"/>
      <url>/2019/10/21/ds-sort/</url>
      
        <content type="html"><![CDATA[<p>本文给出常见的十种常见排序算法的原理以及 Java 实现，按照是否比较可以分为两大类：</p><p>1、 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。<br>&emsp;&emsp;比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><p>2、 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。<br>&emsp;&emsp;计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。<br>&emsp;&emsp;非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决，算法时间复杂度 O(n) 。<br>&emsp;&emsp;非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置，所以对数据规模和数据分布有一定的要求。</p><p><img src="/2019/10/21/ds-sort/sort.png" alt title="排序算法"></p><p>相关概念：<br>1、稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br>2、不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。<br>3、时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br>4、空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>原理：<br>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。</p><p>步骤如下：<br>1、从第一个数据开始，与第二个数据相比较，如果第二个数据小于第一个数据，则交换两个数据的位置。<br>2、指针由第一个数据移向第二个数据，第二个数据与第三个数据相比较，如果第三个数据小于第二个数据，则交换两个数据的位置。<br>3、依此类推，完成第一轮排序。第一轮排序结束后，最大的元素被移到了最右面。<br>4、依照上面的过程进行第二轮排序，将第二大的排在倒数第二的位置。<br>5、重复上述过程，没排完一轮，比较次数就减少一次。</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort(int[] arr) &#123;</span><br><span class="line">    for(int i = 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for(int j = 0; j &lt; arr.length - 1 - i; j++) &#123;</span><br><span class="line">            if(arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+1];</span><br><span class="line">                arr[j+1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>原理：<br>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</p><p>步骤如下：<br>1、给定数组：int[] arr={里面n个数据}；<br>2、第1趟排序，在待排序数据arr[1]~arr[n]中选出最小的数据，将它与arr[1]交换；<br>3、第2趟，在待排序数据arr[2]~arr[n]中选出最小的数据，将它与arr[2]交换；<br>4、以此类推，第i趟在待排序数据arr[i]~arr[n]中选出最小的数据，将它与arr[i]交换，直到全部排序完成。</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0; i &lt; arr.length - 1; i++) &#123;// 做第i趟排序</span><br><span class="line">    int k = i;</span><br><span class="line">    for(int j = k + 1; j &lt; arr.length; j++)&#123;// 选最小的记录</span><br><span class="line">        if(arr[j] &lt; arr[k])&#123; </span><br><span class="line">            k = j; //记下目前找到的最小值所在的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换</span><br><span class="line">    if(i != k)&#123;  //交换a[i]和a[k]</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        arr[i] = arr[k];</span><br><span class="line">        arr[k] = temp;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>选择排序总结：<br>1、N个元素需要排序N-1轮；<br>2、第i轮需要比较N-i次；<br>3、N个元素排序，需要比较n（n-1）/2次；<br>4、选择排序的算法复杂度仍为O（n*n）；<br>5、相比于冒泡排序，选择排序的交换次数大大减少，因此速度要快于冒泡排序</p><h2 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h2><p>原理：<br>每次执行，把后面的数插入到前面已经排序好的数组中，直到最后一个完成。</p><p>详细步骤：<br>利用插入法对无序数组排序时，我们其实是将数组R划分成两个子区间R[1．．i-1]（已排好序的有序区）和R[i．．n]（当前未排序的部分，可称无序区）。<strong>插入排序的基本操作是将当前无序区的第1个记录R[i]插人到有序区R[1．．i-1]中适当的位置上，使R[1．．i]变为新的有序区</strong>。因为这种方法每次使有序区增加1个记录，通常称增量法。<br>插入排序与打扑克时整理手上的牌非常类似。摸来的第1张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的1张并插入左手的牌(有序区)中正确的位置上。为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较。</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void InsertSort(int[] arr)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    int n = arr.Length;</span><br><span class="line">    int target;</span><br><span class="line"> </span><br><span class="line">    //假定第一个元素被放到了正确的位置上，这样，仅需遍历1 ~ n-1</span><br><span class="line">    for (i = 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        target = arr[i];</span><br><span class="line"> </span><br><span class="line">        while (j &gt; 0 &amp;&amp; target &lt; arr[j - 1])</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - 1];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        arr[j] = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>插入排序分析：<br>1、时间复杂度，由于仍然需要两层循环，插入排序的时间复杂度仍然为O(n*n)。<br>2、比较次数：在第一轮排序中，插入排序最多比较一次；在第二轮排序中插入排序最多比较二次；以此类推，最后一轮排序时，最多比较N-1次，因此插入排序的最多比较次数为1+2+…+N-1=N*(N-1)/2。尽管如此，实际上插入排序很少会真的比较这么多次，因为一旦发现左侧有比目标元素小的元素，比较就停止了，因此，插入排序平均比较次数为N*(N-1)/4。<br>3、移动次数：插入排序的移动次数与比较次数几乎一致，但移动的速度要比交换的速度快得多。<br>综上，插入排序的速度约比冒泡排序快一倍（比较次数少一倍），比选择排序还要快一些，对于基本有序的数据，插入排序的速度会很快，是简单排序中效率最高的排序算法。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>原理：<br>选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。然后对这两部分分别重复这个过程，直到整个有序。</p><p>算法思想：<br>基于分治的思想，是冒泡排序的改进型。首先在数组中选择一个基准点（该基准点的选取可能影响快速排序的效率，后面讲解选取的方法），然后分别从数组的两端扫描数组，设两个指示标志（lo指向起始位置，hi指向末尾)，首先从后半部分开始，如果发现有元素比该基准点的值小，就交换lo和hi位置的值，然后从前半部分开始扫秒，发现有元素大于基准点的值，就交换lo和hi位置的值，如此往复循环，直到lo&gt;=hi,然后把基准点的值放到hi这个位置。一次排序就完成了。以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。</p><p>例子：<br>待划分数据：7, 6, 9, 8, 5,1，假设阈值为5<br>第一轮：左指针指向7，右指针指向1，左指针向后移，右指针向左移，发现左面第一个大于5的元素7，右面第一个小于5的元素1，交换7和1的位置，结果：1,6,9,8,5,7；<br>第二轮：从6开始找大于5的数字，找到6，右边从5起找小于5的数字，找到1，但此时由于6在1的右面，，即右指针&lt;左指针，左右指针交叉，此时划分结束。原数列被划分为两部分，左侧子数列只有一个元素，即为1，其为小于阈值的子数列；右侧子数列包括5个元素，均为大于阈值5的元素。</p><p>对于基准位置的选取一般有三种方法：固定切分，随机切分和三取样切分。固定切分的效率并不是太好，随机切分是常用的一种切分，效率比较高，最坏情况下时间复杂度有可能为O(N2).对于三数取中选择基准点是最理想的一种。<br>三数取中切分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static int partition(int []array,int lo,int hi)&#123;</span><br><span class="line">    //三数取中</span><br><span class="line">    int mid=lo+(hi-lo)/2;</span><br><span class="line">    if(array[mid]&gt;array[hi])&#123;</span><br><span class="line">        swap(array[mid],array[hi]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(array[lo]&gt;array[hi])&#123;</span><br><span class="line">        swap(array[lo],array[hi]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(array[mid]&gt;array[lo])&#123;</span><br><span class="line">        swap(array[mid],array[lo]);</span><br><span class="line">    &#125;</span><br><span class="line">    int key=array[lo];</span><br><span class="line">    </span><br><span class="line">    while(lo&lt;hi)&#123;</span><br><span class="line">        while(array[hi]&gt;=key&amp;&amp;hi&gt;lo)&#123;//从后半部分向前扫描</span><br><span class="line">            hi--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[lo]=array[hi];</span><br><span class="line">        while(array[lo]&lt;=key&amp;&amp;hi&gt;lo)&#123;//从前半部分向后扫描</span><br><span class="line">            lo++;</span><br><span class="line">        &#125;</span><br><span class="line">        array[hi]=array[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    array[hi]=key;</span><br><span class="line">    return hi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int a,int b)&#123;</span><br><span class="line">    int temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(int[] array,int lo ,int hi)&#123;</span><br><span class="line">    if(lo&gt;=hi)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    int index=partition(array,lo,hi);</span><br><span class="line">    sort(array,lo,index-1);</span><br><span class="line">    sort(array,index+1,hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br>1、快速排序的时间复杂度为O(NlogN).<br>2、快速排序在序列中元素很少时，效率将比较低，因此一般在序列中元素很少时使用插入排序，这样可以提高整体效率。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。</p><p>原理：<br>归并排序（Merge）是将两个（或两个以上）有序表合并成一个新的有序表。即把待排序序列分为若干个子序列，每个子序列是有序的，然后再把有序子序列合并为整体有序序列。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><p>每个递归过程涉及三个步骤:<br>第一, 分解: 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素.<br>第二, 治理: 对每个子序列分别调用归并排序MergeSort, 进行递归操作<br>第三, 合并: 合并两个排好序的子序列,生成排序结果.</p><p>示例如下图：<br><img src="/2019/10/21/ds-sort/sort-merge.jpg" alt></p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static int[] sort(int[] a,int low,int high)&#123;</span><br><span class="line">    int mid = (low+high)/2;</span><br><span class="line">    if(low&lt;high)&#123;</span><br><span class="line">        sort(a,low,mid);</span><br><span class="line">        sort(a,mid+1,high);</span><br><span class="line">        //左右归并</span><br><span class="line">        merge(a,low,mid,high);</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void merge(int[] a, int low, int mid, int high) &#123;</span><br><span class="line">    int[] temp = new int[high-low+1];</span><br><span class="line">    int i= low;</span><br><span class="line">    int j = mid+1;</span><br><span class="line">    int k=0;</span><br><span class="line">    // 把较小的数先移到新数组中</span><br><span class="line">    while(i&lt;=mid &amp;&amp; j&lt;=high)&#123;</span><br><span class="line">        if(a[i]&lt;a[j])&#123;</span><br><span class="line">            temp[k++] = a[i++];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 把左边剩余的数移入数组 </span><br><span class="line">    while(i&lt;=mid)&#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 把右边边剩余的数移入数组</span><br><span class="line">    while(j&lt;=high)&#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    // 把新数组中的数覆盖nums数组</span><br><span class="line">    for(int x=0;x&lt;temp.length;x++)&#123;</span><br><span class="line">        a[x+low] = temp[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br>（1）稳定性：归并排序是一种稳定的排序。<br>（2）存储结构要求：可用顺序存储结构。也易于在链表上实现。<br>（3）时间复杂度：对长度为n的文件，需进行趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlogn)。<br>（4）空间复杂度：需要一个辅助向量来暂存两有序子文件归并的结果，故其辅助空间复杂度为O(n)，显然它不是就地排序。<br> 注意：若用单链表做存储结构，很容易给出就地的归并排序</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序(Shell Sort)是插入排序的一种，是针对直接插入排序算法的改进，是将整个无序列分割成若干小的子序列分别进行插入排序，希尔排序并不稳定。该方法又称<strong>缩小增量排序</strong>，因DL．Shell于1959年提出而得名。</p><p>原理：<br>先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量dt=1(dt&lt;dt-l&lt;…&lt;d2&lt;d1)，即所有记录放在同一组中进行直接插入排序为止。</p><p>Shell排序的执行时间依赖于增量序，好的增量序列的共同特征：<br>① 最后一个增量必须为1；<br>② 应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。       </p><p>希尔排序的时间性能优于直接插入排序的原因：<br>①当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。<br>②当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度O(n2)差别不大。<br>③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。<br>因此，希尔排序在效率上较直接插人排序有较大的改进。       </p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void shellSort(int[] a)&#123;</span><br><span class="line">    double gap = a.length;//增量长度</span><br><span class="line">    int dk,sentinel,k;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        gap = (int)Math.ceil(gap/2);//逐渐减小增量长度</span><br><span class="line">        dk = (int)gap;//确定增量长度 </span><br><span class="line">        for(int i=0;i&lt;dk;i++)&#123;</span><br><span class="line">            //用增量将序列分割，分别进行直接插入排序。随着增量变小为1，最后整体进行直接插入排序</span><br><span class="line">            for(int j=i+dk;j&lt;a.length;j = j+dk)&#123;</span><br><span class="line">                k = j-dk;</span><br><span class="line">                sentinel = a[j];</span><br><span class="line">                while(k&gt;=0 &amp;&amp; sentinel&lt;a[k])&#123;</span><br><span class="line">                    a[k+dk] = a[k];</span><br><span class="line">                    k = k-dk;</span><br><span class="line">                &#125;</span><br><span class="line">                a[k+dk] = sentinel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //当dk为1的时候，整体进行直接插入排序  </span><br><span class="line">        if(dk==1)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br>1、希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式移动，使得排序的效率提高。<br>2、需要注意的是，增量序列的最后一个增量值必须等于1才行。<br>3、由于记录是跳跃式的移动，希尔排序中相等数据可能会交换位置，所以希尔排序是不稳定的算法。<br>4、希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。<br>5、希尔排序最好时间复杂度和平均时间复杂度都是O(nlogn)，最坏时间复杂度为O(n2)。</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>对简单选择排序的优化。堆排序是一种树形选择排序方法，它的特点是：在排序的过程中，将array[0，…，n-1]看成是一颗完全二叉树的顺序存储结构，利用完全二叉树中双亲节点和孩子结点之间的内在关系，在当前无序区中选择关键字最大（最小）的元素。</p><p>堆的定义：<br>n个关键字序列array[0，…，n-1]，当且仅当满足下列要求：(0 &lt;= i &lt;= (n-1)/2)时<br>① array[i] &lt;= array[2<em>i + 1] 且 array[i] &lt;= array[2</em>i + 2]； 称为小根堆；<br>② array[i] &gt;= array[2<em>i + 1] 且 array[i] &gt;= array[2</em>i + 2]； 称为大根堆；</p><p>步骤如下：<br>1、将序列构建成大顶堆。<br>2、将根节点与最后一个节点交换，然后断开最后一个节点。<br>3、重复第一、二步，直到所有节点断开。<br><img src="/2019/10/21/ds-sort/sort-heap.png" alt></p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 构建大顶堆</span><br><span class="line"> */</span><br><span class="line">public static void adjustHeap(int[] a, int i, int len) &#123;</span><br><span class="line">    int temp, j;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    for (j = 2 * i; j &lt; len; j *= 2) &#123;// 沿关键字较大的孩子结点向下筛选</span><br><span class="line">        if (j &lt; len &amp;&amp; a[j] &lt; a[j + 1])</span><br><span class="line">            ++j; // j为关键字中较大记录的下标</span><br><span class="line">        if (temp &gt;= a[j])</span><br><span class="line">            break;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void heapSort(int[] a) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = a.length / 2 - 1; i &gt;= 0; i--) &#123;// 构建一个大顶堆</span><br><span class="line">        adjustHeap(a, i, a.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = a.length - 1; i &gt;= 0; i--) &#123;// 将堆顶记录和当前未经排序子序列的最后一个记录交换</span><br><span class="line">        int temp = a[0];</span><br><span class="line">        a[0] = a[i];</span><br><span class="line">        a[i] = temp;</span><br><span class="line">        adjustHeap(a, 0, i - 1);// 将a中前i-1个记录重新调整为大顶堆</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br>1、空间复杂度:o(1)；<br>2、时间复杂度:建堆：o(n)，每次调整o(log n)，故最好、最坏、平均情况下：o(n*logn);<br>3、稳定性：不稳定</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>原理:<br>对每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。<br>所以可以直接把 arr[i] 放到它输出数组中的位置上。假设有5个数小于 arr[i]，所以 arr[i] 应该放在数组的第6个位置上。</p><p>示例如下：<br>需要三个数组:<br>待排序数组 int[] arr = new int[]{4,3,6,3,5,1};<br>辅助计数数组 int[] help = new int[max - min + 1]; //该数组大小为待排序数组中的最大值减最小值+1<br>输出数组 int[] res = new int[arr.length];<br>1.求出待排序数组的最大值max=6， 最小值min=1<br>2.实例化辅助计数数组help， help用来记录每个元素之前出现的元素个数， 此时help = [1,0,2,1,1,1]<br>3.计算 arr 每个数字应该在排序后数组中应该处于的位置，此时 help = [1,1,4,5,6,7];<br>4.根据 help 数组求得排序后的数组，此时 res = [1,3,3,4,5,6]</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static int[] countSort(int[] arr)&#123;</span><br><span class="line">  int max = Integer.MIN_VALUE;</span><br><span class="line">  int min = Integer.MAX_VALUE;</span><br><span class="line">   </span><br><span class="line">  //找出数组中的最大最小值</span><br><span class="line">  for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">    max = Math.max(max, arr[i]);</span><br><span class="line">    min = Math.min(min, arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  int[] help = new int[max - min + 1];</span><br><span class="line">   </span><br><span class="line">  //找出每个数字出现的次数</span><br><span class="line">  for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">    int mapPos = arr[i] - min;</span><br><span class="line">    help[mapPos]++;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  //计算每个数字应该在排序后数组中应该处于的位置</span><br><span class="line">  for(int i = 1; i &lt; help.length; i++)&#123;</span><br><span class="line">    help[i] = help[i-1] + help[i];</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  //根据help数组进行排序</span><br><span class="line">  int res[] = new int[arr.length];</span><br><span class="line">  for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">    int post = --help[arr[i] - min];</span><br><span class="line">    res[post] = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br>1、计数排序是一种拿空间换时间的排序算法，它仅适用于数据比较集中的情况。比如 [0~100]，[10000~19999] 这样的数据。<br>2、只能是整形数组。<br>3、数组元素必须都大于0。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>原理：<br>把数组 arr 划分为n个大小相同子区间（桶），每个子区间各自排序，最后合并 。<br>计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>步骤如下：<br>1.找出待排序数组中的最大值max、最小值min<br>2.我们使用 动态数组ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(max-min)/arr.length+1<br>3.遍历数组 arr，计算每个元素 arr[i] 放的桶<br>4.每个桶各自排序<br>5.遍历桶数组，把排序好的元素放进输出数组</p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void bucketSort(int[] arr)&#123;</span><br><span class="line">int max = Integer.MIN_VALUE;</span><br><span class="line">int min = Integer.MAX_VALUE;</span><br><span class="line">for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">max = Math.max(max, arr[i]);</span><br><span class="line">min = Math.min(min, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//桶数</span><br><span class="line">int bucketNum = (max - min) / arr.length + 1;</span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketNum);</span><br><span class="line">for(int i = 0; i &lt; bucketNum; i++)&#123;</span><br><span class="line">bucketArr.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将每个元素放入桶</span><br><span class="line">for(int i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">int num = (arr[i] - min) / (arr.length);</span><br><span class="line">bucketArr.get(num).add(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对每个桶进行排序</span><br><span class="line">for(int i = 0; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">Collections.sort(bucketArr.get(i));// 对每个桶进行排序，这里使用了Collections.sort</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    //将桶中元素全部取出来并放入 arr 中输出</span><br><span class="line">int index = 0;</span><br><span class="line">for (ArrayList&lt;Integer&gt; bucket : bucketArr) &#123;</span><br><span class="line">    for (Float data : bucket) &#123;</span><br><span class="line">        arr[index++] = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br>1、桶排序可用于最大最小值相差较大的数据情况，比如[9012,19702,39867,68957,83556,102456]。<br>2、但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。<br>3、桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序（Radix Sort）分为两种：第一种是LSD ，从最低位开始排序， 第二种是 MSD 从最高位开始排。这里介绍第一种LSD排序算法。<br>首先，我们先了解什么是基数。基数是根据具体的排序情况而定的，比如我们常见的基数是十进制-10，还有二进制-2。</p><p>原理：<br>基数排序的总体思路就是将待排序数据拆分成多个关键字进行排序，也就是说，基数排序的实质是<strong>多关键字排序</strong>。通过对每一个位上的值相排序，就可以完成对整个数组的排序。</p><p>步骤如下：<br>1、遍历所有数组元素，找出元素最大的位值<br>2、从低位到高位把数组元素上的位值存入链表中<br>3、遍历所有链表，将链表里面的值重新赋值给数组，再清空链表。</p><p>示例如下：<br>例如：对数组int[ ]  data = {421, 240, 35, 532, 305, 430, 124}；<br>1、进行排序，首先我们要做的是对个位上的数值进行排序。<br>第一遍排序的结果为：　　240 430 421 532 124 35 305<br>2、再进行十位上的数值排序：<br>第二遍排序的结果为：　　305 421 124 430 532 35 240<br>3、再进行百位上的数值排序：<br>第三遍排序的结果为：　　35 124 240 305 421 430 532<br>最后我们的到的排序结果就是： 35 124 240 305 421 430 532 </p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//实现基数排序</span><br><span class="line">public void radixSort(int[] data) &#123;</span><br><span class="line">    int maxBin = maxBin(data);</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    for(int i  = 0; i &lt; 10; i ++) &#123;</span><br><span class="line">        list.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0, factor = 1; i &lt; maxBin; factor *= 10, i ++) &#123;</span><br><span class="line">        for(int j = 0; j &lt; data.length; j ++) &#123;</span><br><span class="line">            list.get((data[j]/factor)%10).add(data[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0, k = 0; j &lt; list.size(); j ++) &#123;</span><br><span class="line">            while(!list.get(j).isEmpty()) &#123;</span><br><span class="line">                data[k] = list.get(j).get(0);</span><br><span class="line">                list.get(j).remove(0);</span><br><span class="line">                k ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//计算数组里元素的最大位数</span><br><span class="line">public int maxBin(int[] data) &#123;</span><br><span class="line">    int maxLen = 0;</span><br><span class="line">    for(int i = 0; i &lt; data.length; i ++) &#123;</span><br><span class="line">        int size = Integer.toString(data[i]).length();</span><br><span class="line">        maxLen =  size &gt; maxLen ? size : maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>算法分析：<br>1、基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。<br>2、基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2019/10/21/ds-sort/sort-time.png" alt title="算法复杂度"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a><br><a href="https://www.runoob.com/w3cnote/java-sorting-algorithm-analysis-and-implementation.html" target="_blank" rel="noopener">Java 排序算法分析与实现</a><br><a href="https://www.cnblogs.com/coderising/p/5708801.html" target="_blank" rel="noopener">快速排序</a><br><a href="https://www.cnblogs.com/of-fanruice/p/7678801.html" target="_blank" rel="noopener">Java实现归并排序</a><br><a href="https://www.cnblogs.com/of-fanruice/p/7674593.html" target="_blank" rel="noopener">Java实现希尔排序</a><br><a href="https://www.cnblogs.com/zer0Black/p/6169858.html" target="_blank" rel="noopener">计数排序和桶排序（Java实现）</a><br><a href="https://www.cnblogs.com/ranter/p/9197983.html" target="_blank" rel="noopener">数据结构Java版之基数排序（四）</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2019/10/21/design-mode-prototype/"/>
      <url>/2019/10/21/design-mode-prototype/</url>
      
        <content type="html"><![CDATA[<p>原型模式属于对象的创建模式：<strong>通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象</strong>。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、对象之间相同或相似，即只是个别的几个属性不同的时候。<br>2、对象的创建过程比较麻烦，但复制比较简单的时候。</p><h2 id="原型模式的结构"><a href="#原型模式的结构" class="headerlink" title="原型模式的结构"></a>原型模式的结构</h2><p>原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。</p><p><img src="/2019/10/21/design-mode-prototype/prototype.png" alt></p><p>这种形式涉及到三个角色：<br>（1）客户(Client)角色：客户类提出创建对象的请求。<br>（2）抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。<br>（3）具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。</p><h2 id="浅克隆与深克隆"><a href="#浅克隆与深克隆" class="headerlink" title="浅克隆与深克隆"></a>浅克隆与深克隆</h2><p>浅克隆只是复制了基础属性，列如八大基本类型，然而引用类型实际上没有复制，只是将对应的引用给复制了。</p><p>简单的说：如果一个对象中只有基本类型属性，那深克隆和浅克隆效果都是一样的，基本类型数据不管是用深克隆还是浅克隆都会被克隆出一份，但如果对象中包含引用对象属性，那浅克隆其实这是拷贝了一份引用，而深克隆确实把整个引用对象都拷贝了一份。</p><h2 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h2><p>（1）根据客户端要求实现动态创建对象，客户端不需要知道对象的创建细节，便于代码的维护和扩展。</p><p>（2）使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是<strong>复制大对象时</strong>，性能的差别非常明显。所以在<strong>需要重复地创建相似对象时</strong>可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。</p><p>（3）原型模式类似于工厂模式，但它没有了工厂模式中的抽象工厂和具体工厂的实现，代码结构更清晰和简单。</p><p>（4）可用于<strong>保护性拷贝</strong>，避免原始的对象被外部修改。</p><h2 id="原型模式的注意事项"><a href="#原型模式的注意事项" class="headerlink" title="原型模式的注意事项"></a>原型模式的注意事项</h2><p>（1）使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不 会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为 private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的。</p><p>（2）在使用时要注意深拷贝与浅拷贝的问题。clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//具体原型类</span><br><span class="line">class Realizetype implements Cloneable</span><br><span class="line">&#123;</span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体原型创建成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Object clone() throws CloneNotSupportedException</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体原型复制成功！&quot;);</span><br><span class="line">        return (Realizetype)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//原型模式的测试类</span><br><span class="line">public class PrototypeTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)throws CloneNotSupportedException</span><br><span class="line">    &#123;</span><br><span class="line">        Realizetype obj1=new Realizetype();</span><br><span class="line">        Realizetype obj2=(Realizetype)obj1.clone();</span><br><span class="line">        System.out.println(&quot;obj1==obj2?&quot;+(obj1==obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果如下：</span><br><span class="line">具体原型创建成功！</span><br><span class="line">具体原型复制成功！</span><br><span class="line">obj1==obj2?false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2019/10/21/design-mode-builder/"/>
      <url>/2019/10/21/design-mode-builder/</url>
      
        <content type="html"><![CDATA[<p>建造者模式的定义是：<strong>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示</strong>。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p><p>主要优点如下：<br>1、各个具体的建造者相互独立，有利于系统的扩展。<br>2、客户端不必知道产品内部组成的细节，便于控制细节风险。</p><p>其缺点如下：<br>1、产品的组成部分必须相同，这限制了其使用范围。<br>2、如果产品的内部变化复杂，该模式会增加很多的建造者类。</p><p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。<br>2、创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</p><h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>建造者（Builder）模式的主要角色如下：<br>1、产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。<br>2、抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。<br>3、具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。<br>4、指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</p><p><img src="/2019/10/21/design-mode-builder/builder.jpg" alt title="结构图"></p><p>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class Product</span><br><span class="line">&#123;</span><br><span class="line">    private String partA;</span><br><span class="line">    private String partB;</span><br><span class="line">    private String partC;</span><br><span class="line">    public void setPartA(String partA)</span><br><span class="line">    &#123;</span><br><span class="line">        this.partA=partA;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPartB(String partB)</span><br><span class="line">    &#123;</span><br><span class="line">        this.partB=partB;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPartC(String partC)</span><br><span class="line">    &#123;</span><br><span class="line">        this.partC=partC;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()</span><br><span class="line">    &#123;</span><br><span class="line">        //显示产品的特性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Builder</span><br><span class="line">&#123;</span><br><span class="line">    //创建产品对象</span><br><span class="line">    protected Product product=new Product();</span><br><span class="line">    public abstract void buildPartA();</span><br><span class="line">    public abstract void buildPartB();</span><br><span class="line">    public abstract void buildPartC();</span><br><span class="line">    //返回产品对象</span><br><span class="line">    public Product getResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteBuilder extends Builder</span><br><span class="line">&#123;</span><br><span class="line">    public void buildPartA()</span><br><span class="line">    &#123;</span><br><span class="line">        product.setPartA(&quot;建造 PartA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void buildPartB()</span><br><span class="line">    &#123;</span><br><span class="line">        product.setPartA(&quot;建造 PartB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void buildPartC()</span><br><span class="line">    &#123;</span><br><span class="line">        product.setPartA(&quot;建造 PartC&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Director</span><br><span class="line">&#123;</span><br><span class="line">    private Builder builder;</span><br><span class="line">    public Director(Builder builder)</span><br><span class="line">    &#123;</span><br><span class="line">        this.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">    //产品构建与组装方法</span><br><span class="line">    public Product construct()</span><br><span class="line">    &#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        return builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Builder builder=new ConcreteBuilder();</span><br><span class="line">        Director director=new Director(builder);</span><br><span class="line">        Product product=director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配算法</title>
      <link href="/2019/10/17/ds-string-matching/"/>
      <url>/2019/10/17/ds-string-matching/</url>
      
        <content type="html"><![CDATA[<p>字符串的匹配算法有：<br>1、单模式串匹配算法（BF算法，RK算法，BM算法，KMP算法）<br>2、多模式串匹配算法有（Trie树，AC自动机）</p><h2 id="BF（Brute-Force）算法"><a href="#BF（Brute-Force）算法" class="headerlink" title="BF（Brute Force）算法"></a>BF（Brute Force）算法</h2><p>BF算法就是拿模式串m，从主串n的第0位开始匹配，如果匹配不成功，则后移一位继续匹配。<br>是比较简单的一种字符串匹配算法，在处理简单的数据时候就可以用这种算法，完全匹配，速度很慢，时间复杂度最坏情况O(M*N)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int bf(String str,String sub)&#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = 0;</span><br><span class="line">        while(i &lt; str.length())&#123;</span><br><span class="line">            while(j &lt; sub.length())&#123;</span><br><span class="line">                if(str.charAt(i) == sub.charAt(j))&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    i = i-j+1;</span><br><span class="line">                    j =0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return i-j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="RK（Rabin-Karp）算法"><a href="#RK（Rabin-Karp）算法" class="headerlink" title="RK（Rabin-Karp）算法"></a>RK（Rabin-Karp）算法</h2><p>RK算法：数字的匹配比字符串快速，就把主串中的这n-m+1的子串分别求哈希值，然后在分别跟模式串的哈希值进行比较。如果哈希值不一样那肯定不匹配，如果哈希值一样，因为哈希算法存在哈希冲突，这时候在拿模式串跟该子串对比一下就好了。</p><p>虽然模式串跟子串的对比速度提高了，但是我们事先需要遍历主串，逐个求子串的哈希值，这部分也挺耗时的，所以需要设计比较高效的哈希算法尽量的减少哈希冲突的产生。</p><h2 id="BM（Boyer-Moore）算法"><a href="#BM（Boyer-Moore）算法" class="headerlink" title="BM（Boyer-Moore）算法"></a>BM（Boyer-Moore）算法</h2><p>上面两种字符串匹配算法都有缺点，BF算法在极端情况下效率会很低，RK算法需要有一个很好的哈希算法，而设计一个好的哈希算法并不简单，有没有尽可能的高效，极端情况下效率退化也不大的算法呢，下面看看BM算法。</p><p>BM算法是一种非常高效的算法，各种记事本的查找功能一般都是采用的这种算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下 O(N) 的时间复杂度。在实践中，比 KMP 算法的实际效能高。</p><p>BM 算法定义了两个规则：</p><ul><li>坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为 -1。</li><li>好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为 -1。</li></ul><p>通过坏字符算法与好后缀算法分别获取位移值，取两者中的最大值进行位移操作。</p><p>案例可参考：<a href="http://wiki.jikexueyuan.com/project/kmp-algorithm/bm.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/kmp-algorithm/bm.html</a></p><p>BM算法完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// a,b 表示主串和模式串；n，m 表示主串和模式串的长度。</span><br><span class="line">public int bm(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置</span><br><span class="line">  generateBC(b, m, bc); // 构建坏字符哈希表</span><br><span class="line">  int[] suffix = new int[m];</span><br><span class="line">  boolean[] prefix = new boolean[m];</span><br><span class="line">  generateGS(b, m, suffix, prefix);</span><br><span class="line">  int i = 0; // j 表示主串与模式串匹配的第一个字符</span><br><span class="line">  while (i &lt;= n - m) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    for (j = m - 1; j &gt;= 0; --j) &#123; // 模式串从后往前匹配</span><br><span class="line">      if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是 j</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &lt; 0) &#123;</span><br><span class="line">      return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br><span class="line">    &#125;</span><br><span class="line">    int x = j - bc[(int)a[i+j]];</span><br><span class="line">    int y = 0;</span><br><span class="line">    if (j &lt; m-1) &#123; // 如果有好后缀的话</span><br><span class="line">      y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    i = i + Math.max(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// j 表示坏字符对应的模式串中的字符下标 ; m 表示模式串长度</span><br><span class="line">private int moveByGS(int j, int m, int[] suffix, boolean[] prefix) &#123;</span><br><span class="line">  int k = m - 1 - j; // 好后缀长度</span><br><span class="line">  if (suffix[k] != -1) return j - suffix[k] +1;</span><br><span class="line">  for (int r = j+2; r &lt;= m-1; ++r) &#123;</span><br><span class="line">    if (prefix[m-r] == true) &#123;</span><br><span class="line">      return r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void generateBC(char[] b, int m, int[] bc) &#123;</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            bc[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            int ascii = (int) b[i];</span><br><span class="line">            bc[ascii] = i; // 如果ascii相同只需要存储 bc[ascii] = 最后一个</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateGS(char[] b, int m, int[] suffix, boolean[] prefix) &#123;</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123; //初始化</span><br><span class="line">            suffix[i] = -1;</span><br><span class="line">            prefix[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m - 1; ++i) &#123; // b[0,i]</span><br><span class="line">            int j = i;</span><br><span class="line">            int k = 0;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; b[j] == b[m - 1 - k]) &#123;</span><br><span class="line">                --j;</span><br><span class="line">                ++k;</span><br><span class="line">                suffix[k] = j + 1;//记录模式串每个可以匹配前缀子串的长度 等于 最大下标值</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (j == -1) prefix[k] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="KMP（Knuth-Morris-Pratt）算法"><a href="#KMP（Knuth-Morris-Pratt）算法" class="headerlink" title="KMP（Knuth Morris Pratt）算法"></a>KMP（Knuth Morris Pratt）算法</h2><p>模式串跟主串左端对齐，先比较第一个字符，如果不一样就，模式串后移，直到第一个字符相等</p><p>第一个字符匹配上之后在匹配第二个，直到有不相等的为止，比如下面</p><p>主串：cd<strong>ababaea</strong>bac</p><p>模式串：ababacd</p><p>e和c不匹配，e就可以理解为坏字符，ababa可以理解为好前缀，那移动几位呢？</p><p>我们拿好前缀本身，在它的后缀子串中查找最长的那个可以跟好前缀的前缀子串匹配的。</p><p>移动位数 = 已匹配的字符数 - 对应的部分匹配值的长度</p><p>如何求这个对应的匹配值呢？这个不涉及到主串只需要根据模式串就可以求出来。</p><p>比如这里的模式串是 ababacd</p><p>a的前缀和后缀都是空，共有元素为0<br>ab的前缀是[a]后缀是[b]，共有元素为0<br>aba的前缀是[a,ab]后缀是[ba,a]，共有元素a的长度是1<br>abab的前缀是[a,ab,aba]后缀是[bab,ab,b],共有元素是[ab]长度为2<br>ababa的前缀是[a,ab,aba,abab]后缀是[baba,aba,ba,a],最长共有元素是[aba]长度是3<br>ababac的前缀是[a,ab,aba,abab,ababa]后缀是[babac,abac,bac,ac,c]共有元素为0<br>ababacd的前缀是[a,ab,aba,abab,ababa,ababac]后缀是[babacd,abacd,bacd,acd,cd,d]共有元素是0</p><p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// a, b 分别是主串和模式串；n, m 分别是主串和模式串的长度。</span><br><span class="line">public static int kmp(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[] next = getNexts(b, m);</span><br><span class="line">  int j = 0;</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    while (j &gt; 0 &amp;&amp; a[i] != b[j]) &#123; // 一直找到 a[i] 和 b[j]</span><br><span class="line">      j = next[j - 1] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j == m) &#123; // 找到匹配模式串的了</span><br><span class="line">      return i - m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line">// b 表示模式串，m 表示模式串的长度</span><br><span class="line">private static int[] getNexts(char[] b, int m) &#123;</span><br><span class="line">  int[] next = new int[m];</span><br><span class="line">  next[0] = -1;</span><br><span class="line">  int k = -1;</span><br><span class="line">  for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">    while (k != -1 &amp;&amp; b[k + 1] != b[i]) &#123;</span><br><span class="line">      k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    if (b[k + 1] == b[i]) &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/mingyunxiaohai/article/details/87563292" target="_blank" rel="noopener">https://blog.csdn.net/mingyunxiaohai/article/details/87563292</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/10/17/design-mode-singleton/"/>
      <url>/2019/10/17/design-mode-singleton/</url>
      
        <content type="html"><![CDATA[<p>Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。（事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效，下面会讨论。）</p><p>主要优点：<br>1、提供了对唯一实例的受控访问。<br>2、由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。<br>3、允许可变数目的实例。</p><p>主要缺点：<br>1、由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。<br>2、单例类的职责过重，在一定程度上违背了“单一职责原则”。<br>3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</p><p>以下列出单例模式的几种写法及单例模式的漏洞解决方案：</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>类初始化时创建对象，不管需不需要实例对象，都会创建。不存在线程安全问题，因为实例是在类创建和初始化时创建，是由类加载器完成的，类加载器是线程安全的。</p><p>缺点，无法延时加载,没有使用就已经加载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"> </span><br><span class="line">    private static final Singleton mInstance = new Singleton();</span><br><span class="line"> </span><br><span class="line">    private Singleton()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>优化了恶汉式无法延迟加载的问题。<br>缺点：存在同步问题，多线程并发的时候会失效，getInstance不同步。比如：一个线程在创建mInstance时，还未创建完成，另一个线程访问mInstance此时还是为空，又创建了一次。</p><p>对懒汉式的优化，主要是在线程安全方面，使用synchronized关键字或同步代码块修饰，使得同时只能有一个线程访问。但存在性能缺陷的，因为使用了synchronized关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"> </span><br><span class="line">    private static Singleton mInstance;</span><br><span class="line"> </span><br><span class="line">    private Singleton()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(mInstance == null)&#123;</span><br><span class="line">            mInstance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DCL双重检查锁"><a href="#DCL双重检查锁" class="headerlink" title="DCL双重检查锁"></a>DCL双重检查锁</h2><p>DCL双重检查锁，是对第二种方法性能缺陷的优化。</p><p>DCL双重检查锁仅在真正创建mInstance实例的时候加上了synchronized关键字。而且使用volatile关键字修饰，是为了禁止编译器对volatile变量重排序，并且保证volatile变量的读操作发生在写操作之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"> </span><br><span class="line">    private static volatile Singleton mInstance =null; //volatile关键字是为了禁止编译器对 volatile关键字修饰的变量进行重排序，并保证volatile变量的读操作发生在写操作之后</span><br><span class="line"> </span><br><span class="line">    private Singleton()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(mInstance == null)&#123; //第一次检查</span><br><span class="line">            synchronized (Singleton.class)&#123; //同步代码块</span><br><span class="line">                if(mInstance == null)&#123; //第二次检查</span><br><span class="line">                    mInstance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>利用static final关键字的同步机制，初始化后就无法修改保证了线程安全。使用静态内部类的方式保证了延迟加载，不使用不会被加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123; //完成了懒汉式的延迟加载，同时static保证了线程安全。</span><br><span class="line"> </span><br><span class="line">    private  Singleton()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getIntance()&#123;</span><br><span class="line">        return SingletonHolder.mIntance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static class SingletonHolder&#123; //私有的，初始化的时候，没有调用getIntance方法则不会加载</span><br><span class="line">        private static final Singleton mIntance = new Singleton();  //static,final是jvm提供的同步机制，初始化后就无法修改了</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举（推荐用法）"><a href="#枚举（推荐用法）" class="headerlink" title="枚举（推荐用法）"></a>枚举（推荐用法）</h2><p>1.简洁<br>2.线程安全<br>3.可以防止反射注入,反序列化它也不会重新生成新的实例</p><p>所有的枚举类型隐性地继承自java.lang.Enum 。枚举实质上还是类！而每个枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final 修饰的。可以直接通过枚举类型名使用它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line"></span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  public void doSomething()&#123;</span><br><span class="line">     System.out.println(&quot;do sth.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单例模式存在的漏洞"><a href="#单例模式存在的漏洞" class="headerlink" title="单例模式存在的漏洞"></a>单例模式存在的漏洞</h2><p>1、 通过反射获取单例对象</p><p>我们观察反射获取单例的代码，发现它还是调用了私有的构造方法获取对象【声明为私有的构造方法就是为了不让类外直接new对象】。如果只让私有的构造器只能调用一次就可以避免反射。</p><p>2、 反序列化获得单例模式对象</p><p>传统的单例模式的另外一个问题是一旦你实现了serializable接口，他们就不再是单例的了，因为readObject()方法总是返回一个 新的实例对象，就像java中的构造器一样。如果定义了readResolve()则直接返回此方法指定的对象，而不需要再创建新的对象！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 序列化必须实现Serializable接口，否则序列化时会报错</span><br><span class="line"> */</span><br><span class="line">public class Singleton implements Serializable&#123;</span><br><span class="line">     </span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"> </span><br><span class="line">    private static Singleton sl;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        //如果sl不为空即这不是第一次调用该构造器</span><br><span class="line">        if(sl != null)</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(sl == null) &#123;</span><br><span class="line">            sl = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return sl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    /**</span><br><span class="line">     * 反序列化时，如果定义了readResolve()则直接返回此方法指定的对象，而不需要在创建新的对象！</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Object readResolve() &#123; </span><br><span class="line">        return getInstance(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/d9d9dcf23359" target="_blank" rel="noopener">为什么说枚举是最好的Java单例实现方法？</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象7大原则</title>
      <link href="/2019/10/17/design-mode-principle/"/>
      <url>/2019/10/17/design-mode-principle/</url>
      
        <content type="html"><![CDATA[<p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</p><h2 id="开闭原则-Open-Close-Principle"><a href="#开闭原则-Open-Close-Principle" class="headerlink" title="开闭原则(Open Close Principle)"></a>开闭原则(Open Close Principle)</h2><p>开闭原则的定义是：软件中的对象（类、模块、函数等）应该对于扩展是开放的，对于修改是封闭的。意思就是说当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下：<br>1、软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。<br>2、粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。<br>3、遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p><p>实现方法：<br>可以通过“<strong>抽象约束、封装变化</strong>”来实现开闭原则，即<strong>通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中</strong>。<br>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><h2 id="里式替换原则-Liskov-Substitution-Principle"><a href="#里式替换原则-Liskov-Substitution-Principle" class="headerlink" title="里式替换原则(Liskov Substitution Principle)"></a>里式替换原则(Liskov Substitution Principle)</h2><p>继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</p><p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p><p>它包含以下4层含义：<br>1、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>2、子类中可以增加自己特有的方法。<br>3、当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。<br>4、当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p><p>里氏替换原则通俗来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p><h2 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h2><p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；<strong>抽象不应该依赖细节，细节应该依赖抽象</strong>（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：<strong>要面向接口编程，不要面向实现编程</strong>。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p><p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p><p>主要作用如下：<br>1、可以降低类间的耦合性。<br>2、可以提高系统的稳定性。<br>3、可以减少并行开发引起的风险。<br>4、可以提高代码的可读性和可维护性。</p><p>实现方法：<br>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则：<br>1、每个类尽量提供接口或抽象类，或者两者都具备。<br>2、变量的声明类型尽量是接口或者是抽象类。<br>3、任何类都不应该从具体类派生。<br>4、使用继承时尽量遵循里氏替换原则。</p><h2 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h2><p>这里的职责是指类变化的原因，单一职责原则规定<strong>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</strong>（There should never be more than one reason for a class to change）。简单来说，一个类中应该是一组相关性很高的函数、数据的封装。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：<br>1、一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；<br>2、当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</p><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点：<br>1、降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。<br>2、提高类的可读性。复杂性降低，自然其可读性会提高。<br>3、提高系统的可维护性。可读性提高，那自然更容易维护了。<br>4、变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</p><p>实现方法：<br>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p><p>注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p><h2 id="接口隔离原则-Interface-Segregation-Principles"><a href="#接口隔离原则-Interface-Segregation-Principles" class="headerlink" title="接口隔离原则(Interface Segregation Principles)"></a>接口隔离原则(Interface Segregation Principles)</h2><p>定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>（The dependency of one class to another one should depend on the smallest possible interface）。</p><p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：<br>1、单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。<br>2、单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点：<br>1、将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。<br>2、接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。<br>3、如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。<br>4、使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。<br>5、能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</p><p>实现方法：<br>在具体应用接口隔离原则时，应该根据以下几个规则来衡量：<br>1、接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。<br>2、为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。<br>3、了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。<br>4、提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p><h2 id="迪米特原则-Law-of-Demeter"><a href="#迪米特原则-Law-of-Demeter" class="headerlink" title="迪米特原则(Law of Demeter)"></a>迪米特原则(Law of Demeter)</h2><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。又称为最少知识原则：<strong>一个对象应该对其他对象有最少的了解</strong>。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点：<br>1、降低了类之间的耦合度，提高了模块的相对独立性。<br>2、由于亲合度降低，从而提高了类的可复用率和系统的扩展性。<br>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><p>实现方法：<br>从迪米特法则的定义和特点可知，它强调以下两点：<br>1、从依赖者的角度来说，只依赖应该依赖的对象。<br>2、从被依赖者的角度说，只暴露应该暴露的方法。<br>所以，在运用迪米特法则时要注意以下 6 点：<br>1、在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。<br>2、在类的结构设计上，尽量降低类成员的访问权限。<br>3、在类的设计上，优先考虑将一个类设置成不变类。<br>4、在对其他类的引用上，将引用其他对象的次数降到最低。<br>5、不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。<br>6、谨慎使用序列化（Serializable）功能。</p><h2 id="合成复用原则-Composite-Reuse-Principle"><a href="#合成复用原则-Composite-Reuse-Principle" class="headerlink" title="合成复用原则(Composite Reuse Principle)"></a>合成复用原则(Composite Reuse Principle)</h2><p>合成复用原则又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p><p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点:<br>1.继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。<br>2.子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。<br>3.它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</p><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点:<br>1.它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。<br>2.新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。<br>3.复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</p><p>实现方法：<br>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理</title>
      <link href="/2019/10/16/ds-hashmap/"/>
      <url>/2019/10/16/ds-hashmap/</url>
      
        <content type="html"><![CDATA[<p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK8的HashMap源码进行分析。</p><h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><p>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p><p>　　 <strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)<br>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)<br>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。<br>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p><p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构和链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p><p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p><p>　　　　　　　　<strong>存储位置 = f(关键字)</strong></p><p>　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p><p><img src="/2019/10/16/ds-hashmap/hash-insert.png" alt></p><p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，<strong>当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞</strong>。哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而<strong>HashMap即是采用了链地址法，也就是数组+链表+红黑树的方式</strong>。</p><h2 id="HashMap底层存储结构"><a href="#HashMap底层存储结构" class="headerlink" title="HashMap底层存储结构"></a>HashMap底层存储结构</h2><p>HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The table, initialized on first use, and resized as</span><br><span class="line"> * necessary. When allocated, length is always a power of two.</span><br><span class="line"> * (We also tolerate length zero in some operations to allow</span><br><span class="line"> * bootstrapping mechanics that are currently not needed.)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Basic hash bin node, used for most entries.  (See below for</span><br><span class="line"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><br><span class="line"> */</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line">    public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125;</span><br><span class="line">    public final V setValue(V newValue) &#123; ... &#125;</span><br><span class="line">    public final boolean equals(Object o) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为table数组的长度是有限的，再好的hash函数也会出现index冲突的情况，所以我们用<strong>链表</strong>来解决这个问题，table数组的每一个元素不只是一个Entry对象，也是一个链表的头节点，每一个Entry对象通过Next指针指向下一个Entry节点。当新来的Entry映射到冲突数组位置时，只需要插入对应的链表即可。</p><p>需要注意的是：新来的Entry节点插入链表时，会插在链表的头部，因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。</p><p>HashMap中的table数组如下所示：</p><p><img src="/2019/10/16/ds-hashmap/hashmap-table.png" alt></p><p>所以，HashMap是<strong>数组+链表+红黑树</strong>（在Java 8中为了优化Entry的查找性能，新加了红黑树部分）实现的。</p><h2 id="Put方法原理"><a href="#Put方法原理" class="headerlink" title="Put方法原理"></a>Put方法原理</h2><p>调用hashMap.put(“str”, 1)，将会在HashMap的table数组中插入一个Key为“str”的元素，这时候需要我们用一个hash()函数来确定Entry的插入位置，而每种数据类型有自己的hashCode()函数，比如String类型的hashCode()函数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int hashCode(byte[] value) &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line">    for (byte v : value) &#123;</span><br><span class="line">        h = 31 * h + (v &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，put()函数的执行路径是这样的：</p><ol><li>首先put(“str”, 1)会调用HashMap的hash(“str”)方法。</li><li>在hash()内部，会调用String(Latin1)内部的hashcode()获取字符串”str”的hashcode。</li><li>“str”的hashcode被返回给put()，put()通过一定计算得到最终的插入位置index。</li><li>最后将这个Entry插入到table的index位置。</li></ol><p>这里就出现了两个问题，问题1: 在put()里怎样得到插入位置index？问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？</p><h3 id="问题1-在put-里怎样得到插入位置index？"><a href="#问题1-在put-里怎样得到插入位置index？" class="headerlink" title="问题1: 在put()里怎样得到插入位置index？"></a>问题1: 在put()里怎样得到插入位置index？</h3><p>对于不同的hash码我们希望它被插入到不同的位置，所以我们首先会想到对数组长度的取模运算，但是由于取模运算的效率很低，所以HashMap的发明者用<strong>位运算</strong>替代了取模运算。</p><p>在put()里是通过如下的语句得到插入位置的(<strong>key的哈希值与map长度-1相与</strong>)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash(key) &amp; (Length - 1)</span><br></pre></td></tr></table></figure></p><p>其中Length是table数组的长度。为了实现和取模运算相同的功能，这里要求(Length - 1)这部分的二进制表示全为1，我们用HashMap的默认初始长度16举例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设&quot;str&quot;的hash吗为: 1001 0110 1011 1110 1101 0010 1001 0101</span><br><span class="line"></span><br><span class="line">Length - 1 = 15 : 1111</span><br><span class="line"></span><br><span class="line">hash(&quot;str&quot;) &amp; (Length - 1) = 0101</span><br></pre></td></tr></table></figure><p>如果(Length - 1)这部分不全为1，假如Length是10，那么Length - 1 = 9 ：1001 那么无论再和任何hash码做与操作，中间两位数都会是0，这样就会出现大量不同的hash码被映射到相同位置的情况。</p><p>所以，<strong>在HashMap中table数组的默认长度是16，并且要求每次自动扩容或者手动扩容时，长度都必须是2的幂。</strong></p><h3 id="问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？"><a href="#问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？" class="headerlink" title="问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？"></a>问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？</h3><p>HashMap中的hash()函数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>HashMap中的hash()函数是将得到hashcode做进一步处理，它将hashcode的高16位和低16位进行异或操作</strong>，这样做的目的是：在table的长度比较小的情况下，也能保证hashcode的高位参与到地址映射的计算当中，同时不会有太大的开销。</p><p>综上所述：从hashcode计算得到table索引的计算过程如下所示：</p><p><img src="/2019/10/16/ds-hashmap/hash-process.png" alt></p><p>put()方法的执行过程如下所示：</p><p><img src="/2019/10/16/ds-hashmap/hash-put.png" alt></p><h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><p>在HashMap中有一下两个属性和扩容相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int threshold;</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure></p><p>其中threshold = Length * loadFactor，Length表示table数组的长度（默认值是16），<strong>loadFactor为负载因子（默认值是0.75）</strong>，阀值threshold表示当table数组中存储的元素超过这个阀值的时候，就需要扩容了。以默认长度16，和默认负载因子0.75为例，threshold = 16 * 0.75 = 12，即当table数组中存储的元素个数超过12个的时候，table数组就该扩容了。</p><p>当然Java中的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，然后将旧数组中的元素经过重新计算放到新数组中，那么怎样对旧元素进行重新映射呢？</p><p>其实很简单，由于我们在扩容时，是使用2的幂扩展，即数组的长度扩大到原来的2倍, 4倍, 8倍…，因此<strong>在resize时(Length - 1)这部分相当于在高位新增一个或多个1bit</strong>，我们以扩大到原来的两倍为例说明：</p><p><img src="/2019/10/16/ds-hashmap/rehash1.png" alt></p><p>(a)中n为16，(b)中n扩大到两倍为32，相当于(n - 1)这部分的高位多了一个1, 然后和原hash码作与操作，<strong>这样元素在数组中映射的位置要么不变，要不向后移动16个位置</strong>：</p><p><img src="/2019/10/16/ds-hashmap/rehash2.png" alt></p><p>因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="/2019/10/16/ds-hashmap/rehash3.png" alt></p><p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中resize的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p><p>JDK 1.8 以后哈希表的 添加、删除、查找、扩容方法都增加了一种 节点为 TreeNode 的情况：</p><ul><li>添加时，当桶中链表个数超过 8 时会转换成红黑树；</li><li>删除、扩容时，如果桶中结构为红黑树，并且树中元素个数太少的话，会进行修剪或者直接还原成链表结构；</li><li>查找时即使哈希函数不优，大量元素集中在一个桶中，由于有红黑树结构，性能也不会差。</li></ul><h2 id="HashMap死锁形成原理"><a href="#HashMap死锁形成原理" class="headerlink" title="HashMap死锁形成原理"></a>HashMap死锁形成原理</h2><p>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用线程安全的ConcurrentHashMap。</p><p>要理解HashMap死锁形成的原理，我们要对HashMap的resize里的transfer过程有所了解，transfer过程是将旧数组中的元素复制到新数组中，在Java 8之前，复制过程会导致链表倒置，这也是形成死锁的重要原因（Java 8中已经不会倒置），transfer的基本过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 新建节点e指向当前节点，新建节点next指向e.next</span><br><span class="line">2. 将e.next指向新数组中指定位置newTable[i]</span><br><span class="line">3. newTable[i] = e</span><br><span class="line">4. e = next</span><br></pre></td></tr></table></figure></p><p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现在有链表1-&gt;2-&gt;3，要将它复制到新数组的newTable[i]位置</span><br><span class="line">1. Node e = 1, next = e.next;</span><br><span class="line">2. e.next = newTable[i];</span><br><span class="line">3. newTable[i] = e;</span><br><span class="line">4. e = next, next = e.next;</span><br><span class="line">执行完后会得到这样的结果：</span><br><span class="line">newTable[i]=3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure></p><p>死锁会在这种情况产生：两个线程同时往HashMap里放Entry，同时HashMap正好需要扩容，如果一个线程已经完成了transfer过程，而另一个线程不知道，并且又要进行transfer的时候，死锁就会形成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在Thread1已将完成了transfer，newTable[i]=3-&gt;2-&gt;1</span><br><span class="line">在Thread2中:</span><br><span class="line">Node e = 1, next = e.next;</span><br><span class="line">e.next = newTable[i]    : 1 -&gt; newTable[i]=3</span><br><span class="line">newTable[i] = e         : newTable[i] = 1-&gt;3-&gt;2-&gt;1  //这时候链表换已经形成了</span><br></pre></td></tr></table></figure></p><p>在形成链表换以后再对HashMap进行Get操作时，就会形成死循环。</p><p>在Java 8中对这里进行了优化，链表复制到新数组时并不会倒置，不会因为多个线程put导致死循环，但是还有很多弊端，比如数据丢失等，因此多线程情况下还是建议使用ConcurrentHashMap。</p><h2 id="HashMap和Hashtable有什么区别"><a href="#HashMap和Hashtable有什么区别" class="headerlink" title="HashMap和Hashtable有什么区别"></a>HashMap和Hashtable有什么区别</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="/2019/10/16/ds-hashmap/hashmap-extends-tree.png" alt></p><p>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为<strong>ConcurrentHashMap引入了分段锁</strong>。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li><li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li><li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li><li>JDK1.8引入红黑树大程度优化了HashMap的性能。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xinxingastro.github.io/2018/05/11/Java/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">HashMap底层实现原理</a><br><a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">HashMap实现原理及源码分析</a><br><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android WebView 性能优化</title>
      <link href="/2019/09/26/android-webview/"/>
      <url>/2019/09/26/android-webview/</url>
      
        <content type="html"><![CDATA[<h2 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h2><p>这个比较容易，开启webView的缓存功能就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WebSettings settings = webView.getSettings();</span><br><span class="line">settings.setAppCacheEnabled(true);</span><br><span class="line">settings.setDatabaseEnabled(true);</span><br><span class="line">settings.setDomStorageEnabled(true);//开启DOM缓存，关闭的话H5自身的一些操作是无效的</span><br><span class="line">settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">settings.setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure></p><p>这边我们通过setCacheMode方法来设置WebView的缓存策略，WebSettings.LOAD_DEFAULT是默认的缓存策略，它在缓存可获取并且没有过期的情况下加载缓存，否则通过网络获取资源。这样的话可以减少页面的网络请求次数，那我们如何在离线的情况下也能打开页面呢，这里我们在加载页面的时候可以通过判断网络状态，<strong>在无网络的情况下更改webview的缓存策略</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">NetworkInfo info = cm.getActiveNetworkInfo();</span><br><span class="line">if(info.isAvailable())</span><br><span class="line">&#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">&#125;else </span><br><span class="line">&#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY);//不使用网络，只加载缓存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以使我们的混合应用在没有网络的情况下也能使用一部分的功能，不至于什么都显示不了了，当然如果我们将缓存做的更好一些，在网络好的时候，比如说在WIFI状态下，去后台加载一些网页缓存起来，这样处理的话，即使在无网络情况下第一次打开某些页面的时候，也能将该页面显示出来。<br>当然缓存资源后随之会带来一个问题，那就是<strong>资源无法及时更新，WebSettings.LOAD_DEFAULT中的页面中的缓存版本好像不是很起作用，所以我们这边可能需要自己做一个缓存版本控制</strong>。这个缓存版本控制可以放在APP版本更新中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (upgrade.cacheControl &gt; cacheControl)</span><br><span class="line">&#123;</span><br><span class="line">    webView.clearCache(true);//删除DOM缓存</span><br><span class="line">    VersionUtils.clearCache(mContext.getCacheDir());//删除APP缓存</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        mContext.deleteDatabase(&quot;webview.db&quot;);//删除数据库缓存</span><br><span class="line">        mContext.deleteDatabase(&quot;webviewCache.db&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>1.可以将 Webview 的 Activity 新起一个进程，结束的时候直接System.exit(0);退出当前进程；<br>启动新进程，主要代码： AndroidManifest.xml 配置文件代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.ui.activity.Html5Activity&quot;</span><br><span class="line">    android:process=&quot;:lyl.boon.process.web&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.lyl.boon.ui.activity.htmlactivity&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p><p>在新进程中启动 Activity ，里面传了 一个 Url：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.lyl.boon.ui.activity.htmlactivity&quot;);</span><br><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">bundle.putString(&quot;url&quot;, gankDataEntity.getUrl());</span><br><span class="line">intent.putExtra(&quot;bundle&quot;,bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p><p>然后在 Html5Activity 的onDestory() 最后加上 System.exit(0); 杀死当前进程。</p><p>Android7.0系统以后，WebView相对来说是比较稳定的，无论承载WebView的容器是否在主进程，都不需要担心WebView崩溃导致应用也跟着崩溃。然后7.0以下的系统就没有这么幸运了，特别是低版本的WebView。考虑应用的稳定性，我们可以把7.0以下系统的WebView使用一个独立进程的Activity来包装，这样即使WebView崩溃了，也只是WebView所在的进程发生了崩溃，主进程还是不受影响的。</p><p>2.不在xml中定义 Webview ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        mWebView = new WebView(getApplicationContext());</span><br><span class="line">        mWebView.setLayoutParams(params);</span><br><span class="line">        mLayout.addView(mWebView);</span><br></pre></td></tr></table></figure></p><p>3.在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        if (mWebView != null) &#123;</span><br><span class="line">            mWebView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);</span><br><span class="line">mWebView.getSettings().setJavaScriptEnabled(false);</span><br><span class="line">        mWebView.clearFormData();</span><br><span class="line">            mWebView.clearHistory();</span><br><span class="line">mWebView.stopLoading();</span><br><span class="line"></span><br><span class="line">            ((ViewGroup) mWebView.getParent()).removeView(mWebView);</span><br><span class="line">            mWebView.destroy();</span><br><span class="line">            mWebView = null;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>有时候一个页面资源比较多，图片，CSS，js比较多，还引用了JQuery这种庞然巨兽，从加载到页面渲染完成需要比较长的时间，有一个解决方案是<strong>将这些资源打包进APK里面，然后当页面加载这些资源的时候让它从本地获取</strong>，这样可以提升加载速度也能减少服务器压力。重写WebClient类中的shouldInterceptRequest方法，再将这个类设置给WebView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(new WebViewClient()</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public WebResourceResponse shouldInterceptRequest(WebView view, String url)</span><br><span class="line">    &#123;</span><br><span class="line">        if (url.contains(&quot;[tag]&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            String localPath = url.replaceFirst(&quot;^http.*[tag]\\]&quot;, &quot;&quot;);</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                InputStream is = getApplicationContext().getAssets().open(localPath);</span><br><span class="line">                Log.d(TAG, &quot;shouldInterceptRequest: localPath &quot; + localPath);</span><br><span class="line">                String mimeType = &quot;text/javascript&quot;;</span><br><span class="line">                if (localPath.endsWith(&quot;css&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                    mimeType = &quot;text/css&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                return new WebResourceResponse(mimeType, &quot;UTF-8&quot;, is);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里我们队页面中带有特殊标记的请求进行过滤替换，也就是上面代码中的[tag]，这个可以跟做后台开发的同事约定好来就行了。对图片资源或者其他资源进行替换也是可以的。补充一个小点<strong>可以通过settings.setLoadsImagesAutomatically(true);来设置在页面装载完成之后再去加载图片。</strong>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">webView.getSettings().setBlockNetworkImage(true);  </span><br><span class="line">webView.setWebChromeClient(new WebChromeClient() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void onProgressChanged(WebView view, int newProgress) &#123;  </span><br><span class="line">                if (newProgress == 100) &#123;  </span><br><span class="line">                    // 网页加载完成  </span><br><span class="line">                    loadDialog.dismiss();  </span><br><span class="line">                    webView.getSettings().setBlockNetworkImage(false);  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    // 网页加载中  </span><br><span class="line">                    loadDialog.show();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><h2 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h2><h3 id="SSL问题"><a href="#SSL问题" class="headerlink" title="SSL问题"></a>SSL问题</h3><p>通常情况下，通过WebView的loadUrl(String url)方法，可以顺利加载页面。但是，当load通过SSL加密的HTTPS页面时，如果这个页面的安全证书无法得到认证，WebView就会显示成空白页。</p><p>解决方式：<br>通过重写WebViewClient的onReceivedSslError方法来接受所有网站的证书，忽略SSL错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123;</span><br><span class="line">    handler.proceed();</span><br><span class="line">    super.onReceivedSslError(view, handler, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="低版本兼容问题"><a href="#低版本兼容问题" class="headerlink" title="低版本兼容问题"></a>低版本兼容问题</h3><p>由于现在h5大部分都是 vue的形式打包，（可能过个一两年就变了，但是万变不离其中），这个时候要注意了， 由于是webv加载的h5，在Android老的机型上  webview 内核可能不支持  最新的h5 框架，这时候 就需要我们找h5 的同学 搞事情了，  对于 vue，想要老机器不出现白屏其实也很简单，让h5的同学 做一下老版本的兼容，具体方法：</p><p>虽然vue-cli引入了babel对js语法进行降级，但是还是有些老旧的机型会发生各种各样的问题，这里需要引入一个叫babel-polyfill的包。所以你只需只在你引入import vue之前 import babel-polyfill进来就可以了，主要是为了让es6对个别机型做到兼容。</p><h2 id="301-302重定向问题"><a href="#301-302重定向问题" class="headerlink" title="301/302重定向问题"></a>301/302重定向问题</h2><p>WebView的301/302重定向问题，绝对在踩坑排行榜里名列前茅。。。随便搜了几个解决方案，要么不能满足业务需求，要么清一色没有彻底解决问题。</p><p><a href="https://stackoverflow.com/questions/4066438/android-webview-how-to-handle-redirects-in-app-instead-of-opening-a-browser" target="_blank" rel="noopener">https://stackoverflow.com/questions/4066438/android-webview-how-to-handle-redirects-in-app-instead-of-opening-a-browser</a><br><a href="http://blog.csdn.net/jdsjlzx/article/details/51698250" target="_blank" rel="noopener">http://blog.csdn.net/jdsjlzx/article/details/51698250</a><br><a href="http://www.cnblogs.com/pedro-neer/p/5318354.html" target="_blank" rel="noopener">http://www.cnblogs.com/pedro-neer/p/5318354.html</a><br><a href="http://www.jianshu.com/p/c01769ababfa" target="_blank" rel="noopener">http://www.jianshu.com/p/c01769ababfa</a></p><h3 id="301-302业务场景及白屏问题"><a href="#301-302业务场景及白屏问题" class="headerlink" title="301/302业务场景及白屏问题"></a>301/302业务场景及白屏问题</h3><p>先来分析一下业务场景。对于需要对url进行拦截以及在url中需要拼接特定参数的WebView来说，301和302发生的情景主要有以下几种：</p><ul><li>首次进入，有重定向，然后直接加载H5页面，如http跳转https</li><li>首次进入，有重定向，然后跳转到native页面，如扫一扫短链，然后跳转到native</li><li>二次加载，有重定向，跳转到native页面</li><li>对于考拉业务来说，还有类似登录后跳转到某个页面的需求。如我的拼团，未登录状态下点击我的拼团跳转到登录页面，登录完成后再加载我的拼团页。</li></ul><p>第一种情况属于正常情况，暂时没遇到什么坑。</p><p>第二种情况，会遇到<strong>WebView空白页问题</strong>，属于原始url不能拦截到native页面，但301/302后的url拦截到native页面的情况，当遇到这种情况时，需要把WebView对应的Activity结束，否则当用户从拦截后的页面返回上一个页面时，是一个WebView空白页。</p><p>第三种情况，也会遇到<strong>WebView空白页问题</strong>，原因在于加载的第一个页面发生了重定向到了第二个页面，第二个页面被客户端拦截跳转到native页面，那么WebView就停留在第一个页面的状态了，第一个页面显然是空白页。</p><p>第四种情况，会遇到<strong>无限加载登录页面的问题</strong>。考拉的登录链接是类似下面这种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://m.kaola.com/login.html?target=登录后跳转的url</span><br></pre></td></tr></table></figure></p><p>如果登录成功后还重新加载这个url，那么就会循环跳转到登录页面。第四点解决起来比较简单，登录成功以后拿到target后的跳转url再重新加载即可。</p><h3 id="301-302回退栈问题"><a href="#301-302回退栈问题" class="headerlink" title="301/302回退栈问题"></a>301/302回退栈问题</h3><p>无论是哪种重定向场景，都不可避免地会遇到回退栈的处理问题，如果处理不当，用户按返回键的时候不一定能回到重定向之前的那个页面。很多开发者在覆写WebViewClient.shouldOverrideUrlLoading()方法时，会简单地使用以下方式粗暴处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WebView.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">    view.loadUrl(url);</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>这种方法最致命的弱点就是如果不经过特殊处理，那么按返回键是没有效果的，还会停留在302之前的页面。现有的解决方案无非就几种：</p><ol><li>手动管理回退栈，遇到重定向时回退两次<a href="https://qbeenslee.com/article/android-webview-302-redirect/" target="_blank" rel="noopener">^6</a>。</li><li>通过HitTestResult判断是否是重定向，从而决定是否自己加载url<a href="https://www.cnblogs.com/zimengfang/p/6183869.html" target="_blank" rel="noopener">^7</a>。</li><li>通过设置标记位，在onPageStarted和onPageFinished分别标记变量避免重定向<a href="https://blog.csdn.net/dg_summer/article/details/78105582" target="_blank" rel="noopener">^9</a>。</li></ol><p>可以说，这几种解决方案都不是完美的，都有缺陷。以下给出301/302较优解决方案：</p><h3 id="解决301-302回退栈问题"><a href="#解决301-302回退栈问题" class="headerlink" title="解决301/302回退栈问题"></a>解决301/302回退栈问题</h3><p>能否结合上面的几种方案，来更加准确地判断301/302的情况呢？下面说一下本文的解决思路。在提供解决方案之前，我们需要了解一下shouldOverrideUrlLoading方法的返回值代表什么意思。</p><blockquote><p>Give the host application a chance to take over the control when a new url is about to be loaded in the current WebView. If WebViewClient is not provided, by default WebView will ask Activity Manager to choose the proper handler for the url. If WebViewClient is provided, return true means the host application handles the url, while return false means the current WebView handles the url.</p></blockquote><p>简单地说，就是返回true，那么url就已经由客户端处理了，WebView就不管了，如果返回false，那么当前的WebView实现就会去处理这个url。</p><p>WebView能否知道某个url是不是301/302呢？当然知道，WebView能够拿到url的请求信息和响应信息，根据header里的code很轻松就可以实现，事实正是如此，交给WebView来处理重定向(return false)，这时候按返回键，是可以正常地回到重定向之前的那个页面的。（PS：WebView在5.0以后是一个独立的apk，可以单独升级，新版本的WebView实现肯定处理了重定向问题）</p><p>但是，业务对url拦截有需求，肯定不能把所有的情况都交给系统WebView处理。为了解决url拦截问题，本文引入了另一种思想——通过用户的touch事件来判断重定向。下面通过代码来说明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * WebView基础类，处理一些基础的公有操作</span><br><span class="line"> *</span><br><span class="line"> * @author xingli</span><br><span class="line"> * @time 2017-12-06</span><br><span class="line"> */</span><br><span class="line">public class BaseWebView extends WebView &#123;</span><br><span class="line">    private boolean mTouchByUser;</span><br><span class="line">    public BaseWebView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line">    public BaseWebView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    public BaseWebView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void loadUrl(String url, Map&lt;String, String&gt; additionalHttpHeaders) &#123;</span><br><span class="line">        super.loadUrl(url, additionalHttpHeaders);</span><br><span class="line">        resetAllStateInternal(url);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void loadUrl(String url) &#123;</span><br><span class="line">        super.loadUrl(url);</span><br><span class="line">        resetAllStateInternal(url);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void postUrl(String url, byte[] postData) &#123;</span><br><span class="line">        super.postUrl(url, postData);</span><br><span class="line">        resetAllStateInternal(url);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void loadData(String data, String mimeType, String encoding) &#123;</span><br><span class="line">        super.loadData(data, mimeType, encoding);</span><br><span class="line">        resetAllStateInternal(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding,</span><br><span class="line">            String historyUrl) &#123;</span><br><span class="line">        super.loadDataWithBaseURL(baseUrl, data, mimeType, encoding, historyUrl);</span><br><span class="line">        resetAllStateInternal(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void reload() &#123;</span><br><span class="line">        super.reload();</span><br><span class="line">        resetAllStateInternal(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isTouchByUser() &#123;</span><br><span class="line">        return mTouchByUser;</span><br><span class="line">    &#125;</span><br><span class="line">    private void resetAllStateInternal(String url) &#123;</span><br><span class="line">        if (!TextUtils.isEmpty(url) &amp;&amp; url.startsWith(&quot;javascript:&quot;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        resetAllState();</span><br><span class="line">    &#125;</span><br><span class="line">// 加载url时重置touch状态</span><br><span class="line">    protected void resetAllState() &#123;</span><br><span class="line">        mTouchByUser = false;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">            //用户按下到下一个链接加载之前，置为true</span><br><span class="line">                mTouchByUser = true;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setWebViewClient(final WebViewClient client) &#123;</span><br><span class="line">        super.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">                boolean handleByChild = null != client &amp;&amp; client.shouldOverrideUrlLoading(view, url);</span><br><span class="line">               if (handleByChild) &#123;</span><br><span class="line">             // 开放client接口给上层业务调用，如果返回true，表示业务已处理。</span><br><span class="line">                    return true;</span><br><span class="line">               &#125; else if (!isTouchByUser()) &#123;</span><br><span class="line">             // 如果业务没有处理，并且在加载过程中用户没有再次触摸屏幕，认为是301/302事件，直接交由系统处理。</span><br><span class="line">                    return super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                //否则，属于二次加载某个链接的情况，为了解决拼接参数丢失问题，重新调用loadUrl方法添加固有参数。</span><br><span class="line">                    loadUrl(url);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @RequiresApi(api = Build.VERSION_CODES.N)</span><br><span class="line">            @Override</span><br><span class="line">            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123;</span><br><span class="line">                boolean handleByChild = null != client &amp;&amp; client.shouldOverrideUrlLoading(view, request);</span><br><span class="line">                if (handleByChild) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (!isTouchByUser()) &#123;</span><br><span class="line">                    return super.shouldOverrideUrlLoading(view, request);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    loadUrl(request.getUrl().toString());</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码解决了正常情况下的回退栈问题。</p><h3 id="解决业务白屏问题"><a href="#解决业务白屏问题" class="headerlink" title="解决业务白屏问题"></a>解决业务白屏问题</h3><p>为了解决白屏问题，考拉目前的解决思路和上面的回退栈问题思路有些类似，通过监听touch事件分发以及onPageFinished事件来判断是否产生白屏，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">public class KaolaWebview extends BaseWebView implements DownloadListener, Lifeful, OnActivityResultListener &#123;</span><br><span class="line">    private boolean mIsBlankPageRedirect;  //是否因重定向导致的空白页面。</span><br><span class="line">    public KaolaWebview(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    public KaolaWebview(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    public KaolaWebview(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    protected void back() &#123;</span><br><span class="line">        if (mBackStep &lt; 1) &#123;</span><br><span class="line">            mJsApi.trigger2(&quot;kaolaGoback&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            realBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            mIsBlankPageRedirect = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    private WebViewClient mWebViewClient = new WebViewClient() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">            url = WebViewUtils.removeBlank(url);</span><br><span class="line">            //允许启动第三方应用客户端</span><br><span class="line">            if (WebViewUtils.canHandleUrl(url)) &#123;</span><br><span class="line">                boolean handleByCaller = false;</span><br><span class="line">                // 如果不是用户触发的操作，就没有必要交给上层处理了，直接走url拦截规则。</span><br><span class="line">                if (null != mIWebViewClient &amp;&amp; isTouchByUser()) &#123;</span><br><span class="line">                    handleByCaller = mIWebViewClient.shouldOverrideUrlLoading(view, url);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!handleByCaller) &#123;</span><br><span class="line">                    handleByCaller = handleOverrideUrl(url);</span><br><span class="line">                &#125;</span><br><span class="line">                return handleByCaller || super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    notifyBeforeLoadUrl(url);</span><br><span class="line">                    Intent intent = Intent.parseUri(url, Intent.URI_INTENT_SCHEME);</span><br><span class="line">                    intent.addCategory(Intent.CATEGORY_BROWSABLE);</span><br><span class="line">                    mContext.startActivity(intent);</span><br><span class="line">                    if (!mIsBlankPageRedirect) &#123;</span><br><span class="line">                    // 如果遇到白屏问题，手动后退</span><br><span class="line">                        back();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    ExceptionUtils.printExceptionTrace(e);</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @RequiresApi(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">        @Override</span><br><span class="line">        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123;</span><br><span class="line">            return shouldOverrideUrlLoading(view, request.getUrl().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        private boolean handleOverrideUrl(final String url) &#123;</span><br><span class="line">           RouterResult result =  WebActivityRouter.startFromWeb(</span><br><span class="line">                    new IntentBuilder(mContext, url).setRouterActivityResult(new RouterActivityResult() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onActivityFound() &#123;</span><br><span class="line">                            if (!mIsBlankPageRedirect) &#123;</span><br><span class="line">                    // 路由已经拦截到跳转到native页面，但此时可能发生了</span><br><span class="line">                    // 301/302跳转，那么执行后退动作，防止白屏。</span><br><span class="line">                                back();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onActivityNotFound() &#123;</span><br><span class="line">                            if (mIWebViewClient != null) &#123;</span><br><span class="line">                                mIWebViewClient.onActivityNotFound();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">            return result.isSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPageFinished(WebView view, String url) &#123;</span><br><span class="line">        mIsBlankPageRedirect = true;</span><br><span class="line">        if (null != mIWebViewClient) &#123;</span><br><span class="line">            mIWebViewClient.onPageReallyFinish(view, url);</span><br><span class="line">        &#125;</span><br><span class="line">        super.onPageFinished(view, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本来上面的两个问题可以用同一个变量控制解决的，但由于历史代码遗留问题，目前还没有时间优化测试，这也是代码暂不公布的原因之一。</p><h2 id="loadUrl-url-map-方法加载带hash（带-号）的url导致刷新问题或请求头缓存问题"><a href="#loadUrl-url-map-方法加载带hash（带-号）的url导致刷新问题或请求头缓存问题" class="headerlink" title="loadUrl(url,map)方法加载带hash（带#号）的url导致刷新问题或请求头缓存问题"></a>loadUrl(url,map)方法加载带hash（带#号）的url导致刷新问题或请求头缓存问题</h2><p>1.如果调用loadUrl(url,map)方法去加载资源，那么在此调用loadUrl(ur),reload,loadUrl(url,map)造成无法刷新的问题。这个现象主要出现在Android 8.0的系统中。<br>可尝试调用如下url尝试：</p><pre><code>https://baike.baidu.com/item/%E9%83%8E%E5%B9%B3/58857#/https://baike.baidu.com/item/%E9%83%8E%E5%B9%B3/58857#/?a=123https://baike.baidu.com/item/%E9%83%8E%E5%B9%B3/58857#3</code></pre><p>2.loadUrl(url,map) 第二个参数map中传入的数据用于请求头，此外这个请求头数据会被webview缓存下来，刷新时，请求头中的数据还是原来的，因此，不适用传入需要进程变化的“状态”信息。</p><p>解决方法：不要使用loadUrl(url,map)，推荐使用loadUrl(url)，如果非要传输参数，还不如在url中添加参数。</p><h2 id="是否应该开启硬件加速"><a href="#是否应该开启硬件加速" class="headerlink" title="是否应该开启硬件加速"></a>是否应该开启硬件加速</h2><p>由于碎片化问题太多，建议保持默认状态【默认表示由系统决定，不要手动设置】，否则可能产生问题。</p><h2 id="Cookie同步导致的内存泄漏"><a href="#Cookie同步导致的内存泄漏" class="headerlink" title="Cookie同步导致的内存泄漏"></a>Cookie同步导致的内存泄漏</h2><p>使用CookieSyncManager同步时，会永久引用第一个acitivity的的Context，为了避免此种情况，请使用ApplicationContext<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> if (Build.VERSION.SDK_INT &lt; 21) &#123;</span><br><span class="line">        android.webkit.CookieSyncManager.createInstance(context.getApplicationContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Android5-0-WebView中Http和Https混合问题"><a href="#Android5-0-WebView中Http和Https混合问题" class="headerlink" title="Android5.0 WebView中Http和Https混合问题"></a>Android5.0 WebView中Http和Https混合问题</h2><p>在Android 5.0上 Webview 默认不允许加载 Http 与 Https 混合内容：</p><p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">     webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参数类型说明：<br>MIXED_CONTENT_ALWAYS_ALLOW：允许从任何来源加载内容，即使起源是不安全的；<br>MIXED_CONTENT_NEVER_ALLOW：不允许Https加载Http的内容，即不允许从安全的起源去加载一个不安全的资源；<br>MIXED_CONTENT_COMPATIBILITY_MODE：当涉及到混合式内容时，WebView 会尝试去兼容最新Web浏览器的风格。</p><p>在5.0以下 Android 默认是 全允许，但是到了5.0以上，就是不允许，实际情况下很我们很难确定所有的网页都是https的，所以就需要这一步的操作。</p><h2 id="onPageFinished被调用多次"><a href="#onPageFinished被调用多次" class="headerlink" title="onPageFinished被调用多次"></a>onPageFinished被调用多次</h2><p>使用onPageProgressChanged代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void  handleProgress(WebView view, int newProgress)&#123;</span><br><span class="line">    if(progressPending.get()!=newProgress)&#123;</span><br><span class="line">        progressPending.set(newProgress);</span><br><span class="line">        onProgressChanged(newProgress);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final void onProgressChanged(WebView view, int newProgress) &#123;</span><br><span class="line">    super.onProgressChanged(view, newProgress);</span><br><span class="line">    handleProgress(view,newProgress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onProgressChanged(int newProgress)&#123;</span><br><span class="line">   Log.i(&quot;WebChromeClient&quot;,&quot;progress=&quot;+newProgress+&quot;%&quot;);</span><br><span class="line">   if(newProgress==100)&#123;</span><br><span class="line">       Log.i(&quot;WebChromeClient&quot;,&quot;加载完成&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="H5优化"><a href="#H5优化" class="headerlink" title="H5优化"></a>H5优化</h2><p>Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使 用JQuery，会在处理完DOM对象，执行完$(document).ready(function() {});事件自会后才会渲染并显示页面。而同样的页面在iPhone上却是载入相当的快，因为iPhone是显示完页面才会触发脚本的执行。所以我们这边的解决方案延迟JS脚本的载入，这个方面的问题是需要Web前端工程师帮忙优化的，网上应该有比较多LazyLoad插件，这里放一个比较老的链接<a href="https://wonko.com/post/painless_javascript_lazy_loading_with_lazyload/" target="_blank" rel="noopener">Painless JavaScript lazy loading with LazyLoad</a>,同样也放上一小段前端代码，仅供参考。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;/css/j/lazyload-min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  loadComplete() &#123;</span><br><span class="line">    //instead of document.read();</span><br><span class="line">  &#125; </span><br><span class="line">  function loadscript() &#123;</span><br><span class="line">    LazyLoad.loadOnce([</span><br><span class="line">      &apos;/css/j/jquery-1.6.2.min.js&apos;,</span><br><span class="line">      &apos;/css/j/flow/jquery.flow.1.1.min.js&apos;,</span><br><span class="line">      &apos;/css/j/min.js?v=2011100852&apos;</span><br><span class="line">      ], loadComplete);</span><br><span class="line">  &#125;</span><br><span class="line">  setTimeout(loadscript,10);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/427600ca2107" target="_blank" rel="noopener">https://www.jianshu.com/p/427600ca2107</a><br><a href="https://my.oschina.net/ososchina/blog/1799575" target="_blank" rel="noopener">https://my.oschina.net/ososchina/blog/1799575</a><br><a href="https://iluhcm.com/2017/12/10/design-an-elegant-and-powerful-android-webview-part-one/" target="_blank" rel="noopener">https://iluhcm.com/2017/12/10/design-an-elegant-and-powerful-android-webview-part-one/</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android ListView原理完全解析</title>
      <link href="/2019/09/05/android-listview/"/>
      <url>/2019/09/05/android-listview/</url>
      
        <content type="html"><![CDATA[<p>ListView的结构，如下图所示：</p><p><img src="/2019/09/05/android-listview/listview.png" alt></p><h2 id="Adapter作用"><a href="#Adapter作用" class="headerlink" title="Adapter作用"></a>Adapter作用</h2><p>Adapter是适配器的意思，它在ListView和数据源之间起到了一个桥梁的作用，ListView并不会直接和数据源打交道，而是会借助Adapter这个桥梁来去访问真正的数据源，与之前不同的是，Adapter的接口都是统一的，因此ListView不用再去担心任何适配方面的问题。而Adapter又是一个接口(interface)，它可以去实现各种各样的子类，每个子类都能通过自己的逻辑来去完成特定的功能，以及与特定数据源的适配操作，比如说ArrayAdapter可以用于数组和List类型的数据源适配，SimpleCursorAdapter可以用于游标类型的数据源适配，这样就非常巧妙地把数据源适配困难的问题解决掉了，并且还拥有相当不错的扩展性。简单的原理示意图如下所示：</p><p>当然Adapter的作用不仅仅只有<strong>数据源适配</strong>这一点，还有一个非常非常重要的方法也需要我们在Adapter当中去重写，就是getView()方法</p><h2 id="RecycleBin机制"><a href="#RecycleBin机制" class="headerlink" title="RecycleBin机制"></a>RecycleBin机制</h2><p>在开始分析ListView的源码之前，还有一个东西是我们提前需要了解的，就是RecycleBin机制，这个机制也是ListView能够实现成百上千条数据都不会OOM最重要的一个原因。其实RecycleBin的代码并不多，它是写在AbsListView中的一个内部类，所以所有继承自AbsListView的子类，也就是ListView和GridView，都可以使用这个机制。那我们来看一下RecycleBin中的主要代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The RecycleBin facilitates reuse of views across layouts. The RecycleBin</span><br><span class="line"> * has two levels of storage: ActiveViews and ScrapViews. ActiveViews are</span><br><span class="line"> * those views which were onscreen at the start of a layout. By</span><br><span class="line"> * construction, they are displaying current information. At the end of</span><br><span class="line"> * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews</span><br><span class="line"> * are old views that could potentially be used by the adapter to avoid</span><br><span class="line"> * allocating views unnecessarily.</span><br><span class="line"> * </span><br><span class="line"> * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener)</span><br><span class="line"> * @see android.widget.AbsListView.RecyclerListener</span><br><span class="line"> */</span><br><span class="line">class RecycleBin &#123;</span><br><span class="line">private RecyclerListener mRecyclerListener;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * The position of the first view stored in mActiveViews.</span><br><span class="line"> */</span><br><span class="line">private int mFirstActivePosition;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Views that were on screen at the start of layout. This array is</span><br><span class="line"> * populated at the start of layout, and at the end of layout all view</span><br><span class="line"> * in mActiveViews are moved to mScrapViews. Views in mActiveViews</span><br><span class="line"> * represent a contiguous range of Views, with position of the first</span><br><span class="line"> * view store in mFirstActivePosition.</span><br><span class="line"> */</span><br><span class="line">private View[] mActiveViews = new View[0];</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Unsorted views that can be used by the adapter as a convert view.</span><br><span class="line"> */</span><br><span class="line">private ArrayList&lt;View&gt;[] mScrapViews;</span><br><span class="line"> </span><br><span class="line">private int mViewTypeCount;</span><br><span class="line"> </span><br><span class="line">private ArrayList&lt;View&gt; mCurrentScrap;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Fill ActiveViews with all of the children of the AbsListView.</span><br><span class="line"> * </span><br><span class="line"> * @param childCount</span><br><span class="line"> *            The minimum number of views mActiveViews should hold</span><br><span class="line"> * @param firstActivePosition</span><br><span class="line"> *            The position of the first view that will be stored in</span><br><span class="line"> *            mActiveViews</span><br><span class="line"> */</span><br><span class="line">void fillActiveViews(int childCount, int firstActivePosition) &#123;</span><br><span class="line">if (mActiveViews.length &lt; childCount) &#123;</span><br><span class="line">mActiveViews = new View[childCount];</span><br><span class="line">&#125;</span><br><span class="line">mFirstActivePosition = firstActivePosition;</span><br><span class="line">final View[] activeViews = mActiveViews;</span><br><span class="line">for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">View child = getChildAt(i);</span><br><span class="line">AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">// Don&apos;t put header or footer views into the scrap heap</span><br><span class="line">if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">// Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in</span><br><span class="line">// active views.</span><br><span class="line">// However, we will NOT place them into scrap views.</span><br><span class="line">activeViews[i] = child;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Get the view corresponding to the specified position. The view will</span><br><span class="line"> * be removed from mActiveViews if it is found.</span><br><span class="line"> * </span><br><span class="line"> * @param position</span><br><span class="line"> *            The position to look up in mActiveViews</span><br><span class="line"> * @return The view if it is found, null otherwise</span><br><span class="line"> */</span><br><span class="line">View getActiveView(int position) &#123;</span><br><span class="line">int index = position - mFirstActivePosition;</span><br><span class="line">final View[] activeViews = mActiveViews;</span><br><span class="line">if (index &gt;= 0 &amp;&amp; index &lt; activeViews.length) &#123;</span><br><span class="line">final View match = activeViews[index];</span><br><span class="line">activeViews[index] = null;</span><br><span class="line">return match;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Put a view into the ScapViews list. These views are unordered.</span><br><span class="line"> * </span><br><span class="line"> * @param scrap</span><br><span class="line"> *            The view to add</span><br><span class="line"> */</span><br><span class="line">void addScrapView(View scrap) &#123;</span><br><span class="line">AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();</span><br><span class="line">if (lp == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// Don&apos;t put header or footer views or views that should be ignored</span><br><span class="line">// into the scrap heap</span><br><span class="line">int viewType = lp.viewType;</span><br><span class="line">if (!shouldRecycleViewType(viewType)) &#123;</span><br><span class="line">if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">removeDetachedView(scrap, false);</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (mViewTypeCount == 1) &#123;</span><br><span class="line">dispatchFinishTemporaryDetach(scrap);</span><br><span class="line">mCurrentScrap.add(scrap);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dispatchFinishTemporaryDetach(scrap);</span><br><span class="line">mScrapViews[viewType].add(scrap);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (mRecyclerListener != null) &#123;</span><br><span class="line">mRecyclerListener.onMovedToScrapHeap(scrap);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * @return A view from the ScrapViews collection. These are unordered.</span><br><span class="line"> */</span><br><span class="line">View getScrapView(int position) &#123;</span><br><span class="line">ArrayList&lt;View&gt; scrapViews;</span><br><span class="line">if (mViewTypeCount == 1) &#123;</span><br><span class="line">scrapViews = mCurrentScrap;</span><br><span class="line">int size = scrapViews.size();</span><br><span class="line">if (size &gt; 0) &#123;</span><br><span class="line">return scrapViews.remove(size - 1);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">int whichScrap = mAdapter.getItemViewType(position);</span><br><span class="line">if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) &#123;</span><br><span class="line">scrapViews = mScrapViews[whichScrap];</span><br><span class="line">int size = scrapViews.size();</span><br><span class="line">if (size &gt; 0) &#123;</span><br><span class="line">return scrapViews.remove(size - 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void setViewTypeCount(int viewTypeCount) &#123;</span><br><span class="line">if (viewTypeCount &lt; 1) &#123;</span><br><span class="line">throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// noinspection unchecked</span><br><span class="line">ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];</span><br><span class="line">for (int i = 0; i &lt; viewTypeCount; i++) &#123;</span><br><span class="line">scrapViews[i] = new ArrayList&lt;View&gt;();</span><br><span class="line">&#125;</span><br><span class="line">mViewTypeCount = viewTypeCount;</span><br><span class="line">mCurrentScrap = scrapViews[0];</span><br><span class="line">mScrapViews = scrapViews;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的RecycleBin代码并不全，只是把最主要的几个方法提了出来。那么我们先来对这几个方法进行简单解读，这对后面分析ListView的工作原理将会有很大的帮助:</p><ul><li><p><strong>fillActiveViews()</strong> 这个方法接收两个参数，第一个参数表示要存储的view的数量，第二个参数表示ListView中第一个可见元素的position值。RecycleBin当中使用mActiveViews这个数组来存储View，调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews数组当中。</p></li><li><p><strong>getActiveView()</strong> 这个方法和fillActiveViews()是对应的，用于从mActiveViews数组当中获取数据。该方法接收一个position参数，表示元素在ListView当中的位置，方法内部会自动将position值转换成mActiveViews数组对应的下标值。需要注意的是，mActiveViews当中所存储的View，一旦被获取了之后就会从mActiveViews当中移除，下次获取同样位置的View将会返回null，也就是说mActiveViews不能被重复利用。</p></li><li><p><strong>addScrapView()</strong> 用于将一个废弃的View进行缓存，该方法接收一个View参数，当有某个View确定要废弃掉的时候(比如滚动出了屏幕)，就应该调用这个方法来对View进行缓存，RecycleBin当中使用mScrapViews和mCurrentScrap这两个List来存储废弃View。</p></li><li><p><strong>getScrapView()</strong> 用于从废弃缓存中取出一个View，这些废弃缓存中的View是没有顺序可言的，因此getScrapView()方法中的算法也非常简单，就是直接从mCurrentScrap当中获取尾部的一个scrap view进行返回。</p></li><li><p><strong>setViewTypeCount()</strong> 我们都知道Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，而setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。实际上，getViewTypeCount()方法通常情况下使用的并不是很多，所以我们只要知道RecycleBin当中有这样一个功能就行了。</p></li></ul><h2 id="第一次Layout"><a href="#第一次Layout" class="headerlink" title="第一次Layout"></a>第一次Layout</h2><p>不管怎么说，ListView即使再特殊最终还是继承自View的，因此它的执行流程还将会按照View的规则来执行。</p><p>View的执行流程无非就分为三步，onMeasure()用于测量View的大小，onLayout()用于确定View的布局，onDraw()用于将View绘制到界面上。而在ListView当中，onMeasure()并没有什么特殊的地方，因为它终归是一个View，占用的空间最多并且通常也就是整个屏幕。onDraw()在ListView当中也没有什么意义，因为ListView本身并不负责绘制，而是由ListView当中的子元素来进行绘制的。那么ListView大部分的神奇功能其实都是在onLayout()方法中进行的了，因此我们本篇文章也是主要分析的这个方法里的内容。</p><p>如果你到ListView源码中去找一找，你会发现ListView中是没有onLayout()这个方法的，这是因为这个方法是在ListView的父类AbsListView中实现的，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Subclasses should NOT override this method but &#123;@link #layoutChildren()&#125;</span><br><span class="line"> * instead.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">super.onLayout(changed, l, t, r, b);</span><br><span class="line">mInLayout = true;</span><br><span class="line">if (changed) &#123;</span><br><span class="line">int childCount = getChildCount();</span><br><span class="line">for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">getChildAt(i).forceLayout();</span><br><span class="line">&#125;</span><br><span class="line">mRecycler.markChildrenDirty();</span><br><span class="line">&#125;</span><br><span class="line">layoutChildren();</span><br><span class="line">mInLayout = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<strong>onLayout()方法中主要就是一个判断，如果ListView的大小或者位置发生了变化，那么changed变量就会变成true，此时会要求所有的子布局都强制进行重绘</strong>。除此之外倒没有什么难理解的地方了，不过我们注意到，在第16行调用了layoutChildren()这个方法，从方法名上我们就可以猜出这个方法是用来进行子元素布局的。那么进入ListView的layoutChildren()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void layoutChildren() &#123;</span><br><span class="line">    final boolean blockLayoutRequests = mBlockLayoutRequests;</span><br><span class="line">    if (!blockLayoutRequests) &#123;</span><br><span class="line">        mBlockLayoutRequests = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        super.layoutChildren();</span><br><span class="line">        invalidate();</span><br><span class="line">        if (mAdapter == null) &#123;</span><br><span class="line">            resetList();</span><br><span class="line">            invokeOnItemScrollListener();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int childrenTop = mListPadding.top;</span><br><span class="line">        int childrenBottom = getBottom() - getTop() - mListPadding.bottom;</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        int index = 0;</span><br><span class="line">        int delta = 0;</span><br><span class="line">        View sel;</span><br><span class="line">        View oldSel = null;</span><br><span class="line">        View oldFirst = null;</span><br><span class="line">        View newSel = null;</span><br><span class="line">        View focusLayoutRestoreView = null;</span><br><span class="line">        // Remember stuff we will need down below</span><br><span class="line">        switch (mLayoutMode) &#123;</span><br><span class="line">        case LAYOUT_SET_SELECTION:</span><br><span class="line">            index = mNextSelectedPosition - mFirstPosition;</span><br><span class="line">            if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</span><br><span class="line">                newSel = getChildAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_FORCE_TOP:</span><br><span class="line">        case LAYOUT_FORCE_BOTTOM:</span><br><span class="line">        case LAYOUT_SPECIFIC:</span><br><span class="line">        case LAYOUT_SYNC:</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_MOVE_SELECTION:</span><br><span class="line">        default:</span><br><span class="line">            // Remember the previously selected view</span><br><span class="line">            index = mSelectedPosition - mFirstPosition;</span><br><span class="line">            if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</span><br><span class="line">                oldSel = getChildAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            // Remember the previous first child</span><br><span class="line">            oldFirst = getChildAt(0);</span><br><span class="line">            if (mNextSelectedPosition &gt;= 0) &#123;</span><br><span class="line">                delta = mNextSelectedPosition - mSelectedPosition;</span><br><span class="line">            &#125;</span><br><span class="line">            // Caution: newSel might be null</span><br><span class="line">            newSel = getChildAt(index + delta);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean dataChanged = mDataChanged;</span><br><span class="line">        if (dataChanged) &#123;</span><br><span class="line">            handleDataChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        // Handle the empty set by removing all views that are visible</span><br><span class="line">        // and calling it a day</span><br><span class="line">        if (mItemCount == 0) &#123;</span><br><span class="line">            resetList();</span><br><span class="line">            invokeOnItemScrollListener();</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (mItemCount != mAdapter.getCount()) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;</span><br><span class="line">                    + &quot;ListView did not receive a notification. Make sure the content of &quot;</span><br><span class="line">                    + &quot;your adapter is not modified from a background thread, but only &quot;</span><br><span class="line">                    + &quot;from the UI thread. [in ListView(&quot; + getId() + &quot;, &quot; + getClass() </span><br><span class="line">                    + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        setSelectedPositionInt(mNextSelectedPosition);</span><br><span class="line">        // Pull all children into the RecycleBin.</span><br><span class="line">        // These views will be reused if possible</span><br><span class="line">        final int firstPosition = mFirstPosition;</span><br><span class="line">        final RecycleBin recycleBin = mRecycler;</span><br><span class="line">        // reset the focus restoration</span><br><span class="line">        View focusLayoutRestoreDirectChild = null;</span><br><span class="line">        // Don&apos;t put header or footer views into the Recycler. Those are</span><br><span class="line">        // already cached in mHeaderViews;</span><br><span class="line">        if (dataChanged) &#123;</span><br><span class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">                recycleBin.addScrapView(getChildAt(i));</span><br><span class="line">                if (ViewDebug.TRACE_RECYCLER) &#123;</span><br><span class="line">                    ViewDebug.trace(getChildAt(i),</span><br><span class="line">                            ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            recycleBin.fillActiveViews(childCount, firstPosition);</span><br><span class="line">        &#125;</span><br><span class="line">        // take focus back to us temporarily to avoid the eventual</span><br><span class="line">        // call to clear focus when removing the focused child below</span><br><span class="line">        // from messing things up when ViewRoot assigns focus back</span><br><span class="line">        // to someone else</span><br><span class="line">        final View focusedChild = getFocusedChild();</span><br><span class="line">        if (focusedChild != null) &#123;</span><br><span class="line">            // TODO: in some cases focusedChild.getParent() == null</span><br><span class="line">            // we can remember the focused view to restore after relayout if the</span><br><span class="line">            // data hasn&apos;t changed, or if the focused position is a header or footer</span><br><span class="line">            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) &#123;</span><br><span class="line">                focusLayoutRestoreDirectChild = focusedChild;</span><br><span class="line">                // remember the specific view that had focus</span><br><span class="line">                focusLayoutRestoreView = findFocus();</span><br><span class="line">                if (focusLayoutRestoreView != null) &#123;</span><br><span class="line">                    // tell it we are going to mess with it</span><br><span class="line">                    focusLayoutRestoreView.onStartTemporaryDetach();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            requestFocus();</span><br><span class="line">        &#125;</span><br><span class="line">        // Clear out old views</span><br><span class="line">        detachAllViewsFromParent();</span><br><span class="line">        switch (mLayoutMode) &#123;</span><br><span class="line">        case LAYOUT_SET_SELECTION:</span><br><span class="line">            if (newSel != null) &#123;</span><br><span class="line">                sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sel = fillFromMiddle(childrenTop, childrenBottom);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_SYNC:</span><br><span class="line">            sel = fillSpecific(mSyncPosition, mSpecificTop);</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_FORCE_BOTTOM:</span><br><span class="line">            sel = fillUp(mItemCount - 1, childrenBottom);</span><br><span class="line">            adjustViewsUpOrDown();</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_FORCE_TOP:</span><br><span class="line">            mFirstPosition = 0;</span><br><span class="line">            sel = fillFromTop(childrenTop);</span><br><span class="line">            adjustViewsUpOrDown();</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_SPECIFIC:</span><br><span class="line">            sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_MOVE_SELECTION:</span><br><span class="line">            sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            if (childCount == 0) &#123;</span><br><span class="line">                if (!mStackFromBottom) &#123;</span><br><span class="line">                    final int position = lookForSelectablePosition(0, true);</span><br><span class="line">                    setSelectedPositionInt(position);</span><br><span class="line">                    sel = fillFromTop(childrenTop);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final int position = lookForSelectablePosition(mItemCount - 1, false);</span><br><span class="line">                    setSelectedPositionInt(position);</span><br><span class="line">                    sel = fillUp(mItemCount - 1, childrenBottom);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</span><br><span class="line">                    sel = fillSpecific(mSelectedPosition,</span><br><span class="line">                            oldSel == null ? childrenTop : oldSel.getTop());</span><br><span class="line">                &#125; else if (mFirstPosition &lt; mItemCount) &#123;</span><br><span class="line">                    sel = fillSpecific(mFirstPosition,</span><br><span class="line">                            oldFirst == null ? childrenTop : oldFirst.getTop());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sel = fillSpecific(0, childrenTop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // Flush any cached views that did not get reused above</span><br><span class="line">        recycleBin.scrapActiveViews();</span><br><span class="line">        if (sel != null) &#123;</span><br><span class="line">            // the current selected item should get focus if items</span><br><span class="line">            // are focusable</span><br><span class="line">            if (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123;</span><br><span class="line">                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp;</span><br><span class="line">                        focusLayoutRestoreView.requestFocus()) || sel.requestFocus();</span><br><span class="line">                if (!focusWasTaken) &#123;</span><br><span class="line">                    // selected item didn&apos;t take focus, fine, but still want</span><br><span class="line">                    // to make sure something else outside of the selected view</span><br><span class="line">                    // has focus</span><br><span class="line">                    final View focused = getFocusedChild();</span><br><span class="line">                    if (focused != null) &#123;</span><br><span class="line">                        focused.clearFocus();</span><br><span class="line">                    &#125;</span><br><span class="line">                    positionSelector(sel);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sel.setSelected(false);</span><br><span class="line">                    mSelectorRect.setEmpty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                positionSelector(sel);</span><br><span class="line">            &#125;</span><br><span class="line">            mSelectedTop = sel.getTop();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mTouchMode &gt; TOUCH_MODE_DOWN &amp;&amp; mTouchMode &lt; TOUCH_MODE_SCROLL) &#123;</span><br><span class="line">                View child = getChildAt(mMotionPosition - mFirstPosition);</span><br><span class="line">                if (child != null) positionSelector(child);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mSelectedTop = 0;</span><br><span class="line">                mSelectorRect.setEmpty();</span><br><span class="line">            &#125;</span><br><span class="line">            // even if there is not selected position, we may need to restore</span><br><span class="line">            // focus (i.e. something focusable in touch mode)</span><br><span class="line">            if (hasFocus() &amp;&amp; focusLayoutRestoreView != null) &#123;</span><br><span class="line">                focusLayoutRestoreView.requestFocus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // tell focus view we are done mucking with it, if it is still in</span><br><span class="line">        // our view hierarchy.</span><br><span class="line">        if (focusLayoutRestoreView != null</span><br><span class="line">                &amp;&amp; focusLayoutRestoreView.getWindowToken() != null) &#123;</span><br><span class="line">            focusLayoutRestoreView.onFinishTemporaryDetach();</span><br><span class="line">        &#125;</span><br><span class="line">        mLayoutMode = LAYOUT_NORMAL;</span><br><span class="line">        mDataChanged = false;</span><br><span class="line">        mNeedSync = false;</span><br><span class="line">        setNextSelectedPositionInt(mSelectedPosition);</span><br><span class="line">        updateScrollIndicators();</span><br><span class="line">        if (mItemCount &gt; 0) &#123;</span><br><span class="line">            checkSelectionChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        invokeOnItemScrollListener();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!blockLayoutRequests) &#123;</span><br><span class="line">            mBlockLayoutRequests = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码比较长，我们挑重点的看。首先可以确定的是，ListView当中目前还没有任何子View，数据都还是由Adapter管理的，并没有展示到界面上，因此第19行getChildCount()方法得到的值肯定是0。接着在第81行会根据dataChanged这个布尔型的值来判断执行逻辑，dataChanged只有在数据源发生改变的情况下才会变成true，其它情况都是false，因此这里会进入到第90行的执行逻辑，调用RecycleBin的fillActiveViews()方法。按理来说，调用fillActiveViews()方法是为了将ListView的子View进行缓存的，可是目前ListView中还没有任何的子View，因此这一行暂时还起不了任何作用。</p><p>接下来在第114行会根据mLayoutMode的值来决定布局模式，默认情况下都是普通模式LAYOUT_NORMAL，因此会进入到第140行的default语句当中。而下面又会紧接着进行两次if判断，childCount目前是等于0的，并且默认的布局顺序是从上往下，因此会进入到第145行的fillFromTop()方法，我们跟进去瞧一瞧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Fills the list from top to bottom, starting with mFirstPosition</span><br><span class="line"> *</span><br><span class="line"> * @param nextTop The location where the top of the first item should be</span><br><span class="line"> *        drawn</span><br><span class="line"> *</span><br><span class="line"> * @return The view that is currently selected</span><br><span class="line"> */</span><br><span class="line">private View fillFromTop(int nextTop) &#123;</span><br><span class="line">    mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);</span><br><span class="line">    mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);</span><br><span class="line">    if (mFirstPosition &lt; 0) &#123;</span><br><span class="line">        mFirstPosition = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return fillDown(mFirstPosition, nextTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这个方法的注释中可以看出，它所负责的主要任务就是从mFirstPosition开始，自顶至底去填充ListView。而这个方法本身并没有什么逻辑，就是判断了一下mFirstPosition值的合法性，然后调用fillDown()方法，那么我们就有理由可以猜测，填充ListView的操作是在fillDown()方法中完成的。进入fillDown()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Fills the list from pos down to the end of the list view.</span><br><span class="line"> *</span><br><span class="line"> * @param pos The first position to put in the list</span><br><span class="line"> *</span><br><span class="line"> * @param nextTop The location where the top of the item associated with pos</span><br><span class="line"> *        should be drawn</span><br><span class="line"> *</span><br><span class="line"> * @return The view that is currently selected, if it happens to be in the</span><br><span class="line"> *         range that we draw.</span><br><span class="line"> */</span><br><span class="line">private View fillDown(int pos, int nextTop) &#123;</span><br><span class="line">    View selectedView = null;</span><br><span class="line">    int end = (getBottom() - getTop()) - mListPadding.bottom;</span><br><span class="line">    while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123;</span><br><span class="line">        // is this the selected item?</span><br><span class="line">        boolean selected = pos == mSelectedPosition;</span><br><span class="line">        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);</span><br><span class="line">        nextTop = child.getBottom() + mDividerHeight;</span><br><span class="line">        if (selected) &#123;</span><br><span class="line">            selectedView = child;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    return selectedView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这里使用了一个while循环来执行重复逻辑，一开始nextTop的值是第一个子元素顶部距离整个ListView顶部的像素值，pos则是刚刚传入的mFirstPosition的值，而end是ListView底部减去顶部所得的像素值，mItemCount则是Adapter中的元素数量。因此一开始的情况下nextTop必定是小于end值的，并且pos也是小于mItemCount值的。那么每执行一次while循环，pos的值都会加1，并且nextTop也会增加，当nextTop大于等于end时，也就是子元素已经超出当前屏幕了，或者pos大于等于mItemCount时，也就是所有Adapter中的元素都被遍历结束了，就会跳出while循环。</p><p>那么while循环当中又做了什么事情呢？值得让人留意的就是第18行调用的makeAndAddView()方法，进入到这个方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Obtain the view and add it to our list of children. The view can be made</span><br><span class="line"> * fresh, converted from an unused view, or used as is if it was in the</span><br><span class="line"> * recycle bin.</span><br><span class="line"> *</span><br><span class="line"> * @param position Logical position in the list</span><br><span class="line"> * @param y Top or bottom edge of the view to add</span><br><span class="line"> * @param flow If flow is true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @return View that was added</span><br><span class="line"> */</span><br><span class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</span><br><span class="line">        boolean selected) &#123;</span><br><span class="line">    View child;</span><br><span class="line">    if (!mDataChanged) &#123;</span><br><span class="line">        // Try to use an exsiting view for this position</span><br><span class="line">        child = mRecycler.getActiveView(position);</span><br><span class="line">        if (child != null) &#123;</span><br><span class="line">            // Found it -- we&apos;re using an existing child</span><br><span class="line">            // This just needs to be positioned</span><br><span class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Make a new view for this position, or convert an unused view if possible</span><br><span class="line">    child = obtainView(position, mIsScrap);</span><br><span class="line">    // This needs to be positioned and measured</span><br><span class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里在第19行尝试从RecycleBin当中快速获取一个active view，不过很遗憾的是目前RecycleBin当中还没有缓存任何的View，所以这里得到的值肯定是null。那么取得了null之后就会继续向下运行，到第28行会调用obtainView()方法来再次尝试获取一个View，这次的obtainView()方法是可以保证一定返回一个View的，于是下面立刻将获取到的View传入到了setupChild()方法当中。那么obtainView()内部到底是怎么工作的呢？我们先进入到这个方法里面看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get a view and have it show the data associated with the specified</span><br><span class="line"> * position. This is called when we have already discovered that the view is</span><br><span class="line"> * not available for reuse in the recycle bin. The only choices left are</span><br><span class="line"> * converting an old view or making a new one.</span><br><span class="line"> * </span><br><span class="line"> * @param position</span><br><span class="line"> *            The position to display</span><br><span class="line"> * @param isScrap</span><br><span class="line"> *            Array of at least 1 boolean, the first entry will become true</span><br><span class="line"> *            if the returned view was taken from the scrap heap, false if</span><br><span class="line"> *            otherwise.</span><br><span class="line"> * </span><br><span class="line"> * @return A view displaying the data associated with the specified position</span><br><span class="line"> */</span><br><span class="line">View obtainView(int position, boolean[] isScrap) &#123;</span><br><span class="line">isScrap[0] = false;</span><br><span class="line">View scrapView;</span><br><span class="line">scrapView = mRecycler.getScrapView(position);</span><br><span class="line">View child;</span><br><span class="line">if (scrapView != null) &#123;</span><br><span class="line">child = mAdapter.getView(position, scrapView, this);</span><br><span class="line">if (child != scrapView) &#123;</span><br><span class="line">mRecycler.addScrapView(scrapView);</span><br><span class="line">if (mCacheColorHint != 0) &#123;</span><br><span class="line">child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">isScrap[0] = true;</span><br><span class="line">dispatchFinishTemporaryDetach(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">child = mAdapter.getView(position, null, this);</span><br><span class="line">if (mCacheColorHint != 0) &#123;</span><br><span class="line">child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>obtainView()方法中的代码并不多，但却包含了非常非常重要的逻辑，不夸张的说，整个ListView中最重要的内容可能就在这个方法里了。那么我们还是按照执行流程来看，在第19行代码中调用了RecycleBin的getScrapView()方法来尝试获取一个废弃缓存中的View，同样的道理，这里肯定是获取不到的，getScrapView()方法会返回一个null。这时该怎么办呢？没有关系，代码会执行到第33行，调用mAdapter的getView()方法来去获取一个View。那么mAdapter是什么呢？当然就是当前ListView关联的适配器了。而getView()方法又是什么呢？还用说吗，这个就是我们平时使用ListView时最最经常重写的一个方法了，这里getView()方法中传入了三个参数，分别是position，null和this。</p><p>那么我们平时写ListView的Adapter时，getView()方法通常会怎么写呢？这里我举个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">Fruit fruit = getItem(position);</span><br><span class="line">View view;</span><br><span class="line">if (convertView == null) &#123;</span><br><span class="line">view = LayoutInflater.from(getContext()).inflate(resourceId, null);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">view = convertView;</span><br><span class="line">&#125;</span><br><span class="line">ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line">fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">fruitName.setText(fruit.getName());</span><br><span class="line">return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>getView()方法接受的三个参数，第一个参数position代表当前子元素的的位置，我们可以通过具体的位置来获取与其相关的数据。第二个参数convertView，刚才传入的是null，说明没有convertView可以利用，因此我们会调用LayoutInflater的inflate()方法来去加载一个布局。接下来会对这个view进行一些属性和值的设定，最后将view返回。</p><p>那么这个View也会作为obtainView()的结果进行返回，并最终传入到setupChild()方法当中。其实也就是说，第一次layout过程当中，所有的子View都是调用LayoutInflater的inflate()方法加载出来的，这样就会相对比较耗时，但是不用担心，后面就不会再有这种情况了，那么我们继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a view as a child and make sure it is measured (if necessary) and</span><br><span class="line"> * positioned properly.</span><br><span class="line"> *</span><br><span class="line"> * @param child The view to add</span><br><span class="line"> * @param position The position of this child</span><br><span class="line"> * @param y The y position relative to which this view will be positioned</span><br><span class="line"> * @param flowDown If true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @param recycled Has this view been pulled from the recycle bin? If so it</span><br><span class="line"> *        does not need to be remeasured.</span><br><span class="line"> */</span><br><span class="line">private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,</span><br><span class="line">        boolean selected, boolean recycled) &#123;</span><br><span class="line">    final boolean isSelected = selected &amp;&amp; shouldShowSelector();</span><br><span class="line">    final boolean updateChildSelected = isSelected != child.isSelected();</span><br><span class="line">    final int mode = mTouchMode;</span><br><span class="line">    final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp;</span><br><span class="line">            mMotionPosition == position;</span><br><span class="line">    final boolean updateChildPressed = isPressed != child.isPressed();</span><br><span class="line">    final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();</span><br><span class="line">    // Respect layout params that are already in the view. Otherwise make some up...</span><br><span class="line">    // noinspection unchecked</span><br><span class="line">    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">    if (p == null) &#123;</span><br><span class="line">        p = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    p.viewType = mAdapter.getItemViewType(position);</span><br><span class="line">    if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp;</span><br><span class="line">            p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</span><br><span class="line">        attachViewToParent(child, flowDown ? -1 : 0, p);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p.forceAdd = false;</span><br><span class="line">        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">            p.recycledHeaderFooter = true;</span><br><span class="line">        &#125;</span><br><span class="line">        addViewInLayout(child, flowDown ? -1 : 0, p, true);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildSelected) &#123;</span><br><span class="line">        child.setSelected(isSelected);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildPressed) &#123;</span><br><span class="line">        child.setPressed(isPressed);</span><br><span class="line">    &#125;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</span><br><span class="line">                mListPadding.left + mListPadding.right, p.width);</span><br><span class="line">        int lpHeight = p.height;</span><br><span class="line">        int childHeightSpec;</span><br><span class="line">        if (lpHeight &gt; 0) &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        child.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cleanupLayoutState(child);</span><br><span class="line">    &#125;</span><br><span class="line">    final int w = child.getMeasuredWidth();</span><br><span class="line">    final int h = child.getMeasuredHeight();</span><br><span class="line">    final int childTop = flowDown ? y : y - h;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        final int childRight = childrenLeft + w;</span><br><span class="line">        final int childBottom = childTop + h;</span><br><span class="line">        child.layout(childrenLeft, childTop, childRight, childBottom);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        child.offsetLeftAndRight(childrenLeft - child.getLeft());</span><br><span class="line">        child.offsetTopAndBottom(childTop - child.getTop());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</span><br><span class="line">        child.setDrawingCacheEnabled(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>setupChild()方法当中的代码虽然比较多，但是我们只看核心代码的话就非常简单了，刚才调用obtainView()方法获取到的子元素View，这里在第40行调用了addViewInLayout()方法将它添加到了ListView当中。那么根据fillDown()方法中的while循环，会让子元素View将整个ListView控件填满然后就跳出，也就是说即使我们的Adapter中有一千条数据，ListView也只会加载第一屏的数据，剩下的数据反正目前在屏幕上也看不到，所以不会去做多余的加载工作，这样就可以保证ListView中的内容能够迅速展示到屏幕上。</p><p>那么到此为止，第一次Layout过程结束。</p><h2 id="第二次Layout"><a href="#第二次Layout" class="headerlink" title="第二次Layout"></a>第二次Layout</h2><p>虽然我在源码中并没有找出具体的原因，但如果你自己做一下实验的话就会发现，<strong>即使是一个再简单的View，在展示到界面上之前都会经历至少两次onMeasure()和两次onLayout()的过程</strong>。其实这只是一个很小的细节，平时对我们影响并不大，因为不管是onMeasure()或者onLayout()几次，反正都是执行的相同的逻辑，我们并不需要进行过多关心。但是在ListView中情况就不一样了，因为这就意味着layoutChildren()过程会执行两次，而这个过程当中涉及到向ListView中添加子元素，如果相同的逻辑执行两遍的话，那么ListView中就会存在一份重复的数据了。因此ListView在layoutChildren()过程当中做了第二次Layout的逻辑处理，非常巧妙地解决了这个问题，下面我们就来分析一下第二次Layout的过程。</p><p>其实第二次Layout和第一次Layout的基本流程是差不多的，那么我们还是从layoutChildren()方法开始看起：</p><p>同样还是在第19行，调用getChildCount()方法来获取子View的数量，只不过现在得到的值不会再是0了，而是ListView中一屏可以显示的子View数量，因为我们刚刚在第一次Layout过程当中向ListView添加了这么多的子View。下面在第90行调用了RecycleBin的fillActiveViews()方法，这次效果可就不一样了，因为目前ListView中已经有子View了，这样所有的子View都会被缓存到RecycleBin的mActiveViews数组当中，后面将会用到它们。</p><p>接下来将会是非常非常重要的一个操作，<strong>在第113行调用了detachAllViewsFromParent()方法。这个方法会将所有ListView当中的子View全部清除掉，从而保证第二次Layout过程不会产生一份重复的数据。那有的朋友可能会问了，这样把已经加载好的View又清除掉，待会还要再重新加载一遍，这不是严重影响效率吗？不用担心，还记得我们刚刚调用了RecycleBin的fillActiveViews()方法来缓存子View吗，待会儿将会直接使用这些缓存好的View来进行加载，而并不会重新执行一遍inflate过程，因此效率方面并不会有什么明显的影响。</strong></p><p>那么我们接着看，在第141行的判断逻辑当中，由于不再等于0了，因此会进入到else语句当中。而else语句中又有三个逻辑判断，第一个逻辑判断不成立，因为默认情况下我们没有选中任何子元素，mSelectedPosition应该等于-1。第二个逻辑判断通常是成立的，因为mFirstPosition的值一开始是等于0的，只要adapter中的数据大于0条件就成立。那么进入到fillSpecific()方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Put a specific item at a specific location on the screen and then build</span><br><span class="line"> * up and down from there.</span><br><span class="line"> *</span><br><span class="line"> * @param position The reference view to use as the starting point</span><br><span class="line"> * @param top Pixel offset from the top of this view to the top of the</span><br><span class="line"> *        reference view.</span><br><span class="line"> *</span><br><span class="line"> * @return The selected view, or null if the selected view is outside the</span><br><span class="line"> *         visible area.</span><br><span class="line"> */</span><br><span class="line">private View fillSpecific(int position, int top) &#123;</span><br><span class="line">    boolean tempIsSelected = position == mSelectedPosition;</span><br><span class="line">    View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected);</span><br><span class="line">    // Possibly changed again in fillUp if we add rows above this one.</span><br><span class="line">    mFirstPosition = position;</span><br><span class="line">    View above;</span><br><span class="line">    View below;</span><br><span class="line">    final int dividerHeight = mDividerHeight;</span><br><span class="line">    if (!mStackFromBottom) &#123;</span><br><span class="line">        above = fillUp(position - 1, temp.getTop() - dividerHeight);</span><br><span class="line">        // This will correct for the top of the first view not touching the top of the list</span><br><span class="line">        adjustViewsUpOrDown();</span><br><span class="line">        below = fillDown(position + 1, temp.getBottom() + dividerHeight);</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        if (childCount &gt; 0) &#123;</span><br><span class="line">            correctTooHigh(childCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        below = fillDown(position + 1, temp.getBottom() + dividerHeight);</span><br><span class="line">        // This will correct for the bottom of the last view not touching the bottom of the list</span><br><span class="line">        adjustViewsUpOrDown();</span><br><span class="line">        above = fillUp(position - 1, temp.getTop() - dividerHeight);</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        if (childCount &gt; 0) &#123;</span><br><span class="line">             correctTooLow(childCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (tempIsSelected) &#123;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; else if (above != null) &#123;</span><br><span class="line">        return above;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return below;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>fillSpecific()这算是一个新方法了，不过其实它和fillUp()、fillDown()方法功能也是差不多的，主要的区别在于，fillSpecific()方法会优先将指定位置的子View先加载到屏幕上，然后再加载该子View往上以及往下的其它子View。那么由于这里我们传入的position就是第一个子View的位置，于是fillSpecific()方法的作用就基本上和fillDown()方法是差不多的了，这里我们就不去关注太多它的细节，而是将精力放在makeAndAddView()方法上面。再次回到makeAndAddView()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Obtain the view and add it to our list of children. The view can be made</span><br><span class="line"> * fresh, converted from an unused view, or used as is if it was in the</span><br><span class="line"> * recycle bin.</span><br><span class="line"> *</span><br><span class="line"> * @param position Logical position in the list</span><br><span class="line"> * @param y Top or bottom edge of the view to add</span><br><span class="line"> * @param flow If flow is true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @return View that was added</span><br><span class="line"> */</span><br><span class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</span><br><span class="line">        boolean selected) &#123;</span><br><span class="line">    View child;</span><br><span class="line">    if (!mDataChanged) &#123;</span><br><span class="line">        // Try to use an exsiting view for this position</span><br><span class="line">        child = mRecycler.getActiveView(position);</span><br><span class="line">        if (child != null) &#123;</span><br><span class="line">            // Found it -- we&apos;re using an existing child</span><br><span class="line">            // This just needs to be positioned</span><br><span class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Make a new view for this position, or convert an unused view if possible</span><br><span class="line">    child = obtainView(position, mIsScrap);</span><br><span class="line">    // This needs to be positioned and measured</span><br><span class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仍然还是在第19行尝试从RecycleBin当中获取Active View，然而这次就一定可以获取到了，因为前面我们调用了RecycleBin的fillActiveViews()方法来缓存子View。那么既然如此，就不会再进入到第28行的obtainView()方法，而是会直接进入setupChild()方法当中，这样也省去了很多时间，因为如果在obtainView()方法中又要去infalte布局的话，那么ListView的初始加载效率就大大降低了。</p><p>注意在第23行，setupChild()方法的最后一个参数传入的是true，这个参数表明当前的View是之前被回收过的，那么我们再次回到setupChild()方法当中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a view as a child and make sure it is measured (if necessary) and</span><br><span class="line"> * positioned properly.</span><br><span class="line"> *</span><br><span class="line"> * @param child The view to add</span><br><span class="line"> * @param position The position of this child</span><br><span class="line"> * @param y The y position relative to which this view will be positioned</span><br><span class="line"> * @param flowDown If true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @param recycled Has this view been pulled from the recycle bin? If so it</span><br><span class="line"> *        does not need to be remeasured.</span><br><span class="line"> */</span><br><span class="line">private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,</span><br><span class="line">        boolean selected, boolean recycled) &#123;</span><br><span class="line">    final boolean isSelected = selected &amp;&amp; shouldShowSelector();</span><br><span class="line">    final boolean updateChildSelected = isSelected != child.isSelected();</span><br><span class="line">    final int mode = mTouchMode;</span><br><span class="line">    final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp;</span><br><span class="line">            mMotionPosition == position;</span><br><span class="line">    final boolean updateChildPressed = isPressed != child.isPressed();</span><br><span class="line">    final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();</span><br><span class="line">    // Respect layout params that are already in the view. Otherwise make some up...</span><br><span class="line">    // noinspection unchecked</span><br><span class="line">    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">    if (p == null) &#123;</span><br><span class="line">        p = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    p.viewType = mAdapter.getItemViewType(position);</span><br><span class="line">    if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp;</span><br><span class="line">            p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</span><br><span class="line">        attachViewToParent(child, flowDown ? -1 : 0, p);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p.forceAdd = false;</span><br><span class="line">        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">            p.recycledHeaderFooter = true;</span><br><span class="line">        &#125;</span><br><span class="line">        addViewInLayout(child, flowDown ? -1 : 0, p, true);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildSelected) &#123;</span><br><span class="line">        child.setSelected(isSelected);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildPressed) &#123;</span><br><span class="line">        child.setPressed(isPressed);</span><br><span class="line">    &#125;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</span><br><span class="line">                mListPadding.left + mListPadding.right, p.width);</span><br><span class="line">        int lpHeight = p.height;</span><br><span class="line">        int childHeightSpec;</span><br><span class="line">        if (lpHeight &gt; 0) &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        child.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cleanupLayoutState(child);</span><br><span class="line">    &#125;</span><br><span class="line">    final int w = child.getMeasuredWidth();</span><br><span class="line">    final int h = child.getMeasuredHeight();</span><br><span class="line">    final int childTop = flowDown ? y : y - h;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        final int childRight = childrenLeft + w;</span><br><span class="line">        final int childBottom = childTop + h;</span><br><span class="line">        child.layout(childrenLeft, childTop, childRight, childBottom);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        child.offsetLeftAndRight(childrenLeft - child.getLeft());</span><br><span class="line">        child.offsetTopAndBottom(childTop - child.getTop());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</span><br><span class="line">        child.setDrawingCacheEnabled(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，setupChild()方法的最后一个参数是recycled，然后在第32行会对这个变量进行判断，由于recycled现在是true，所以会执行attachViewToParent()方法，而第一次Layout过程则是执行的else语句中的addViewInLayout()方法。<strong>这两个方法最大的区别在于，如果我们需要向ViewGroup中添加一个新的子View，应该调用addViewInLayout()方法，而如果是想要将一个之前detach的View重新attach到ViewGroup上，就应该调用attachViewToParent()方法。</strong>那么由于前面在layoutChildren()方法当中调用了detachAllViewsFromParent()方法，这样ListView中所有的子View都是处于detach状态的，所以这里attachViewToParent()方法是正确的选择。</p><p>经历了这样一个detach又attach的过程，ListView中所有的子View又都可以正常显示出来了，那么第二次Layout过程结束。</p><h2 id="滑动加载更多数据"><a href="#滑动加载更多数据" class="headerlink" title="滑动加载更多数据"></a>滑动加载更多数据</h2><p>经历了两次Layout过程，虽说我们已经可以在ListView中看到内容了，然而关于ListView最神奇的部分我们却还没有接触到，因为目前ListView中只是加载并显示了第一屏的数据而已。比如说我们的Adapter当中有1000条数据，但是第一屏只显示了10条，ListView中也只有10个子View而已，那么剩下的990是怎样工作并显示到界面上的呢？这就要看一下ListView滑动部分的源码了，因为我们是通过手指滑动来显示更多数据的。</p><p>由于滑动部分的机制是属于通用型的，即ListView和GridView都会使用同样的机制，因此这部分代码就肯定是写在AbsListView当中的了。那么监听触控事件是在onTouchEvent()方法当中进行的，我们就来看一下AbsListView中的这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">if (!isEnabled()) &#123;</span><br><span class="line">// A disabled view that is clickable still consumes the touch</span><br><span class="line">// events, it just doesn&apos;t respond to them.</span><br><span class="line">return isClickable() || isLongClickable();</span><br><span class="line">&#125;</span><br><span class="line">final int action = ev.getAction();</span><br><span class="line">View v;</span><br><span class="line">int deltaY;</span><br><span class="line">if (mVelocityTracker == null) &#123;</span><br><span class="line">mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">&#125;</span><br><span class="line">mVelocityTracker.addMovement(ev);</span><br><span class="line">switch (action &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class="line">case MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">mActivePointerId = ev.getPointerId(0);</span><br><span class="line">final int x = (int) ev.getX();</span><br><span class="line">final int y = (int) ev.getY();</span><br><span class="line">int motionPosition = pointToPosition(x, y);</span><br><span class="line">if (!mDataChanged) &#123;</span><br><span class="line">if ((mTouchMode != TOUCH_MODE_FLING) &amp;&amp; (motionPosition &gt;= 0)</span><br><span class="line">&amp;&amp; (getAdapter().isEnabled(motionPosition))) &#123;</span><br><span class="line">// User clicked on an actual view (and was not stopping a</span><br><span class="line">// fling). It might be a</span><br><span class="line">// click or a scroll. Assume it is a click until proven</span><br><span class="line">// otherwise</span><br><span class="line">mTouchMode = TOUCH_MODE_DOWN;</span><br><span class="line">// FIXME Debounce</span><br><span class="line">if (mPendingCheckForTap == null) &#123;</span><br><span class="line">mPendingCheckForTap = new CheckForTap();</span><br><span class="line">&#125;</span><br><span class="line">postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if (ev.getEdgeFlags() != 0 &amp;&amp; motionPosition &lt; 0) &#123;</span><br><span class="line">// If we couldn&apos;t find a view to click on, but the down</span><br><span class="line">// event was touching</span><br><span class="line">// the edge, we will bail out and try again. This allows</span><br><span class="line">// the edge correcting</span><br><span class="line">// code in ViewRoot to try to find a nearby view to</span><br><span class="line">// select</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (mTouchMode == TOUCH_MODE_FLING) &#123;</span><br><span class="line">// Stopped a fling. It is a scroll.</span><br><span class="line">createScrollingCache();</span><br><span class="line">mTouchMode = TOUCH_MODE_SCROLL;</span><br><span class="line">mMotionCorrection = 0;</span><br><span class="line">motionPosition = findMotionRow(y);</span><br><span class="line">reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (motionPosition &gt;= 0) &#123;</span><br><span class="line">// Remember where the motion event started</span><br><span class="line">v = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">mMotionViewOriginalTop = v.getTop();</span><br><span class="line">&#125;</span><br><span class="line">mMotionX = x;</span><br><span class="line">mMotionY = y;</span><br><span class="line">mMotionPosition = motionPosition;</span><br><span class="line">mLastY = Integer.MIN_VALUE;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">final int pointerIndex = ev.findPointerIndex(mActivePointerId);</span><br><span class="line">final int y = (int) ev.getY(pointerIndex);</span><br><span class="line">deltaY = y - mMotionY;</span><br><span class="line">switch (mTouchMode) &#123;</span><br><span class="line">case TOUCH_MODE_DOWN:</span><br><span class="line">case TOUCH_MODE_TAP:</span><br><span class="line">case TOUCH_MODE_DONE_WAITING:</span><br><span class="line">// Check if we have moved far enough that it looks more like a</span><br><span class="line">// scroll than a tap</span><br><span class="line">startScrollIfNeeded(deltaY);</span><br><span class="line">break;</span><br><span class="line">case TOUCH_MODE_SCROLL:</span><br><span class="line">if (PROFILE_SCROLLING) &#123;</span><br><span class="line">if (!mScrollProfilingStarted) &#123;</span><br><span class="line">Debug.startMethodTracing(&quot;AbsListViewScroll&quot;);</span><br><span class="line">mScrollProfilingStarted = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (y != mLastY) &#123;</span><br><span class="line">deltaY -= mMotionCorrection;</span><br><span class="line">int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;</span><br><span class="line">// No need to do all this work if we&apos;re not going to move</span><br><span class="line">// anyway</span><br><span class="line">boolean atEdge = false;</span><br><span class="line">if (incrementalDeltaY != 0) &#123;</span><br><span class="line">atEdge = trackMotionScroll(deltaY, incrementalDeltaY);</span><br><span class="line">&#125;</span><br><span class="line">// Check to see if we have bumped into the scroll limit</span><br><span class="line">if (atEdge &amp;&amp; getChildCount() &gt; 0) &#123;</span><br><span class="line">// Treat this like we&apos;re starting a new scroll from the</span><br><span class="line">// current</span><br><span class="line">// position. This will let the user start scrolling back</span><br><span class="line">// into</span><br><span class="line">// content immediately rather than needing to scroll</span><br><span class="line">// back to the</span><br><span class="line">// point where they hit the limit first.</span><br><span class="line">int motionPosition = findMotionRow(y);</span><br><span class="line">if (motionPosition &gt;= 0) &#123;</span><br><span class="line">final View motionView = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">mMotionViewOriginalTop = motionView.getTop();</span><br><span class="line">&#125;</span><br><span class="line">mMotionY = y;</span><br><span class="line">mMotionPosition = motionPosition;</span><br><span class="line">invalidate();</span><br><span class="line">&#125;</span><br><span class="line">mLastY = y;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case MotionEvent.ACTION_UP: &#123;</span><br><span class="line">switch (mTouchMode) &#123;</span><br><span class="line">case TOUCH_MODE_DOWN:</span><br><span class="line">case TOUCH_MODE_TAP:</span><br><span class="line">case TOUCH_MODE_DONE_WAITING:</span><br><span class="line">final int motionPosition = mMotionPosition;</span><br><span class="line">final View child = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">if (child != null &amp;&amp; !child.hasFocusable()) &#123;</span><br><span class="line">if (mTouchMode != TOUCH_MODE_DOWN) &#123;</span><br><span class="line">child.setPressed(false);</span><br><span class="line">&#125;</span><br><span class="line">if (mPerformClick == null) &#123;</span><br><span class="line">mPerformClick = new PerformClick();</span><br><span class="line">&#125;</span><br><span class="line">final AbsListView.PerformClick performClick = mPerformClick;</span><br><span class="line">performClick.mChild = child;</span><br><span class="line">performClick.mClickMotionPosition = motionPosition;</span><br><span class="line">performClick.rememberWindowAttachCount();</span><br><span class="line">mResurrectToPosition = motionPosition;</span><br><span class="line">if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) &#123;</span><br><span class="line">final Handler handler = getHandler();</span><br><span class="line">if (handler != null) &#123;</span><br><span class="line">handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap</span><br><span class="line">: mPendingCheckForLongPress);</span><br><span class="line">&#125;</span><br><span class="line">mLayoutMode = LAYOUT_NORMAL;</span><br><span class="line">if (!mDataChanged &amp;&amp; mAdapter.isEnabled(motionPosition)) &#123;</span><br><span class="line">mTouchMode = TOUCH_MODE_TAP;</span><br><span class="line">setSelectedPositionInt(mMotionPosition);</span><br><span class="line">layoutChildren();</span><br><span class="line">child.setPressed(true);</span><br><span class="line">positionSelector(child);</span><br><span class="line">setPressed(true);</span><br><span class="line">if (mSelector != null) &#123;</span><br><span class="line">Drawable d = mSelector.getCurrent();</span><br><span class="line">if (d != null &amp;&amp; d instanceof TransitionDrawable) &#123;</span><br><span class="line">((TransitionDrawable) d).resetTransition();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">postDelayed(new Runnable() &#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">child.setPressed(false);</span><br><span class="line">setPressed(false);</span><br><span class="line">if (!mDataChanged) &#123;</span><br><span class="line">post(performClick);</span><br><span class="line">&#125;</span><br><span class="line">mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, ViewConfiguration.getPressedStateDuration());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125; else if (!mDataChanged &amp;&amp; mAdapter.isEnabled(motionPosition)) &#123;</span><br><span class="line">post(performClick);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">break;</span><br><span class="line">case TOUCH_MODE_SCROLL:</span><br><span class="line">final int childCount = getChildCount();</span><br><span class="line">if (childCount &gt; 0) &#123;</span><br><span class="line">if (mFirstPosition == 0</span><br><span class="line">&amp;&amp; getChildAt(0).getTop() &gt;= mListPadding.top</span><br><span class="line">&amp;&amp; mFirstPosition + childCount &lt; mItemCount</span><br><span class="line">&amp;&amp; getChildAt(childCount - 1).getBottom() &lt;= getHeight()</span><br><span class="line">- mListPadding.bottom) &#123;</span><br><span class="line">mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">final VelocityTracker velocityTracker = mVelocityTracker;</span><br><span class="line">velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);</span><br><span class="line">final int initialVelocity = (int) velocityTracker</span><br><span class="line">.getYVelocity(mActivePointerId);</span><br><span class="line">if (Math.abs(initialVelocity) &gt; mMinimumVelocity) &#123;</span><br><span class="line">if (mFlingRunnable == null) &#123;</span><br><span class="line">mFlingRunnable = new FlingRunnable();</span><br><span class="line">&#125;</span><br><span class="line">reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);</span><br><span class="line">mFlingRunnable.start(-initialVelocity);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">setPressed(false);</span><br><span class="line">// Need to redraw since we probably aren&apos;t drawing the selector</span><br><span class="line">// anymore</span><br><span class="line">invalidate();</span><br><span class="line">final Handler handler = getHandler();</span><br><span class="line">if (handler != null) &#123;</span><br><span class="line">handler.removeCallbacks(mPendingCheckForLongPress);</span><br><span class="line">&#125;</span><br><span class="line">if (mVelocityTracker != null) &#123;</span><br><span class="line">mVelocityTracker.recycle();</span><br><span class="line">mVelocityTracker = null;</span><br><span class="line">&#125;</span><br><span class="line">mActivePointerId = INVALID_POINTER;</span><br><span class="line">if (PROFILE_SCROLLING) &#123;</span><br><span class="line">if (mScrollProfilingStarted) &#123;</span><br><span class="line">Debug.stopMethodTracing();</span><br><span class="line">mScrollProfilingStarted = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">setPressed(false);</span><br><span class="line">View motionView = this.getChildAt(mMotionPosition - mFirstPosition);</span><br><span class="line">if (motionView != null) &#123;</span><br><span class="line">motionView.setPressed(false);</span><br><span class="line">&#125;</span><br><span class="line">clearScrollingCache();</span><br><span class="line">final Handler handler = getHandler();</span><br><span class="line">if (handler != null) &#123;</span><br><span class="line">handler.removeCallbacks(mPendingCheckForLongPress);</span><br><span class="line">&#125;</span><br><span class="line">if (mVelocityTracker != null) &#123;</span><br><span class="line">mVelocityTracker.recycle();</span><br><span class="line">mVelocityTracker = null;</span><br><span class="line">&#125;</span><br><span class="line">mActivePointerId = INVALID_POINTER;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case MotionEvent.ACTION_POINTER_UP: &#123;</span><br><span class="line">onSecondaryPointerUp(ev);</span><br><span class="line">final int x = mMotionX;</span><br><span class="line">final int y = mMotionY;</span><br><span class="line">final int motionPosition = pointToPosition(x, y);</span><br><span class="line">if (motionPosition &gt;= 0) &#123;</span><br><span class="line">// Remember where the motion event started</span><br><span class="line">v = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">mMotionViewOriginalTop = v.getTop();</span><br><span class="line">mMotionPosition = motionPosition;</span><br><span class="line">&#125;</span><br><span class="line">mLastY = y;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中的代码就非常多了，因为它所处理的逻辑也非常多，要监听各种各样的触屏事件。但是我们目前所关心的就只有手指在屏幕上滑动这一个事件而已，对应的是ACTION_MOVE这个动作，那么我们就只看这部分代码就可以了。可以看到，ACTION_MOVE这个case里面又嵌套了一个switch语句，是根据当前的TouchMode来选择的。那这里我可以直接告诉大家，当手指在屏幕上滑动时，TouchMode是等于TOUCH_MODE_SCROLL这个值的。</p><p>这样的话，代码就应该会走到第78行的这个case里面去了，在这个case当中并没有什么太多需要注意的东西，唯一一点非常重要的就是第92行调用的trackMotionScroll()方法，相当于我们手指只要在屏幕上稍微有一点点移动，这个方法就会被调用，而如果是正常在屏幕上滑动的话，那么这个方法就会被调用很多次。那么我们进入到这个方法中瞧一瞧，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">boolean trackMotionScroll(int deltaY, int incrementalDeltaY) &#123;</span><br><span class="line">final int childCount = getChildCount();</span><br><span class="line">if (childCount == 0) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">final int firstTop = getChildAt(0).getTop();</span><br><span class="line">final int lastBottom = getChildAt(childCount - 1).getBottom();</span><br><span class="line">final Rect listPadding = mListPadding;</span><br><span class="line">final int spaceAbove = listPadding.top - firstTop;</span><br><span class="line">final int end = getHeight() - listPadding.bottom;</span><br><span class="line">final int spaceBelow = lastBottom - end;</span><br><span class="line">final int height = getHeight() - getPaddingBottom() - getPaddingTop();</span><br><span class="line">if (deltaY &lt; 0) &#123;</span><br><span class="line">deltaY = Math.max(-(height - 1), deltaY);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">deltaY = Math.min(height - 1, deltaY);</span><br><span class="line">&#125;</span><br><span class="line">if (incrementalDeltaY &lt; 0) &#123;</span><br><span class="line">incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);</span><br><span class="line">&#125;</span><br><span class="line">final int firstPosition = mFirstPosition;</span><br><span class="line">if (firstPosition == 0 &amp;&amp; firstTop &gt;= listPadding.top &amp;&amp; deltaY &gt;= 0) &#123;</span><br><span class="line">// Don&apos;t need to move views down if the top of the first position</span><br><span class="line">// is already visible</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if (firstPosition + childCount == mItemCount &amp;&amp; lastBottom &lt;= end &amp;&amp; deltaY &lt;= 0) &#123;</span><br><span class="line">// Don&apos;t need to move views up if the bottom of the last position</span><br><span class="line">// is already visible</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">final boolean down = incrementalDeltaY &lt; 0;</span><br><span class="line">final boolean inTouchMode = isInTouchMode();</span><br><span class="line">if (inTouchMode) &#123;</span><br><span class="line">hideSelector();</span><br><span class="line">&#125;</span><br><span class="line">final int headerViewsCount = getHeaderViewsCount();</span><br><span class="line">final int footerViewsStart = mItemCount - getFooterViewsCount();</span><br><span class="line">int start = 0;</span><br><span class="line">int count = 0;</span><br><span class="line">if (down) &#123;</span><br><span class="line">final int top = listPadding.top - incrementalDeltaY;</span><br><span class="line">for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">final View child = getChildAt(i);</span><br><span class="line">if (child.getBottom() &gt;= top) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">count++;</span><br><span class="line">int position = firstPosition + i;</span><br><span class="line">if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</span><br><span class="line">mRecycler.addScrapView(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">final int bottom = getHeight() - listPadding.bottom - incrementalDeltaY;</span><br><span class="line">for (int i = childCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">final View child = getChildAt(i);</span><br><span class="line">if (child.getTop() &lt;= bottom) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">start = i;</span><br><span class="line">count++;</span><br><span class="line">int position = firstPosition + i;</span><br><span class="line">if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</span><br><span class="line">mRecycler.addScrapView(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mMotionViewNewTop = mMotionViewOriginalTop + deltaY;</span><br><span class="line">mBlockLayoutRequests = true;</span><br><span class="line">if (count &gt; 0) &#123;</span><br><span class="line">detachViewsFromParent(start, count);</span><br><span class="line">&#125;</span><br><span class="line">offsetChildrenTopAndBottom(incrementalDeltaY);</span><br><span class="line">if (down) &#123;</span><br><span class="line">mFirstPosition += count;</span><br><span class="line">&#125;</span><br><span class="line">invalidate();</span><br><span class="line">final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);</span><br><span class="line">if (spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) &#123;</span><br><span class="line">fillGap(down);</span><br><span class="line">&#125;</span><br><span class="line">if (!inTouchMode &amp;&amp; mSelectedPosition != INVALID_POSITION) &#123;</span><br><span class="line">final int childIndex = mSelectedPosition - mFirstPosition;</span><br><span class="line">if (childIndex &gt;= 0 &amp;&amp; childIndex &lt; getChildCount()) &#123;</span><br><span class="line">positionSelector(getChildAt(childIndex));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mBlockLayoutRequests = false;</span><br><span class="line">invokeOnItemScrollListener();</span><br><span class="line">awakenScrollBars();</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法接收两个参数，deltaY表示从手指按下时的位置到当前手指位置的距离，incrementalDeltaY则表示据上次触发event事件手指在Y方向上位置的改变量，那么其实我们就可以通过incrementalDeltaY的正负值情况来判断用户是向上还是向下滑动的了。如第34行代码所示，如果incrementalDeltaY小于0，说明是向下滑动，否则就是向上滑动。</p><p>下面将会进行一个边界值检测的过程，可以看到，从第43行开始，当ListView向下滑动的时候，就会进入一个for循环当中，从上往下依次获取子View，第47行当中，如果该子View的bottom值已经小于top值了，就说明这个子View已经移出屏幕了，所以会调用RecycleBin的addScrapView()方法将这个View加入到废弃缓存当中，并将count计数器加1，计数器用于记录有多少个子View被移出了屏幕。那么如果是ListView向上滑动的话，其实过程是基本相同的，只不过变成了从下往上依次获取子View，然后判断该子View的top值是不是大于bottom值了，如果大于的话说明子View已经移出了屏幕，同样把它加入到废弃缓存中，并将计数器加1。</p><p>接下来在第76行，会根据当前计数器的值来进行一个detach操作，它的作用就是把所有移出屏幕的子View全部detach掉，在ListView的概念当中，所有看不到的View就没有必要为它进行保存，因为屏幕外还有成百上千条数据等着显示呢，一个好的回收策略才能保证ListView的高性能和高效率。<strong>紧接着在第78行调用了offsetChildrenTopAndBottom()方法，并将incrementalDeltaY作为参数传入，这个方法的作用是让ListView中所有的子View都按照传入的参数值进行相应的偏移，这样就实现了随着手指的拖动，ListView的内容也会随着滚动的效果。</strong></p><p>然后在第84行会进行判断，如果ListView中最后一个View的底部已经移入了屏幕，或者ListView中第一个View的顶部移入了屏幕，就会调用fillGap()方法，那么因此我们就可以猜出fillGap()方法是用来加载屏幕外数据的，进入到这个方法中瞧一瞧，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Fills the gap left open by a touch-scroll. During a touch scroll,</span><br><span class="line"> * children that remain on screen are shifted and the other ones are</span><br><span class="line"> * discarded. The role of this method is to fill the gap thus created by</span><br><span class="line"> * performing a partial layout in the empty space.</span><br><span class="line"> * </span><br><span class="line"> * @param down</span><br><span class="line"> *            true if the scroll is going down, false if it is going up</span><br><span class="line"> */</span><br><span class="line">abstract void fillGap(boolean down);</span><br><span class="line">OK，AbsListView中的fillGap()是一个抽象方法，那么我们立刻就能够想到，它的具体实现肯定是在ListView中完成的了。回到ListView当中，fillGap()方法的代码如下所示：</span><br><span class="line">void fillGap(boolean down) &#123;</span><br><span class="line">    final int count = getChildCount();</span><br><span class="line">    if (down) &#123;</span><br><span class="line">        final int startOffset = count &gt; 0 ? getChildAt(count - 1).getBottom() + mDividerHeight :</span><br><span class="line">                getListPaddingTop();</span><br><span class="line">        fillDown(mFirstPosition + count, startOffset);</span><br><span class="line">        correctTooHigh(getChildCount());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final int startOffset = count &gt; 0 ? getChildAt(0).getTop() - mDividerHeight :</span><br><span class="line">                getHeight() - getListPaddingBottom();</span><br><span class="line">        fillUp(mFirstPosition - 1, startOffset);</span><br><span class="line">        correctTooLow(getChildCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>down参数用于表示ListView是向下滑动还是向上滑动的，可以看到，如果是向下滑动的话就会调用fillDown()方法，而如果是向上滑动的话就会调用fillUp()方法。那么这两个方法我们都已经非常熟悉了，内部都是通过一个循环来去对ListView进行填充，所以这两个方法我们就不看了，但是填充ListView会通过调用makeAndAddView()方法来完成，又是makeAndAddView()方法，但这次的逻辑再次不同了，所以我们还是回到这个方法瞧一瞧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Obtain the view and add it to our list of children. The view can be made</span><br><span class="line"> * fresh, converted from an unused view, or used as is if it was in the</span><br><span class="line"> * recycle bin.</span><br><span class="line"> *</span><br><span class="line"> * @param position Logical position in the list</span><br><span class="line"> * @param y Top or bottom edge of the view to add</span><br><span class="line"> * @param flow If flow is true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @return View that was added</span><br><span class="line"> */</span><br><span class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</span><br><span class="line">        boolean selected) &#123;</span><br><span class="line">    View child;</span><br><span class="line">    if (!mDataChanged) &#123;</span><br><span class="line">        // Try to use an exsiting view for this position</span><br><span class="line">        child = mRecycler.getActiveView(position);</span><br><span class="line">        if (child != null) &#123;</span><br><span class="line">            // Found it -- we&apos;re using an existing child</span><br><span class="line">            // This just needs to be positioned</span><br><span class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Make a new view for this position, or convert an unused view if possible</span><br><span class="line">    child = obtainView(position, mIsScrap);</span><br><span class="line">    // This needs to be positioned and measured</span><br><span class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不管怎么说，这里首先仍然是会尝试调用RecycleBin的getActiveView()方法来获取子布局，只不过肯定是获取不到的了，因为在第二次Layout过程中我们已经从mActiveViews中获取过了数据，而根据RecycleBin的机制，mActiveViews是不能够重复利用的，因此这里返回的值肯定是null。</p><p>既然getActiveView()方法返回的值是null，那么就还是会走到第28行的obtainView()方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get a view and have it show the data associated with the specified</span><br><span class="line"> * position. This is called when we have already discovered that the view is</span><br><span class="line"> * not available for reuse in the recycle bin. The only choices left are</span><br><span class="line"> * converting an old view or making a new one.</span><br><span class="line"> * </span><br><span class="line"> * @param position</span><br><span class="line"> *            The position to display</span><br><span class="line"> * @param isScrap</span><br><span class="line"> *            Array of at least 1 boolean, the first entry will become true</span><br><span class="line"> *            if the returned view was taken from the scrap heap, false if</span><br><span class="line"> *            otherwise.</span><br><span class="line"> * </span><br><span class="line"> * @return A view displaying the data associated with the specified position</span><br><span class="line"> */</span><br><span class="line">View obtainView(int position, boolean[] isScrap) &#123;</span><br><span class="line">isScrap[0] = false;</span><br><span class="line">View scrapView;</span><br><span class="line">scrapView = mRecycler.getScrapView(position);</span><br><span class="line">View child;</span><br><span class="line">if (scrapView != null) &#123;</span><br><span class="line">child = mAdapter.getView(position, scrapView, this);</span><br><span class="line">if (child != scrapView) &#123;</span><br><span class="line">mRecycler.addScrapView(scrapView);</span><br><span class="line">if (mCacheColorHint != 0) &#123;</span><br><span class="line">child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">isScrap[0] = true;</span><br><span class="line">dispatchFinishTemporaryDetach(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">child = mAdapter.getView(position, null, this);</span><br><span class="line">if (mCacheColorHint != 0) &#123;</span><br><span class="line">child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>这里在第19行会调用RecyleBin的getScrapView()方法来尝试从废弃缓存中获取一个View，那么废弃缓存有没有View呢？当然有，因为刚才在trackMotionScroll()方法中我们就已经看到了，一旦有任何子View被移出了屏幕，就会将它加入到废弃缓存中，而从obtainView()方法中的逻辑来看，一旦有新的数据需要显示到屏幕上，就会尝试从废弃缓存中获取View。所以它们之间就形成了一个生产者和消费者的模式，那么ListView神奇的地方也就在这里体现出来了，不管你有任意多条数据需要显示，ListView中的子View其实来来回回就那么几个，移出屏幕的子View会很快被移入屏幕的数据重新利用起来，因而不管我们加载多少数据都不会出现OOM的情况，甚至内存都不会有所增加。</strong></p><p>那么另外还有一点是需要大家留意的，这里获取到了一个scrapView，然后我们在第22行将它作为第二个参数传入到了Adapter的getView()方法当中。那么第二个参数是什么意思呢？我们再次看一下一个简单的getView()方法示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">Fruit fruit = getItem(position);</span><br><span class="line">View view;</span><br><span class="line">if (convertView == null) &#123;</span><br><span class="line">view = LayoutInflater.from(getContext()).inflate(resourceId, null);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">view = convertView;</span><br><span class="line">&#125;</span><br><span class="line">ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line">fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">fruitName.setText(fruit.getName());</span><br><span class="line">return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个参数就是我们最熟悉的convertView呀，难怪平时我们在写getView()方法是要判断一下convertView是不是等于null，如果等于null才调用inflate()方法来加载布局，不等于null就可以直接利用convertView，因为convertView就是我们之间利用过的View，只不过被移出屏幕后进入到了废弃缓存中，现在又重新拿出来使用而已。然后我们只需要把convertView中的数据更新成当前位置上应该显示的数据，那么看起来就好像是全新加载出来的一个布局一样，这背后的道理你是不是已经完全搞明白了？</p><p>之后的代码又都是我们熟悉的流程了，从缓存中拿到子View之后再调用setupChild()方法将它重新attach到ListView当中，因为缓存中的View也是之前从ListView中detach掉的，这部分代码就不再重复进行分析了。</p><p>为了方便大家理解，这里我再附上一张图解说明：<br><img src="/2019/09/05/android-listview/recycle_bin.png" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/44996879</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> listView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NDK之CMake</title>
      <link href="/2019/08/16/android-ndk-knowledge/"/>
      <url>/2019/08/16/android-ndk-knowledge/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>JNI（Java Native Interface），是方便Java调用C、C++等Native代码所封装的一层接口，相当于一座桥梁。通过JNI可以操作一些Java无法完成的与系统相关的特性，尤其在图像和视频处理中大量用到。</p><p>NDK（native development kit）提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。NDK集成了<strong>交叉编译器</strong>，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so，该动态库可以兼容各个平台。</p><h2 id="2、CMake"><a href="#2、CMake" class="headerlink" title="2、CMake"></a>2、CMake</h2><p>CMake是一个跨平台的安装(编译)工具，通过编写CMakeLists.txt，可以生成对应的makefile或project文件，再调用底层的编译。AS 2.2之后工具中增加了对CMake的支持，官方也推荐用CMake+CMakeLists.txt的方式，代替ndk-build+Android.mk+Application.mk的方式去构建JNI项目.</p><h3 id="创建使用CMake构建的项目"><a href="#创建使用CMake构建的项目" class="headerlink" title="创建使用CMake构建的项目"></a>创建使用CMake构建的项目</h3><p>开始前AS要先在SDK Manager中安装SDK Tools-&gt;CMake，只要勾选Include C++ Support。其中会提示配置C++支持的功能.</p><p>一般默认就可以了，各个选项的具体含义:</p><blockquote><p>C++ Standard：指定编译库的环境。<br>Exception Support:当前项目支持C++异常处理<br>Runtime Type Information Support：除异常处理外，还支持动态转类型(dynamic casting) 、模块集成、以及对象I/O</p></blockquote><h3 id="工程的目录结构"><a href="#工程的目录结构" class="headerlink" title="工程的目录结构"></a>工程的目录结构</h3><p>创建好的工程主Module下直接就有.externalNativeBuild，多出一个CMakeLists.txt，相当于以前的配置文件。并且在src/main目录下多了一个cpp文件夹，里面存放的是C++文件，相当于以前的jni文件夹。这个是工程创建后AS生成的示例JNI方法，返回了一个字符串。后面开发JNI就可以按照这个目录结构。</p><p>相应的，build.gradle下也增加了一些配置:</p><pre><code>android {    ...    defaultConfig {        ...        externalNativeBuild {            cmake {                cppFlags &quot;-std=c++14 -frtti -fexceptions&quot;                abiFilters &quot;x86&quot;, &quot;arm64-v8a&quot;, &quot;armeabi-v7a&quot;            }        }    }    buildTypes {        ...    }    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }}</code></pre><p>defaultConfig中的externalNativeBuild各项属性和前面创建项目时的选项配置有关，外部的externalNativeBuild则定义了CMakeLists.txt的存放路径。<br>如果只是在自己的项目中使用，CMake的方式在打包APK的时候会自动将cpp文件编译成so文件拷贝进去。如果要提供给外部使用时，Make Project，之后在libs目录下就可以看到生成的对应配置的相关CPU平台的.so文件。</p><h3 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h3><p>CMakeLists.txt可以自定义命令、查找文件、头文件包含、设置变量，具体可见 官方文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 编译本地库时我们需要的最小的cmake版本</span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line">#设置生成的so动态库最后输出的路径，一定要在add_library之前设置，否则不会生效</span><br><span class="line">set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;)</span><br><span class="line"></span><br><span class="line"># 相当于Android.mk。如果是多次使用add_library，则会生成多个so库；</span><br><span class="line"># 如果想将多个本地文件编译到一个so库中，只要最后一个参数添加多个C/C++文件的相对路径就可以</span><br><span class="line">add_library( # Sets the name of the library.设置编译生成本地库的名字</span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             # Sets the library as a shared library.库的类型</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).编译文件的路径</span><br><span class="line">             src/main/cpp/native-lib.cpp )</span><br><span class="line"></span><br><span class="line"># 添加一些我们在编译我们的本地库的时候需要依赖的一些库，这里是用来打log的库。可以写多个find_library</span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"># 关联自己生成的库和一些第三方库或者系统库</span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       # Links the target library to the log library</span><br><span class="line">                       # included in the NDK.</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br><span class="line"></span><br><span class="line">#设置头文件搜索路径（和此txt同个路径的头文件无需设置），可选</span><br><span class="line">#INCLUDE_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/common)</span><br><span class="line"></span><br><span class="line">#指定用到的系统库或者NDK库或者第三方库的搜索路径，可选。</span><br><span class="line">#LINK_DIRECTORIES(/usr/local/lib)</span><br><span class="line"></span><br><span class="line">#添加子目录,将会调用子目录中的CMakeLists.txt</span><br><span class="line">ADD_SUBDIRECTORY(one)</span><br><span class="line">ADD_SUBDIRECTORY(two)</span><br></pre></td></tr></table></figure></p><ul><li>cmake_minimum_required(VERSION 3.4.1)：指定CMake的最小版本</li><li>add_library：创建一个静态或者动态库，并提供其关联的源文件路径，开发者可以定义多个库，CMake会自动去构建它们。Gradle可以自动将它们打包进APK中。<br>第一个参数——native-lib：是库的名称<br>第二个参数——SHARED：是库的类别，是动态的还是静态的<br>第三个参数——src/main/cpp/native-lib.cpp：是库的源文件的路径</li><li>find_library：找到一个预编译的库，并作为一个变量保存起来。由于CMake在搜索库路径的时候会包含系统库，并且CMake会检查它自己之前编译的库的名字，所以开发者需要保证开发者自行添加的库的名字的独特性。<br>第一个参数——log-lib：设置路径变量的名称<br>第一个参数—— log：指定NDK库的名子，这样CMake就可以找到这个库</li><li>target_link_libraries：指定CMake链接到目标库。开发者可以链接多个库，比如开发者可以在此定义库的构建脚本，并且预编译第三方库或者系统库。<br>第一个参数——native-lib：指定的目标库<br>第一个参数——${log-lib}：将目标库链接到NDK中的日志库，</li></ul><p>如果想要配置so库的目标CPU平台，可以在build.gradle中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        ndk&#123;</span><br><span class="line">            abiFilters &quot;x86&quot;,&quot;armeabi&quot;,&quot;armeabi-v7a&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="set-target-properties"><a href="#set-target-properties" class="headerlink" title="set_target_properties"></a>set_target_properties</h4><p>设置目标的一些属性来改变它们构建的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(target1 target2 ...</span><br><span class="line">                      PROPERTIES prop1 value1</span><br><span class="line">                      prop2 value2 ...)</span><br></pre></td></tr></table></figure></p><p>使用示例为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(cocos2d</span><br><span class="line">    PROPERTIES</span><br><span class="line">    ARCHIVE_OUTPUT_DIRECTORY &quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span><br><span class="line">    LIBRARY_OUTPUT_DIRECTORY &quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span><br><span class="line">    VERSION &quot;$&#123;COCOS2D_X_VERSION&#125;&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>为一个目标设置属性。该命令的语法是列出所有你想要变更的文件，然后提供你想要设置的值。你能够使用任何你想要的属性/值对，并且在随后的代码中调用GET_TARGET_PROPERTY命令取出属性的值。</p><p>大家在用cmake时，应该经常会用到第三方so库，导入第三方so库中需要使用到set_target_properties,例如这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(</span><br><span class="line"></span><br><span class="line">Thirdlib</span><br><span class="line"></span><br><span class="line">PROPERTIES IMPORTED_LOCATION</span><br><span class="line"></span><br><span class="line">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/jniLibs/libThirdlib.so</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>CMAKE_CURRENT_SOURCE_DIR 这个变量是系统自定义的，表示CMakeLists.txt文件的绝对路径</p><h3 id="包含其他-CMake-项目"><a href="#包含其他-CMake-项目" class="headerlink" title="包含其他 CMake 项目"></a>包含其他 CMake 项目</h3><p>如果想要编译多个 CMake 项目并在 Android 项目中包含它们的输出，您可以使用一个 CMakeLists.txt 文件（即您关联到 Gradle 的那个文件）作为顶级 CMake 编译脚本，并添加其他 CMake 项目作为此编译脚本的依赖项。以下顶级 CMake 编译脚本使用 add_subdirectory() 命令将另一个 CMakeLists.txt 文件指定为编译依赖项，然后关联其输出，就像处理任何其他预编译库一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Sets lib_src_DIR to the path of the target CMake project.</span><br><span class="line">set( lib_src_DIR ../gmath )</span><br><span class="line"></span><br><span class="line"># Sets lib_build_DIR to the path of the desired output directory.</span><br><span class="line">set( lib_build_DIR ../gmath/outputs )</span><br><span class="line">file(MAKE_DIRECTORY $&#123;lib_build_DIR&#125;)</span><br><span class="line"></span><br><span class="line"># Adds the CMakeLists.txt file located in the specified directory</span><br><span class="line"># as a build dependency.</span><br><span class="line">add_subdirectory( # Specifies the directory of the CMakeLists.txt file.</span><br><span class="line">                  $&#123;lib_src_DIR&#125;</span><br><span class="line"></span><br><span class="line">                  # Specifies the directory for the build outputs.</span><br><span class="line">                  $&#123;lib_build_DIR&#125; )</span><br><span class="line"></span><br><span class="line"># Adds the output of the additional CMake build as a prebuilt static</span><br><span class="line"># library and names it lib_gmath.</span><br><span class="line">add_library( lib_gmath STATIC IMPORTED )</span><br><span class="line">set_target_properties( lib_gmath PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       $&#123;lib_build_DIR&#125;/$&#123;ANDROID_ABI&#125;/lib_gmath.a )</span><br><span class="line">include_directories( $&#123;lib_src_DIR&#125;/include )</span><br><span class="line"></span><br><span class="line"># Links the top-level CMake build output against lib_gmath.</span><br><span class="line">target_link_libraries( native-lib ... lib_gmath )</span><br></pre></td></tr></table></figure></p><h2 id="3、Android-mk"><a href="#3、Android-mk" class="headerlink" title="3、Android.mk"></a>3、Android.mk</h2><p>Android.mk内容示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE    := ndkdemotest-jni</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := ndkdemotest.c</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure></p><ul><li><p>LOCAL_PATH := $(call my-dir)：每个Android.mk文件必须以定义开始。它用于在开发tree中查找源文件。宏my-dir则由Build System 提供。返回包含Android.mk目录路径。</p></li><li><p>include $(CLEAR_VARS) ：CLEAR_VARS变量由Build System提供。并指向一个指定的GNU Makefile，由它负责清理很多LOCAL_xxx。例如LOCAL_MODULE，LOCAL_SRC_FILES，LOCAL_STATIC_LIBRARIES等等。但不是清理LOCAL_PATH。这个清理是必须的，因为所有的编译控制文件由同一个GNU Make解析和执行，其变量是全局的。所以清理后才能便面相互影响。</p></li><li><p>LOCAL_MODULE := ndkdemotest-jni：LOCAL_MODULE模块必须定义，以表示Android.mk中的每一个模块。名字必须唯一且不包含空格。Build System 会自动添加适当的前缀和后缀。例如，demo，要生成动态库，则生成libdemo.so。但请注意：如果模块名字被定义为libabd，则生成libabc.so。不再添加前缀。</p></li><li><p>LOCAL_SRC_FILES := ndkdemotest.c：这行代码表示将要打包的C/C++源码。不必列出头文件，build System 会自动帮我们找出依赖文件。缺省的C++ 源码的扩展名为.cpp。</p></li><li><p>include $(BUILD_SHARED_LIBRARY)：BUILD_SHARED_LIBRARY是Build System提供的一个变量，指向一个GUN Makefile Script。它负责收集自从上次调用include $(CLEAR_VARS)后的所有LOCAL_xxxxinx。并决定编译什么类型：<br>1）BUILD_STATIC_LIBRARY：编译为静态库<br>2）BUILD_SHARED_LIBRARY：编译为动态库<br>3）BUILD_EXECUTABLE：编译为Native C 可执行程序<br>4）BUILD_PREBUILT：该模块已经预先编译</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wzhseu/article/details/79683045" target="_blank" rel="noopener">https://blog.csdn.net/wzhseu/article/details/79683045</a><br><a href="https://www.cnblogs.com/alphagl/p/6280061.html" target="_blank" rel="noopener">CMake学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Android NDK </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android小知识点笔记</title>
      <link href="/2019/08/12/android-note/"/>
      <url>/2019/08/12/android-note/</url>
      
        <content type="html"><![CDATA[<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>外部类创建匿名内部类后，有可能匿名内部类还在使用，而外部类实例（或者创建内部类的方法）已经被回收了。如果此时匿名内部类用到了外部类的成员变量，那么就会出现匿名内部类要去访问一个不存在的变量的这种荒唐情况，为了延长局部变量的生命周期，于是匿名内部类使用的局部变量会被复制一份，从而使得局部变量的生命周期看起来变长了。但是这样又会引出另一个问题：<strong>数据一致性的问题！为了保证局部变量和 内部类中复制品 的数据一致性，于是要求内部类使用的局部变量是final的</strong>。</p><h2 id="λ表达式"><a href="#λ表达式" class="headerlink" title="λ表达式"></a>λ表达式</h2><p>λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。<strong>λ表达式可以被当做是一个Object（注意措辞），λ表达式的目标类型是“函数接口（functional interface）”</strong>。    </p><p><strong>λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。</strong>Java8有一个短期目标和一个长期目标。<strong>短期目标是：配合“集合类批处理操作”的内部迭代和并行处理；长期目标是将Java向函数式编程语言这个方向引导</strong>（并不是要完全变成一门函数式编程语言，只是让它有更多的函数式编程语言的特性）。</p><p>Java8为集合类引入了另一个重要概念：流（stream）。一个流通常以一个集合类实例为其数据源，然后在其上定义各种操作。流的API设计使用了管道（pipelines）模式。对流的一次操作会返回另一个流。你可能会觉得List 被迭代了好多次，map，filter，distinct都分别是一次循环，效率会不好。实际并非如此。这些返回另一个Stream的方法都是“懒（lazy）”的，而最后返回最终结果的方法则是“急（eager）”的。在遇到eager方法之前，lazy的方法不会执行。</p><p><strong>内部类总是持有一个其外部类对象的引用。而λ表达式呢，除非在它内部用到了其外部类（包围类）对象的方法或者成员，否则它就不持有这个对象的引用。</strong>在Java8以前，如果要在内部类访问外部对象的一个本地变量，那么这个变量必须声明为final才行。在Java8中，这种限制被去掉了，代之以一个新的概念，“effectively final”。它的意思是你可以声明为final，也可以不声明final但是按照final来用，也就是一次赋值永不改变。</p><p><strong>任何一个λ表达式都可以代表某个函数接口的唯一方法的匿名描述符。我们也可以使用某个类的某个具体方法来代表这个描述符，叫做方法引用。</strong></p><h2 id="String-amp-StringBuffer-amp-StringBuilder"><a href="#String-amp-StringBuffer-amp-StringBuilder" class="headerlink" title="String &amp; StringBuffer &amp; StringBuilder"></a>String &amp; StringBuffer &amp; StringBuilder</h2><p>1、长度是否可变<br>String 是被 final 修饰的，他的长度是不可变的，就算调用 String 的concat 方法，那也是把字符串拼接起来并重新创建一个对象，把拼接后的 String 的值赋给新创建的对象<br>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象，StringBuffer 与 StringBuilder 中的方法和功能完全是等价的。调用StringBuffer 的 append 方法，来改变 StringBuffer 的长度，并且，相比较于 StringBuffer，String 一旦发生长度变化，是非常耗费内存的！</p><p>2、执行效率<br>三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String</p><p>3、应用场景<br>如果要操作少量的数据用 = String<br>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder<br>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p><p>StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。</p><h2 id="Java中Vector和ArrayList的区别"><a href="#Java中Vector和ArrayList的区别" class="headerlink" title="Java中Vector和ArrayList的区别"></a>Java中Vector和ArrayList的区别</h2><p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p><ol><li>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li><li>Vector与ArrayList一样，<strong>也是通过数组实现的，不同的是它支持线程的同步</strong>，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</li><li><strong>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢</strong>。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</li></ol><h2 id="View绘制与事件"><a href="#View绘制与事件" class="headerlink" title="View绘制与事件"></a>View绘制与事件</h2><p><img src="/2019/08/12/android-note/view.webp" alt title="UI 管理系统的层级"></p><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>onMeasure()、onLayout()：<br>measure是测量的意思，那么onMeasure()方法顾名思义就是用于测量视图的大小的。<strong>View系统的绘制流程会从ViewRoot的performTraversals()方法中开始</strong>，在其内部调用View的measure()方法。<br><strong>getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。</strong>另外，getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p><p>onDraw()步骤:<br>1.第一步是从第9行代码开始的，这一步的作用是对视图的背景进行绘制<br>2.第三步是在第34行执行的，这一步的作用是对视图的内容进行绘制<br>3.第四步的作用是对当前视图的所有子视图进行绘制<br>4.第六步的作用是对视图的滚动条进行绘制。其实不管是Button也好，TextView也好，任何一个视图都是有滚动条的，只是一般情况下我们都没有让它显示出来而已。<br>部分源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">if (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">    ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);</span><br><span class="line">&#125;</span><br><span class="line">final int privateFlags = mPrivateFlags;</span><br><span class="line">final boolean dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">        (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN;</span><br><span class="line">// Step 1, draw the background, if needed</span><br><span class="line">int saveCount;</span><br><span class="line">if (!dirtyOpaque) &#123;</span><br><span class="line">    final Drawable background = mBGDrawable;</span><br><span class="line">    if (background != null) &#123;</span><br><span class="line">        final int scrollX = mScrollX;</span><br><span class="line">        final int scrollY = mScrollY;</span><br><span class="line">        if (mBackgroundSizeChanged) &#123;</span><br><span class="line">            background.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);</span><br><span class="line">            mBackgroundSizeChanged = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((scrollX | scrollY) == 0) &#123;</span><br><span class="line">            background.draw(canvas);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canvas.translate(scrollX, scrollY);</span><br><span class="line">            background.draw(canvas);</span><br><span class="line">            canvas.translate(-scrollX, -scrollY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">final int viewFlags = mViewFlags;</span><br><span class="line">boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class="line">boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class="line">if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">    // Step 3, draw the content</span><br><span class="line">    if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line">    // Step 4, draw the children</span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line">    // Step 6, draw decorations (scrollbars)</span><br><span class="line">    onDrawScrollBars(canvas);</span><br><span class="line">    // we&apos;re done...</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>调用视图的setVisibility()、setEnabled()、setSelected()等方法时都会导致视图重绘，而如果我们想要手动地强制让视图进行重绘，可以调用invalidate()方法来实现。当然了，setVisibility()、setEnabled()、setSelected()等方法的内部其实也是通过调用invalidate()方法来实现的。</p><p>invalidate()方法中，当ViewParent不等于空的时候就会一直循环下去。在这个while循环当中会不断地获取当前布局的父布局，并调用它的invalidateChildInParent()方法，<strong>在ViewGroup的invalidateChildInParent()方法中主要是来计算需要重绘的矩形区域</strong>，当循环到最外层的根布局后，就会调用ViewRoot的invalidateChildInParent()方法了, 最终会调用到performTraversals()方法。<br>invalidate()方法虽然最终会调用到performTraversals()方法中，但这时measure和layout流程是不会重新执行的，因为视图没有强制重新测量的标志位，而且大小也没有发生过变化，所以这时只有draw流程可以得到执行。而如果你希望视图的绘制流程可以完完整整地重新走一遍，就不能使用invalidate()方法，而应该调用requestLayout()了。</p><p>参考：<a href="https://blog.csdn.net/guolin_blog/article/details/17045157" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/17045157</a></p><h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>Android中触摸事件传递过程中最重要的是dispatchTouchEvent()、onInterceptTouchEvent()和onTouchEvent()方法。这里记录一下他们的处理过程，以供记忆：<br>1.dispatchTouchEvent是处理触摸事件分发,事件(多数情况)是从Activity的dispatchTouchEvent开始的。执行super.dispatchTouchEvent(ev)，事件向下分发。dispatchTouchEvent()返回true，后续事件（ACTION_MOVE、ACTION_UP）会再传递，如果返回false，dispatchTouchEvent()就接收不到ACTION_UP、ACTION_MOVE。<br>2.onInterceptTouchEvent是ViewGroup提供的方法，默认返回false，返回true表示拦截。<br>3.onTouchEvent是View中提供的方法，ViewGroup也有这个方法，view中不提供onInterceptTouchEvent。view中默认返回true，表示消费了这个事件。</p><p>事件传递流程如下：<br>1.ACTION_DOWN首先会传递到onInterceptTouchEvent()方法<br>2.如果该ViewGroup的onInterceptTouchEvent()在接收到down事件处理完成之后return false，那么后续的move, up等事件将继续会先传递给该ViewGroup，之后才和down事件一样传递给最终的目标view的onTouchEvent()处理。<br>3.如果该ViewGroup的onInterceptTouchEvent()在接收到down事件处理完成之后return true，那么后续的move, up等事件将不再传递给onInterceptTouchEvent()，而是和down事件一样传递给该ViewGroup的onTouchEvent()处理，注意，目标view将接收不到任何事件。<br>4.如果最终需要处理事件的view的onTouchEvent()返回了false，那么该事件将被传递至其上一层次的view的onTouchEvent()处理。<br>5.如果最终需要处理事件的view的onTouchEvent()返回了true，那么后续事件将可以继续传递给该view的onTouchEvent()处理。</p><p><img src="/2019/08/12/android-note/view-touchevent.jpg" alt><br>当触摸事件ACTION_DOWN发生之后，先调用Activity中的dispatchTouchEvent函数进行处理，紧接着ACTION_DOWN事件传递给ViewGroup中的dispatchTouchEvent函数，接着viewGroup中的dispatchTouchEvent中的ACTION_DOWN事件传递到调用ViewGroup中的onInterceptTouchEvent函数，此函数负责拦截ACTION_DOWN事件。由于viewGroup下还包含子View，所以默认返回值为false，即不拦截此ACTION_DOWN事件。如果返回false，则ACTION_DOWN事件继续传递给其子view。由于子view不是viewGroup的控件，所以ACTION_DOWN事件接着传递到onTouchEvent进行处理事件。此时消息的传递基本上结束。从上可以分析，motionEvent事件的传递是采用隧道方式传递。隧道方式，即从根元素依次往下传递直到最内层子元素或在中间某一元素中由于某一条件停止传递。</p><p>参考：<a href="https://blog.csdn.net/qiushuiqifei/article/details/9918527" target="_blank" rel="noopener">https://blog.csdn.net/qiushuiqifei/article/details/9918527</a></p><h2 id="Android属性动画优化"><a href="#Android属性动画优化" class="headerlink" title="Android属性动画优化"></a>Android属性动画优化</h2><p>android的三种动画：</p><ul><li>View Animation（视图动画，平移、缩放、透明等）</li><li>Drawable Animation（帧动画）</li><li>Property Animation（属性动画）</li></ul><p>现在项目的动画问题最主要出在动画部分临时变量多，GC触发频繁，内存泄漏。属性动画优化思路：</p><ol><li>硬件加速<br>在开始动画时调用View.setLayerType(View.LAYER_TYPE_HARDWARE, null)<br>运行动画<br>动画结束时调用View.setLayerType(View.LAYER_TYPE_NONE, null).</li><li>减少临时变量,使用PropertyValuesHolder(可以用在多属性动画同时工作管理) ,一个view同时发生多种属性效果时，建议这种写法。</li><li>使用Keyframe<br>Keyframe是PropertyValuesHolder的成员，用来管理每一个关键帧的出现时间。一个view的单个属性先后发生一系列变化时，建议使用Keyframe达到效果。<br>总的来说就是：ObjectAnimator把属性值的更新委托给PropertyValuesHolder执行，PropertyValuesHolder再把关键帧的时序性计算委托给Keyframe。<br>最后，不同的view再用不同的ObjectAnimator管理。</li><li>内存泄漏: animator.setRepeatCount(ValueAnimator.INFINITE)及时cancel（）</li><li>动画卡顿，可以考虑使用自定义控件实现，如果一个自定义不行，那就是两个</li></ol><h2 id="ART和Dalvik"><a href="#ART和Dalvik" class="headerlink" title="ART和Dalvik"></a>ART和Dalvik</h2><p>Android4.4版本以前是Dalvik虚拟机，4.4版本开始引入ART虚拟机（Android Runtime）。在4.4版本上，两种运行时环境共存，可以相互切换，但是在5.0版本以后，Dalvik虚拟机则被彻底的丢弃，全部采用ART。</p><h3 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h3><p>ART 是一种执行效率更高且更省电的运行机制，执行的是本地机器码，这些本地机器码是从dex字节码转换而来。<strong>ART采用的是AOT（Ahead-Of-Time）编译</strong>，应用在第一次安装的时候，字节码就会预先编译成机器码存储在本地。在App运行时，ART模式就较Dalvik模式少了解释字节码的过程，所以App的运行效率会有所提高，占用内存也会相应减少。</p><h3 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h3><p>Dalvik 虚拟机采用的是JIT（Just-In-Time）编译模式，意思为即时编译，我们知道apk被安装到手机中时，对应目录会有dex或odex和apk文件，apk文件存储的是资源文件，而dex或odex（经过优化后的dex文件内部存储class文件）内部存储class文件，每次运行app时虚拟机会将dex文件解释翻译成机器码，这样才算是本地可执行代码，之后被系统运行。</p><p>Dalvik虚拟机可以看做是一个Java VM，他负责解释dex文件为机器码，如果我们不做处理的话，每次执行代码，都需要Dalvik将dex代码翻译为微处理器指令，然后交给系统处理，这样效率不高。为了解决这个问题，<strong>Google在2.2版本添加了JIT编译器，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。</strong>JIT代表运行时编译策略，也可以理解成一种运行时编译器，是为了加快Dalvik虚拟机解释dex速度提出的一种技术方案，来缓存频繁使用的本地机器码。</p><h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p><strong>Dalvik每次都要编译再运行，Art只会安装时启动编译</strong><br>Art占用空间比Dalvik大（原生代码占用的存储空间更大），就是用<strong>“空间换时间”</strong><br>Art减少编译，减少了CPU使用频率，使用明显改善电池续航<br>Art应用启动更快、运行更快、体验更流畅、触感反馈更及时</p><h2 id="UncaughtExceptionHandler"><a href="#UncaughtExceptionHandler" class="headerlink" title="UncaughtExceptionHandler"></a>UncaughtExceptionHandler</h2><p>如果给一个线程设置了UncaughtExceptionHandler 这个接口：<br>1、这个线程中，所有未处理或者说未捕获的异常都将会由这个接口处理，也就说被这个接口给try…catch了。<br>2、在这个线程中抛出异常时，java虚拟机将会忽略，也就是说，java虚拟机不会让程序崩溃了。<br>3、如果没有设置，那么最终会调用getDefaultUncaughtExceptionHandler 获取默认的UncaughtExceptionHandler 来处理异常。</p><h2 id="UI模块化-ViewController"><a href="#UI模块化-ViewController" class="headerlink" title="UI模块化(ViewController)"></a>UI模块化(ViewController)</h2><p>ViewController 是一种界面开发组件化的实现方式,利用它可以将一些复杂的 UI 界面开发组件化, 从而更好的组织代码结构,从而提高开发效率,降低维护成本。</p><p>将一个大的复杂界面拆分为若干子界面模块，这里需要通过一种恰当的代码组织方式去帮助我们实现一个子界面模块，这种所谓的恰当的模式就叫 <strong>ViewController</strong> ，通过 ViewController 我们可以把一个布局和业务逻辑封装为一个模块，Activity 只需要拿到这个模块的实例，就可以操作这个模块。</p><h2 id="aar"><a href="#aar" class="headerlink" title="@aar"></a>@aar</h2><p>@aar的方式关闭传递依赖</p><pre><code>// 只下载该库，其他所依赖的所有库不下载compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1@aar&apos;// 在使用@aar的前提下还能下载其他依赖库，则需要添加transitive=true的条件compile (&quot;io.reactivex.rxjava2:rxandroid::2.0.1@aar&quot;) {    transitive=true}</code></pre><h2 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h2><p>Groovy语言=<strong>Java语言的扩展+众多脚本语言的语法。运行在JVM虚拟机上。Gradle项目构框架使用groovy语言实现。</strong> 基于Gradle框架为我们实现了一些项目构件框架。</p><p>Groovy是一门jvm语言，它最终是要编译成class文件然后在jvm上执行，所以<strong>Java语言的特性Groovy都支持，我们完全可以混写Java和Groovy。</strong></p><p>在Groovy中，数据类型有：<br>1) Java中的基本数据类型<br>2) Java中的对象<br>3) Closure（闭包）<br>4) 加强的List、Map等集合类型<br>5) 加强的File、Stream等IO类型</p><p>类型可以显示声明，也可以用 def 来声明，用 def 声明的类型Groovy将会进行类型推断。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect Oriented Programming 面向切面编程）则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</p><p><strong>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。能将同一个关注点聚焦到同一个方法中解决。</strong></p><h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><p>由于AndroidStudio默认是没有ajc编译器的，所以在Android中使用@AspectJ来编写（包括SpringAOP也是如此）。它在代码的编译期间扫描目标程序，根据切点（PointCut）匹配,将开发者编写的Aspect程序编织（Weave）到目标程序的.class文件中，对目标程序作了重构（重构单位是JoinPoint），目的就是建立目标程序与Aspect程序的连接（获得执行的对象、方法、参数等上下文信息），从而达到AOP的目的。</p><p>AspectJ是通过对目标工程的.class文件进行代码注入的方式将通知(Advise)插入到目标代码中：<br>第一步：根据pointCut切点规则匹配的joinPoint；<br>第二步：将Advise插入到目标JoinPoint中。<br>这样在程序运行时被重构的连接点将会回调Advise方法，就实现了AspectJ代码与目标代码之间的连接。<br><img src="/2019/08/12/android-note/aspectj.png" alt></p><h3 id="Gradle-Transform"><a href="#Gradle-Transform" class="headerlink" title="Gradle Transform"></a>Gradle Transform</h3><p>Gradle Transform是Android官方提供给开发者在项目构建阶段即由class到dex转换期间修改class文件的一套api。目前比较经典的应用是字节码插桩、代码注入技术。Gradle Transform更多的是提供一种可以让开发者参与项目构建的机制，而诸如修改字节码等更加具体的细节则需要开发者去实现。</p><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>代理Hook:如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。</p><p>hook，又叫钩子，通常是指对一些方法进行拦截。这样当这些方法被调用时，也能够执行我们自己的代码，这也是面向切面编程的思想（AOP）。</p><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p>大致思路：<br>1.找到需要Hook方法的系统类<br>2.利用代理模式来代理系统类的运行拦截我们需要拦截的方法<br>3.使用反射的方法把这个系统类替换成你的代理类</p><p>案例可参考：<br><a href="https://blog.csdn.net/yulong0809/article/details/56842027" target="_blank" rel="noopener">https://blog.csdn.net/yulong0809/article/details/56842027</a></p><h2 id="应用的启动过程"><a href="#应用的启动过程" class="headerlink" title="应用的启动过程"></a>应用的启动过程</h2><p>1.首先我们要启动的Activity会去ActivityManagerService中去校检是否合法</p><p>2.通过回调ActivityThread中内部类ApplicationThread的scheduleLaunchActivity去发送一个消息到ActivityThread中的内部类H中，H继承于Handler</p><p>3.然后会通过反射创建Activity对象及Application对象，并回调响应生命周期方法</p><p>这里说一点ActivityManagerService和我们应用间沟通几乎都是ActivityThread，ApplicationThread，H这几个类之间来回调用，而且不只是Activity，我们Android的四大组件几乎都用了这种模式</p><p>参考：<br><a href="https://blog.csdn.net/yulong0809/article/details/58589715" target="_blank" rel="noopener">https://blog.csdn.net/yulong0809/article/details/58589715</a></p><h2 id="Watchdog"><a href="#Watchdog" class="headerlink" title="Watchdog"></a>Watchdog</h2><p>能通过关闭FinalizerWatchdogDaemon来减少TimeoutException的触发。需要注意的是，此种方法并不是去解决问题，而是为了避免上报异常采取的一种 hack 方案，并没有真正的解决引起 finialize() 超时的问题。</p><pre><code>// Android P 以后不能反射FinalizerWatchdogDaemonif (Build.VERSION.SDK_INT &gt;= 28) {    Log.w(TAG, &quot;stopWatchDog, do not support after Android P, just return&quot;);    return;}try {    final Class clazz = Class.forName(&quot;java.lang.Daemons$FinalizerWatchdogDaemon&quot;);    final Field field = clazz.getDeclaredField(&quot;INSTANCE&quot;);    field.setAccessible(true);    final Object watchdog = field.get(null);    try {        final Field thread = clazz.getSuperclass().getDeclaredField(&quot;thread&quot;);        thread.setAccessible(true);        thread.set(watchdog, null);    } catch (final Throwable t) {        Log.e(TAG, &quot;stopWatchDog, set null occur error:&quot; + t);        t.printStackTrace();        try {            // 直接调用stop方法，在Android 6.0之前会有线程安全问题            final Method method = clazz.getSuperclass().getDeclaredMethod(&quot;stop&quot;);            method.setAccessible(true);            method.invoke(watchdog);        } catch (final Throwable e) {            Log.e(TAG, &quot;stopWatchDog, stop occur error:&quot; + t);            t.printStackTrace();        }    }} catch (final Throwable t) {    Log.e(TAG, &quot;stopWatchDog, get object occur error:&quot; + t);    t.printStackTrace();}</code></pre><h2 id="NFC"><a href="#NFC" class="headerlink" title="NFC"></a>NFC</h2><p>Near Field Communication (NFC) 为<strong>一短距离无线通信技术，通常有效通讯距离为4厘米以内。NFC工作频率为13.65 兆赫兹，通信速率为106 kbit/秒到 848kbit/秒</strong>。</p><p>NFC支持如下3种工作模式：<br>读卡器模式（Reader/writer mode）、<br>仿真卡模式(Card Emulation Mode)、<br>点对点模式（P2P mode）。</p><p>Android SDK API主要支持NFC论坛标准（Forum Standard），这种标准被称为NDEF（NFC Data Exchange Format，NFC数据交换格式），类似传感器。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池使用的好处：<br>1：对多个线程进行统一地管理，避免资源竞争中出现的问题。<br>2：（重点）：对线程进行复用，线程在执行完任务后不会立刻销毁，而会等待另外的任务，这样就不会频繁地创建、销毁线程和调用GC。<br>3：JAVA提供了一套完整的ExecutorService线程池创建的api，可创建多种功能不一的线程池，使用起来很方便。</p><p>创建线程池，主要是利用ThreadPoolExecutor这个类，而这个类有几种构造方法，其中参数最多的一种构造方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                             int maximumPoolSize,</span><br><span class="line">                             long keepAliveTime,</span><br><span class="line">                             TimeUnit unit,</span><br><span class="line">                             BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                             ThreadFactory threadFactory) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>corePoolSize: 该线程池中核心线程的数量。<br>maximumPoolSize：该线程池中最大线程数量。(区别于corePoolSize)<br>keepAliveTime:从字面上就可以理解，是非核心线程空闲时要等待下一个任务到来的时间，当任务很多，每个任务执行时间很短的情况下调大该值有助于提高线程利用率。注意：当allowCoreThreadTimeOut属性设为true时，该属性也可用于核心线程。<br>unit:上面时间属性的单位<br>workQueue:任务队列<br>threadFactory:线程工厂，可用于设置线程名字等等，一般无须设置该参数。</p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava2原理解析</title>
      <link href="/2019/08/09/android-rxjava-principle/"/>
      <url>/2019/08/09/android-rxjava-principle/</url>
      
        <content type="html"><![CDATA[<p>本篇主要对以下三个方面进行讲解：</p><ul><li>RxJava是流式编程，在每一条流中，都至少包含三个要素：源头/被订阅者(Observable或Flowable)、订阅者(Observer或subscriber)、触发时机(subscribe()方法)；</li><li>其次就是线程切换（subscribeOn()和observeOn()）；</li><li>最后就是数据操作(如map()、flatMap()等)。</li></ul><h2 id="1、订阅（subscribe）"><a href="#1、订阅（subscribe）" class="headerlink" title="1、订阅（subscribe）"></a>1、订阅（subscribe）</h2><p>首先看下最简单的情况：</p><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {    @Override    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {        // doSomething, eg:         // emitter.onNext(&quot;onNext&quot;);        // emitter.onComplete();    }}).subscribe();</code></pre><p>一条RxJava流若是没有调用subscribe()方法，该流便无法执行，即<strong>必须由subscribe()确定了订阅关系后这条流才能生效</strong>，原因如下：</p><pre><code>// Observable.javapublic static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) {    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);    // 可以直接忽略RxJavaPlugins的相关方法，不影响我们理解原理    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));  }// 无论调用subscribe的哪个重载方法，最终都会走到这个方法public final void subscribe(Observer&lt;? super T&gt; observer) {    ... // 省去不重要代码    subscribeActual(observer);    ...}protected abstract void subscribeActual(Observer&lt;? super T&gt; observer);</code></pre><p>可以看到subscribe()里面主要是调用了subscribeActual，而subscribeActual是一个抽象方法，所以具体实现在子类中，这里的子类便是ObservableCreate，再来看它的实现：</p><pre><code>// ObservableCreate.javapublic ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) {    this.source = source;}protected void subscribeActual(Observer&lt;? super T&gt; observer) {    CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);    observer.onSubscribe(parent);    try {        source.subscribe(parent);    } catch (Throwable ex) {        Exceptions.throwIfFatal(ex);        parent.onError(ex);    }}</code></pre><p><strong>ObservableCreate中subscribeActual的实现就是将我们的observer封装成CreateEmitter（ObservableEmitter的实现类），再执行observer.onSubscribe，确保onSubscribe总能在onNext等其他订阅行为之前执行，接着就是我们的核心代码：source.subscribe(parent)，source便是我们一开始创建流时新建的ObservableOnSubscribe对象，而parent则是封装后的CreateEmitter，所以其实此时执行的便是在创建ObservableOnSubscribe时实现的public void subscribe(ObservableEmitter<string> emitter) throws Exception方法，此时整条流的订阅关系便成立了。</string></strong></p><p>现在我们知道，事件流的执行实际上是由子类实现的subscribeActual控制的，所以其他的Observable创建方式也是一样的道理，这里再以fromIterable为例看一下：</p><pre><code>// Observable.javapublic static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source) {    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);    return RxJavaPlugins.onAssembly(new ObservableFromIterable&lt;T&gt;(source));}// ObservableFromIterable.javapublic ObservableFromIterable(Iterable&lt;? extends T&gt; source) {    this.source = source;}@Overridepublic void subscribeActual(Observer&lt;? super T&gt; s) {    Iterator&lt;? extends T&gt; it;    try {        it = source.iterator();    } catch (Throwable e) {        Exceptions.throwIfFatal(e);        EmptyDisposable.error(e, s);        return;    }    boolean hasNext;    try {        hasNext = it.hasNext();    } catch (Throwable e) {        Exceptions.throwIfFatal(e);        EmptyDisposable.error(e, s);        return;    }    if (!hasNext) {        EmptyDisposable.complete(s);        return;    }    FromIterableDisposable&lt;T&gt; d = new FromIterableDisposable&lt;T&gt;(s, it);    s.onSubscribe(d);    if (!d.fusionMode) {        d.run();    }}    </code></pre><p>可以看到，这里是将observer和我们的数据源列表封装为FromIterableDisposable，然后执行d.run()，下面看下run的实现：</p><pre><code>// FromIterableDisposable.javaFromIterableDisposable(Observer&lt;? super T&gt; actual, Iterator&lt;? extends T&gt; it) {    this.actual = actual;    this.it = it;}void run() {    boolean hasNext;    do {        if (isDisposed()) {            return;        }        T v;        try {            v = ObjectHelper.requireNonNull(it.next(), &quot;The iterator returned a null value&quot;);        } catch (Throwable e) {            Exceptions.throwIfFatal(e);            actual.onError(e);            return;        }        actual.onNext(v);        if (isDisposed()) {            return;        }        try {            hasNext = it.hasNext();        } catch (Throwable e) {            Exceptions.throwIfFatal(e);            actual.onError(e);            return;        }    } while (hasNext);    if (!isDisposed()) {        actual.onComplete();    }}</code></pre><p>在run方法中不停地遍历数据源列表，然后根据实际情况执行对应的事件处理方法(actual.onNext(v);等，actual即为我们传进来的observer)，这便完成了RxJava流的处理。</p><p>总结：<strong>RxJava2的订阅原理其实便是在subcribe时执行子类中实现的subscribeActual方法，该方法最终会去调用observer相关的订阅方法，可理解为观察者模式的一种变形。</strong></p><h2 id="2、线程切换"><a href="#2、线程切换" class="headerlink" title="2、线程切换"></a>2、线程切换</h2><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><pre><code>// Observable.javapublic final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) {    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));    }</code></pre><p>subscribeOn时其实也是创建了一个Observable子类去实现subscribeActual方法：</p><pre><code>// ObservableSubscribeOn.javapublic void subscribeActual(final Observer&lt;? super T&gt; s) {    final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);    s.onSubscribe(parent);    parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));}</code></pre><p>这里将下游的Observer s封装成SubscribeOnObserver后又封装成Runnable的实现类SubscribeTask，在run方法中source.subscribe(parent)：</p><pre><code>// ObservableSubscribeOn.javafinal class SubscribeTask implements Runnable {    private final SubscribeOnObserver&lt;T&gt; parent;    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) {        this.parent = parent;    }    @Override    public void run() {        source.subscribe(parent);    }}</code></pre><p>然后通过scheduler.scheduleDirect(new SubscribeTask(parent))将这个Task放到Worker中：</p><pre><code>// Scheduler.javapublic Disposable scheduleDirect(@NonNull Runnable run) {    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);}public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {    final Worker w = createWorker();    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);    DisposeTask task = new DisposeTask(decoratedRun, w);    w.schedule(task, delay, unit);    return task;}public abstract Worker createWorker();</code></pre><p>而createWorker由Scheduler子类实现，即我们执行的线程类型，如AndroidSchedulers.mainThread()、Schedulers.io()，这里以mainThread()为例，</p><pre><code>// AndroidSchedulers.javapublic static Scheduler mainThread() {    return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);}private static final Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(new Callable&lt;Scheduler&gt;() {    @Override     public Scheduler call() throws Exception {        return MainHolder.DEFAULT;    }});private static final class MainHolder {    static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper()));}</code></pre><p>RxAndroidPlugins里面的非常简单，这里最终返回的就是HandlerScheduler，因此来看下它实现的createWorker和schedule方法：</p><pre><code>// HandlerScheduler.javapublic Worker createWorker() { return new HandlerWorker(handler); }</code></pre><p>在HandlerWorker中实现schedule(task, delay, unit)：</p><pre><code>// HandlerWorker.javapublic Disposable schedule(Runnable run, long delay, TimeUnit unit) {    ...    ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);    Message message = Message.obtain(handler, scheduled);    message.obj = this; // Used as token for batch disposal of this worker&apos;s runnables.    handler.sendMessageDelayed(message, unit.toMillis(delay));    ....    return scheduled;}</code></pre><p>这里将handler（由上面创建DEFAULT Scheduler时可知，该handler为UI线程的handler）和run又再次封装为ScheduledRunnable，然后通过handler发送到主线程处理，因此便保证了订阅操作（source.subscribe(parent)）执行在主线程。</p><p>同时，由上面可知，rx流由subscribe开始触发，然后执行source.subscribe(observer)，然而source可能也是上游操作后的产物（如map），因此便会触发上游内部的subscribe，直到源头，即<strong>rx流由subscribe开始触发，然后逆向向上寻找直到源头，才开始真正的执行</strong>。因此，若是有多个subscribeOn，最终的subscribe也是被放到最上面的subscribeOn（即第一个）指定的线程中执行，<strong>这便是指定多个subscribeOn只有第一个生效的原因</strong>。</p><p>总结：<strong>其实就是将订阅操作放到Runnable中执行，并结合handler机制将Runnable发送到主线程，对于其他线程（不同的线程模式会创建不同的Scheduler，并持有对应的线程池）则是将Runnable交给指定线程池处理。这便保证了在指定线程获取/处理数据源（observable）。</strong></p><h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h3><pre><code>// Observable.javapublic final Observable&lt;T&gt; observeOn(Scheduler scheduler) {    return observeOn(scheduler, false, bufferSize());}public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);    ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);    return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));}</code></pre><p>observeOn的线程切换则是在ObservableObserveOn中处理的：</p><pre><code>// ObservableObserveOn.javaprotected void subscribeActual(Observer&lt;? super T&gt; observer) {    if (scheduler instanceof TrampolineScheduler) {         source.subscribe(observer);    } else {        Scheduler.Worker w = scheduler.createWorker();        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));    }}</code></pre><p>这里也是根据指定线程类型创建Worker（可参考上面subscribeOn原理），并将observer和w一同放到ObserveOnObserver中：</p><pre><code>// ObserveOnObserver.javapublic void onNext(T t) {    ....    schedule();}void schedule() {    if (getAndIncrement() == 0) {        worker.schedule(this);    }}public void run() {    if (outputFused) {        drainFused();    } else {         drainNormal();    }}void drainNormal() {    ...    for (;;) {        ...        for (;;) {            ...            a.onNext(v);        }        ...    }}</code></pre><p>可以看到，onNext执行的是schedule，而schedule则是将该对象直接放到指定线程的Worker中，然后在run中去执行对应的事件处理方法（onNext等），因此便实现了将下游的observer放到指定线程执行的目的，当然，这里只是将其直接下游的observer放到指定线程而已，对于其下游的下游则不一定。<strong>也就是说，observeOn可以有多个，每个都是对其直接下游做线程切换，若是下游不再切换，则所有下游都在该指定线程中执行。</strong></p><p>总结:<strong>observeOn其实就是将下游的observer放到指定线程里面去执行。</strong></p><h2 id="3、数据变换"><a href="#3、数据变换" class="headerlink" title="3、数据变换"></a>3、数据变换</h2><p>在事件从源头流到最终观察者的过程中，我们可以对事件进行操作转换，这里以map和flatMap为例进行解析。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><pre><code>// Observable.javapublic final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {    ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);    return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));}</code></pre><p>执行map操作时其实是<strong>将上游的observable和我们自己实现的mapper封住成一个ObservableMap</strong>，所以具体实现就是在ObservableMap的subscribeActual中：</p><pre><code>// ObservableMap.javapublic void subscribeActual(Observer&lt;? super U&gt; t) {    source.subscribe(new MapObserver&lt;T, U&gt;(t, function));}</code></pre><p>看到这句是不是很熟悉，从上面的订阅原理可知，到这里其实真正执行的便是MapObserver中的onNext等方法了，而其onNext里便是先执行map转换，再将转换结果交给下游的observer执行：</p><pre><code>// MapObserver.java@Overridepublic void onNext(T t) {    if (done) { // error or complete        return;    }    if (sourceMode != NONE) {        actual.onNext(null);        return;    }    U v;    try {    v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;);    } catch (Throwable ex) {        fail(ex);    return;    }    actual.onNext(v);}</code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>我们调用的flatMap最终执行的是该重载方法：</p><pre><code>// Observable.javapublic final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, boolean delayErrors, int maxConcurrency, int bufferSize) {     ...     return RxJavaPlugins.onAssembly(new ObservableFlatMap&lt;T, R&gt;(this, mapper, delayErrors, maxConcurrency, bufferSize));}</code></pre><p>因此看下ObservableFlatMap：</p><pre><code>// ObservableFlatMap.javapublic ObservableFlatMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends ObservableSource&lt;? extends U&gt;&gt; mapper, boolean delayErrors, int maxConcurrency, int bufferSize) {    super(source);    this.mapper = mapper;    this.delayErrors = delayErrors;    this.maxConcurrency = maxConcurrency;    this.bufferSize = bufferSize;}@Overridepublic void subscribeActual(Observer&lt;? super U&gt; t) {    if (ObservableScalarXMap.tryScalarXMapSubscribe(source, t, mapper)) {    return;    }    source.subscribe(new MergeObserver&lt;T, U&gt;(t, mapper, delayErrors, maxConcurrency, bufferSize));}</code></pre><p>所以实际的操作是在MergeObserver，这里我们就看下onNext就好了：</p><pre><code>// MergeObserver.javapublic void onNext(T t) {    // safeguard against misbehaving sources    if (done) {        return;    }    ObservableSource&lt;? extends U&gt; p;    try {        p = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper returned a null ObservableSource&quot;);    } catch (Throwable e) {        Exceptions.throwIfFatal(e);        s.dispose();        onError(e);        return;    }    if (maxConcurrency != Integer.MAX_VALUE) {        synchronized (this) {            if (wip == maxConcurrency) {                sources.offer(p);                return;            }            wip++;        }    }    subscribeInner(p);}</code></pre><p>可以看到，这里是想<strong>将上游传进来的对象通过我们自己实现的mapper进行转换，然后再执行subscribeInner(p)</strong>（maxConcurrency默认就是Integer.MAX_VALUE），因此看下subscribeInner(p)：</p><pre><code>// MergeObserver.javavoid subscribeInner(ObservableSource&lt;? extends U&gt; p) {    for (;;) {        if (p instanceof Callable) {            if (tryEmitScalar(((Callable&lt;? extends U&gt;)p)) &amp;&amp; maxConcurrency != Integer.MAX_VALUE) {                boolean empty = false;                synchronized (this) {                    p = sources.poll();                    if (p == null) {                        wip--;                        empty = true;                    }                }                if (empty) {                    drain();                    break;                }            } else {                break;            }        } else {            InnerObserver&lt;T, U&gt; inner = new InnerObserver&lt;T, U&gt;(this, uniqueId++);            if (addInner(inner)) {                p.subscribe(inner);            }            break;        }    }}</code></pre><p>这里是个无线循环，根据是否为Callable类型执行不同的逻辑，一般Observable.just为Callable，而from类型的则不是。这里看下from的逻辑，毕竟Callable类型又没指定maxConcurrency的话，是直接break，所以没什么好看的。而非Callable类型的，可以看到这里又封装成了InnerObserver，而for循环并没有什么用。</p><p>总结：<strong>在执行操作符方法(如map、flatMap等)时，会生成对应的Observable对象，在该对象中实现具体业务逻辑，对上游流下来的数据进行操作，再将处理后的结果交给下游的的订阅者继续处理。</strong></p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>RxJava2事件流的产生由subscribe方法调用subscribeActual(observer)触发，而subscribeActual由Observable子类实现，每个子类里的实现逻辑不同，可能会先执行自己的操作（如map或flatMap等 ），但最终都会调用source.subscribe，source即为该节点的上游数据源，因此需要上游操作执行完才能拿到source，最终便形成逐级逆向向上获取数据源（Observable或Flowable），即形成了从最开始的源头发射数据一路向下经过各个节点的操作后交给最终观察者的链式模型。</p><p>而对于线程切换，subscribeOn即是将订阅操作（observer）放到Runnable中执行，并将Runnable放到指定线程里操作；observeOn则是将下游的observer放到指定线程里面去执行。</p><h2 id="5、参考资料"><a href="#5、参考资料" class="headerlink" title="5、参考资料"></a>5、参考资料</h2><p><a href="https://blog.csdn.net/reakingf/article/details/84845705" target="_blank" rel="noopener">https://blog.csdn.net/reakingf/article/details/84845705</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava2五种被观察者及背压</title>
      <link href="/2019/08/07/android-rxjava-role/"/>
      <url>/2019/08/07/android-rxjava-role/</url>
      
        <content type="html"><![CDATA[<p>RxJava五种被观察者为Flowable, Observable，Single, Completable, Maybe。</p><p>五种被观察者可通过toFlowable, toObservable，toSingle, toCompletable, toMaybe相互转换。</p><h2 id="1、Flowable"><a href="#1、Flowable" class="headerlink" title="1、Flowable"></a>1、Flowable</h2><h3 id="1-1、Flowable简介"><a href="#1-1、Flowable简介" class="headerlink" title="1.1、Flowable简介"></a>1.1、Flowable简介</h3><p>Flowable类，用于实现Reactive-Streams模式，并提供工厂方法，中间运算符以及使用反应式数据流的能力。</p><p>Reactive-Streams使用Flowable运行，Flowable实现了Publishers。因此，许多运算符直接接受Publishers，并允许与其他Reactive-Streams的实现进行直接交互操作</p><pre><code>public abstract class Flowable&lt;T&gt; implements Publisher&lt;T&gt;</code></pre><p><strong>Flowable为操作符提供128个元素的默认缓冲区大小，可通过bufferSize() 方法获取，可通过系统参数rx2.buffer-size全局覆盖</strong>。但是大多数运算符都有重载，允许显式设置其内部缓冲区大小。</p><pre><code>/** The default buffer size. */static final int BUFFER_SIZE;static {    BUFFER_SIZE = Math.max(16, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128));}/** * Returns the default internal buffer size used by most async operators. * &lt;p&gt;The value can be overridden via system parameter {@code rx2.buffer-size} * &lt;em&gt;before&lt;/em&gt; the Flowable class is loaded. * @return the default internal buffer size. */public static int bufferSize() {    return BUFFER_SIZE;}</code></pre><h3 id="1-2、Flowable官方图解"><a href="#1-2、Flowable官方图解" class="headerlink" title="1.2、Flowable官方图解"></a>1.2、Flowable官方图解</h3><p><img src="/2019/08/07/android-rxjava-role/rxjava-flowable.jpg" alt><br>1）看到上图有点疑问，不是在说Flowable嘛，怎么图解里的说明是Observable呢？</p><p>2）其实在官方文档里面Flowable和Observable都使用的是上面这个图解，因此这两个类肯定是提供相似功能，既然是相似，那么这幅图就是他们的共性，那不同的地方是什么呢？</p><p>不同之处是：<strong>Flowable支持Backpressure，Observable不支持Backpressure；只有在需要处理背压问题时，才需要使用Flowable</strong>。</p><p>由于<strong>只有在上下游运行在不同的线程中，且上游发射数据的速度大于下游接收处理数据的速度时，才会产生背压问题</strong>；<br>所以，如果能够确定：<br>1、上下游运行在同一个线程中，<br>2、上下游工作在不同的线程中，但是下游处理数据的速度不慢于上游发射数据的速度，<br>3、上下游工作在不同的线程中，但是数据流中只有一条数据<br>则不会产生背压问题，就没有必要使用Flowable，以免影响性能。</p><p>类似于Observable,在使用Flowable时，也可以通过create操作符创建发射数据流，代码如下：</p><pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {            @Override            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {                e.onNext(1);                e.onNext(2);                e.onNext(3);                e.onComplete();            }        }, BackpressureStrategy.BUFFER) //create方法中多了一个BackpressureStrategy类型的参数        .subscribeOn(Schedulers.newThread())//为上下游分别指定各自的线程        .observeOn(Schedulers.newThread())        .subscribe(new Subscriber&lt;Integer&gt;() {            @Override            public void onSubscribe(Subscription s) {   //onSubscribe回调的参数不是Disposable而是Subscription                s.request(Long.MAX_VALUE);            //注意此处，暂时先这么设置            }            @Override            public void onNext(Integer integer) {                System.out.println(&quot;接收----&gt; &quot; + integer);            }            @Override            public void onError(Throwable t) {            }            @Override            public void onComplete() {                System.out.println(&quot;接收----&gt; 完成&quot;);            }        });</code></pre><p>运行结果如下：</p><pre><code>System.out: 接收----&gt; 1System.out: 接收----&gt; 2System.out: 接收----&gt; 3System.out: 接收----&gt; 完成</code></pre><p>发射与处理数据流在形式上与Observable大同小异，发射器中均有onNext，onError，onComplete方法，订阅器中也均有onSubscribe，onNext，onError，onComplete方法。<br>但是在细节方面还是有三点不同：<br>一、create方法中多了一个BackpressureStrategy类型的参数。<br>二、订阅器Subscriber中，方法onSubscribe回调的参数不是Disposable而是Subscription，多了行代码：s.request(Long.MAX_VALUE);<br>三、Flowable发射数据时，使用特有的发射器FlowableEmitter，不同于Observable的ObservableEmitter</p><h3 id="1-3、Backpressure"><a href="#1-3、Backpressure" class="headerlink" title="1.3、Backpressure"></a>1.3、Backpressure</h3><p>在通过create操作符创建Flowable时，多了一个BackpressureStrategy类型的参数，BackpressureStrategy是个枚举，源码如下：</p><pre><code>/** * Represents the options for applying backpressure to a source sequence. */public enum BackpressureStrategy {    /**     * OnNext events are written without any buffering or dropping.     * Downstream has to deal with any overflow.     * &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators.     */    MISSING,    /**     * Signals a MissingBackpressureException in case the downstream can&apos;t keep up.     */    ERROR,    /**     * Buffers &lt;em&gt;all&lt;/em&gt; onNext values until the downstream consumes it.     */    BUFFER,    /**     * Drops the most recent onNext value if the downstream can&apos;t keep up.     */    DROP,    /**     * Keeps only the latest onNext value, overwriting any previous value if the     * downstream can&apos;t keep up.     */    LATEST}</code></pre><p><strong>当上游发送数据的速度快于下游接收数据的速度，且运行在不同的线程中时，Flowable通过自身特有的异步缓存池，来缓存没来得及处理的数据，缓存池的容量上限为128</strong></p><p>BackpressureStrategy的作用便是用来设置Flowable通过异步缓存池缓存数据的策略。在源码FlowableCreate类中，可以看到五个泛型分别对应五个java类，通过代理模式对原始的发射器进行了包装：</p><pre><code>Overridepublic void subscribeActual(Subscriber&lt;? super T&gt; t) {    BaseEmitter&lt;T&gt; emitter;    switch (backpressure) {        case MISSING: {            emitter = new MissingEmitter&lt;T&gt;(t);            break;        }        case ERROR: {            emitter = new ErrorAsyncEmitter&lt;T&gt;(t);            break;        }        case DROP: {            emitter = new DropAsyncEmitter&lt;T&gt;(t);            break;        }        case LATEST: {            emitter = new LatestAsyncEmitter&lt;T&gt;(t);            break;        }        default: {            emitter = new BufferAsyncEmitter&lt;T&gt;(t, bufferSize());            break;        }    }    t.onSubscribe(emitter);    try {        source.subscribe(emitter);    } catch (Throwable ex) {        Exceptions.throwIfFatal(ex);        emitter.onError(ex);    }}</code></pre><h4 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h4><p>对应于ErrorAsyncEmitter<t>类，在其源码</t></p><pre><code>static final class ErrorAsyncEmitter&lt;T&gt; extends NoOverflowBaseAsyncEmitter&lt;T&gt; {        private static final long serialVersionUID = 338953216916120960L;        ErrorAsyncEmitter(Subscriber&lt;? super T&gt; actual) {            super(actual);        }        @Override        void onOverflow() {            onError(new MissingBackpressureException(&quot;create: could not emit value due to lack of requests&quot;));        }    }abstract static class NoOverflowBaseAsyncEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; {        private static final long serialVersionUID = 4127754106204442833L;        NoOverflowBaseAsyncEmitter(Subscriber&lt;? super T&gt; actual) {            super(actual);        }        @Override        public final void onNext(T t) {            if (isCancelled()) {                return;            }            if (t == null) {                onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));                return;            }            if (get() != 0) {                actual.onNext(t);                BackpressureHelper.produced(this, 1);            } else {                onOverflow();            }        }        abstract void onOverflow();    }</code></pre><p>onOverflow方法中可以看到，<strong>在此策略下，如果放入Flowable的异步缓存池中的数据超限了，则会抛出MissingBackpressureException异常。父类的onNext中，在判断get() != 0，即缓存池未满的情况下，才会让被代理类调用onNext方法</strong>。运行如下代码：</p><pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {            @Override            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {                for (int i = 1; i &lt;= 129; i++) {                    e.onNext(i);                }                e.onComplete();            }        }, BackpressureStrategy.ERROR)        .subscribeOn(Schedulers.newThread())        .observeOn(Schedulers.newThread())        .subscribe(new Subscriber&lt;Integer&gt;() {            @Override            public void onSubscribe(Subscription s) {                s.request(Long.MAX_VALUE);            //注意此处，暂时先这么设置            }            @Override            public void onNext(Integer integer) {                try {                    Thread.sleep(10000);                } catch (InterruptedException ignore) {                }                System.out.println(integer);            }            @Override            public void onError(Throwable t) {                t.printStackTrace();            }            @Override            public void onComplete() {                System.out.println(&quot;接收----&gt; 完成&quot;);            }        });</code></pre><p>创建并通过Flowable发射129条数据，Subscriber的onNext方法睡10秒之后再开始接收，运行后会发现控制台打印如下异常：</p><pre><code>W/System.err: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requestsW/System.err:     at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411)W/System.err:     at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377)</code></pre><p>如果将Flowable发射数据的条数改为128，则不会出现此异常。</p><h4 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h4><p>对应于DropAsyncEmitter<t>类，通过DropAsyncEmitter类和它父类NoOverflowBaseAsyncEmitter的源码</t></p><pre><code>static final class DropAsyncEmitter&lt;T&gt; extends NoOverflowBaseAsyncEmitter&lt;T&gt; {    private static final long serialVersionUID = 8360058422307496563L;    DropAsyncEmitter(Subscriber&lt;? super T&gt; actual) {        super(actual);    }    @Override    void onOverflow() {        // nothing to do    }}</code></pre><p>可以看到，DropAsyncEmitter的onOverflow是个空方法，没有执行任何操作。所以<strong>在此策略下，如果Flowable的异步缓存池满了，会丢掉上游发送的数据</strong>。</p><p>存池中数据的清理，并不是Subscriber接收一条，便清理一条，而是存在一个延迟，等累积一段时间后统一清理一次。也就是Subscriber接收到第96条数据时，缓存池才开始清理数据，之后Flowable发射的数据才得以放入。如果数据处于缓存池存满的状态时，则被丢弃。</p><h4 id="LATEST"><a href="#LATEST" class="headerlink" title="LATEST"></a>LATEST</h4><p>对应于LatestAsyncEmitter<t>类<br>与Drop策略一样，如果缓存池满了，会丢掉将要放入缓存池中的数据，不同的是，不管缓存池的状态如何，<strong>LATEST都会将最后一条数据强行放入缓存池中</strong>，来保证观察者在接收到完成通知之前，能够接收到Flowable最新发射的一条数据。</t></p><h4 id="BUFFER"><a href="#BUFFER" class="headerlink" title="BUFFER"></a>BUFFER</h4><p>Flowable处理背压的默认策略，对应于BufferAsyncEmitter<t>类</t></p><p>其部分源码为：</p><pre><code>static final class BufferAsyncEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; {        private static final long serialVersionUID = 2427151001689639875L;        final SpscLinkedArrayQueue&lt;T&gt; queue;        . . . . . .        final AtomicInteger wip;        BufferAsyncEmitter(Subscriber&lt;? super T&gt; actual, int capacityHint) {            super(actual);            this.queue = new SpscLinkedArrayQueue&lt;T&gt;(capacityHint);            this.wip = new AtomicInteger();        }        . . . . . .}</code></pre><p>在其构造方法中可以发现，其内部维护了一个缓存池SpscLinkedArrayQueue，其大小不限，此策略下，<strong>如果Flowable默认的异步缓存池满了，会通过此缓存池暂存数据，它与Observable的异步缓存池一样，可以无限制向里添加数据，不会抛出MissingBackpressureException异常，但会导致OOM</strong>。</p><p>和使用Observable时一样，都会导致内存剧增，最后导致OOM,不同的是使用Flowable内存增长的速度要慢得多，那是因为基于Flowable发射的数据流，以及对数据加工处理的各操作符都添加了背压支持，附加了额外的逻辑，其运行效率要比Observable低得多。</p><h4 id="MISSING"><a href="#MISSING" class="headerlink" title="MISSING"></a>MISSING</h4><p>对应于MissingEmitter<t>类，通过其源码：</t></p><pre><code>static final class MissingEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; {        private static final long serialVersionUID = 3776720187248809713L;        MissingEmitter(Subscriber&lt;? super T&gt; actual) {            super(actual);        }        @Override        public void onNext(T t) {            if (isCancelled()) {                return;            }            if (t != null) {                actual.onNext(t);            } else {                onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));                return;            }            for (;;) {                long r = get();                if (r == 0L || compareAndSet(r, r - 1)) {                    return;                }            }        }    }</code></pre><p>可以发现，在传递数据时</p><pre><code>actual.onNext(t);</code></pre><p>并没有对缓存池的状态进行判断，所以在此策略下，通过Create方法创建的Flowable相当于没有指定背压策略，不会对通过onNext发射的数据做缓存或丢弃处理，需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）指定背压策略。</p><p>onBackpressureXXX背压操作符：<strong>Flowable除了通过create创建的时候指定背压策略，也可以在通过其它创建操作符just，fromArray等创建后通过背压操作符指定背压策略</strong>。</p><blockquote><p>onBackpressureBuffer()对应BackpressureStrategy.BUFFER<br>onBackpressureDrop()对应BackpressureStrategy.DROP<br>onBackpressureLatest()对应BackpressureStrategy.LATEST</p></blockquote><p>例如代码</p><pre><code>Flowable.range(0, 500)        .onBackpressureDrop()        .subscribeOn(Schedulers.newThread())        .observeOn(Schedulers.newThread())        .subscribe(new Consumer&lt;Integer&gt;() {            @Override            public void accept(@NonNull Integer integer) throws Exception {                System.out.println(integer);            }        });</code></pre><h4 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h4><p>Subscription与Disposable均是观察者与可观察对象建立订阅状态后回调回来的参数，如同<strong>通过Disposable的dispose()方法可以取消Observer与Oberverable的订阅关系一样，通过Subscription的cancel()方法也可以取消Subscriber与Flowable的订阅关系</strong>。<br>不同的是接口Subscription中多了一个方法request(long n)，如上面代码中的：</p><pre><code>s.request(Long.MAX_VALUE);   </code></pre><p>Flowable在设计的时候，采用了一种新的思路——<strong>响应式拉取</strong>方式，来<strong>设置下游对数据的请求数量，上游可以根据下游的需求量，按需发送数据。如果不显示调用request则默认下游的需求量为零，上游Flowable发射的数据不会交给下游Subscriber处理。</strong></p><p>多次调用request，数字会累积。</p><p>上游并没有根据下游的实际需求，发送数据，而是能发送多少，就发送多少，不管下游是否需要。而且超出下游需求之外的数据，仍然放到了异步缓存池中。这点我们可以通过以下代码来验证：</p><pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {            @Override            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {                for (int i = 1; i &lt; 130; i++) {                    System.out.println(&quot;发射----&gt;&quot; + i);                    e.onNext(i);                }                e.onComplete();            }        }, BackpressureStrategy.ERROR)        .subscribeOn(Schedulers.newThread())        .observeOn(Schedulers.newThread())        .subscribe(new Subscriber&lt;Integer&gt;() {            @Override            public void onSubscribe(Subscription s) {                s.request(1);            }            @Override            public void onNext(Integer integer) {                System.out.println(&quot;接收------&gt;&quot; + integer);            }            @Override            public void onError(Throwable t) {                t.printStackTrace();            }            @Override            public void onComplete() {                System.out.println(&quot;接收------&gt;完成&quot;);            }        });</code></pre><p>通过Flowable发射130条数据，通过s.request(1)设置下游的数据请求量为1条，设置缓存策略为BackpressureStrategy.ERROR，如果异步缓存池超限，会导致MissingBackpressureException异常。久违的异常出现了，所以超出下游需求之外的数据，仍然放到了异步缓存池中，并导致缓存池溢出。</p><p>那么上游如何才能按照下游的请求数量发送数据呢，虽然通过request可以设置下游的请求数量，但是上游并没有获取到这个数量，如何获取呢？这便需要用到Flowable与Observable的第三点区别，Flowable特有的发射器FlowableEmitter</p><h4 id="FlowableEmitter"><a href="#FlowableEmitter" class="headerlink" title="FlowableEmitter"></a>FlowableEmitter</h4><p>flowable的发射器FlowableEmitter与observable的发射器ObservableEmitter均继承自Emitter<br>比较两者源码可以发现：</p><pre><code>public interface ObservableEmitter&lt;T&gt; extends Emitter&lt;T&gt; {    void setDisposable(Disposable d);    void setCancellable(Cancellable c);    boolean isDisposed();    ObservableEmitter&lt;T&gt; serialize();}</code></pre><p>与</p><pre><code>public interface FlowableEmitter&lt;T&gt; extends Emitter&lt;T&gt; {    void setDisposable(Disposable s);    void setCancellable(Cancellable c);    long requested();    boolean isCancelled();    FlowableEmitter&lt;T&gt; serialize();}</code></pre><p>接口FlowableEmitter中多了一个方法</p><pre><code>long requested();</code></pre><p>上游在发送数据的时候并不需要考虑下游需不需要，而只需要考虑异步缓存池中是否放得下，放得下便发，放不下便暂停。所以，通过e.requested()获取到的值，并不是下游真正的数据请求数量，而是异步缓存池中可放入数据的数量。数据放入缓存池中后，再由缓存池按照下游的数据请求量向下传递，待到传递完的数据累积到95条之后，将其清除，腾出空间存放新的数据。如果下游处理数据缓慢，则缓存池向下游传递数据的速度也相应变慢，进而没有传递完的数据可清除，也就没有足够的空间存放新的数据，上游通过e.requested()获取的值也就变成了0，如果此时，再发送数据的话，则会根据BackpressureStrategy背压策略的不同，抛出MissingBackpressureException异常，或者丢掉这条数据。</p><p>我们<strong>可以通过这个方法来获取当前未完成的请求数量，上游只需要在e.requested()等于0时，暂停发射数据，便可解决背压问题。</strong></p><h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>下面，对其通过Flowable做些改进，让其既不会产生背压问题，也不会引起异常或者数据丢失。<br>代码如下：</p><pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {            @Override            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {                int i = 0;                while (true) {                    if (e.requested() == 0) continue;//此处添加代码，让flowable按需发送数据                    System.out.println(&quot;发射----&gt;&quot; + i);                    i++;                    e.onNext(i);                }            }        }, BackpressureStrategy.MISSING)        .subscribeOn(Schedulers.newThread())        .observeOn(Schedulers.newThread())        .subscribe(new Subscriber&lt;Integer&gt;() {            private Subscription mSubscription;            @Override            public void onSubscribe(Subscription s) {                s.request(1);            //设置初始请求数据量为1                mSubscription = s;            }            @Override            public void onNext(Integer integer) {                try {                    Thread.sleep(50);                    System.out.println(&quot;接收------&gt;&quot; + integer);                    mSubscription.request(1);//每接收到一条数据增加一条请求量                } catch (InterruptedException ignore) {                }            }            @Override            public void onError(Throwable t) {            }            @Override            public void onComplete() {            }        });</code></pre><p>下游处理数据的速度Thread.sleep(50)赶不上上游发射数据的速度，不同的是，我们在下游onNext(Integer integer) 方法中，每接收一条数据增加一条请求量，</p><pre><code>mSubscription.request(1)</code></pre><p>在上游添加代码</p><pre><code>if(e.requested()==0)continue;</code></pre><p>让上游按需发送数据，上游严格按照下游的需求量发送数据，不会产生MissingBackpressureException异常，或者丢失数据。</p><h2 id="2、Observable"><a href="#2、Observable" class="headerlink" title="2、Observable"></a>2、Observable</h2><h3 id="2-1、Observable简介"><a href="#2-1、Observable简介" class="headerlink" title="2.1、Observable简介"></a>2.1、Observable简介</h3><p>Observable类是不支持背压的，Observable是Reactive的一个抽象基类，Observable提供工厂方法，中间运算符以及消费同步和/或异步数据流的功能。</p><p>Observable类中的多数运算符接受一个或者多个ObservableSource，ObservableSource是非背压的基本接口，Observable实现了这个接口。</p><p>public abstract class Observable<t> implements ObservableSource<t><br>默认情况下，Observable的为其运算符提供128个元素的缓冲区大小运行，可看考Flowable.bufferSize()，可以通过系统参数rx2.buffer-size全局覆盖。但是，大多数运算符都有重载，允许设置其内部缓冲区大小。</t></t></p><h3 id="2-2、Flowable和Observable对比"><a href="#2-2、Flowable和Observable对比" class="headerlink" title="2.2、Flowable和Observable对比"></a>2.2、Flowable和Observable对比</h3><p>在上面已经说明了二者最大的区别。</p><p>官方也给出的解释是：</p><blockquote><p>The design of this class was derived from the Reactive-Streams design and specification by removing any backpressure-related infrastructure and implementation detail, replacing the org.reactivestreams.Subscription with Disposable as the primary means to dispose of a flow.</p></blockquote><p>中文翻译：</p><blockquote><p>该类的设计源自Reactive-Streams设计和规范，通过删除任何与背压相关的基本结构和实现细节，将Disposable替换为org.reactivestreams.Subscription作为处理流的主要方式。</p></blockquote><p>从代码层面上做简单的说明,Flowable实现了Publisher接口，Publisher源码如下:</p><pre><code>public interface Publisher&lt;T&gt; {    /**     * Request {@link Publisher} to start streaming data.     * &lt;p&gt;     * This is a &quot;factory method&quot; and can be called multiple times, each time starting a new {@link Subscription}.     * &lt;p&gt;     * Each {@link Subscription} will work for only a single {@link Subscriber}.     * &lt;p&gt;     * A {@link Subscriber} should only subscribe once to a single {@link Publisher}.     * &lt;p&gt;     * If the {@link Publisher} rejects the subscription attempt or otherwise fails it will     * signal the error via {@link Subscriber#onError}.     *     * @param s the {@link Subscriber} that will consume signals from this {@link Publisher}     */    public void subscribe(Subscriber&lt;? super T&gt; s);}</code></pre><p>Observable实现了ObservableSource接口，ObservableSource源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface ObservableSource&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Subscribes the given Observer to this ObservableSource instance.</span><br><span class="line">     * @param observer the Observer, not null</span><br><span class="line">     * @throws NullPointerException if &#123;@code observer&#125; is null</span><br><span class="line">     */</span><br><span class="line">    void subscribe(Observer&lt;? super T&gt; observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对比ObservableSource和Publisher，都有一个同名的接口subscribe()</p><h3 id="2-4、形象理解ObservableSource和Publisher有何异同"><a href="#2-4、形象理解ObservableSource和Publisher有何异同" class="headerlink" title="2.4、形象理解ObservableSource和Publisher有何异同"></a>2.4、形象理解ObservableSource和Publisher有何异同</h3><p>ObservableSource：可观察源</p><p>Publisher：发布者</p><p>subscribe：订阅</p><p>Subscriber：订阅者</p><p>Observer：观察者</p><p>对于ObservableSource，可以将subscribe(Observer observer)理解为Observer通过subscribe订阅了ObservableSource</p><p>对于Publisher，可以将subscribe(Subscriber s)理解为Subscriber通过subscribe订阅了Publisher</p><p>上面的解释可能比较抽象，通俗的举个例子，来个角色扮演</p><p>第一组：报刊（ObservableSource）、报刊订阅者（Observer）、订阅报刊的行为（subscribe)</p><p>第二组：报刊发布人(Publisher)、报刊订阅者（Subscriber）、订阅报刊的行为（subscribe)</p><p>把这个场景串起来讲就是：报刊订阅者订阅了报刊，或者说报刊订阅者在报刊发布人手中订阅了报刊。</p><p><strong>这其实是典型的观察者模式，所不同的是信息的发布者是ObservableSource还是Publisher，信息的订阅者是Observer还是Subscriber，统一的行为都是subscribe。</strong></p><h2 id="3、Single"><a href="#3、Single" class="headerlink" title="3、Single"></a>3、Single</h2><h3 id="3-1、Single简介"><a href="#3-1、Single简介" class="headerlink" title="3.1、Single简介"></a>3.1、Single简介</h3><pre><code>public abstract class Single&lt;T&gt; implements SingleSource&lt;T&gt; </code></pre><p>Single实现了SingleSource</p><pre><code>/** * Represents a basic {@link Single} source base interface, * consumable via an {@link SingleObserver}. * &lt;p&gt; * This class also serves the base type for custom operators wrapped into * Single via {@link Single#create(SingleOnSubscribe)}. * * @param &lt;T&gt; the element type * @since 2.0 */public interface SingleSource&lt;T&gt; {    /**     * Subscribes the given SingleObserver to this SingleSource instance.     * @param observer the SingleObserver, not null     * @throws NullPointerException if {@code observer} is null     */    void subscribe(SingleObserver&lt;? super T&gt; observer);}</code></pre><p>Single类为单个值响应实现Reactive Pattern。</p><p><strong>Single和Observable类似，所不同的是Single只能发出一个值，要么发射成功要么发射失败，也没有“onComplete”作为完成时的回调</strong></p><p>Single类实现了基类SingleSource的接口，SingleObserver作为Single发出来的消息的默认消费者，SingleObserver通过subscribe(SingleObserver&lt;? super T&gt; observer)在Single中订阅消息</p><pre><code>public interface SingleObserver&lt;T&gt; {    /**     * Provides the SingleObserver with the means of cancelling (disposing) the     * connection (channel) with the Single in both     * synchronous (from within {@code onSubscribe(Disposable)} itself) and asynchronous manner.     * @param d the Disposable instance whose {@link Disposable#dispose()} can     * be called anytime to cancel the connection     * @since 2.0     */    void onSubscribe(Disposable d);    /**     * Notifies the SingleObserver with a single item and that the {@link Single} has finished sending     * push-based notifications.     * &lt;p&gt;     * The {@link Single} will not call this method if it calls {@link #onError}.     *     * @param value     *          the item emitted by the Single     */    void onSuccess(T value);    /**     * Notifies the SingleObserver that the {@link Single} has experienced an error condition.     * &lt;p&gt;     * If the {@link Single} calls this method, it will not thereafter call {@link #onSuccess}.     *     * @param e     *          the exception encountered by the Single     */    void onError(Throwable e);}</code></pre><h3 id="3-2、Single与Observable的区别"><a href="#3-2、Single与Observable的区别" class="headerlink" title="3.2、Single与Observable的区别"></a>3.2、Single与Observable的区别</h3><p>Single只能发送单个消息，不能发送消息流，而且观察者接收到消息也只有两种情况，要么接收成功，要么接收失败</p><h3 id="3-3、Single官方图解"><a href="#3-3、Single官方图解" class="headerlink" title="3.3、Single官方图解"></a>3.3、Single官方图解</h3><p><img src="/2019/08/07/android-rxjava-role/rxjava-single.jpg" alt></p><h2 id="4、Completable"><a href="#4、Completable" class="headerlink" title="4、Completable"></a>4、Completable</h2><h3 id="4-1、Completable简介"><a href="#4-1、Completable简介" class="headerlink" title="4.1、Completable简介"></a>4.1、Completable简介</h3><p>Completable类<strong>表示延迟计算，没有任何值，只表示完成或异常</strong>。</p><p>Completable的行为类似于Observable，在计算完成后只能发出完成或错误信号，由onComplete或onError接口来处理，没有onNext或onSuccess等回调接口</p><p>Completable实现了基类CompletableSource的接口，CompletableObserver通过subscribe()方法在Completable处订阅消息。</p><p>Completable遵循协议：onSubscribe (onComplete | onError)</p><pre><code>public abstract class Completable implements CompletableSourcepublic interface CompletableSource {    /**     * Subscribes the given CompletableObserver to this CompletableSource instance.     * @param cs the CompletableObserver, not null     * @throws NullPointerException if {@code cs} is null     */    void subscribe(CompletableObserver cs);}public interface CompletableObserver {    void onSubscribe(Disposable d);    void onComplete();    void onError(Throwable e);}</code></pre><p>从源码中我们可以看到CompletableObserver里面有三个接口：</p><p>1）onSubscribe中传入参数Disposable，由Completable调用一次，在CompletableObserver实例上设置Disposable，然后可以随时取消订阅。</p><p>2）onComplete一旦延迟计算正常完成将会被调用</p><p>3）onError 一旦延迟计算抛出异常将会被调用</p><h3 id="4-3、Completable示例"><a href="#4-3、Completable示例" class="headerlink" title="4.3、Completable示例"></a>4.3、Completable示例</h3><p>注意：<strong> 通过Disposable调用dispose()取消订阅，后面的消息无法接收。</strong></p><p>运行下面的例子，可以看到在调用dispose后，onStart被回调后，后续的消息就收不到了；去掉dispose，onStart回调后，三秒后onComplete将会被回调</p><pre><code> private void doCompletable() {        Disposable d = Completable.complete()                .delay(3, TimeUnit.SECONDS, Schedulers.io())                .subscribeWith(new DisposableCompletableObserver() {                    @Override                    public void onStart() {                        System.out.println(&quot;Started&quot;);                    }                    @Override                    public void onError(Throwable error) {                        error.printStackTrace();                    }                    @Override                    public void onComplete() {                        System.out.println(&quot;onComplete!&quot;);                    }                });        d.dispose();    }运行完毕的结果是：10-02 11:10:34.797 15565-15565/hq.demo.net I/System.out: Started注释d.dispose()后在运行结果是：10-02 14:34:19.490 23232-23232/hq.demo.net I/System.out: Started10-02 14:34:22.492 23232-23483/hq.demo.net I/System.out: Done!</code></pre><p>上面使用的是DisposableCompletableObserver通过subscribeWith来订阅消息，返回一个Disposable可以通过dispose来取消订阅关系，DisposableCompletableObserver是CompletableObserve的子类，只是增加了可取消订阅的功能。当然也能通过CompletableObserve方法操作，但是无法取消订阅关系，除此外没什么本质区别。</p><h2 id="5、Maybe"><a href="#5、Maybe" class="headerlink" title="5、Maybe"></a>5、Maybe</h2><h3 id="5-1、Maybe简介"><a href="#5-1、Maybe简介" class="headerlink" title="5.1、Maybe简介"></a>5.1、Maybe简介</h3><p>Maybe类<strong>表示延迟计算和单个值的发射，这个值可能根本没有或异常。</strong></p><p>Maybe类实现MaybeSource的接口，MaybeObserver通过subscribe(MaybeObserver)在Maybe处订阅消息</p><p>Maybe遵循协议：onSubscribe (onSuccess | onError | onComplete)，也就是Maybe发射消息后，可能会回调的接口是onSuccess | onError | onComplete</p><pre><code>public abstract class Maybe&lt;T&gt; implements MaybeSource&lt;T&gt;public interface MaybeSource&lt;T&gt; {    /**     * Subscribes the given MaybeObserver to this MaybeSource instance.     * @param observer the MaybeObserver, not null     * @throws NullPointerException if {@code observer} is null     */    void subscribe(MaybeObserver&lt;? super T&gt; observer);}public interface MaybeObserver&lt;T&gt; {    void onSubscribe(Disposable d);    void onSuccess(T value);    void onError(Throwable e);    void onComplete();}</code></pre><h3 id="5-3、Maybe示例"><a href="#5-3、Maybe示例" class="headerlink" title="5.3、Maybe示例"></a>5.3、Maybe示例</h3><p>下面是个例子，注意让线程睡多少秒可以修改测试dispose，与Completable类似，但是<strong>无论怎么onStart()都会被回调</strong>，为什么onStart()都会被回调呢？可以看DisposableMaybeObserver源码，在订阅消息的时候就会首先回调onSubscribe，这个时候dispose还没有运行了，这个动作发生在订阅的时候，没有订阅何来取消订阅呢。</p><pre><code>public abstract class DisposableMaybeObserver&lt;T&gt; implements MaybeObserver&lt;T&gt;, Disposable {    final AtomicReference&lt;Disposable&gt; s = new AtomicReference&lt;Disposable&gt;();    @Override    public final void onSubscribe(Disposable s) {        if (DisposableHelper.setOnce(this.s, s)) {            onStart();        }    }    /**     * Called once the single upstream Disposable is set via onSubscribe.     */    protected void onStart() {    }    @Override    public final boolean isDisposed() {        return s.get() == DisposableHelper.DISPOSED;    }    @Override    public final void dispose() {        DisposableHelper.dispose(s);    }}</code></pre><p>下面是实例的运行和结果</p><pre><code>private void doMaybe() {        new Thread(new Runnable() {            @Override            public void run() {                Disposable d = Maybe.just(&quot;Hello World&quot;)                        .delay(3, TimeUnit.SECONDS, Schedulers.io())                        .subscribeWith(new DisposableMaybeObserver&lt;String&gt;() {                            @Override                            public void onStart() {                                System.out.println(&quot;Started&quot;);                            }                            @Override                            public void onSuccess(String value) {                                System.out.println(&quot;Success: &quot; + value);                            }                            @Override                            public void onError(Throwable error) {                                error.printStackTrace();                            }                            @Override                            public void onComplete() {                                System.out.println(&quot;Done!&quot;);                            }                        });                try {                    Thread.sleep(4000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                d.dispose();            }        }).start();    }运行结果是：10-02 15:01:53.320 25573-25649/hq.demo.net I/System.out: Started10-02 15:01:56.324 25573-25654/hq.demo.net I/System.out: Success: Hello World如果把Thread.sleep(4000)修改为Thread.sleep(2000)运行结果是：10-02 15:05:34.362 25840-25872/hq.demo.net I/System.out: Started</code></pre><p>上面例子使用DisposableMaybeObserver通过subscribeWith在Maybe处订阅，并返回一个Disposable，可以通过Disposable调用dispose来取消订阅。当然我们也可以通过下面的方式来完成，但是无法取消订阅关系：</p><pre><code>private void doMaybe() {    Maybe.just(&quot;Hello World&quot;)            .delay(3, TimeUnit.SECONDS, Schedulers.io())            .subscribe(new MaybeObserver&lt;String&gt;() {                @Override                public void onSubscribe(Disposable d) {                    System.out.println(&quot;Started&quot;);                }                @Override                public void onSuccess(String value) {                    System.out.println(&quot;Success: &quot; + value);                }                @Override                public void onError(Throwable e) {                    e.printStackTrace();                }                @Override                public void onComplete() {                    System.out.println(&quot;Done!&quot;);                }            });    }</code></pre><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>Single、Completable、Maybe是简化的Observable，只是具有少部分功能：</p><blockquote><p><strong>Single：只能发射一条单一数据或者一条异常通知，不能发射完成通知，数据与通知只能发射一个，二选一<br>Completable：只能发射一条完成通知或者一条异常通知，不能发射数据，要么发射完成通知要么发射异常通知，二选一<br>Maybe：只能发射一条单一数据，和发射一条完成通知，或者一条异常通知，完成通知和异常通知二选一，只能在发射完成通知或异常通知之前发射数据，否则发射数据无效</strong></p></blockquote><h2 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h2><p><a href="https://blog.csdn.net/weixin_36709064/article/details/82911270" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36709064/article/details/82911270</a><br><a href="https://www.jianshu.com/p/ff8167c1d191/" target="_blank" rel="noopener">Flowable背压支持</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava2操作符汇总</title>
      <link href="/2019/08/06/android-rxjava/"/>
      <url>/2019/08/06/android-rxjava/</url>
      
        <content type="html"><![CDATA[<p><strong>RxJava是一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库</strong>(a library for composing asynchronous and event-based programs using observable sequences for the Java VM)。</p><p>RxJava能帮助我们在实现异步执行的前提下保持代码的清晰。它的原理就是创建一个Observable来完成异步任务，组合使用各种不同的链式操作，来实现各种复杂的操作，最终将任务的执行结果发射给Observer进行处理。</p><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>RxJava 有以下三个基本的元素：<br>1.被观察者（Observable）<br>2.观察者（Observer）<br>3.订阅（subscribe）</p><p>1.创建被观察者：</p><pre><code>Observable observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {    @Override    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());        e.onNext(1);        e.onNext(2);        e.onNext(3);        e.onComplete();    }});</code></pre><p>2.创建观察者：</p><pre><code>Observer observer = new Observer&lt;Integer&gt;() {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;======================onSubscribe&quot;);    }    @Override    public void onNext(Integer integer) {        Log.d(TAG, &quot;======================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;======================onError&quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;======================onComplete&quot;);    }};</code></pre><p>3.订阅</p><pre><code>observable.subscribe(observer);</code></pre><p>也可以链式调用</p><h3 id="RxJava-中的调度器"><a href="#RxJava-中的调度器" class="headerlink" title="RxJava 中的调度器"></a>RxJava 中的调度器</h3><table><thead><tr><th>调度器</th><th>作用</th></tr></thead><tbody><tr><td>Schedulers.computation( )</td><td>用于使用计算任务，如事件循环和回调处理</td></tr><tr><td>Schedulers.immediate( )</td><td>当前线程</td></tr><tr><td>Schedulers.io( )</td><td>用于 IO 密集型任务，如果异步阻塞 IO 操作</td></tr><tr><td>Schedulers.newThread( )</td><td>创建一个新的线程</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>Android 的 UI 线程，用于操作 UI</td></tr></tbody></table><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul><li>每次掉用过onError或onComplete其中一个方法后，就会掉用dispose()方法解除订阅</li><li>CompositeDisposable可以容纳多个disposable，每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可快速解除所有添加的Disposable类.</li></ul><h2 id="2、创建操作符"><a href="#2、创建操作符" class="headerlink" title="2、创建操作符"></a>2、创建操作符</h2><h3 id="create"><a href="#create" class="headerlink" title="create()"></a>create()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source)</code></pre><p>作用：创建一个被观察者</p><h3 id="just"><a href="#just" class="headerlink" title="just()"></a>just()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; just(T item) ......public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10)</code></pre><p>作用：创建一个被观察者，并发送事件，发送的事件不可以超过10个以上。</p><p>示例如下：</p><pre><code>Observable.just(1, 2, 3).subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;=================onSubscribe&quot;);    }    @Override    public void onNext(Integer integer) {        Log.d(TAG, &quot;=================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;=================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;=================onComplete &quot;);    }});看看打印结果：=================onSubscribe=================onNext 1=================onNext 2=================onNext 3=================onComplete </code></pre><h3 id="fromArray"><a href="#fromArray" class="headerlink" title="fromArray()"></a>fromArray()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items)</code></pre><p>作用：这个方法和 just() 类似，只不过 fromArray 可以传入多于10个的变量，并且可以传入一个数组。</p><h3 id="fromIterable"><a href="#fromIterable" class="headerlink" title="fromIterable()"></a>fromIterable()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source)</code></pre><p>作用：这个方法和 fromArray() 类似，直接发送一个 List 集合数据给观察者</p><h3 id="fromCallable-amp-fromRunnalbe"><a href="#fromCallable-amp-fromRunnalbe" class="headerlink" title="fromCallable() &amp; fromRunnalbe()"></a>fromCallable() &amp; fromRunnalbe()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromCallable(Callable&lt;? extends T&gt; supplier)</code></pre><p>作用：这里的 Callable 是 java.util.concurrent 中的 Callable，Callable 和 Runnable 的用法基本一致，只是它会返回一个结果值，这个结果值就是发给观察者的。</p><p>Observable.fromCallable()类似于:</p><pre><code>Observable.defer {    try {        Observable.just(...)    } catch(e: Throwable) {        Observable.error(e)    }}</code></pre><p>因此，just为运行同步，而fromCallable可以被推迟到另一个Scheduler与subscribeOn（“后”和执行）。</p><p>示例如下：</p><pre><code>Observable.fromCallable(new Callable &lt; Integer &gt; () {    @Override    public Integer call() throws Exception {        return 1;    }}).subscribe(new Consumer &lt; Integer &gt; () {    @Override    public void accept(Integer integer) throws Exception {        Log.d(TAG, &quot;================accept &quot; + integer);    }});</code></pre><h3 id="fromFuture"><a href="#fromFuture" class="headerlink" title="fromFuture()"></a>fromFuture()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future)</code></pre><p>作用：参数中的 Future 是 java.util.concurrent 中的 Future，Future 的作用是增加了 cancel() 等方法操作 Callable，它可以通过 get() 方法来获取 Callable 返回的值。</p><p>示例如下：</p><pre><code>FutureTask &lt; String &gt; futureTask = new FutureTask &lt; &gt; (new Callable &lt; String &gt; () {    @Override    public String call() throws Exception {        Log.d(TAG, &quot;CallableDemo is Running&quot;);        return &quot;返回结果&quot;;    }});Observable.fromFuture(futureTask)    .doOnSubscribe(new Consumer &lt; Disposable &gt; () {    @Override    public void accept(Disposable disposable) throws Exception {        futureTask.run();    }}).subscribe(new Consumer &lt; String &gt; () {    @Override    public void accept(String s) throws Exception {        Log.d(TAG, &quot;================accept &quot; + s);    }});</code></pre><p>doOnSubscribe() 的作用就是只有订阅时才会发送事件。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer()"></a>defer()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; defer(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)</code></pre><p>作用：这个方法的作用就是直到被观察者被订阅后才会创建被观察者。</p><p>示例如下：</p><pre><code>// i 要定义为成员变量Integer i = 100;Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() {    @Override    public ObservableSource&lt;? extends Integer&gt; call() throws Exception {        return Observable.just(i);    }});i = 200;Observer observer = new Observer&lt;Integer&gt;() {    @Override    public void onSubscribe(Disposable d) {    }    @Override    public void onNext(Integer integer) {        Log.d(TAG, &quot;================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }};observable.subscribe(observer);i = 300;observable.subscribe(observer);打印结果如下：================onNext 200================onNext 300</code></pre><p>因为 defer() 只有观察者订阅的时候才会创建新的被观察者，所以每订阅一次就会打印一次，并且都是打印 i 最新的值。</p><h3 id="timer"><a href="#timer" class="headerlink" title="timer()"></a>timer()</h3><pre><code>public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit) </code></pre><p>作用：当到指定时间后就会发送一个 0L 的值给观察者。</p><p>示例如下：</p><pre><code>Observable.timer(2, TimeUnit.SECONDS).subscribe(new Observer &lt; Long &gt; () {    @Override    public void onSubscribe(Disposable d) {    }    @Override    public void onNext(Long aLong) {        Log.d(TAG, &quot;===============onNext &quot; + aLong);    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});</code></pre><h3 id="interval"><a href="#interval" class="headerlink" title="interval()"></a>interval()</h3><pre><code>public static Observable&lt;Long&gt; interval(long period, TimeUnit unit)public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit)</code></pre><p>作用：每隔一段时间就会发送一个事件，这个事件是从0开始，不断增1的数字。</p><p>示例如下：</p><pre><code>Observable.interval(4, TimeUnit.SECONDS).subscribe(new Observer &lt; Long &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==============onSubscribe &quot;);    }    @Override    public void onNext(Long aLong) {        Log.d(TAG, &quot;==============onNext &quot; + aLong);    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});打印结果：05-20 20:48:10.321 28723-28723/com.example.louder.rxjavademo D/chan: ==============onSubscribe 05-20 20:48:14.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 005-20 20:48:18.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 105-20 20:48:22.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 205-20 20:48:26.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 305-20 20:48:30.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 405-20 20:48:34.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 5</code></pre><p>从时间就可以看出每隔4秒就会发出一次数字递增1的事件。这里说下 interval() 第三个方法的 initialDelay 参数，这个参数的意思就是 onSubscribe 回调之后，再次回调 onNext 的间隔时间。</p><h3 id="intervalRange"><a href="#intervalRange" class="headerlink" title="intervalRange()"></a>intervalRange()</h3><pre><code>public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)</code></pre><p>作用：可以指定发送事件的开始值和数量，其他与 interval() 的功能一样。</p><p>示例如下：</p><pre><code>Observable.intervalRange(2, 5, 2, 1, TimeUnit.SECONDS).subscribe(new Observer &lt; Long &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==============onSubscribe &quot;);    }    @Override    public void onNext(Long aLong) {        Log.d(TAG, &quot;==============onNext &quot; + aLong);    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});打印结果：05-21 00:03:01.672 2504-2504/com.example.louder.rxjavademo D/chan: ==============onSubscribe 05-21 00:03:03.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 205-21 00:03:04.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 305-21 00:03:05.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 405-21 00:03:06.673 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 505-21 00:03:07.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 6</code></pre><p>可以看出收到5次 onNext 事件，并且是从 2 开始的。</p><h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><pre><code>public static Observable&lt;Integer&gt; range(final int start, final int count)</code></pre><p>作用：同时发送一定范围的事件序列。</p><p>示例如下：</p><pre><code>Observable.range(2, 5).subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==============onSubscribe &quot;);    }    @Override    public void onNext(Integer aLong) {        Log.d(TAG, &quot;==============onNext &quot; + aLong);    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});打印结果：==============onSubscribe ==============onNext 2==============onNext 3==============onNext 4==============onNext 5==============onNext 6</code></pre><h3 id="rangeLong"><a href="#rangeLong" class="headerlink" title="rangeLong()"></a>rangeLong()</h3><pre><code>public static Observable&lt;Long&gt; rangeLong(long start, long count)</code></pre><p>作用：与 range() 一样，只是数据类型为 Long</p><h3 id="empty-amp-never-amp-error"><a href="#empty-amp-never-amp-error" class="headerlink" title="empty() &amp; never() &amp; error()"></a>empty() &amp; never() &amp; error()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; empty()public static &lt;T&gt; Observable&lt;T&gt; never()public static &lt;T&gt; Observable&lt;T&gt; error(final Throwable exception)</code></pre><p>作用：<br>1.empty() ： 直接发送 onComplete() 事件<br>2.never()：不发送任何事件<br>3.error()：发送 onError() 事件</p><p>示例如下：</p><pre><code>Observable.empty().subscribe(new Observer &lt; Object &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe&quot;);    }    @Override    public void onNext(Object o) {        Log.d(TAG, &quot;==================onNext&quot;);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot; + e);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete&quot;);    }});</code></pre><p>打印结果：</p><pre><code>==================onSubscribe==================onComplete</code></pre><p>换成 never() 的打印结果：</p><pre><code>==================onSubscribe</code></pre><p>换成 error() 的打印结果：</p><pre><code>==================onSubscribe==================onError java.lang.NullPointerException</code></pre><h3 id="amb"><a href="#amb" class="headerlink" title="amb()"></a>amb()</h3><p>public static <t> Observable<t> amb(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources)</t></t></p><p>作用：amb() 要传入一个 Observable 集合，但是<strong>只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃</strong>。</p><p>示例如下：</p><pre><code>ArrayList &lt; Observable &lt; Long &gt;&gt; list = new ArrayList &lt; &gt; ();list.add(Observable.intervalRange(1, 5, 2, 1, TimeUnit.SECONDS));list.add(Observable.intervalRange(6, 5, 0, 1, TimeUnit.SECONDS));Observable.amb(list).subscribe(new Consumer &lt; Long &gt; () {    @Override    public void accept(Long aLong) throws Exception {        Log.d(TAG, &quot;========================aLong &quot; + aLong);    }});打印结果：05-26 10:21:29.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 605-26 10:21:30.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 705-26 10:21:31.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 805-26 10:21:32.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 905-26 10:21:33.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 10</code></pre><h2 id="3、转换操作符"><a href="#3、转换操作符" class="headerlink" title="3、转换操作符"></a>3、转换操作符</h2><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map可以将被观察者发送的数据类型转变成其他的类型</p><pre><code>public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></pre><p>以下代码将 Integer 类型的数据转换成 String：</p><pre><code>Observable.just(1, 2, 3).map(new Function &lt; Integer, String &gt; () {    @Override    public String apply(Integer integer) throws Exception {        return &quot;I&apos;m &quot; + integer;    }}).subscribe(new Observer &lt; String &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.e(TAG, &quot;===================onSubscribe&quot;);    }    @Override    public void onNext(String s) {        Log.e(TAG, &quot;===================onNext &quot; + s);    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});打印结果：===================onSubscribe===================onNext I&apos;m 1===================onNext I&apos;m 2===================onNext I&apos;m 3</code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><p>这个方法可以将事件序列中的元素进行整合加工，返回一个新的被观察者。flatMap() 其实与 map() 类似，但是 flatMap() 返回的是一个 Observerable。</p><pre><code>public final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)</code></pre><p>现在有一个需求就是要将 Person 集合中的每个元素中的 Plan 的 action 打印出来。首先用 map() 来实现这个需求看看：</p><pre><code>Observable.fromIterable(personList).map(new Function &lt; Person, List &lt; Plan &gt;&gt; () {    @Override    public List &lt; Plan &gt; apply(Person person) throws Exception {        return person.getPlanList();    }}).subscribe(new Observer &lt; List &lt; Plan &gt;&gt; () {    @Override    public void onSubscribe(Disposable d) {    }    @Override    public void onNext(List &lt; Plan &gt; plans) {        for (Plan plan: plans) {            List &lt; String &gt; planActionList = plan.getActionList();            for (String action: planActionList) {                Log.d(TAG, &quot;==================action &quot; + action);            }        }    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});</code></pre><p>可以看到 onNext() 用了嵌套 for 循环来实现，如果代码逻辑复杂起来的话，可能需要多重循环才可以实现。现在看下使用 flatMap() 实现：</p><pre><code>Observable.fromIterable(personList).flatMap(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () {    @Override    public ObservableSource &lt; Plan &gt; apply(Person person) {        return Observable.fromIterable(person.getPlanList());    }}).flatMap(new Function &lt; Plan, ObservableSource &lt; String &gt;&gt; () {    @Override    public ObservableSource &lt; String &gt; apply(Plan plan) throws Exception {        return Observable.fromIterable(plan.getActionList());    }}).subscribe(new Observer &lt; String &gt; () {    @Override    public void onSubscribe(Disposable d) {    }    @Override    public void onNext(String s) {        Log.d(TAG, &quot;==================action: &quot; + s);    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});</code></pre><p>从代码可以看出，只需要两个 flatMap() 就可以完成需求，并且代码逻辑非常清晰。</p><h3 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap()"></a>concatMap()</h3><p>concatMap() 和 flatMap() 基本上是一样的，只不过 <strong>concatMap() 转发出来的事件是有序的</strong>，不管是否延时，而 flatMap() 是无序的。</p><pre><code>public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, int prefetch)</code></pre><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer()"></a>buffer()</h3><p>从需要发送的事件当中获取一定数量的事件，并将这些事件放到缓冲区当中一并发出。</p><pre><code>public final Observable&lt;List&lt;T&gt;&gt; buffer(int count, int skip)</code></pre><p>buffer 有两个参数，一个是 count，另一个 skip。<strong>count 缓冲区元素的数量，skip 就代表缓冲区满了之后，发送下一次事件序列的时候要跳过多少元素</strong>。这样说可能还是有点抽象，直接看代码：</p><pre><code>Observable.just(1, 2, 3, 4, 5).buffer(2, 1).subscribe(new Observer &lt; List &lt; Integer &gt;&gt; () {    @Override    public void onSubscribe(Disposable d) {    }    @Override    public void onNext(List &lt; Integer &gt; integers) {        Log.d(TAG, &quot;================缓冲区大小： &quot; + integers.size());        for (Integer i: integers) {            Log.d(TAG, &quot;================元素： &quot; + i);        }    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});打印结果：================缓冲区大小： 2================元素： 1================元素： 2================缓冲区大小： 2================元素： 2================元素： 3================缓冲区大小： 2================元素： 3================元素： 4================缓冲区大小： 2================元素： 4================元素： 5================缓冲区大小： 1================元素： 5</code></pre><p>从结果可以看出，每次发送事件，指针都会往后移动一个元素再取值，直到指针移动到没有元素的时候就会停止取值。</p><h3 id="scan"><a href="#scan" class="headerlink" title="scan()"></a>scan()</h3><p>将数据以一定的逻辑聚合起来。</p><pre><code>public final Observable&lt;T&gt; scan(BiFunction&lt;T, T, T&gt; accumulator)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 4, 5).scan(new BiFunction &lt; Integer, Integer, Integer &gt; () {    @Override    public Integer apply(Integer integer, Integer integer2) throws Exception {        Log.d(TAG, &quot;====================apply &quot;);        Log.d(TAG, &quot;====================integer &quot; + integer);        Log.d(TAG, &quot;====================integer2 &quot; + integer2);        return integer + integer2;    }}).subscribe(new Consumer &lt; Integer &gt; () {    @Override    public void accept(Integer integer) throws Exception {        Log.d(TAG, &quot;====================accept &quot; + integer);    }});打印结果：====================accept 1====================apply ====================integer 1====================integer2 2====================accept 3====================apply ====================integer 3====================integer2 3====================accept 6====================apply ====================integer 6====================integer2 4====================accept 10====================apply ====================integer 10====================integer2 5====================accept 15</code></pre><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy()"></a>groupBy()</h3><p>将发送的数据进行分组，每个分组都会返回一个被观察者。</p><pre><code>public final &lt;K&gt; Observable&lt;GroupedObservable&lt;K, T&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector)</code></pre><p>示例如下：</p><pre><code>Observable.just(5, 2, 3, 4, 1, 6, 8, 9, 7, 10).groupBy(new Function &lt; Integer, Integer &gt; () {    @Override    public Integer apply(Integer integer) throws Exception {        return integer % 3;    }}).subscribe(new Observer &lt; GroupedObservable &lt; Integer, Integer &gt;&gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;====================onSubscribe &quot;);    }    @Override    public void onNext(GroupedObservable &lt; Integer, Integer &gt; integerIntegerGroupedObservable) {        Log.d(TAG, &quot;====================onNext &quot;);        integerIntegerGroupedObservable.subscribe(new Observer &lt; Integer &gt; () {            @Override            public void onSubscribe(Disposable d) {                Log.d(TAG, &quot;====================GroupedObservable onSubscribe &quot;);            }            @Override            public void onNext(Integer integer) {                Log.d(TAG, &quot;====================GroupedObservable onNext  groupName: &quot; + integerIntegerGroupedObservable.getKey() + &quot; value: &quot; + integer);            }            @Override            public void onError(Throwable e) {                Log.d(TAG, &quot;====================GroupedObservable onError &quot;);            }            @Override            public void onComplete() {                Log.d(TAG, &quot;====================GroupedObservable onComplete &quot;);            }        });    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;====================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;====================onComplete &quot;);    }});</code></pre><h3 id="window"><a href="#window" class="headerlink" title="window()"></a>window()</h3><p>发送指定数量的事件时，就将这些事件分为一组。window 中的 count 的参数就是代表指定的数量，例如将 count 指定为2，那么每发2个数据就会将这2个数据分成一组。</p><pre><code>public final Observable&lt;Observable&lt;T&gt;&gt; window(long count)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 4, 5).window(2).subscribe(new Observer &lt; Observable &lt; Integer &gt;&gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;=====================onSubscribe &quot;);    }    @Override    public void onNext(Observable &lt; Integer &gt; integerObservable) {        integerObservable.subscribe(new Observer &lt; Integer &gt; () {            @Override            public void onSubscribe(Disposable d) {                Log.d(TAG, &quot;=====================integerObservable onSubscribe &quot;);            }            @Override            public void onNext(Integer integer) {                Log.d(TAG, &quot;=====================integerObservable onNext &quot; + integer);            }            @Override            public void onError(Throwable e) {                Log.d(TAG, &quot;=====================integerObservable onError &quot;);            }            @Override            public void onComplete() {                Log.d(TAG, &quot;=====================integerObservable onComplete &quot;);            }        });    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;=====================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;=====================onComplete &quot;);    }});打印结果：=====================onSubscribe =====================integerObservable onSubscribe =====================integerObservable onNext 1=====================integerObservable onNext 2=====================integerObservable onComplete =====================integerObservable onSubscribe =====================integerObservable onNext 3=====================integerObservable onNext 4=====================integerObservable onComplete =====================integerObservable onSubscribe =====================integerObservable onNext 5=====================integerObservable onComplete =====================onComplete </code></pre><p>从结果可以发现，window() 将 1~5 的事件分成了3组。</p><h3 id="compose"><a href="#compose" class="headerlink" title="compose()"></a>compose()</h3><p>对Observable进行变换，加工处理。</p><pre><code>public final &lt;R&gt; Observable&lt;R&gt; compose(ObservableTransformer&lt;? super T, ? extends R&gt; composer)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 4, 5)          .compose(new ObservableTransformer&lt;T, T&gt;() {            @Override            public ObservableSource&lt;T&gt; apply(Observable&lt;T&gt; observable) { //比如给observable添加subscribeOn、observeOn                return observable.subscribeOn(Schedulers.io())                        .observeOn(AndroidSchedulers.mainThread());            })　　　　　　.subscribe();</code></pre><h2 id="4、功能操作符"><a href="#4、功能操作符" class="headerlink" title="4、功能操作符"></a>4、功能操作符</h2><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn()"></a>subscribeOn()</h3><p>指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效。如果不指定，则默认为主线程。</p><pre><code>public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler)</code></pre><h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn()"></a>observeOn()</h3><p>指定观察者的线程，可以切换线程，每指定一次就会生效一次。</p><pre><code>public final Observable&lt;T&gt; observeOn(Scheduler scheduler)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3).observeOn(Schedulers.newThread()).flatMap(new Function &lt; Integer, ObservableSource &lt; String &gt;&gt; () {    @Override    public ObservableSource &lt; String &gt; apply(Integer integer) throws Exception {        Log.d(TAG, &quot;======================flatMap Thread name &quot; + Thread.currentThread().getName());        return Observable.just(&quot;chan&quot; + integer);    }}).observeOn(AndroidSchedulers.mainThread()).subscribe(new Observer &lt; String &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;======================onSubscribe&quot;);    }    @Override    public void onNext(String s) {        Log.d(TAG, &quot;======================onNext Thread name &quot; + Thread.currentThread().getName());        Log.d(TAG, &quot;======================onNext &quot; + s);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;======================onError&quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;======================onComplete&quot;);    }});打印结果：======================onSubscribe======================flatMap Thread name RxNewThreadScheduler-1======================flatMap Thread name RxNewThreadScheduler-1======================flatMap Thread name RxNewThreadScheduler-1======================onNext Thread name main======================onNext chan1======================onNext Thread name main======================onNext chan2======================onNext Thread name main======================onNext chan3======================onComplete</code></pre><p>从打印结果可以知道，observeOn 成功切换了线程。</p><h3 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h3><p>延迟一段事件发送事件， onSubscribe 回调之后 onNext 延时后才会回调。</p><pre><code>public final Observable&lt;T&gt; delay(long delay, TimeUnit unit)</code></pre><h3 id="doOnEach"><a href="#doOnEach" class="headerlink" title="doOnEach()"></a>doOnEach()</h3><p>Observable 每发送一件事件之前都会先回调这个方法。</p><pre><code>public final Observable&lt;T&gt; doOnEach(final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification)</code></pre><p>示例如下：</p><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {    @Override    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {        e.onNext(1);        e.onNext(2);        e.onNext(3);        //      e.onError(new NumberFormatException());        e.onComplete();    }}).doOnEach(new Consumer &lt; Notification &lt; Integer &gt;&gt; () {    @Override    public void accept(Notification &lt; Integer &gt; integerNotification) throws Exception {        Log.d(TAG, &quot;==================doOnEach &quot; + integerNotification.getValue());    }}).subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);    }    @Override    public void onNext(Integer integer) {        Log.d(TAG, &quot;==================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});打印结果：==================onSubscribe ==================doOnEach 1==================onNext 1==================doOnEach 2==================onNext 2==================doOnEach 3==================onNext 3==================doOnEach null==================onComplete </code></pre><p>从结果就可以看出每发送一个事件之前都会回调 doOnEach 方法，并且可以取出 onNext() 发送的值。</p><h3 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext()"></a>doOnNext()</h3><p>Observable 每发送 onNext() 之前都会先回调这个方法。</p><pre><code>public final Observable&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext)</code></pre><h3 id="doAfterNext"><a href="#doAfterNext" class="headerlink" title="doAfterNext()"></a>doAfterNext()</h3><p>Observable 每发送 onNext() 之后都会回调这个方法。</p><pre><code>public final Observable&lt;T&gt; doAfterNext(Consumer&lt;? super T&gt; onAfterNext)</code></pre><h3 id="doOnComplete"><a href="#doOnComplete" class="headerlink" title="doOnComplete()"></a>doOnComplete()</h3><p>Observable 每发送 onComplete() 之前都会回调这个方法。</p><pre><code>public final Observable&lt;T&gt; doOnComplete(Action onComplete)</code></pre><h3 id="doOnError"><a href="#doOnError" class="headerlink" title="doOnError()"></a>doOnError()</h3><p>Observable 每发送 onError() 之前都会回调这个方法。</p><pre><code>public final Observable&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError)</code></pre><h3 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe()"></a>doOnSubscribe()</h3><p>Observable 每发送 onSubscribe() 之前都会回调这个方法。</p><pre><code>public final Observable&lt;T&gt; doOnSubscribe(Consumer&lt;? super Disposable&gt; onSubscribe)</code></pre><h3 id="doOnDispose"><a href="#doOnDispose" class="headerlink" title="doOnDispose()"></a>doOnDispose()</h3><p>当调用 Disposable 的 dispose() 之后回调该方法。</p><pre><code>public final Observable&lt;T&gt; doOnDispose(Action onDispose)</code></pre><h3 id="doOnLifecycle"><a href="#doOnLifecycle" class="headerlink" title="doOnLifecycle()"></a>doOnLifecycle()</h3><p>在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅。第二个参数的回调方法的作用与 doOnDispose() 是一样的。</p><pre><code>public final Observable&lt;T&gt; doOnLifecycle(final Consumer&lt;? super Disposable&gt; onSubscribe, final Action onDispose)</code></pre><p>示例如下：</p><pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {    @Override    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {        e.onNext(1);        e.onNext(2);        e.onNext(3);        e.onComplete();    }}).doOnLifecycle(new Consumer&lt;Disposable&gt;() {    @Override    public void accept(Disposable disposable) throws Exception {        Log.d(TAG, &quot;==================doOnLifecycle accept&quot;);    }}, new Action() {    @Override    public void run() throws Exception {        Log.d(TAG, &quot;==================doOnLifecycle Action&quot;);    }}).doOnDispose(    new Action() {        @Override        public void run() throws Exception {            Log.d(TAG, &quot;==================doOnDispose Action&quot;);        }}).subscribe(new Observer&lt;Integer&gt;() {    private Disposable d;    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);        this.d = d;    }    @Override    public void onNext(Integer integer) {        Log.d(TAG, &quot;==================onNext &quot; + integer);        d.dispose();    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});打印结果： ==================doOnLifecycle accept==================onSubscribe ==================onNext 1==================doOnDispose Action==================doOnLifecycle Action</code></pre><p>可以看到当在 onNext() 方法进行取消订阅操作后，doOnDispose() 和 doOnLifecycle() 都会被回调。<br>如果使用 doOnLifecycle 进行取消订阅，来看看打印结果：</p><pre><code>==================doOnLifecycle accept==================onSubscribe </code></pre><p>可以发现 doOnDispose Action 和 doOnLifecycle Action 都没有被回调。</p><h3 id="doOnTerminate-amp-doAfterTerminate"><a href="#doOnTerminate-amp-doAfterTerminate" class="headerlink" title="doOnTerminate() &amp; doAfterTerminate()"></a>doOnTerminate() &amp; doAfterTerminate()</h3><p>doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。</p><pre><code>public final Observable&lt;T&gt; doOnTerminate(final Action onTerminate)public final Observable&lt;T&gt; doAfterTerminate(Action onFinally)</code></pre><h3 id="doFinally"><a href="#doFinally" class="headerlink" title="doFinally()"></a>doFinally()</h3><p>在所有事件发送完毕之后回调该方法。</p><pre><code>public final Observable&lt;T&gt; doFinally(Action onFinally)</code></pre><p>这里可能你会有个问题，那就是 doFinally() 和 doAfterTerminate() 到底有什么区别？区别就是在于取消订阅，如果取消订阅之后 doAfterTerminate() 就不会被回调，而 <strong>doFinally() 无论怎么样都会被回调，且都会在事件序列的最后</strong>。</p><h3 id="onErrorReturn"><a href="#onErrorReturn" class="headerlink" title="onErrorReturn()"></a>onErrorReturn()</h3><p>当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列。</p><pre><code>public final Observable&lt;T&gt; onErrorReturn(Function&lt;? super Throwable, ? extends T&gt; valueSupplier)</code></pre><p>示例如下：</p><pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {    @Override    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {        e.onNext(1);        e.onNext(2);        e.onNext(3);        e.onError(new NullPointerException());    }}).onErrorReturn(new Function&lt;Throwable, Integer&gt;() {    @Override    public Integer apply(Throwable throwable) throws Exception {        Log.d(TAG, &quot;==================onErrorReturn &quot; + throwable);        return 404;    }}).subscribe(new Observer&lt;Integer&gt;() {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);    }    @Override    public void onNext(Integer integer) {        Log.d(TAG, &quot;==================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});打印结果：==================onSubscribe ==================onNext 1==================onNext 2==================onNext 3==================onErrorReturn java.lang.NullPointerException==================onNext 404==================onComplete </code></pre><h3 id="onErrorResumeNext"><a href="#onErrorResumeNext" class="headerlink" title="onErrorResumeNext()"></a>onErrorResumeNext()</h3><p>当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列。</p><pre><code>public final Observable&lt;T&gt; onErrorResumeNext(Function&lt;? super Throwable, ? extends ObservableSource&lt;? extends T&gt;&gt; resumeFunction)</code></pre><p>示例如下：</p><pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {    @Override    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {        e.onNext(1);        e.onNext(2);        e.onNext(3);        e.onError(new NullPointerException());    }}).onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() {    @Override    public ObservableSource&lt;? extends Integer&gt; apply(Throwable throwable) throws Exception {        Log.d(TAG, &quot;==================onErrorResumeNext &quot; + throwable);        return Observable.just(4, 5, 6);    }}).subscribe(new Observer&lt;Integer&gt;() {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);    }    @Override    public void onNext(Integer integer) {        Log.d(TAG, &quot;==================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});打印结果：==================onSubscribe ==================onNext 1==================onNext 2==================onNext 3==================onErrorResumeNext java.lang.NullPointerException==================onNext 4==================onNext 5==================onNext 6==================onComplete </code></pre><h3 id="onExceptionResumeNext"><a href="#onExceptionResumeNext" class="headerlink" title="onExceptionResumeNext()"></a>onExceptionResumeNext()</h3><p>与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception。</p><pre><code>public final Observable&lt;T&gt; onExceptionResumeNext(final ObservableSource&lt;? extends T&gt; next)</code></pre><h3 id="retry"><a href="#retry" class="headerlink" title="retry()"></a>retry()</h3><p>如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数。</p><pre><code>public final Observable&lt;T&gt; retry(long times)</code></pre><h3 id="retryUntil"><a href="#retryUntil" class="headerlink" title="retryUntil()"></a>retryUntil()</h3><p>出现错误事件之后，可以通过此方法判断是否继续发送事件。指示Observable遇到错误时，是否让Observable重新订阅。</p><pre><code>public final Observable&lt;T&gt; retryUntil(final BooleanSupplier stop)</code></pre><p>示例如下：</p><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {    @Override    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {        e.onNext(1);        e.onNext(2);        e.onNext(3);        e.onError(new Exception(&quot;404&quot;));    }}).retryUntil(new BooleanSupplier() {    @Override    public boolean getAsBoolean() throws Exception {        if (i == 6) {            return true;        }        return false;    }}).subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);    }    @Override    public void onNext(Integer integer) {        i += integer;        Log.d(TAG, &quot;==================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});打印结果：==================onSubscribe ==================onNext 1==================onNext 2==================onNext 3==================onError </code></pre><h3 id="retryWhen"><a href="#retryWhen" class="headerlink" title="retryWhen()"></a>retryWhen()</h3><p>当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。<strong>如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件。</strong></p><pre><code>public final void safeSubscribe(Observer&lt;? super T&gt; s)</code></pre><p>示例如下：</p><pre><code>Observable.create(new ObservableOnSubscribe &lt; String &gt; () {    @Override    public void subscribe(ObservableEmitter &lt; String &gt; e) throws Exception {        e.onNext(&quot;chan&quot;);        e.onNext(&quot;ze&quot;);        e.onNext(&quot;de&quot;);        e.onError(new Exception(&quot;404&quot;));        e.onNext(&quot;haha&quot;);    }}).retryWhen(new Function &lt; Observable &lt; Throwable &gt; , ObservableSource &lt;? &gt;&gt; () {    @Override    public ObservableSource &lt;? &gt; apply(Observable &lt; Throwable &gt; throwableObservable) throws Exception {        return throwableObservable.flatMap(new Function &lt; Throwable, ObservableSource &lt;? &gt;&gt; () {            @Override            public ObservableSource &lt;? &gt; apply(Throwable throwable) throws Exception {                if(!throwable.toString().equals(&quot;java.lang.Exception: 404&quot;)) {                    return Observable.just(&quot;可以忽略的异常&quot;);                } else {                    return Observable.error(new Throwable(&quot;终止啦&quot;));                }            }        });    }}).subscribe(new Observer &lt; String &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);    }    @Override    public void onNext(String s) {        Log.d(TAG, &quot;==================onNext &quot; + s);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot; + e.toString());    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});打印结果：==================onSubscribe ==================onNext chan==================onNext ze==================onNext de==================onError java.lang.Throwable: 终止啦将 onError(new Exception(&quot;404&quot;)) 改为 onError(new Exception(&quot;303&quot;)) 看看打印结果：==================onNext chan==================onNext ze==================onNext de==================onNext chan==================onNext ze==================onNext de==================onNext chan==================onNext ze==================onNext de==================onNext chan==================onNext ze==================onNext de==================onNext chan==================onNext ze==================onNext de==================onNext chan......从结果可以看出，会不断重复发送消息。</code></pre><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>重复发送被观察者的事件，times 为发送次数。</p><pre><code>public final Observable&lt;T&gt; repeat(long times)</code></pre><h3 id="repeatWhen"><a href="#repeatWhen" class="headerlink" title="repeatWhen()"></a>repeatWhen()</h3><p>这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件。</p><pre><code>public final Observable&lt;T&gt; repeatWhen(final Function&lt;? super Observable&lt;Object&gt;, ? extends ObservableSource&lt;?&gt;&gt; handler)</code></pre><p>repeatWhen可以实现重订阅功能，而触发重订阅两个关键因素:<br>1.Obervable完成一次订阅，就是Observable调用onComplete<br>2.当Observable调用onComplete就会进入到repeatWhen方法里面，是否要触发重订阅，就需要通过repeatWhen的Function方法所返回的ObservableSource确定，如果返回的是onNext则触发重订阅，而返回的是onComplete/onError则不会触发重订阅</p><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {            @Override            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {                emitter.onComplete();            }        }).doOnComplete(new Action() {            @Override            public void run() throws Exception {                Log.d(TAG, &quot;触发重订阅&quot;);            }        }).repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() {            private int n = 0;            @Override            public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception {                return objectObservable.flatMap(new Function&lt;Object, ObservableSource&lt;?&gt;&gt;() {                    @Override                    public ObservableSource&lt;?&gt; apply(Object o) throws Exception {                        if (n != 3) {                            n++;                            return Observable.timer(3, TimeUnit.SECONDS);                        } else {                            return Observable.empty();                        }                    }                });            }        }).subscribe(new Observer&lt;String&gt;() {            @Override            public void onSubscribe(Disposable d) {            }            @Override            public void onNext(String s) {                Log.d(TAG, &quot;onNext: &quot; + s);            }            @Override            public void onError(Throwable e) {                Log.d(TAG, &quot;onError: &quot; + e);            }            @Override            public void onComplete() {                Log.d(TAG, &quot;onComplete: &quot;);            }        });运行结果:08-02 10:26:13.187 D/MainActivity-vv: 触发重订阅08-02 10:26:16.196 D/MainActivity-vv: 触发重订阅08-02 10:26:19.204 D/MainActivity-vv: 触发重订阅08-02 10:26:22.206 D/MainActivity-vv: 触发重订阅</code></pre><p>repeatWhen可以用于延时轮询，在doOnComplete进行操作</p><h2 id="5、组合操作符"><a href="#5、组合操作符" class="headerlink" title="5、组合操作符"></a>5、组合操作符</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>可以将多个观察者组合在一起，然后按照之前发送顺序发送事件。需要注意的是，concat() 最多只可以发送4个事件。</p><pre><code>public static &lt;T&gt; Observable&lt;T&gt; concat(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)</code></pre><p>示例如下：</p><pre><code>Observable.concat(Observable.just(1, 2),Observable.just(3, 4),Observable.just(5, 6),Observable.just(7, 8)).subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {    }    @Override    public void onNext(Integer integer) {        Log.d(TAG, &quot;================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});打印如下：================onNext 1================onNext 2================onNext 3================onNext 4================onNext 5================onNext 6================onNext 7================onNext 8</code></pre><h3 id="concatArray"><a href="#concatArray" class="headerlink" title="concatArray()"></a>concatArray()</h3><p>与 concat()  作用一样，不过 concatArray() 可以发送多于 4 个被观察者。</p><pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArray(ObservableSource&lt;? extends T&gt;... sources)</code></pre><h3 id="merge-amp-mergeArray"><a href="#merge-amp-mergeArray" class="headerlink" title="merge() &amp; mergeArray()"></a>merge() &amp; mergeArray()</h3><p>这个方法与 concat() 作用基本一样，只是 concat() 是串行发送事件，而<strong> merge() 并行发送事件</strong>。</p><pre><code>public static &lt;T&gt; Observable&lt;T&gt; merge(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)</code></pre><p>现在来演示 concat() 和 merge() 的区别:</p><pre><code>Observable.merge(Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {    @Override    public String apply(Long aLong) throws Exception {        return &quot;A&quot; + aLong;    }}),Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {    @Override    public String apply(Long aLong) throws Exception {        return &quot;B&quot; + aLong;    }}))    .subscribe(new Observer &lt; String &gt; () {    @Override    public void onSubscribe(Disposable d) {    }    @Override    public void onNext(String s) {        Log.d(TAG, &quot;=====================onNext &quot; + s);    }    @Override    public void onError(Throwable e) {    }    @Override    public void onComplete() {    }});打印结果如下：05-21 16:10:31.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B005-21 16:10:31.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A005-21 16:10:32.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A105-21 16:10:32.126 12801-12850/com.example.rxjavademo D/chan: =====================onNext B105-21 16:10:33.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A205-21 16:10:33.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B205-21 16:10:34.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A305-21 16:10:34.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B305-21 16:10:35.124 12801-12849/com.example.rxjavademo D/chan: =====================onNext A405-21 16:10:35.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B405-21 16:10:36.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A505-21 16:10:36.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B5......从结果可以看出，A 和 B 的事件序列都可以发出，将以上的代码换成 concat() 看看打印结果：05-21 16:17:52.352 14597-14621/com.example.rxjavademo D/chan: =====================onNext A005-21 16:17:53.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A105-21 16:17:54.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A205-21 16:17:55.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A305-21 16:17:56.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A405-21 16:17:57.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A5......从结果可以知道，只有等到第一个被观察者发送完事件之后，第二个被观察者才会发送事件。</code></pre><p>mergeArray() 与 merge() 的作用是一样的，只是它可以发送4个以上的被观察者。</p><h3 id="concatArrayDelayError-amp-mergeArrayDelayError"><a href="#concatArrayDelayError-amp-mergeArrayDelayError" class="headerlink" title="concatArrayDelayError() &amp; mergeArrayDelayError()"></a>concatArrayDelayError() &amp; mergeArrayDelayError()</h3><p>在 concatArray() 和 mergeArray() 两个方法当中，如果其中有一个被观察者发送了一个 Error 事件，那么就会停止发送事件，如果你想 <strong>onError() 事件延迟到所有被观察者都发送完事件后再执行</strong>的话，就可以使用  concatArrayDelayError() 和 mergeArrayDelayError()</p><pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)public static &lt;T&gt; Observable&lt;T&gt; mergeArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)</code></pre><p>示例如下：</p><pre><code>Observable.concatArrayDelayError(Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {    @Override    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {        e.onNext(1);        e.onError(new NumberFormatException());    }}), Observable.just(2, 3, 4)).subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {    }    @Override    public void onNext(Integer integer) {        Log.d(TAG, &quot;===================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;===================onError &quot;);    }    @Override    public void onComplete() {    }});打印结果如下：===================onNext 1===================onNext 2===================onNext 3===================onNext 4===================onError </code></pre><p>从结果可以看到，onError 事件是在所有被观察者发送完事件才发送的。mergeArrayDelayError() 也是有同样的作用。</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h3><p>会将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。</p><pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; zip(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper)</code></pre><p>示例如下：</p><pre><code>Observable.zip(Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS)    .map(new Function&lt;Long, String&gt;() {        @Override        public String apply(Long aLong) throws Exception {            String s1 = &quot;A&quot; + aLong;            Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);            return s1;        }}),        Observable.intervalRange(1, 6, 1, 1, TimeUnit.SECONDS)            .map(new Function&lt;Long, String&gt;() {            @Override            public String apply(Long aLong) throws Exception {                String s2 = &quot;B&quot; + aLong;                Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);                return s2;            }        }),        new BiFunction&lt;String, String, String&gt;() {            @Override            public String apply(String s, String s2) throws Exception {                String res = s + s2;                return res;            }        }).subscribe(new Observer&lt;String&gt;() {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;===================onSubscribe &quot;);    }    @Override    public void onNext(String s) {        Log.d(TAG, &quot;===================onNext &quot; + s);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;===================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;===================onComplete &quot;);    }});上面代码中有两个 Observable，第一个发送事件的数量为5个，第二个发送事件的数量为6个。现在来看下打印结果：05-22 09:10:39.952 5338-5338/com.example.rxjavademo D/chan: ===================onSubscribe 05-22 09:10:40.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A105-22 09:10:40.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B1===================onNext A1B105-22 09:10:41.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A205-22 09:10:41.954 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B2===================onNext A2B205-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A305-22 09:10:42.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B305-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================onNext A3B305-22 09:10:43.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A405-22 09:10:43.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B405-22 09:10:43.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A4B405-22 09:10:44.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A505-22 09:10:44.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B505-22 09:10:44.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A5B5===================onComplete </code></pre><p>可以发现最终接收到的事件数量是5，那么为什么第二个 Observable 没有发送第6个事件呢？因为在这之前第一个 Observable 已经发送了 onComplete 事件，所以第二个 Observable 不会再发送事件。</p><h3 id="combineLatest-amp-combineLatestDelayError"><a href="#combineLatest-amp-combineLatestDelayError" class="headerlink" title="combineLatest() &amp;  combineLatestDelayError()"></a>combineLatest() &amp;  combineLatestDelayError()</h3><pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; combineLatest(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; combiner)</code></pre><p>combineLatest() 的作用与 zip() 类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，<strong>只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送</strong>，这样可能还是比较抽象，看看以下例子代码：</p><pre><code>Observable.combineLatest(Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS)    .map(new Function &lt; Long, String &gt; () {@Override    public String apply(Long aLong) throws Exception {        String s1 = &quot;A&quot; + aLong;        Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);        return s1;    }}),Observable.intervalRange(1, 5, 2, 2, TimeUnit.SECONDS)    .map(new Function &lt; Long, String &gt; () {@Override    public String apply(Long aLong) throws Exception {        String s2 = &quot;B&quot; + aLong;        Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);        return s2;    }}),new BiFunction &lt; String, String, String &gt; () {@Override    public String apply(String s, String s2) throws Exception {        String res = s + s2;        return res;    }}).subscribe(new Observer &lt; String &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;===================onSubscribe &quot;);    }    @Override    public void onNext(String s) {        Log.d(TAG, &quot;===================最终接收到的事件 &quot; + s);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;===================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;===================onComplete &quot;);    }});分析上面的代码，Observable A 会每隔1秒就发送一次事件，Observable B 会隔2秒发送一次事件。来看看打印结果：05-22 11:41:20.859 15104-15104/? D/chan: ===================onSubscribe 05-22 11:41:21.859 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A105-22 11:41:22.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A205-22 11:41:22.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B105-22 11:41:22.862 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A2B105-22 11:41:23.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A3===================最终接收到的事件 A3B105-22 11:41:24.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A405-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B205-22 11:41:24.861 15104-15128/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B105-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B205-22 11:41:26.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B305-22 11:41:26.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B305-22 11:41:28.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B405-22 11:41:28.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B405-22 11:41:30.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B505-22 11:41:30.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B5===================onComplete </code></pre><p>分析上述结果可以知道，当发送 A1 事件之后，因为 B 并没有发送任何事件，所以根本不会发生结合。当 B 发送了 B1 事件之后，就会与 A 最近发送的事件 A2 结合成 A2B1，这样只有后面一有被观察者发送事件，这个事件就会与其他被观察者最近发送的事件结合起来了。</p><p>因为 combineLatestDelayError() 就是多了延迟发送 onError() 功能，这里就不再赘述了。</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>与 scan() 操作符的作用也是将发送数据以一定逻辑聚合起来，这两个的区别在于 <strong>scan() 每处理一次数据就会将事件发送给观察者，而 reduce() 会将所有数据聚合在一起才会发送事件给观察者。</strong></p><pre><code>public final Maybe&lt;T&gt; reduce(BiFunction&lt;T, T, T&gt; reducer)</code></pre><p>示例如下：<br>    Observable.just(0, 1, 2, 3)<br>    .reduce(new BiFunction &lt; Integer, Integer, Integer &gt; () {<br>        @Override<br>        public Integer apply(Integer integer, Integer integer2) throws Exception {<br>            int res = integer + integer2;<br>            Log.d(TAG, “====================integer “ + integer);<br>            Log.d(TAG, “====================integer2 “ + integer2);<br>            Log.d(TAG, “====================res “ + res);<br>            return res;<br>        }<br>    })<br>    .subscribe(new Consumer &lt; Integer &gt; () {<br>        @Override<br>        public void accept(Integer integer) throws Exception {<br>            Log.d(TAG, “==================accept “ + integer);<br>        }<br>    });<br>    打印结果：<br>    ====================integer 0<br>    ====================integer2 1<br>    ====================res 1<br>    ====================integer 1<br>    ====================integer2 2<br>    ====================res 3<br>    ====================integer 3<br>    ====================integer2 3<br>    ====================res 6<br>    ==================accept 6<br>从结果可以看到，其实就是前2个数据聚合之后，然后再与后1个数据进行聚合，一直到没有数据为止。</p><h3 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h3><p>将数据收集到数据结构当中。</p><pre><code>public final &lt;U&gt; Single&lt;U&gt; collect(Callable&lt;? extends U&gt; initialValueSupplier, BiConsumer&lt;? super U, ? super T&gt; collector)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 4).collect(new Callable &lt; ArrayList &lt; Integer &gt;&gt; () {    @Override    public ArrayList &lt; Integer &gt; call() throws Exception {        return new ArrayList &lt; &gt; ();    }},new BiConsumer &lt; ArrayList &lt; Integer &gt; , Integer &gt; () {    @Override    public void accept(ArrayList &lt; Integer &gt; integers, Integer integer) throws Exception {        integers.add(integer);    }}).subscribe(new Consumer &lt; ArrayList &lt; Integer &gt;&gt; () {    @Override    public void accept(ArrayList &lt; Integer &gt; integers) throws Exception {        Log.d(TAG, &quot;===============accept &quot; + integers);    }});打印结果：===============accept [1, 2, 3, 4]</code></pre><h3 id="startWith-amp-startWithArray"><a href="#startWith-amp-startWithArray" class="headerlink" title="startWith() &amp; startWithArray()"></a>startWith() &amp; startWithArray()</h3><p>在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出。</p><pre><code>public final Observable&lt;T&gt; startWith(T item)public final Observable&lt;T&gt; startWithArray(T... items)</code></pre><p>示例如下：</p><pre><code>Observable.just(5, 6, 7).startWithArray(2, 3, 4).startWith(1).subscribe(new Consumer &lt; Integer &gt; () {    @Override    public void accept(Integer integer) throws Exception {        Log.d(TAG, &quot;================accept &quot; + integer);    }});打印结果：================accept 1================accept 2================accept 3================accept 4================accept 5================accept 6================accept 7</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>返回被观察者发送事件的数量。</p><pre><code>public final Single&lt;Long&gt; count()</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3).count().subscribe(new Consumer &lt; Long &gt; () {    @Override    public void accept(Long aLong) throws Exception {        Log.d(TAG, &quot;=======================aLong &quot; + aLong);    }});打印结果：=======================aLong 3</code></pre><h2 id="6、过滤操作符"><a href="#6、过滤操作符" class="headerlink" title="6、过滤操作符"></a>6、过滤操作符</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送。<br>    public final Observable<t> filter(Predicate&lt;? super T&gt; predicate)</t></p><p>示例如下：</p><pre><code> Observable.just(1, 2, 3)    .filter(new Predicate &lt; Integer &gt; () {        @Override        public boolean test(Integer integer) throws Exception {            return integer &lt; 2;        }}).subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);    }    @Override    public void onNext(Integer integer) {        i += integer;        Log.d(TAG, &quot;==================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});以上代码只有小于2的事件才会发送，来看看打印结果：==================onSubscribe ==================onNext 1==================onComplete </code></pre><h3 id="ofType"><a href="#ofType" class="headerlink" title="ofType()"></a>ofType()</h3><p>过滤不符合该类型事件</p><pre><code>public final &lt;U&gt; Observable&lt;U&gt; ofType(final Class&lt;U&gt; clazz)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, &quot;chan&quot;, &quot;zhide&quot;).ofType(Integer.class).subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);    }    @Override    public void onNext(Integer integer) {        i += integer;        Log.d(TAG, &quot;==================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});打印结果：==================onSubscribe ==================onNext 1==================onNext 2==================onNext 3==================onComplete </code></pre><h3 id="skip-amp-skipLast"><a href="#skip-amp-skipLast" class="headerlink" title="skip() &amp; skipLast()"></a>skip() &amp; skipLast()</h3><p>跳过正序某些事件，count 代表跳过事件的数量</p><pre><code>public final Observable&lt;T&gt; skip(long count)</code></pre><p>skipLast() 作用也是跳过某些事件，不过它是用来跳过正序的后面的事件。</p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p>过滤事件序列中的重复事件。</p><pre><code>public final Observable&lt;T&gt; distinct() </code></pre><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged()"></a>distinctUntilChanged()</h3><p>过滤掉连续重复的事件</p><pre><code>public final Observable&lt;T&gt; distinctUntilChanged()</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 3, 2, 1).distinctUntilChanged().subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);    }    @Override    public void onNext(Integer integer) {        i += integer;        Log.d(TAG, &quot;==================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});打印结果:==================onSubscribe ==================onNext 1==================onNext 2==================onNext 3==================onNext 2==================onNext 1==================onComplete </code></pre><p>因为事件序列中连续出现两次3，所以第二次3并不会发出。</p><h3 id="take-amp-takeLast"><a href="#take-amp-takeLast" class="headerlink" title="take() &amp; takeLast()"></a>take() &amp; takeLast()</h3><p>控制观察者接收的事件的数量。</p><pre><code>public final Observable&lt;T&gt; take(long count)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 4, 5).take(3).subscribe(new Observer &lt; Integer &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;==================onSubscribe &quot;);    }    @Override    public void onNext(Integer integer) {        i += integer;        Log.d(TAG, &quot;==================onNext &quot; + integer);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;==================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;==================onComplete &quot;);    }});打印结果：==================onSubscribe ==================onNext 1==================onNext 2==================onNext 3==================onComplete </code></pre><p>takeLast() 的作用就是控制观察者只能接受事件序列的后面几件事情。</p><h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce()"></a>debounce()</h3><p>如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者。</p><pre><code>public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit)</code></pre><p>throttleWithTimeout() 与此方法的作用一样。</p><h3 id="firstElement-amp-amp-lastElement"><a href="#firstElement-amp-amp-lastElement" class="headerlink" title="firstElement() &amp;&amp; lastElement()"></a>firstElement() &amp;&amp; lastElement()</h3><p>firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素。</p><pre><code>public final Maybe&lt;T&gt; firstElement()public final Maybe&lt;T&gt; lastElement()</code></pre><h3 id="elementAt-amp-elementAtOrError"><a href="#elementAt-amp-elementAtOrError" class="headerlink" title="elementAt() &amp; elementAtOrError()"></a>elementAt() &amp; elementAtOrError()</h3><p>elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 。</p><pre><code>public final Maybe&lt;T&gt; elementAt(long index)public final Single&lt;T&gt; elementAtOrError(long index)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 4).elementAt(0).subscribe(new Consumer &lt; Integer &gt; () {    @Override    public void accept(Integer integer) throws Exception {        Log.d(TAG, &quot;====================accept &quot; + integer);    }});打印结果：====================accept 1</code></pre><p>将 elementAt() 的值改为5，这时是没有打印结果的，因为没有满足条件的元素。<br>替换 elementAt() 为 elementAtOrError()，代码如下：</p><pre><code>Observable.just(1, 2, 3, 4).elementAtOrError(5).subscribe(new Consumer &lt; Integer &gt; () {    @Override    public void accept(Integer integer) throws Exception {        Log.d(TAG, &quot;====================accept &quot; + integer);    }});</code></pre><p>这时候会抛出 NoSuchElementException 异常。</p><h2 id="7、条件操作符"><a href="#7、条件操作符" class="headerlink" title="7、条件操作符"></a>7、条件操作符</h2><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><p>判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false。</p><pre><code>public final Single&lt;Boolean&gt; all(Predicate&lt;? super T&gt; predicate)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 4).all(new Predicate &lt; Integer &gt; () {    @Override    public boolean test(Integer integer) throws Exception {        return integer &lt; 5;    }}).subscribe(new Consumer &lt; Boolean &gt; () {    @Override    public void accept(Boolean aBoolean) throws Exception {        Log.d(TAG, &quot;==================aBoolean &quot; + aBoolean);    }});打印结果：==================aBoolean true</code></pre><h3 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile()"></a>takeWhile()</h3><p>可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送</p><pre><code>public final Observable&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 4).takeWhile(new Predicate &lt; Integer &gt; () {    @Override    public boolean test(Integer integer) throws Exception {        return integer &lt; 3;    }}).subscribe(new Consumer &lt; Integer &gt; () {    @Override    public void accept(Integer integer) throws Exception {        Log.d(TAG, &quot;========================integer &quot; + integer);    }});打印结果：========================integer 1========================integer 2</code></pre><h3 id="skipWhile"><a href="#skipWhile" class="headerlink" title="skipWhile()"></a>skipWhile()</h3><p>可以设置条件，当某个数据满足条件时不发送该数据，反之则发送。</p><pre><code>public final Observable&lt;T&gt; skipWhile(Predicate&lt;? super T&gt; predicate)</code></pre><h3 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil()"></a>takeUntil()</h3><p>可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了。</p><pre><code>public final Observable&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; stopPredicate</code></pre><p>示例如下：</p><pre><code>Observable.just(1, 2, 3, 4, 5, 6).takeUntil(new Predicate &lt; Integer &gt; () {    @Override    public boolean test(Integer integer) throws Exception {        return integer &gt; 3;    }}).subscribe(new Consumer &lt; Integer &gt; () {    @Override    public void accept(Integer integer) throws Exception {        Log.d(TAG, &quot;========================integer &quot; + integer);    }});打印结果：========================integer 1========================integer 2========================integer 3========================integer 4</code></pre><h3 id="skipUntil"><a href="#skipUntil" class="headerlink" title="skipUntil()"></a>skipUntil()</h3><p>当 <strong>skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者。skipUntil() 里的 Observable 并不会发送事件给观察者。</strong></p><pre><code>public final &lt;U&gt; Observable&lt;T&gt; skipUntil(ObservableSource&lt;U&gt; other)</code></pre><p>示例如下：</p><pre><code>Observable.intervalRange(1, 5, 0, 1, TimeUnit.SECONDS).skipUntil(Observable.intervalRange(6, 5, 3, 1, TimeUnit.SECONDS)).subscribe(new Observer &lt; Long &gt; () {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;========================onSubscribe &quot;);    }    @Override    public void onNext(Long along) {        Log.d(TAG, &quot;========================onNext &quot; + along);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;========================onError &quot;);    }    @Override    public void onComplete() {        Log.d(TAG, &quot;========================onComplete &quot;);    }});打印结果：05-26 10:08:50.574 13023-13023/com.example.rxjavademo D/chan: ========================onSubscribe 05-26 10:08:53.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 405-26 10:08:54.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 5========================onComplete </code></pre><h3 id="sequenceEqual"><a href="#sequenceEqual" class="headerlink" title="sequenceEqual()"></a>sequenceEqual()</h3><p>判断两个  Observable 发送的事件是否相同。</p><pre><code>public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2)</code></pre><h3 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h3><p>判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false。</p><pre><code>public final Single&lt;Boolean&gt; contains(final Object element)</code></pre><h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h3><p>判断事件序列是否为空。</p><pre><code>public final Single&lt;Boolean&gt; isEmpty()</code></pre><h3 id="defaultIfEmpty"><a href="#defaultIfEmpty" class="headerlink" title="defaultIfEmpty()"></a>defaultIfEmpty()</h3><p>如果观察者只发送一个 onComplete() 事件，这个方法会发送一个值。</p><pre><code>public final Observable&lt;T&gt; defaultIfEmpty(T defaultItem)</code></pre><p>示例如下：</p><pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {    @Override    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {        e.onComplete();    }}).defaultIfEmpty(666).subscribe(new Consumer &lt; Integer &gt; () {    @Override    public void accept(Integer integer) throws Exception {        Log.d(TAG, &quot;========================onNext &quot; + integer);    }});打印结果：========================onNext 666</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/post/5b17560e6fb9a01e2862246f" target="_blank" rel="noopener">https://juejin.im/post/5b17560e6fb9a01e2862246f</a><br><a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">https://gank.io/post/560e15be2dca930e00da1083</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter集成Android项目</title>
      <link href="/2019/06/28/flutter-integration/"/>
      <url>/2019/06/28/flutter-integration/</url>
      
        <content type="html"><![CDATA[<h2 id="在现有项目上集成Flutter"><a href="#在现有项目上集成Flutter" class="headerlink" title="在现有项目上集成Flutter"></a>在现有项目上集成Flutter</h2><p>1.在andorid工程目录上级目录下执行命令:</p><pre><code>flutter create -t module xxxx(想要创建的flutter项目名)</code></pre><p>执行完后，一个和Android项目平级的flutter项目就已经创建好了。</p><p>2.添加flutter到当前Android项目：<br>在Android项目根目录下的settings.gradle文件中，添加如下代码：</p><pre><code>setBinding(new Binding([gradle: this]))evaluate(new File(        settingsDir.parentFile,        &quot;flutter_hybrid/.android/include_flutter.groovy&quot;))</code></pre><p>然后，在项目的app目录下，build.gradle文件中，添加如下dependency:</p><pre><code>implementation project(&apos;:flutter&apos;)</code></pre><p>如上，添加完之后，准备工作就完成了。</p><h2 id="集成Flutter页面跳转"><a href="#集成Flutter页面跳转" class="headerlink" title="集成Flutter页面跳转"></a>集成Flutter页面跳转</h2><h3 id="通过继承FlutterActivity跳到默认页面"><a href="#通过继承FlutterActivity跳到默认页面" class="headerlink" title="通过继承FlutterActivity跳到默认页面"></a>通过继承FlutterActivity跳到默认页面</h3><p>1.Application：初始化Flutter</p><pre><code>public class App extends Application {    @Override    public void onCreate() {        super.onCreate();        FlutterMain.startInitialization(this);    }}</code></pre><p>2.Activity：继承FlutterActivity</p><pre><code>/** * debug模式原生跳转到flutter界面会出现白屏，release包就不会出现白屏了 */public class MainFlutterActivity extends FlutterActivity {  @Override  protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    GeneratedPluginRegistrant.registerWith(this);  }</code></pre><p>这样以后，我们就可以跳转这个MainFlutterActivity，实现在Android工程里面进入Flutter工程的默认页面了。</p><h3 id="通过FlutterView跳到指定页面"><a href="#通过FlutterView跳到指定页面" class="headerlink" title="通过FlutterView跳到指定页面"></a>通过FlutterView跳到指定页面</h3><p>首先通过Flutter.createFlutterView方法来创建一个FlutterView类型的View。它有三个构造参数：</p><pre><code>public static FlutterView createView(Activity activity, Lifecycle lifecycle, String initialRoute)</code></pre><p>三个参数分别是：<br>1.Activity，即当前附着的Activity</p><p>2.LifeCycle，且是不能为空(NonNull)的，这也就要求我们必须用AppCompatActivity来承载FlutterView了，如果我们的Activity继承自android.app.Activity是没有getLifeCycle()这个方法的。</p><pre><code>public class FlutterViewActivity extends AppCompatActivity 复制代码</code></pre><p>3.initialRoute这是一个String类型的变量，根据不同的标识跳转不同的Flutter页面：</p><pre><code>Widget _widgetForRoute(String route) {  switch (route) {    case &apos;route1&apos;:      return  MyHomePage(title: &apos;Flutter Demo Home Page1&apos;);    case &apos;route2&apos;:      return  MyHomePage(title: &apos;Flutter Demo Home Page2&apos;);    default:        return  MyHomePage(title: &apos;Flutter Demo Home Page2&apos;);  }}</code></pre><p>然后在当前Activity的OnCreate方法中，执行：</p><pre><code>FlutterView flutterView = Flutter.createView(this, getLifecycle(), &quot;route1&quot;);    setContentView(flutterView);//或者：setContentView(R.layout.activity_flutter);rlContainer = findViewById(R.id.rl_container);rlContainer.addView(flutterView)</code></pre><h2 id="集成到现有项目遇到的坑"><a href="#集成到现有项目遇到的坑" class="headerlink" title="集成到现有项目遇到的坑"></a>集成到现有项目遇到的坑</h2><p>Check failed: vm. Must be able to initialize the VM：</p><pre><code>E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.    [ERROR:flutter/runtime/dart_vm.cc(241)] Could not setup VM data to bootstrap the VM from.    [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance. A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.SIGABRT    0x146b    #00    pc 0002210c    /system/lib/libc.so (tgkill+12) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]    #01    pc 00013165    /system/lib/libc.so (pthread_kill+48) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]    #02    pc 00013379    /system/lib/libc.so (raise+10) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]    #03    pc 000120a3    /system/lib/libc.so [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]    #04    pc 000219c0    /system/lib/libc.so (abort+4) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]    #05    pc 00af85ab    /data/app-lib/xxx.debug-1/libflutter.so [armeabi-v7a::a12434e0b53806a35730000001000000]</code></pre><p>经github上<a href="https://github.com/flutter/flutter/issues/24679" target="_blank" rel="noopener">#24679</a>及其他issue参考，得出以下解决方案：</p><blockquote><p>Import flutter module to your HOST app(set binding, implementation, and instantiate view/fragment)<br>When you clean/rebuild from HOST app, flutter module does not generate properly<br>You need to open your flutter module in a separate AS<br>flutter clean<br>cd .android<br>./gradlew clean<br>./gradlew assembleDebug<br>Return to host app and run app(do not sync or rebuild) :)</p></blockquote><p>翻译过来就是：</p><blockquote><p>本项目执行清理命令。./gradlew clean<br>进入 flutter module 项目执行清理命令。flutter packages get;flutter clean<br>进入 flutter module 的 .android 项目执行清理命令和打包操作。./gradlew clean;./gradlew assemble<br>回到本项目执行打包命令。./gradlew assemble</p></blockquote><p>直接执行下面命令即可：</p><pre><code>$ ./gradlew clean;cd ../flutter_module;flutter packages get;flutter clean;cd .android/;./gradlew clean;./gradlew assemble;cd /d/workspace/app_proj/;./gradlew installDebug</code></pre><p>后续假设你 flutter module 没有更新过，那么以后修改本地项目之后，就直接执行./gradlew installDebug。 注意不要用studio工具运行、rebuild或clean。</p><h3 id="flutter-assets"><a href="#flutter-assets" class="headerlink" title="flutter_assets"></a>flutter_assets</h3><p>assets下缺少flutter_assets也有可能造成此问题。具体可以参考：<a href="https://www.jianshu.com/p/2d0bba84e57e" target="_blank" rel="noopener">https://www.jianshu.com/p/2d0bba84e57e</a></p><h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><p>按照上述方式，debug版本没问题，release却报错。需加以下混淆：</p><pre><code>-keep class io.flutter.app.** { *; }-keep class io.flutter.plugin.** { *; }-keep class io.flutter.util.** { *; }-keep class io.flutter.view.** { *; }-keep class io.flutter.** { *; }-keep class io.flutter.plugins.** { *; }-keep class myapp.flutter.** { *; }</code></pre><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><h3 id="Flutter-调用Android"><a href="#Flutter-调用Android" class="headerlink" title="Flutter 调用Android"></a>Flutter 调用Android</h3><p>java</p><pre><code>new MethodChannel(flutterView, FlutterToAndroidCHANNEL).setMethodCallHandler(new MethodChannel.MethodCallHandler() {    @Override    public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) {        //接收来自flutter的指令withoutParams        if (methodCall.method.equals(&quot;withoutParams&quot;)) {            //跳转到指定Activity            Intent intent = new Intent(NativeActivity.this, NativeActivity.class);            startActivity(intent);            //返回给flutter的参数            result.success(&quot;success&quot;);        }        //接收来自flutter的指令withParams        else if (methodCall.method.equals(&quot;withParams&quot;)) {            //解析参数            String text = methodCall.argument(&quot;flutter&quot;);            //带参数跳转到指定Activity            Intent intent = new Intent(NativeActivity.this, NativeActivity.class);            intent.putExtra(&quot;test&quot;, text);            startActivity(intent);            //返回给flutter的参数            result.success(&quot;success&quot;);        } else {            result.notImplemented();        }    }});</code></pre><p>dart</p><pre><code>Future&lt;Null&gt; _jumpToNative() async {  String result = await toAndroidPlugin.invokeMethod(&apos;withoutParams&apos;);  print(result);}Future&lt;Null&gt; _jumpToNativeWithParams() async {  Map&lt;String, String&gt; map = { &quot;flutter&quot;: &quot;这是一条来自flutter的参数&quot; };  String result = await toAndroidPlugin.invokeMethod(&apos;withParams&apos;, map);  print(result);}</code></pre><h3 id="Android-向-Flutter-传参"><a href="#Android-向-Flutter-传参" class="headerlink" title="Android 向 Flutter 传参"></a>Android 向 Flutter 传参</h3><p>java</p><pre><code>new EventChannel(flutterView, AndroidToFlutterCHANNEL)            .setStreamHandler(new EventChannel.StreamHandler() {                @Override                public void onListen(Object o, EventChannel.EventSink eventSink) {                    String androidParmas = &quot;来自android原生的参数&quot;;                    eventSink.success(androidParmas);                }                @Override                public void onCancel(Object o) {                }            });</code></pre><p>dart</p><pre><code> void _startfromAndroiPlugin(){   if(_fromAndroiSub == null){     _fromAndroiSub =  fromAndroiPlugin.receiveBroadcastStream()     .listen(_onfromAndroiEvent,onError: _onfromAndroiError);   } }void _onfromAndroiEvent(Object event) {   setState(() {     _nativeParams = event;   }); } void _onfromAndroiError(Object error) {   setState(() {     _nativeParams = &quot;error&quot;;     print(error);   }); }</code></pre><p>有几处 要注意一一对应：</p><pre><code>public static final String FlutterToAndroidCHANNEL = &quot;com.litngzhe.toandroid/plugin&quot;; public static final String AndroidToFlutterCHANNEL= &quot;com.litngzhe.toflutter/plugin&quot;;new MethodChannel(flutterView, FlutterToAndroidCHANNEL)new EventChannel(flutterView, AndroidToFlutterCHANNEL) //dart中 获取到插件与原生的交互通道 MethodChannel 中 涉及到的方法名要要统一static const toAndroidPlugin = const MethodChannel(&apos;com.litngzhe.toandroid/plugin&apos;);static const fromAndroiPlugin = const EventChannel(&apos;com.litngzhe.toflutter/plugin&apos;); </code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/chinaltz/FlutterDemo" target="_blank" rel="noopener">FlutterDemo</a><br><a href="https://juejin.im/post/5c74dbeee51d45708f2a20c6" target="_blank" rel="noopener">https://juejin.im/post/5c74dbeee51d45708f2a20c6</a><br><a href="https://github.com/flutter/flutter/issues/24679" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/24679</a><br><a href="https://github.com/flutter/flutter/issues/25147" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/25147</a><br><a href="https://mp.weixin.qq.com/s/OGbH3G3wHVTUt-0EJit8RA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OGbH3G3wHVTUt-0EJit8RA</a></p>]]></content>
      
      
      <categories>
          
          <category> Hybrid Develop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart语言基础</title>
      <link href="/2019/06/25/dart-knowledge/"/>
      <url>/2019/06/25/dart-knowledge/</url>
      
        <content type="html"><![CDATA[<ul><li>在Dart中，一切都是对象，一切对象都是class的实例，哪怕是数字类型、方法甚至null都是对象，所有的对象都是继承自Object</li><li>虽然Dart是强类型语言，但变量类型是可选的，因为Dart可以自动推断变量类型</li><li>Dart支持范型，List&lt;int&gt;表示一个整型的数据列表，List&lt;dynamic&gt;则是一个对象的列表，其中可以装任意对象</li><li>Dart支持顶层方法（如main方法），也支持类方法或对象方法，同时你也可以在方法内部创建方法</li><li>Dart支持顶层变量，也支持类变量或对象变量</li><li>跟Java不同的是，Dart没有public protected private等关键字，如果某个变量以下划线（_）开头，代表这个变量在库中是私有的</li><li>Dart中变量可以以字母或下划线开头，后面跟着任意组合的字符或数字</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>以下代码是Dart中定义变量的方法：</p><pre><code>main() {  var a = 1;  int b = 10;  String s = &quot;hello&quot;;  dynamic c = 0.5;  var count = 10;   final Num = count;  // final 只能赋值一次  const Num1 = 10; // const赋值必须是编译时常量}</code></pre><p>你<strong>可以明确指定某个变量的类型，如int bool String，也可以用var或 dynamic来声明一个变量，Dart会自动推断其数据类型</strong>。</p><p>使用final或const，不要使用var或其他类型，一个被final修饰的变量只能被赋值一次，一个被const修饰的变量是一个编译时常量（const常量毫无疑问也是final常量）。final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量；而 const 要求在声明时初始化，并且赋值必需为编译时常量。</p><p>注意：<strong>没有赋初值的变量都会有默认值null</strong><br>注意：实例变量可以是final的但不能是const的</p><h3 id="内建数据类型"><a href="#内建数据类型" class="headerlink" title="内建数据类型"></a>内建数据类型</h3><p>Dart有如下几种内建的数据类型：</p><ul><li>numbers</li><li>strings</li><li>booleans</li><li>lists(或者是arrays)</li><li>maps</li><li>runes（UTF-32字符集的字符）</li><li><p>symbols<br>下面用一段代码来演示以上各类数据类型：</p><pre><code>main() {  // numbers  var a = 0;  int b = 1;  double c = 0.1;  // strings  var s1 = &apos;hello&apos;;  String s2 = &quot;world&quot;;  // booleans  var real = true;  bool isReal = false;  // lists  var arr = [1, 2, 3, 4, 5];  List&lt;String&gt; arr2 = [&apos;hello&apos;, &apos;world&apos;, &quot;123&quot;, &quot;456&quot;];  List&lt;dynamic&gt; arr3 = [1, true, &apos;haha&apos;, 1.0];  // maps  var map = new Map();  map[&apos;name&apos;] = &apos;zhangsan&apos;;  map[&apos;age&apos;] = 10;  Map m = new Map();  m[&apos;a&apos;] = &apos;a&apos;;  //runes，Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符  var clapping = &apos;\u{1f44f}&apos;;  print(clapping); // 打印的是拍手emoji的表情  // symbols  print(#s == new Symbol(&quot;s&quot;)); // true}</code></pre></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Dart是一个面向对象的编程语言，所以即使是<strong>函数也是一个对象</strong>，也有一种类型Function，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。虽然Dart推荐你给函数加上返回值，但是不加返回值的函数同样可以正常工作，另外你还可以用=&gt;代替return语句，比如下面的代码：</p><pre><code>// 声明返回值int add(int a, int b) {  return a + b;}// 不声明返回值add2(int a, int b) {  return a + b;}// =&gt;是return语句的简写add3(a, b) =&gt; a + b; main() {  print(add(1, 2)); // 3  print(add2(2, 3)); // 5  print(add3(1, 2)); // 3}</code></pre><h4 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h4><pre><code>sayHello({String name}) {  print(&quot;hello, my name is $name&quot;);}sayHello2({name: String}) {  print(&quot;hello, my name is $name&quot;);}main() {  // 打印 hello, my name is zhangsan  sayHello(name: &apos;zhangsan&apos;);  // 打印 hello, my name is wangwu  sayHello2(name: &apos;wangwu&apos;);}</code></pre><p>可以看到，定义命名参数时，你<strong>可以以 {type paramName} 或者 {paramName: type} 两种方式声明参数</strong>，而调用命名参数时，需要以 funcName(paramName: paramValue) 的形式调用。</p><p>命名参数的<strong>参数并不是必须的</strong>，所以上面的代码中，如果调用sayHello()不带任何参数，也是可以的，只不过最后打印出来的结果是：hello, my name is null，在Flutter开发中，你<strong>可以使用@required注解来标识一个命名参数，这代表该参数是必须的</strong>，你不传则会报错，比如下面的代码：</p><pre><code>const Scrollbar({Key key, @required Widget child})</code></pre><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>使用<strong>中括号[]括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面</strong>，如下代码所示：</p><pre><code>sayHello(String name, int age, [String hobby]) { // 位置参数可以有多个，比如[String a, int b]  StringBuffer sb = new StringBuffer();  sb.write(&quot;hello, this is $name and I am $age years old&quot;);  if (hobby != null) {    sb.write(&quot;, my hobby is $hobby&quot;);  }  print(sb.toString());}main() {  // hello, this is zhangsan and I am 20 years old  sayHello(&quot;zhangsan&quot;, 20);  // hello, this is zhangsan and I am 20 years old, my hobby is play football  sayHello(&quot;zhangsan&quot;, 20, &quot;play football&quot;);}</code></pre><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>你可以为命名参数或者位置参数设置默认值，如下代码所示：</p><pre><code>// 命名参数的默认值int add({int a, int b = 3}) { // 不能写成：int add({a: int, b: int = 3})  return a + b;}// 位置参数的默认值int sum(int a, int b, [int c = 3]) {  return a + b + c;}</code></pre><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h4><p>不论在Dart还是Flutter中，必须都需要一个顶层的main()函数，它<strong>是整个应用的入口函数，main()函数的返回值是void，还有一个可选的参数，参数类型是List&lt;String&gt;</strong>。</p><h4 id="函数作为一类对象"><a href="#函数作为一类对象" class="headerlink" title="函数作为一类对象"></a>函数作为一类对象</h4><p>你可以将一个函数作为参数传给另一个函数，比如下面的代码：</p><pre><code>printNum(int a) {  print(&quot;$a&quot;);}main() {  //  依次打印：  //  1  //  2  //  3  var arr = [1, 2, 3];  arr.forEach(printNum);}</code></pre><p>你也可以将一个函数赋值给某个变量，比如下面的代码：</p><pre><code>printNum(int a) {  print(&quot;$a&quot;);}main() {  var f1 = printNum;  Function f2 = printNum;  var f3 = (int a) =&gt; print(&quot;a = $a&quot;);  f1(1);  f2(2);  f3(6);}</code></pre><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>大多数函数都是有名称的，比如main() printName()等，但是你也可以写匿名函数，如果你对Java比较熟悉，那下面的Dart代码你肯定也不会陌生：</p><pre><code>test(Function callback) {  callback(&quot;hello&quot;);}main() {  test((param) {    // 打印hello    print(param);  });}</code></pre><p>匿名函数类似于Java中的接口，往往在某个函数的参数为函数时使用到。</p><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p><strong>所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null</strong></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Dart中的运算符与Java中的类似，比如++a a == b b ? a : b，但是也有一些与Java不太一样的运算符，下面用代码说明：</p><pre><code>main() {  // 与Java相同的运算符操作  int a = 1;  ++a;  a++;  var b = 1;  print(a == b);  // false  print(a * b); // 3  bool real = false;  real ? print(&apos;real&apos;) : print(&apos;not real&apos;); // not real  print(real &amp;&amp; a == b); // false  print(real || a == 3); // true  print(a != 2); // true  print(a &lt;= b); // false  var c = 9;  c += 10;  print(&quot;c = $c&quot;); // c = 19  print(1&lt;&lt;2); // 4  // 与Java不太一样的运算符操作  // is运算符用于判断一个变量是不是某个类型的数据  // is!则是判断变量不是某个类型的数据  var s = &quot;hello&quot;;  print(s is String); // true  var num = 6;  print(num is! String); // true  // ~/才是取整运算符，如果使用/则是除法运算，不取整  int k = 1;  int j = 2;  print(k / j); // 0.5  print(k ~/ j); // 0  // as运算符类似于Java中的cast操作，将一个对象强制类型转换  (emp as Person).teach();  // ??=运算符 如果 ??= 运算符前面的变量为null，则赋值，否则不赋值  var param1 = &quot;hello&quot;, param2 = null;  param1 ??= &quot;world&quot;;  param2 ??= &quot;world&quot;;  print(&quot;param1 = $param1&quot;); // param1 = hello  print(&quot;param2 = $param2&quot;); // param2 = world  // ?.运算符  var str1 = &quot;hello world&quot;;  var str2 = null;  print(str1?.length); // 11  print(str2?.length); // null   print(str2.length); // 报错}</code></pre><h4 id="运算符（级联操作）"><a href="#运算符（级联操作）" class="headerlink" title="..运算符（级联操作）"></a>..运算符（级联操作）</h4><p>如果你对Java中的建造者模式比较熟悉的话，Dart中的..运算符也很好理解，先看下面的代码：</p><pre><code>class Person {  eat() {    print(&quot;I am eating...&quot;);  }  sleep() {    print(&quot;I am sleeping...&quot;);  }  study() {    print(&quot;I am studying...&quot;);  }}main() {  // 依次打印  //  I am eating...  //  I am sleeping...  //  I am studying...  new Person()..eat()      ..sleep()      ..study();}</code></pre><p>可以看到，使用<strong>..调用某个对象的方法（或者成员变量）时，返回值是这个对象本身</strong>，所以你可以接着使用..调用这个对象的其他方法，这不就类似于Java中的建造者模式，每次build某个属性时，都返回一个this对象吗。</p><h3 id="typedefs"><a href="#typedefs" class="headerlink" title="typedefs"></a>typedefs</h3><p>typedef 本质上为 一个方法签名提供了一个别名。官网上介绍TypeDef的时候有一句话说道：<br>“If we change the code to use explicit names and retain type information”<br>使用typedef会保留方法的类型信息。</p><p>考虑下面的代码，哪一个没有使用 typedef。</p><pre><code>class SortedCollection {  Function compare;  SortedCollection(int f(Object a, Object b)) {    compare = f;  }} // Initial, broken implementation. int sort(Object a, Object b) =&gt; 0;main() {  SortedCollection coll = new SortedCollection(sort);  // All we know is that compare is a function,  // but what type of function?  assert(coll.compare is Function);}</code></pre><p>当 f 分配到 compare 的时候类型信息丢失了。f的类型是 (Object, Object) → int(→ 意味着返回的)，然而compare 的类型是方法。如果我们使用显式的名字更改代码并保留类型信息，则开发者和工具都可以使用这些信息。</p><pre><code>typedef int Compare(Object a, Object b);class SortedCollection {  Compare compare;  SortedCollection(this.compare);} // Initial, broken implementation. int sort(Object a, Object b) =&gt; 0;main() {  SortedCollection coll = new SortedCollection(sort);  assert(coll.compare is Function);  assert(coll.compare is Compare);}</code></pre><p>请注意目前 typedefs 仅限于函数类型。</p><p>因为 typedefs 是简单的别名，所以它提供了一种方法来检查任何函数的类型。比如：</p><pre><code>typedef int Compare(int a, int b);int sort(int a, int b) =&gt; a - b;main() {  assert(sort is Compare); // True!}</code></pre><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>if / else switch for /while try / catch语句跟Java中都类似，<strong>try / catch语句可能稍有不同</strong>，下面用一段代码说明：</p><blockquote><p>Dart中规定，if中当且仅当参数为bool类型true时，为真，其他全部都为假。</p></blockquote><pre><code>main() {  // if else语句  int score = 80;  if (score &lt; 60) {    print(&quot;so bad!&quot;);  } else if (score &gt;= 60 &amp;&amp; score &lt; 80) {    print(&quot;just so so!&quot;);  } else if (score &gt;= 80) {    print(&quot;good job!&quot;);  }  // switch语句  String a = &quot;hello&quot;;  // case语句中的数据类型必须是跟switch中的类型一致  switch (a) {    case &quot;hello&quot;:      print(&quot;haha&quot;);      break;    case &quot;world&quot;:      print(&quot;heihei&quot;);      break;    default:      print(&quot;WTF&quot;);  }  // for语句  List&lt;String&gt; list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];  for (int i = 0; i &lt; list.length; i++) {    print(list[i]);  }  for (var i in list) {    print(i);  }  // 这里的箭头函数参数必须用圆括号扩起来  list.forEach((item) =&gt; print(item));  // while语句  int start = 1;  int sum = 0;  while (start &lt;= 100) {    sum += start;    start++;  }  print(sum);  // try catch语句  try {    print(1 ~/ 0);  } catch (e) {    // IntegerDivisionByZeroException    print(e);  }  try {    1 ~/ 0;  } on IntegerDivisionByZeroException { // 捕获指定类型的异常    print(&quot;error&quot;); // 打印出error  } finally {    print(&quot;over&quot;); // 打印出over  }}</code></pre><h4 id="rethrow"><a href="#rethrow" class="headerlink" title="rethrow"></a>rethrow</h4><p>rethrow语句用来处理一个异常，同时<strong>希望这个异常能够被其它调用的部分使用</strong>:</p><pre><code>final foo = &apos;&apos;;void misbehave() {   try {     foo = &quot;1&quot;;   } catch (e) {     print(&apos;2&apos;);     rethrow;// 如果不重新抛出异常，main函数中的catch语句执行不到   }}void main() {   try {     misbehave();   } catch (e) {     print(&apos;3&apos;);   }}</code></pre><h3 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h3><h4 id="类的定义与构造方法"><a href="#类的定义与构造方法" class="headerlink" title="类的定义与构造方法"></a>类的定义与构造方法</h4><p>Dart中的类没有访问控制，所以你不需要用private, protected, public等修饰成员变量或成员函数，一个简单的类如下代码所示：</p><pre><code>class Person {  String name;  int age;  String gender;  Person(this.name, this.age, this.gender);  sayHello() {    print(&quot;hello, this is $name, I am $age years old, I am a $gender&quot;);  }}</code></pre><p>上面的Person类中有3个成员变量，一个构造方法和一个成员方法，看起来<strong>比较奇怪的是Person的构造方法，里面传入的3个参数都是this.xxx，而且没有大括号{}包裹的方法体</strong>，这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码：</p><pre><code>Person(String name, int age, String gender) {    this.name = name;    this.age = age;    this.gender = gender;}</code></pre><p>要调用Person类的成员变量或成员方法，可以用下面的代码：</p><pre><code>var p = new Person(&quot;zhangsan&quot;, 20, &quot;male&quot;);p.sayHello(); // hello, this is zhangsan, I am 20 years old, I am a malep.age = 50;p.gender = &quot;female&quot;;p.sayHello(); // hello, this is zhangsan, I am 50 years old, I am a female</code></pre><p>类除了有跟类名相同的构造方法外，<strong>还可以添加命名的构造方法</strong>，如下代码所示：</p><pre><code>class Point {  num x, y;  Point(this.x, this.y);  // 类的命名构造方法  Point.origin() {    x = 0;    y = 0;  }}main() {  // 调用Point类的命名构造方法origin()  var p = new Point.origin();  var p2 = new Point(1, 2);}</code></pre><p>Dart中使用extends关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：</p><pre><code>class Human {  String name;  Human.fromJson(Map data) {    print(&quot;Human&apos;s fromJson constructor&quot;);  }}class Man extends Human {  Man.fromJson(Map data) : super.fromJson(data) {    print(&quot;Man&apos;s fromJson constructor&quot;);  }}</code></pre><p>由于<strong>Human类没有默认构造方法，只有一个命名构造方法fromJson，所以在Man类继承Human类时，需要调用父类的fromJson方法做初始化，而且必须使用Man.fromJson(Map data) : super.fromJson(data)这种写法</strong>，而不是像Java那样将super写到花括号中。Dart语言中，<strong>子类不会继承父类的命名构造函数</strong>。如果不显式提供子类的构造函数，系统就提供默认的构造函数。</p><p>有时候你仅仅只是在某个类的构造方法中，调用这个类的另一个构造方法，你可以这么写：</p><pre><code>class Point {  num x, y;  Point(this.x, this.y);  // 命名构造方法调用了默认的构造方法  Point.alongXAxis(num x) : this(x, 0);}</code></pre><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>除了调用父类的构造函数，也可以通过初始化列表<strong>在子类的构造函数体前（大括号前）来初始化实例的变量值，使用逗号,分隔</strong>。如下所示：</p><pre><code>class Point {   num x;   num y;   Point(this.x, this.y);   // 初始化列表在构造函数运行前设置实例变量。   Point.fromJson(Map jsonMap)   : x = jsonMap[&apos;x&apos;],     y = jsonMap[&apos;y&apos;] {      print(&apos;In Point.fromJson(): ($x, $y)&apos;);   } }</code></pre><p>注意：上述代码，初始化程序无法访问 this 关键字。</p><h4 id="类的成员方法"><a href="#类的成员方法" class="headerlink" title="类的成员方法"></a>类的成员方法</h4><p>一个类的成员方法是一个函数，为这个类提供某些行为。上面的代码中已经有了一些类的成员方法的定义，这些定义方式跟Java很类似，你可以为某个类的成员变量提供getter/setter方法，如下代码：</p><pre><code>class Rectangle {  num left, top, width, height;  // 构造方法传入left, top, width, height几个参数  Rectangle(this.left, this.top, this.width, this.height);  // right, bottom两个成员变量提供getter/setter方法  num get right =&gt; left + width;  set right(num value) =&gt; left = value - width;  num get bottom =&gt; top + height;  set bottom(num value) =&gt; top = value - height;}</code></pre><h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><p>使用abstract修饰一个类，则这个类是抽象类，抽象类中可以有抽象方法和非抽象方法，抽象方法没有方法体，需要子类去实现，如下代码：</p><pre><code>abstract class Doer {  // 抽象方法，没有方法体，需要子类去实现  void doSomething();  // 普通的方法  void greet() {    print(&quot;hello world!&quot;);  }}class EffectiveDoer extends Doer {  // 实现了父类的抽象方法  void doSomething() {    print(&quot;I&apos;m doing something...&quot;);  }}</code></pre><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>Dart中有类似于C++中的运算符重载语法，比如下面的代码定义了一个向量类，重载了向量的+ -运算：</p><pre><code>class Vector {  num x, y;  Vector(this.x, this.y);  Vector operator +(Vector v) =&gt; new Vector(x + v.x, y + v.y);  Vector operator -(Vector v) =&gt; new Vector(x - v.x, y - v.y);  printVec() {    print(&quot;x: $x, y: $y&quot;);  }}main() {  Vector v1 = new Vector(1, 2);  Vector v2 = new Vector(3, 4);  (v1 - v2).printVec(); // -2, -2  (v1 + v2).printVec(); // 4, 6}</code></pre><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>使用enum关键字定义一个枚举类，这个语法跟Java类似，如下代码：</p><pre><code>enum Color { red, green, blue }</code></pre><h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p>mixins是一个重复使用类中代码的方式，比如下面的代码：</p><pre><code>class A {  a() {    print(&quot;A&apos;s a()&quot;);  }}class B {  b() {    print(&quot;B&apos;s b()&quot;);  }}// 使用with关键字，表示类C是由类A和类B混合而构成class C = A with B;main() {  C c = new C();  c.a(); // A&apos;s a()  c.b(); // B&apos;s b()}</code></pre><p>Dart和Java一样只支持单继承。而且Dart中没有和Java一样提供Interface字段去声明一个接口。如果想使用和Java接口一样的功能可以使用Mixins和implements两种方式，分别解释下两种方式：</p><ul><li><strong>Mixins : 指能够将另一个或多个类的功能添加到您自己的类中，而无需继承这些类</strong></li><li><p><strong>implements : 将一个类作为接口使用</strong></p><pre><code>class A {  void a() {    print(&apos;a&apos;);  }}class B implements A {  @override  void a() {    print(&apos;override a&apos;);  }}class C {  void c() {    print(&apos;c&apos;);  }}class E {  String e = &apos;eeee&apos;;}class D extends A with C, E {  void c() {    print(&apos;c is D&apos;);  }  void d() {    c();  }}</code></pre></li></ul><p>首先看B implements A，所以此时A相对于B来说就是一个接口，所以他要实现B中的方法。换句话说，<strong>Dart每个类都是接口</strong></p><h4 id="静态成员变量和静态成员方法"><a href="#静态成员变量和静态成员方法" class="headerlink" title="静态成员变量和静态成员方法"></a>静态成员变量和静态成员方法</h4><pre><code>// 类的静态成员变量和静态成员方法class Cons {  static const name = &quot;zhangsan&quot;;  static sayHello() {    print(&quot;hello, this is ${Cons.name}&quot;);  }}main() {  Cons.sayHello(); // hello, this is zhangsan  print(Cons.name); // zhangsan}</code></pre><h3 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h3><p>Java和C++语言都有泛型，Dart语言也不例外，使用泛型有很多好处，比如：<br>正确指定泛型类型会产生更好的生成代码。<br>泛型可以减小代码的复杂度<br>Dart内置的数据类型List就是一个泛型数据类型，你可以往List中塞任何你想的数据类型比如整型、字符串、布尔值等</p><h3 id="Dart库（Libraries）"><a href="#Dart库（Libraries）" class="headerlink" title="Dart库（Libraries）"></a>Dart库（Libraries）</h3><p>Dart目前已经有很多的库提供给开发者，许多功能不需要开发者自己去实现，只需要导入对应的包即可，使用import语句来导入某个包，比如下面的代码：</p><pre><code>import &apos;dart:html&apos;;</code></pre><p>如果你想导入自己写的某个代码文件，使用相对路径即可，例如当前有一个demo.dart文件，跟该文件同级目录下有个util.dart文件，文件代码如下：</p><pre><code>// util.dart文件内容int add(int a, int b) {  return a + b;}</code></pre><p>在demo.dart文件中如果要引用util.dart文件，使用下面的方式导入：</p><pre><code>import &apos;./util.dart&apos;;main() {  print(add(1, 2));}</code></pre><p>你可以<strong>使用as关键字为导入的某个包设置一个前缀，或者说别名</strong>，比如下面的代码：</p><pre><code>import &apos;package:lib1/lib1.dart&apos;;import &apos;package:lib2/lib2.dart&apos; as lib2;// Uses Element from lib1.Element element1 = Element();// Uses Element from lib2.lib2.Element element2 = lib2.Element();</code></pre><p>你也可以在导入包时<strong>使用show hide关键字来导入某个包中的部分功能</strong>，比如下面的代码：</p><pre><code>// 只导入fooimport &apos;package:lib1/lib1.dart&apos; show foo;// 导入除了foo的所有其他部分import &apos;package:lib2/lib2.dart&apos; hide foo;</code></pre><p>导入包时使用<strong>deferred as可以让这个包懒加载</strong>，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如下面的代码：</p><pre><code>import &apos;package:greetings/hello.dart&apos; deferred as hello;</code></pre><p>利用<strong>library identifier（库标识符）声明库</strong>：</p><pre><code>// 声明库，名ballgamelibrary ballgame;// 导入html库import &apos;dart:html&apos;;// ...代码从这里开始... </code></pre><h4 id="关联文件与库"><a href="#关联文件与库" class="headerlink" title="关联文件与库"></a>关联文件与库</h4><p>添加实现文件，把<strong>part fileUri</strong>放在有库的文件，其中fileURI是实现文件的路径。然后在实现文件中，添加部分标识符（<strong>part of identifier</strong>），其中标识符是库的名称。下面的示例使用的一部分，在三个文件来实现部分库。</p><p>第一个文件，ballgame.dart，声明球赛库，导入其他需要的库，并指定ball.dart和util.dart是此库的部分：</p><pre><code>library ballgame;import &apos;dart:html&apos;;// ...其他导入在这里...part &apos;ball.dart&apos;;part &apos;util.dart&apos;;// ...代码从这里开始...</code></pre><p>第二、三个文件ball.dart、util.dart，实现了球赛库的一部分：</p><pre><code>part of ballgame;// ...代码从这里开始...</code></pre><h4 id="重新导出库-Re-exporting-libraries"><a href="#重新导出库-Re-exporting-libraries" class="headerlink" title="重新导出库(Re-exporting libraries)"></a>重新导出库(Re-exporting libraries)</h4><p>可以通过重新导出部分库或者全部库来组合或重新打包库。例如，你可能有实现为一组较小的库集成为一个较大库。或者你可以创建一个库，提供了从另一个库方法的子集:</p><pre><code>// In french.dart:library french;hello() =&gt; print(&apos;Bonjour!&apos;);goodbye() =&gt; print(&apos;Au Revoir!&apos;);// In togo.dart:library togo;import &apos;french.dart&apos;;export &apos;french.dart&apos; show hello;// In another .dart file:import &apos;togo.dart&apos;;void main() {    hello();   //print bonjour    goodbye(); //FAIL}</code></pre><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>Dart是单线程模型，也就没有了所谓的主线程/子线程之分。</p><p>Dart提供了类似ES7中的async await等异步操作，Dart库大多方法返回 Future 和 Stream 对象。这些方法是异步的：它们在设置一个可能的耗时操作（比如 I/O 操作）之后返回，而无需等待操作完成。</p><p>async和await往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成async，并给其中的耗时操作加上await关键字，如果这个方法有返回值，你需要将返回值塞到Future中并返回，如下代码所示：</p><pre><code>Future checkVersion() async {  var version = await lookUpVersion();  // Do something with version}</code></pre><p>下面的代码使用Dart从网络获取数据并打印出来：</p><pre><code>import &apos;dart:async&apos;;import &apos;package:http/http.dart&apos; as http;Future&lt;String&gt; getNetData() async{  http.Response res = await http.get(&quot;https://www.baidu.com&quot;);  return res.body;}main() {  getNetData().then((str) {    print(str);  });}</code></pre><h4 id="Even-Looper"><a href="#Even-Looper" class="headerlink" title="Even-Looper"></a>Even-Looper</h4><p>Dart是单线程模型，也就没有了所谓的主线程/子线程之分。<br>Dart也是Event-Looper以及Event-Queue的模型，所有的事件都是通过EventLooper的依次执行。而Dart的Event Loop就是：</p><ul><li>从EventQueue中获取Event</li><li>处理Event</li><li>直到EventQueue为空</li></ul><p><img src="/2019/06/25/dart-knowledge/event-loop.png" alt><br>而这些Event包括了用户输入，点击，Timer，文件IO等</p><h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>一旦某个Dart的函数开始执行，它将执行到这个函数结束，也就是<strong>Dart的函数不会被其他Dart代码打断</strong>。</p><p>Dart中没有线程的概念，只有isolate，每个isolate都是隔离的，并不会共享内存。而一个Dart程序是在Main isolate的main函数开始，而<strong>在Main函数结束后，Main isolate线程开始一个一个（one by one）的开始处理Event Queue中的每一个Event</strong>。</p><p><img src="/2019/06/25/dart-knowledge/event-loop-and-main.png" alt title="Main isolate"></p><h4 id="Event-Queue以及Microtask-Queue"><a href="#Event-Queue以及Microtask-Queue" class="headerlink" title="Event Queue以及Microtask Queue"></a>Event Queue以及Microtask Queue</h4><p>Dart中的Main Isolate只有一个Event Looper，但是存在两个Event Queue:Event Queue以及Microtask Queue。</p><p><strong><em>Microtask Queue存在的意义是：希望通过这个Queue来处理稍晚一些的事情，但是在下一个消息到来之前需要处理完的事情。</em></strong></p><p>当<strong>Event Looper正在处理Microtask Queue中的Event时候，Event Queue中的Event就停止了处理了</strong>，此时App不能绘制任何图形，不能处理任何鼠标点击，不能处理文件IO等等</p><p>Event-Looper挑选Task的执行顺序为：1.优先全部执行完Microtask Queue中的Event；2.直到Microtask Queue为空时，才会执行Event Queue中的Event：</p><p><img src="/2019/06/25/dart-knowledge/both-queues.png" alt title="both-queues"><br><strong>Dart中只能知道Event处理的先后顺序，但是并不知道某个Event执行的具体时间点，因为它的处理模型是一个单线程循环</strong>，而不是基于时钟调度（即它的执行只是按照Event处理完，就开始循环下一个Event，而与Java中的Thread调度不一样，没有时间调度的概念），也就是我们既是指定另一个Delay Time的Task，希望它在预期的时间后开始执行，它有可能不会在那个时间执行，需要看是否前面的Event是否已经Dequeue。</p><h4 id="异步任务调度"><a href="#异步任务调度" class="headerlink" title="异步任务调度"></a>异步任务调度</h4><p>当有代码可以在后续任务执行的时候，有两种方式，通过dart:async这个Lib中的API即可：</p><ul><li>使用Future类，可以将任务加入到Event Queue的队尾</li><li>使用scheduleMicrotask函数，将任务加入到Microtask Queue队尾</li></ul><p>当使用EventQueue时，需要考虑清楚，<strong>尽量避免microtask queue过于庞大，否则会阻塞其他事件的处理</strong>：</p><p><img src="/2019/06/25/dart-knowledge/scheduling-tasks.png" alt title="scheduling-tasks"></p><h4 id="使用Future"><a href="#使用Future" class="headerlink" title="使用Future"></a>使用Future</h4><p>一般常用的Future构造函数：</p><pre><code>new Future((){    //  doing something});</code></pre><p>而一般常用的还有当有分治任务时，需要将一个大任务拆成很多小任务一步步执行时，就需要使用到Future.then函数来拆解任务</p><pre><code>void main(){new Future(() =&gt; futureTask)  //  异步任务的函数        .then((m) =&gt; &quot;futueTask execute result:$m&quot;)  //   任务执行完后的子任务        .then((m) =&gt; m.length)  //  其中m为上个任务执行完后的返回的结果        .then((m) =&gt; printLength(m))        .whenComplete(() =&gt; whenTaskCompelete);  //  当所有任务完成后的回调函数}int futureTask() {    return 21; }void printLength(int length) {    print(&quot;Text Length:$length&quot;);}void whenTaskCompelete() {    print(&quot;Task Complete&quot;);}</code></pre><p>当任务需要延迟执行时，可以使用new Future.delay来将任务延迟执行，而如上所述，只有当Main isolate的Event Queue处于Idle的状态时，才会延迟1s执行，否则等待的时间会比1s长很多</p><pre><code>new Future.delayed(const Duration(seconds: 1), () =&gt; futureTask);</code></pre><p>当需要做动画的时候，不要使用Future，而需要使用<a href="https://api.dartlang.org/stable/1.24.3/dart-html/Window/animationFrame.html" target="_blank" rel="noopener">animateFrame</a></p><p>PS:</p><ul><li>Future中的then并没有创建新的Event丢到Event Queue中，而只是一个普通的Function Call，在FutureTask执行完后，立即开始执行</li><li>当Future在then函数之前已经执行完成了，则会创建一个task，将该task的添加到microtask queue中，并且该任务将会执行通过then传入的函数</li><li>Future只是创建了一个Event，将Event插入到了Event Queue的队尾</li><li>使用Future.value构造函数的时候，就会和第二条一样，创建Task丢到microtask Queue中执行then传入的函数</li><li>Future.sync构造函数执行了它传入的函数之后，也会立即创建Task丢到microtask Queue中执行</li></ul><h4 id="使用scheduleMicrotask"><a href="#使用scheduleMicrotask" class="headerlink" title="使用scheduleMicrotask"></a>使用scheduleMicrotask</h4><p>在最顶层的调用关系中，使用该函数即可：</p><pre><code>async.scheduleMicrotask(() =&gt; microtask());void microtask(){  //  doing something}</code></pre><h4 id="使用isolate以及Worker"><a href="#使用isolate以及Worker" class="headerlink" title="使用isolate以及Worker"></a>使用isolate以及Worker</h4><p>当有计算很繁重的任务时，则需要使用isolate或者Worker来执行，以保持App对用户操作的及时响应。Isolate的实现可能是一个单独的线程，或者一个单独的进程，需要看Dart VM是如何实现的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/06aebcad0543" target="_blank" rel="noopener">https://www.jianshu.com/p/06aebcad0543</a><br><a href="https://www.jianshu.com/p/9e5f4c81cc7d" target="_blank" rel="noopener">https://www.jianshu.com/p/9e5f4c81cc7d</a><br><a href="https://www.jianshu.com/p/a4affde4c8ca" target="_blank" rel="noopener">Flutter–Dart中的异步</a><br><a href="https://dart.dev/articles/archive/event-loop" target="_blank" rel="noopener">https://dart.dev/articles/archive/event-loop</a></p>]]></content>
      
      
      <categories>
          
          <category> Hybrid Develop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter知识点</title>
      <link href="/2019/06/25/flutter-knowledge/"/>
      <url>/2019/06/25/flutter-knowledge/</url>
      
        <content type="html"><![CDATA[<h2 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h2><p>在Flutter中，View相当于是Widget。<strong>Widget仅支持一帧</strong>，并且在每一帧上，Flutter的框架都会创建一个Widget实例树(相当于一次性绘制整个界面)。在Flutter中的widget是不可变的，这允许widget变得超级轻量。</p><h3 id="Widget状态"><a href="#Widget状态" class="headerlink" title="Widget状态"></a>Widget状态</h3><p>在Flutter中Widget是不可变的，不会直接更新，而必须使用Widget的状态。这是<strong>Stateful和Stateless widget</strong>的概念的来源。一个Stateless Widget就像它的名字，是一个没有状态信息的widget。</p><p>这里要注意的重要一点是无状态和有状态widget的核心特性是相同的。每一帧它们都会重新构建，不同之处在于<strong>StatefulWidget有一个State对象，它可以跨帧存储状态数据并恢复它</strong>。</p><p>如果你有疑问，那么要记住这个规则：<strong>如果一个widget发生了变化（例如用户与它交互），它就是有状态的。但是，如果一个子widget对变化做出反应，而其父widget对变化没有反应，那么包含的父widget仍然可以是无状态的widget。</strong></p><h3 id="Widget编写"><a href="#Widget编写" class="headerlink" title="Widget编写"></a>Widget编写</h3><p>在Android中，您通过XML编写布局，但在Flutter中，使用widget树来编写布局。<br>可以查看Flutter所提供的所有布局: <a href="https://flutterchina.club/widgets/layout/" target="_blank" rel="noopener">Flutter widget layout</a></p><p>在Android中，您可以从父级控件调用addChild或removeChild以动态添加或删除View。 在Flutter中，因为widget是不可变的，所以没有addChild。相反，您可以传入一个函数，该函数返回一个widget给父项，并通过布尔值控制该widget的创建。</p><p>在Flutter中，可以通过动画库给widget添加动画，将widget包装到Animation中。与Android相似，在Flutter中，您有一个AnimationController和一个Interpolator， 它是Animation类的扩展，例如CurvedAnimation。您将控制器和动画传递到AnimationWidget中，并告诉控制器启动动画。<br>See <a href="https://flutter.io/widgets/animation/" target="_blank" rel="noopener">https://flutter.io/widgets/animation/</a> and <a href="https://flutter.io/tutorials/animation" target="_blank" rel="noopener">https://flutter.io/tutorials/animation</a> for more specific details.</p><p>Flutter有两个类可以帮助您绘制画布，CustomPaint和CustomPainter，它们实现您的算法以绘制到画布。<br>在这个人气较高的的StackOverFlow答案中，您可以看到签名painter是如何实现的：请参阅<a href="https://stackoverflow.com/questions/46241071/create-signature-area-for-mobile-app-in-dart-flutter" target="_blank" rel="noopener">https://stackoverflow.com/questions/46241071/create-signature-area-for-mobile-app-in-dart-flutter</a></p><h3 id="如何构建自定义-Widgets"><a href="#如何构建自定义-Widgets" class="headerlink" title="如何构建自定义 Widgets"></a>如何构建自定义 Widgets</h3><p>在Flutter中，<strong>一个自定义widget通常是通过组合其它widget来实现的，而不是继承</strong>。</p><p>我们来看看如何构建持有一个label的CustomButton。这是通过将Text与RaisedButton组合来实现的，而不是扩展RaisedButton并重写其绘制方法实现：</p><pre><code>class CustomButton extends StatelessWidget {  final String label;  CustomButton(this.label);  @override  Widget build(BuildContext context) {    return new RaisedButton(onPressed: () {}, child: new Text(label));  }}</code></pre><h2 id="Intents"><a href="#Intents" class="headerlink" title="Intents"></a>Intents</h2><p>Flutter不具有Intents的概念，但如果需要的话，Flutter可以通过Native整合来触发Intents。</p><p>要在Flutter中切换屏幕，您可以访问路由以绘制新的Widget。 管理多个屏幕有两个核心概念和类：<strong>Route 和 Navigator</strong>。Route是应用程序的“屏幕”或“页面”的抽象（可以认为是Activity）， Navigator是管理Route的Widget。Navigator可以通过push和pop route以实现页面切换。</p><p>在Flutter中，可以将具有指定Route的Map传递到顶层MaterialApp实例</p><pre><code>void main() {  runApp(new MaterialApp(    home: new MyAppHome(), // becomes the route named &apos;/&apos;    routes: &lt;String, WidgetBuilder&gt; {      &apos;/a&apos;: (BuildContext context) =&gt; new MyPage(title: &apos;page A&apos;),      &apos;/b&apos;: (BuildContext context) =&gt; new MyPage(title: &apos;page B&apos;),      &apos;/c&apos;: (BuildContext context) =&gt; new MyPage(title: &apos;page C&apos;),    },  ));}</code></pre><p>然后，您可以通过Navigator来切换到命名路由的页面。</p><pre><code>Navigator.of(context).pushNamed(&apos;/b&apos;);</code></pre><p>Intents的另一个主要的用途是调用外部组件，如Camera或File picker。为此，您需要和native集成（或使用现有的库）</p><h3 id="处理外部传入的Intents"><a href="#处理外部传入的Intents" class="headerlink" title="处理外部传入的Intents"></a>处理外部传入的Intents</h3><p>Flutter可以通过直接与Android层通信并请求共享的数据来处理来自Android的Intents</p><p>在这个例子中，我们注册文本共享intent，所以其他应用程序可以共享文本到我们的Flutter应用程序</p><p>这个应用程序的基本流程是我们<strong>首先处理Android端的共享文本数据，然后等待Flutter请求数据，然后通过MethodChannel发送</strong>。</p><p>首先在在AndroidManifest.xml中注册我们想要处理的intent:</p><pre><code>&lt;activity       android:name=&quot;.MainActivity&quot;       android:launchMode=&quot;singleTop&quot;       android:theme=&quot;@style/LaunchTheme&quot;       android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection&quot;       android:hardwareAccelerated=&quot;true&quot;       android:windowSoftInputMode=&quot;adjustResize&quot;&gt;       &lt;!-- This keeps the window background of the activity showing            until Flutter renders its first frame. It can be removed if            there is no splash screen (such as the default splash screen            defined in @style/LaunchTheme). --&gt;       &lt;meta-data           android:name=&quot;io.flutter.app.android.SplashScreenUntilFirstFrame&quot;           android:value=&quot;true&quot; /&gt;       &lt;intent-filter&gt;           &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;           &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;       &lt;/intent-filter&gt;       &lt;intent-filter&gt;           &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;           &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;           &lt;data android:mimeType=&quot;text/plain&quot; /&gt;       &lt;/intent-filter&gt;   &lt;/activity&gt;</code></pre><p>然后，在MainActivity中处理intent，一旦我们从intent中获得共享文本数据，我们就会持有它，直到Flutter在完成准备就绪时请求它。</p><pre><code>public class MainActivity extends FlutterActivity {    String sharedText;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        GeneratedPluginRegistrant.registerWith(this);        Intent intent = getIntent();        String action = intent.getAction();        String type = intent.getType();        if (Intent.ACTION_SEND.equals(action) &amp;&amp; type != null) {            if (&quot;text/plain&quot;.equals(type)) {                handleSendText(intent); // Handle text being sent            }        }        new MethodChannel(getFlutterView(), &quot;app.channel.shared.data&quot;).setMethodCallHandler(new MethodChannel.MethodCallHandler() {            @Override            public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) {                if (methodCall.method.contentEquals(&quot;getSharedText&quot;)) {                    result.success(sharedText);                    sharedText = null;                }            }        });    }    void handleSendText(Intent intent) {        sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);    }}</code></pre><p>最后，在Flutter中，在渲染Flutter视图时请求数据：</p><pre><code>class _SampleAppPageState extends State&lt;SampleAppPage&gt; {  static const platform = const MethodChannel(&apos;app.channel.shared.data&apos;);  String dataShared = &quot;No data&quot;;  @override  void initState() {    super.initState();    getSharedText();  }  @override  Widget build(BuildContext context) {    return new Scaffold(body: new Center(child: new Text(dataShared)));  }  getSharedText() async {    var sharedData = await platform.invokeMethod(&quot;getSharedText&quot;);    if (sharedData != null) {      setState(() {        dataShared = sharedData;      });    }  }}</code></pre><h3 id="startActivityForResult-在Flutter中等价于什么"><a href="#startActivityForResult-在Flutter中等价于什么" class="headerlink" title="startActivityForResult 在Flutter中等价于什么"></a>startActivityForResult 在Flutter中等价于什么</h3><p>处理Flutter中所有路由的Navigator类可用于从已经push到栈的路由中获取结果。 这可以通过等待push返回的Future来完成。例如，如果您要启动让用户选择其位置的位置的路由，则可以执行以下操作：</p><pre><code>Map coordinates = await Navigator.of(context).pushNamed(&apos;/location&apos;);</code></pre><p>然后在你的位置路由中，一旦用户选择了他们的位置，你可以将结果”pop”出栈：</p><pre><code>Navigator.of(context).pop({&quot;lat&quot;:43.821757,&quot;long&quot;:-79.226392});</code></pre><h2 id="异步UI"><a href="#异步UI" class="headerlink" title="异步UI"></a>异步UI</h2><h3 id="runOnUiThread-在Flutter中等价于什么"><a href="#runOnUiThread-在Flutter中等价于什么" class="headerlink" title="runOnUiThread 在Flutter中等价于什么"></a>runOnUiThread 在Flutter中等价于什么</h3><p>Dart是单线程执行模型，<strong>支持Isolates（在另一个线程上运行Dart代码的方式）、事件循环和异步编程</strong>。 除非您启动一个Isolate，否则您的Dart代码将在主UI线程中运行，并由事件循环驱动（译者语：和JavaScript一样）。</p><h3 id="AsyncTask和IntentService在Flutter中等价于什么"><a href="#AsyncTask和IntentService在Flutter中等价于什么" class="headerlink" title="AsyncTask和IntentService在Flutter中等价于什么"></a>AsyncTask和IntentService在Flutter中等价于什么</h3><p>由于Flutter是单线程的，运行一个事件循环（如Node.js），所以您不必担心线程管理或者使用AsyncTasks、IntentServices。</p><p>要异步运行代码，可以将函数声明为异步函数，并在该函数中等待这个耗时任务</p><pre><code>loadData() async {  String dataURL = &quot;https://jsonplaceholder.typicode.com/posts&quot;;  http.Response response = await http.get(dataURL);  setState(() {    widgets = JSON.decode(response.body);  });}</code></pre><p>这就是典型的进行网络或数据库调用的方式</p><p>在Android上，当您继承AsyncTask时，通常会覆盖3个方法，OnPreExecute、doInBackground和onPostExecute。 在Flutter中没有这种模式的等价物，因为您只需等待一个长时间运行的函数，而Dart的事件循环将负责其余的事情。但是，有时您可能需要处理大量数据，导致UI可能会挂起。在这种情况下，与AsyncTask一样，在Flutter中，可以利用多个CPU内核来执行耗时或计算密集型任务。这是通过使用<strong>Isolates</strong>来完成的。</p><p>Isolate是一个独立的执行线程，它运行时不会与主线程共享任何内存。这意味着你不能从该线程访问变量或通过调用setState来更新你的UI。</p><h3 id="OkHttp在Flutter中等价于什么"><a href="#OkHttp在Flutter中等价于什么" class="headerlink" title="OkHttp在Flutter中等价于什么"></a>OkHttp在Flutter中等价于什么</h3><p>当使用受欢迎的“http”package时，Flutter进行网络信非常简单。</p><p>虽然<a href="https://pub.dartlang.org/packages/http" target="_blank" rel="noopener">“http” package </a>没有实现OkHttp的所有功能，但“http” package 抽象出了许多常用的API，可以简单有效的发起网络请求。</p><p>您可以通过在pubspec.yaml中添加依赖项来使用它</p><pre><code>dependencies:  ...  http: &apos;&gt;=0.11.3+12&apos;</code></pre><p>在Android中，当您执行耗时任务时，通常会显示进度指示器。在Flutter中，这可以通过渲染<strong>Progress Indicator widget</strong>来实现。您可以通过编程方式显示Progress Indicator ， 通过布尔值通知Flutter在耗时任务发起之前更新其状态。</p><h2 id="项目结构和资源"><a href="#项目结构和资源" class="headerlink" title="项目结构和资源"></a>项目结构和资源</h2><h3 id="在哪里存储分辨率相关的图片文件-HDPI-XXHDPI"><a href="#在哪里存储分辨率相关的图片文件-HDPI-XXHDPI" class="headerlink" title="在哪里存储分辨率相关的图片文件? HDPI/XXHDPI"></a>在哪里存储分辨率相关的图片文件? HDPI/XXHDPI</h3><p>Flutter遵循像iOS这样简单的3种分辨率格式: 1x, 2x, and 3x.</p><p>创建一个名为images的文件夹，并为每个图像文件生成一个@2x和@3x文件，并将它们放置在如下这样的文件夹中:</p><pre><code>…/my_icon.png…/2.0x/my_icon.png…/3.0x/my_icon.png</code></pre><p>然后，您需要在pubspec.yaml文件中声明这些图片:</p><pre><code>assets: - images/a_dot_burr.jpeg - images/a_dot_ham.jpeg</code></pre><p>然后您可以使用AssetImage访问您的图像</p><pre><code>return new AssetImage(&quot;images/a_dot_burr.jpeg&quot;);</code></pre><h3 id="在哪里存储字符串-如何存储不同的语言"><a href="#在哪里存储字符串-如何存储不同的语言" class="headerlink" title="在哪里存储字符串? 如何存储不同的语言"></a>在哪里存储字符串? 如何存储不同的语言</h3><p>目前，最好的做法是创建一个名为Strings的类</p><pre><code>class Strings{  static String welcomeMessage = &quot;Welcome To Flutter&quot;;}</code></pre><p>然后在你的代码中，你可以像访问你的字符串一样：</p><pre><code>new Text(Strings.welcomeMessage)</code></pre><p>Flutter对Android的可访问性提供了基本的支持，虽然这个功能正在进行中。</p><p>鼓励Flutter开发者使用<a href="https://pub.dev/packages/intl" target="_blank" rel="noopener">intl package</a>进行国际化和本地化</p><h3 id="Android-Gradle-vs-Flutter-pubspec-yaml"><a href="#Android-Gradle-vs-Flutter-pubspec-yaml" class="headerlink" title="Android Gradle vs Flutter pubspec.yaml"></a>Android Gradle vs Flutter pubspec.yaml</h3><p>在Android中，您可以在Gradle文件来添加依赖项。</p><p>在Flutter中，虽然在Flutter项目中的Android文件夹下有Gradle文件，但只有在添加平台相关所需的依赖关系时才使用这些文件。 否则，应该使用pubspec.yaml声明用于Flutter的外部依赖项。</p><p>发现好的flutter packages的一个好地方 <a href="https://pub.dartlang.org/flutter/packages/" target="_blank" rel="noopener">Pub</a></p><h2 id="Activities-和-Fragments"><a href="#Activities-和-Fragments" class="headerlink" title="Activities 和 Fragments"></a>Activities 和 Fragments</h2><p>在Flutter中，这两个概念都等同于Widget。</p><h3 id="如何监听Android-Activity生命周期事件"><a href="#如何监听Android-Activity生命周期事件" class="headerlink" title="如何监听Android Activity生命周期事件"></a>如何监听Android Activity生命周期事件</h3><p>在Android中，您可以覆盖Activity的方法来捕获Activity的生命周期回调。</p><p>在Flutter中您可以通过<strong>挂接到WidgetsBinding观察并监听didChangeAppLifecycleState更改事件来监听</strong>生命周期事件</p><p>您可以监听到的生命周期事件是</p><ul><li>resumed - 应用程序可见并响应用户输入。这是来自Android的onResume</li><li>inactive - 应用程序处于非活动状态，并且未接收用户输入。此事件在Android上未使用，仅适用于iOS</li><li>paused - 应用程序当前对用户不可见，不响应用户输入，并在后台运行。这是来自Android的暂停</li><li><p>suspending - 该应用程序将暂时中止。这在iOS上未使用</p><p>  class _LifecycleWatcherState extends State<lifecyclewatcher> with WidgetsBindingObserver {</lifecyclewatcher></p><pre><code>AppLifecycleState _lastLifecyleState;@overridevoid initState() {  super.initState();  WidgetsBinding.instance.addObserver(this);}@overridevoid dispose() {  WidgetsBinding.instance.removeObserver(this);  super.dispose();}@overridevoid didChangeAppLifecycleState(AppLifecycleState state) {  setState(() {    _lastLifecyleState = state;  });}@overrideWidget build(BuildContext context) {  if (_lastLifecyleState == null)    return new Text(&apos;This widget has not observed any lifecycle changes.&apos;, textDirection: TextDirection.ltr);  return new Text(&apos;The most recent lifecycle state this widget observed was: $_lastLifecyleState.&apos;,      textDirection: TextDirection.ltr);}</code></pre><p>  }</p></li></ul><h2 id="Layouts"><a href="#Layouts" class="headerlink" title="Layouts"></a>Layouts</h2><h3 id="LinearLayout在Flutter中相当于什么"><a href="#LinearLayout在Flutter中相当于什么" class="headerlink" title="LinearLayout在Flutter中相当于什么"></a>LinearLayout在Flutter中相当于什么</h3><p>在Android中，使用LinearLayout来使您的控件呈水平或垂直排列。在Flutter中，您可以使用Row或Co​​lumn来实现相同的结果:</p><pre><code>@overrideWidget build(BuildContext context) {  return new Row(    mainAxisAlignment: MainAxisAlignment.center,    children: &lt;Widget&gt;[      new Text(&apos;Row One&apos;),      new Text(&apos;Row Two&apos;),      new Text(&apos;Row Three&apos;),      new Text(&apos;Row Four&apos;),    ],  );}</code></pre><h3 id="RelativeLayout在Flutter中等价于什么"><a href="#RelativeLayout在Flutter中等价于什么" class="headerlink" title="RelativeLayout在Flutter中等价于什么"></a>RelativeLayout在Flutter中等价于什么</h3><p>RelativeLayout用于使widget相对于彼此位置排列。在Flutter中，有几种方法可以实现相同的结果</p><p>您可以通过使用Column、Row和Stack的组合来实现RelativeLayout的效果。您可以为widget构造函数指定相对于父组件的布局规则。</p><p>一个在Flutter中构建RelativeLayout的好例子，请参考在StackOverflow上: <a href="https://stackoverflow.com/questions/44396075/equivalent-of-relativelayout-in" target="_blank" rel="noopener">https://stackoverflow.com/questions/44396075/equivalent-of-relativelayout-in</a> -flutter</p><h3 id="ScrollView在Flutter中等价于什么"><a href="#ScrollView在Flutter中等价于什么" class="headerlink" title="ScrollView在Flutter中等价于什么"></a>ScrollView在Flutter中等价于什么</h3><p>在Android中，ScrollView允许您包含一个子控件，以便在用户设备的屏幕比控件内容小的情况下，使它们可以滚动。</p><p>在Flutter中，最简单的方法是使用ListView。但<strong>在Flutter中，一个ListView既是一个ScrollView，也是一个Android ListView</strong>。</p><h2 id="手势检测和触摸事件处理"><a href="#手势检测和触摸事件处理" class="headerlink" title="手势检测和触摸事件处理"></a>手势检测和触摸事件处理</h2><h3 id="如何将一个onClick监听器添加到Flutter中的widget"><a href="#如何将一个onClick监听器添加到Flutter中的widget" class="headerlink" title="如何将一个onClick监听器添加到Flutter中的widget"></a>如何将一个onClick监听器添加到Flutter中的widget</h3><p>在Flutter中，添加触摸监听器有两种方法:</p><ol><li><p>如果Widget支持事件监听，则可以将一个函数传递给它并进行处理。例如，RaisedButton有一个onPressed参数:</p><pre><code>@overrideWidget build(BuildContext context) {  return new RaisedButton(      onPressed: () {        print(&quot;click&quot;);      },      child: new Text(&quot;Button&quot;));}</code></pre></li><li><p>如果Widget不支持事件监听，则可以将该Widget包装到GestureDetector中，并将处理函数传递给onTap参数:</p><pre><code>class SampleApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return new Scaffold(        body: new Center(      child: new GestureDetector(        child: new FlutterLogo(          size: 200.0,        ),        onTap: () {          print(&quot;tap&quot;);        },      ),    ));  }}</code></pre></li></ol><h3 id="如何处理widget上的其他手势"><a href="#如何处理widget上的其他手势" class="headerlink" title="如何处理widget上的其他手势"></a>如何处理widget上的其他手势</h3><p>使用GestureDetector，可以监听多种手势，例如:</p><p>Tap</p><blockquote><p>onTapDown<br>onTapUp<br>onTap<br>onTapCancel</p></blockquote><p>Double tap</p><blockquote><p>onDoubleTap 用户快速连续两次在同一位置轻敲屏幕.</p></blockquote><p>长按</p><blockquote><p>onLongPress</p></blockquote><p>垂直拖动</p><blockquote><p>onVerticalDragStart<br>onVerticalDragUpdate<br>onVerticalDragEnd</p></blockquote><p>水平拖拽</p><blockquote><p>onHorizontalDragStart<br>onHorizontalDragUpdate<br>onHorizontalDragEnd</p></blockquote><h2 id="Listview-amp-Adapter"><a href="#Listview-amp-Adapter" class="headerlink" title="Listview &amp; Adapter"></a>Listview &amp; Adapter</h2><h3 id="ListView在Flutter中相当于什么"><a href="#ListView在Flutter中相当于什么" class="headerlink" title="ListView在Flutter中相当于什么"></a>ListView在Flutter中相当于什么</h3><p>在Flutter中，ListView就是一个ListView！</p><p>在Android ListView中，您可以创建一个适配器，然后您可以将它传递给ListView，该适配器将使用适配器返回的内容来展示每一行。 然而，你必须确保在合适的时机回收行，否则，你会得到各种疯狂的视觉和内存问题。</p><p>在Flutter中，由于Flutter的不可变的widget模型，将一个Widgets列表传递给的ListView，而Flutter将负责确保它们快速平滑地滚动。</p><h3 id="怎么知道哪个列表项被点击"><a href="#怎么知道哪个列表项被点击" class="headerlink" title="怎么知道哪个列表项被点击"></a>怎么知道哪个列表项被点击</h3><p>在Android中，ListView有一个方法’onItemClickListener’来确定哪个列表项被点击。 Flutter中可以更轻松地通过您传入的处理回调来进行操作：</p><pre><code>_getListData() {   List&lt;Widget&gt; widgets = [];   for (int i = 0; i &lt; 100; i++) {     widgets.add(new GestureDetector(       child: new Padding(           padding: new EdgeInsets.all(10.0),           child: new Text(&quot;Row $i&quot;)),       onTap: () {         print(&apos;row tapped&apos;);       },     ));   }   return widgets; }</code></pre><h3 id="如何动态更新ListView"><a href="#如何动态更新ListView" class="headerlink" title="如何动态更新ListView"></a>如何动态更新ListView</h3><p>需要更新适配器并调用notifyDataSetChanged。在Flutter中，如果setState（）中更新widget列表，您会发现没有变化， 这是因为当setState被调用时，Flutter渲染引擎会遍历所有的widget以查看它们是否已经改变。 当遍历到你的ListView时，它会做一个==运算，以查看两个ListView是否相同，因为没有任何改变，因此没有更新数据。</p><p>要更新您的ListView，然后在setState中创建一个新的List（）并将所有旧数据复制到新列表中。这是实现更新的简单方法（译者语：此时状态改变，ListView被<strong>重新构建</strong>）</p><p>然而，<strong>推荐的方法是使用ListView.Builder</strong>。当您拥有动态列表或包含大量数据的列表时，此方法非常有用。 这实际上相当于在Android上使用RecyclerView，它会自动为您回收列表元素：</p><pre><code>@override Widget build(BuildContext context) {   return new Scaffold(       appBar: new AppBar(         title: new Text(&quot;Sample App&quot;),       ),       body: new ListView.builder(           itemCount: widgets.length,           itemBuilder: (BuildContext context, int position) {             return getRow(position);           })); }Widget getRow(int i) {   return new GestureDetector(     child: new Padding(         padding: new EdgeInsets.all(10.0),         child: new Text(&quot;Row $i&quot;)),     onTap: () {       setState(() {         widgets.add(getRow(widgets.length + 1));         print(&apos;row $i&apos;);       });     },   ); }</code></pre><p>我们不是创建一个“新的ListView”，而是创建一个新的ListView.builder，它接受两个参数，即列表的初始长度和一个ItemBuilder函数。ItemBuilder函数非常类似于Android适配器中的getView函数，它需要一个位置并返回要为该位置渲染的行。</p><p>最后，但最重要的是，如果您注意到onTap函数，在里面，我们不会再重新创建列表，而只是添加新元素到列表。</p><h2 id="使用-Text"><a href="#使用-Text" class="headerlink" title="使用 Text"></a>使用 Text</h2><h3 id="如何在-Text-widget上设置自定义字体"><a href="#如何在-Text-widget上设置自定义字体" class="headerlink" title="如何在 Text widget上设置自定义字体"></a>如何在 Text widget上设置自定义字体</h3><p>在Android SDK（从Android O开始）中，创建一个Font资源文件并将其传递到TextView的FontFamily参数中。</p><p>在Flutter中，首先你需要把你的字体文件放在项目文件夹中（最好的做法是创建一个名为assets的文件夹）</p><p>接下来在pubspec.yaml文件中，声明字体：</p><pre><code>fonts:   - family: MyCustomFont     fonts:       - asset: fonts/MyCustomFont.ttf       - style: italic</code></pre><p>最后，将字体应用到Text widget:</p><pre><code>@overrideWidget build(BuildContext context) {  return new Scaffold(    appBar: new AppBar(      title: new Text(&quot;Sample App&quot;),    ),    body: new Center(      child: new Text(        &apos;This is a custom font text&apos;,        style: new TextStyle(fontFamily: &apos;MyCustomFont&apos;),      ),    ),  );}</code></pre><h3 id="如何在Text上定义样式"><a href="#如何在Text上定义样式" class="headerlink" title="如何在Text上定义样式"></a>如何在Text上定义样式</h3><p>Text的样式参数需要一个TextStyle对象，您可以在其中自定义许多参数。</p><h2 id="表单输入"><a href="#表单输入" class="headerlink" title="表单输入"></a>表单输入</h2><h3 id="Input的”hint”在flutter中相当于什么"><a href="#Input的”hint”在flutter中相当于什么" class="headerlink" title="Input的”hint”在flutter中相当于什么"></a>Input的”hint”在flutter中相当于什么</h3><p>在Flutter中，您可以通过向Text Widget的装饰构造函数参数添加<strong>InputDecoration对象</strong>，轻松地为输入框显示占位符文本</p><pre><code>body: new Center(  child: new TextField(    decoration: new InputDecoration(hintText: &quot;This is a hint&quot;),  ))</code></pre><h3 id="如何显示验证错误"><a href="#如何显示验证错误" class="headerlink" title="如何显示验证错误"></a>如何显示验证错误</h3><p>就像您如何使用“hint”一样，您可以将InputDecoration对象传递给Text的装饰构造函数。</p><p>但是，您不希望首先显示错误，并且通常会在用户输入一些无效数据时显示该错误。这可以通过更新状态并传递一个新的InputDecoration对象来完成：</p><pre><code>class _SampleAppPageState extends State&lt;SampleAppPage&gt; {  String _errorText;  @override  Widget build(BuildContext context) {    return new Scaffold(      appBar: new AppBar(        title: new Text(&quot;Sample App&quot;),      ),      body: new Center(        child: new TextField(          onSubmitted: (String text) {            setState(() {              if (!isEmail(text)) {                _errorText = &apos;Error: This is not an email&apos;;              } else {                _errorText = null;              }            });          },          decoration: new InputDecoration(hintText: &quot;This is a hint&quot;, errorText: _getErrorText()),        ),      ),    );  }  _getErrorText() {    return _errorText;  }  bool isEmail(String em) {    String emailRegexp =        r&apos;^(([^&lt;&gt;()[\]\\.,;:\s@\&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@\&quot;]+)*)|(\&quot;.+\&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$&apos;;    RegExp regExp = new RegExp(p);    return regExp.hasMatch(em);  }}</code></pre><h2 id="Flutter-插件"><a href="#Flutter-插件" class="headerlink" title="Flutter 插件"></a>Flutter 插件</h2><p>如何使用 GPS sensor<br>要访问GPS传感器，您可以使用社区插件 <a href="https://pub.dartlang.org/packages/location" target="_blank" rel="noopener">https://pub.dartlang.org/packages/location</a></p><p>如何访问相机<br>访问相机的流行社区插件是 <a href="https://pub.dartlang.org/packages/image_picker" target="_blank" rel="noopener">https://pub.dartlang.org/packages/image_picker</a></p><p>如何使用Facebook登陆<br>要访问Facebook Connect功能，您可以使用 <a href="https://pub.dartlang.org/packages/flutter_facebook_connect" target="_blank" rel="noopener">https://pub.dartlang.org/packages/flutter_facebook_connect</a> .</p><p>如何构建自定义集成Native功能<br>如果有Flutter或其社区插件缺失的平台特定功能，那么您可以自己按照以下教程构建<a href="https://flutterchina.club/developing-packages/" target="_blank" rel="noopener">https://flutterchina.club/developing-packages/</a><br>简而言之，Flutter的插件架构就像在Android中使用Event bus一样：您可以发出消息并让接收者进行处理并将结果返回给您，在这种情况下，接收者将是iOS或Android。</p><p>如何在我的Flutter应用程序中使用NDK<br>自定义插件首先会与Android应用程序通信，您可以在其中调用native标记的函数。一旦Native完成了相应操作，就可以将响应消息发回给Flutter并呈现结果。</p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Flutter很好的实现了一个美丽的Material Design，它会满足很多样式和主题的需求。 与Android中使用XML声明主题不同，在Flutter中，您可以<strong>通过顶层widget声明主题</strong>。</p><p>MaterialApp是一个方便的widget，它包装了许多Material Design应用通常需要的widget，它通过添加Material特定功能构建在WidgetsApp上。</p><p>如果你不想使用Material Components，那么你可以声明一个顶级widget-WidgetsApp，它是一个便利的类，它包装了许多应用程序通常需要的widget。</p><p>要自定义Material Components的颜色和样式，您可以将ThemeData对象传递到MaterialApp widget中，例如在下面的代码中，您可以看到主色板设置为蓝色，并且所有选择区域的文本颜色都应为红色。</p><pre><code>class SampleApp extends StatelessWidget {  @override  Widget build(BuildContext context) {    return new MaterialApp(      title: &apos;Sample App&apos;,      theme: new ThemeData(        primarySwatch: Colors.blue,        textSelectionColor: Colors.red      ),      home: new SampleAppPage(),    );  }}</code></pre><p>Scaffold 是 Material library 中提供的一个widget, 它提供了默认的导航栏、标题和包含主屏幕widget树的body属性。widget树可以很复杂。</p><h2 id="数据库和本地存储"><a href="#数据库和本地存储" class="headerlink" title="数据库和本地存储"></a>数据库和本地存储</h2><h3 id="如何在Flutter中访问Shared-Preferences"><a href="#如何在Flutter中访问Shared-Preferences" class="headerlink" title="如何在Flutter中访问Shared Preferences ?"></a>如何在Flutter中访问Shared Preferences ?</h3><p>在Flutter中，您可以通过使用插件Shared_Preferences来访问此功能</p><p>这个插件包装了<a href="https://pub.dartlang.org/packages/shared_preferences" target="_blank" rel="noopener">Shared Preferences</a>和NSUserDefaults（与iOS相同）的功能</p><pre><code>import &apos;package:flutter/material.dart&apos;;import &apos;package:shared_preferences/shared_preferences.dart&apos;;void main() {  runApp(    new MaterialApp(      home: new Scaffold(        body: new Center(          child: new RaisedButton(            onPressed: _incrementCounter,            child: new Text(&apos;Increment Counter&apos;),          ),        ),      ),    ),  );}_incrementCounter() async {  SharedPreferences prefs = await SharedPreferences.getInstance();  int counter = (prefs.getInt(&apos;counter&apos;) ?? 0) + 1;  print(&apos;Pressed $counter times.&apos;);  prefs.setInt(&apos;counter&apos;, counter);}</code></pre><h3 id="如何在Flutter中访问SQLite"><a href="#如何在Flutter中访问SQLite" class="headerlink" title="如何在Flutter中访问SQLite"></a>如何在Flutter中访问SQLite</h3><p>在Android中，您可以使用SQLite存储，通过SQL查询的结构化数据。</p><p>在Flutter中，您可以使用<a href="https://pub.dartlang.org/packages/sqflite" target="_blank" rel="noopener">SQFlite插件</a>来访问SQFlite此功能</p><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>在Android中，您可以使用Firebase云消息传递为您的应用设置推送通知。</p><p>在Flutter中，您可以使用<a href="https://github.com/flutter/plugins/tree/master/packages/firebase_messaging" target="_blank" rel="noopener">Firebase_Messaging</a>插件访问此功能</p><blockquote><p>注意：在中国无法使用Firebase服务。</p></blockquote><h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>YAML是一个类似 XML的标记语言。YAML强调以数据为中心，并不是以标识语言为重点</p><p>规范：</p><ul><li>大小写敏感</li><li>缩进代表层级，使用空格，默认2个空格（flutter工具做了处理，tab也可以）</li><li>#表示注释内容</li><li>: 表示键值对，注意后面要空格</li><li>{} 表示键值表</li><li>表示列表，注意后面要空格</li><li>[] 表示数组，注意每项之间有空格</li><li><p>? 表示复杂的键</p><pre><code># 依赖库dependencies:  flutter:    sdk: flutter  cupertino_icons: ^0.1.2flutter:  #使用Material图标  uses-material-design: true  #assets文件  assets:    - images/1.png    - images/2.gif  #字体样式  fonts:     #family与fonts是一个整体，列表的一项     - family: Schyler       fonts:         - asset: fonts/Schyler-Regular.ttf         - asset: fonts/Schyler-Italic.ttf           style: italic     - family: Trajan Pro       fonts:         - asset: fonts/TrajanPro.ttf         - asset: fonts/TrajanPro_Bold.ttf           weight: 700</code></pre></li></ul><p>-可转化为[]，:也可以转化为{}，转化后类似json</p><pre><code>dependencies: {flutter: {sdk: flutter}, cupertino_icons: ^0.1.2}assets: [images/1.png, images/2.gif]</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://flutterchina.club/flutter-for-android" target="_blank" rel="noopener">Flutter for Android 开发者</a></p>]]></content>
      
      
      <categories>
          
          <category> Hybrid Develop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux概念</title>
      <link href="/2019/06/25/hybird-redux/"/>
      <url>/2019/06/25/hybird-redux/</url>
      
        <content type="html"><![CDATA[<p>Redux是一个状态管理器。</p><p>Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers）。</p><h3 id="Redux核心概念"><a href="#Redux核心概念" class="headerlink" title="Redux核心概念"></a>Redux核心概念</h3><ul><li>actions</li><li>store</li><li>reducers</li></ul><p><img src="/2019/06/25/hybird-redux/redux.jpg" alt></p><p><strong>Actions</strong><br>简单地，<strong>Actions就是事件。Actions传递来自这个应用（用户接口，内部事件比如API调用和表单提交）的数据给store。store只获取来自Actions的信息</strong>。内部Actions就是简单的具有一个type属性（通常是常量）的JavaScript对象，这个对象描述了action的类型以及传递给store的负载信息:</p><pre><code>{    type: LOGIN_FORM_SUBMIT,    payload: {username: &apos;alex&apos;, password: &apos;123456&apos;}}</code></pre><p><strong>Reducers</strong><br>在函数式JavaScript中reducer基于数组reduce方法，接收一个回调（reducer）让你从多个值中获得单个值，整数和，或者一个一系列值的累积。在Redux中，<strong>reducer就是获得这个应用的当前状态和事件然后返回一个新状态的函数</strong>。理解reducer是怎样工作的至关重要，因为它们完成大部分工作。这是一个非常简单的reducer，通过获取当前state和一个action作为参数，再返回下一个state：</p><pre><code>function handleAuth(state, action) {    return _.assign({}, state, {        auth: action.payload      });}</code></pre><p>对于更多复杂的项目，使用Redux提供的combineReducers()实例是必要的（推荐）。它把在这个应用中所有的reducer结合在一起成为单个索引reducer。每一个reducer负责它自己那部分应用的状态，这个状态参数和其他reducer的不一样。<strong>combineReducers()实例使文件结构更容易维护</strong>。<br>如果一个对象（state）只改变一些值，Redux就创建一个新的对象，那些没有改变的值将会指向旧的对象而且新的值将会被创建。这对性能是极好的。为了让它更有效率你可以添加 Immutable.js</p><pre><code>const rootReducer = combineReducers({    handleAuth: handleAuth,    editProfile: editProfile,    changePassword: changePassword});</code></pre><p><strong>Store</strong><br>Store对象<strong>保存应用的状态并提供一些帮助方法来存取状态，分发状态以及注册监听。全部state由一个store来表示</strong>。任何action通过reducer返回一个新的状态对象。这就使得Redux非常简单以及可预测。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5d04790a6fb9a07efa09164d" target="_blank" rel="noopener">完全理解 redux（从零实现一个 redux）</a></p>]]></content>
      
      
      <categories>
          
          <category> Hybrid Develop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android IBinder机制</title>
      <link href="/2019/05/30/android-binder/"/>
      <url>/2019/05/30/android-binder/</url>
      
        <content type="html"><![CDATA[<p>Android系统Binder机制中的四个组件Client、Server、Service Manager和Binder驱动程序的关系如下图所示：</p><p><img src="/2019/05/30/android-binder/binder.jpg" alt></p><ol><li><p>Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中</p></li><li><p>Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server</p></li><li><p>Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信</p></li><li><p>Client和Server之间的进程间通信通过Binder驱动程序间接实现</p></li><li><p>Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力</p></li></ol><h3 id="Android-整体架构"><a href="#Android-整体架构" class="headerlink" title="Android 整体架构"></a>Android 整体架构</h3><p>我们先来大概看下 Android 这座大山的整体轮廓。我们先从 Android 的整体架构来看看 Binder 是处于什么地位，这张图引自 Android 项目开源网站：<a href="https://source.android.com：" target="_blank" rel="noopener">https://source.android.com：</a></p><p><img src="/2019/05/30/android-binder/android-system.webp" alt></p><p>从下往上依次为</p><ul><li>内核层：Linux 内核和各类硬件设备的驱动，这里需要注意的是，Binder IPC 驱动也是在这一层实现，比较特殊</li><li>硬件抽象层：封装「内核层」硬件驱动，提供可供「系统服务层」调用的统一硬件接口</li><li>系统服务层：提供核心服务，并且提供可供「应用程序框架层」调用的接口</li><li>Binder IPC 层：作为「系统服务层」与「应用程序框架层」的 IPC 桥梁，互相传递接口调用的数据，实现跨进层的通讯</li><li>应用程序框架层：这一层可以理解为 Android SDK，提供四大组件，View 绘制体系等平时开发中用到的基础部件</li></ul><p>在一个大的项目里面，<strong>分层</strong>是非常重要的，处于最底层的接口最具有「通用性」，接口粒度最细，越往上层通用性降低。理论上来说上面的每一层都可以「开放」给开发者调用，例如开发者可以直接调用硬件抽象层的接口去操作硬件，或者直接调用系统服务层中的接口去直接操作系统服务，甚至是像 Windows 开发一样，开发者可以在内核层写程序，运行在内核中。不过开放带来的问题就是开发者权利太大，对于系统的稳定性是没有任何好处的，一个病毒制作者写了一个内核层的病毒，系统也许永远也起不来了。所以谷歌的做法是将开发者的权利收拢到了「应用程序框架层」，开发者只能调用这一层提供的接口。</p><p>上面的层次中，内核层与硬件抽象层均用 C/C++ 实现，系统服务层是以 Java 实现，硬件抽象层编译为 so 文件，以 JNI 的形式供系统服务层使用。系统服务层中的服务随系统的启动而启动，只要不关机，就会一直运行。这些服务干什么事情呢？其实很简单，就是完成一个手机该有的核心功能如短信的收发管理、电话的接听、挂断以及应用程序的包管理、Activity 的管理等等。每一个服务均运行在一个独立进程中，因为是以 Java 实现，所以本质上来说就是运行在一个独立进程的 Dalvik 虚拟机中。问题就来了，开发者的 APP 运行在一个新的进程空间，如何调用到系统服务层中的接口呢？答案是 IPC（Inter-Process Communication），进程间通讯，缩写与 RPC（Remote Procedure Call）是不一样的，实现原理也是不一样的。每一个系统服务在应用层序框架层都有一个 Manager 与之对应，方便开发者调用其相关的功能，具体关系大致如下</p><p><img src="/2019/05/30/android-binder/ipc.webp" alt></p><p>IPC 的方式有很多种，例如 socket、共享内存、管道、消息队列等等，我们就不去深究为何要使用 Binder 而不使用其他方式去做，到目前为止，这座大山的面目算是有个大概的轮廓了。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><strong>Android 从下而上分了内核层、硬件抽象层、系统服务层、Binder IPC 层、应用程序框架层</strong></li><li><strong>Android 中「应用程序框架层」以 SDK 的形式开放给开发者使用，「系统服务层」中的核心服务随系统启动而运行，通过应用层序框架层提供的 Manager 实时为应用程序提供服务调用。系统服务层中每一个服务运行在自己独立的进程空间中，应用程序框架层中的 Manager 通过 Binder IPC 的方式调用系统服务层中的服务。</strong></li></ul><h3 id="Binder-IPC-的架构"><a href="#Binder-IPC-的架构" class="headerlink" title="Binder IPC 的架构"></a>Binder IPC 的架构</h3><p>下面我们就来看看 Binder IPC 的架构是怎样的</p><p><img src="/2019/05/30/android-binder/ipc-binder.webp" alt></p><p>Binder IPC 属于 C/S 结构，Client 部分是用户代码，用户代码最终会调用 Binder Driver 的 transact 接口，Binder Driver 会调用 Server，这里的 Server 与 service 不同，可以理解为 Service 中 onBind 返回的 Binder 对象，请注意区分下:</p><ul><li>Client：用户需要实现的代码，如 AIDL 自动生成的接口类</li><li>Binder Driver：在内核层实现的 Driver</li><li>Server：这个 Server 就是 Service 中 onBind 返回的 IBinder 对象</li></ul><p>需要注意的是，上面绿色的色块部分都是属于用户需要实现的部分，而蓝色部分是系统去实现了。也就是说 Binder Driver 这块并不需要知道，Server 中会开启一个线程池去处理客户端调用。为什么要用线程池而不是一个单线程队列呢？试想一下，如果用单线程队列，则会有任务积压，多个客户端同时调用一个服务的时候就会有来不及响应的情况发生，这是绝对不允许的。</p><p>对于调用 Binder Driver 中的 transact 接口，客户端可以手动调用，也可以通过 AIDL 的方式生成的代理类来调用，服务端可以继承 Binder 对象，也可以继承 AIDL 生成的接口类的 Stub 对象。</p><p>切记，这里 Server 的实现是线程池的方式，而不是单线程队列的方式，区别在于，单线程队列的话，Server 的代码是线程安全的，线程池的话，Server 的代码则不是线程安全的，需要开发者自己做好多线程同步。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li><strong>Binder IPC 属于 C/S 架构，包括 Client、Driver、Server 三个部分</strong></li><li><strong>Client 可以手动调用 Driver 的 transact 接口，也可以通过 AIDL 生成的 Proxy 调用</strong></li><li><strong>Server 中会启动一个「线程池」来处理 Client 的调用请求，处理完成后将结果返回给 Driver，Driver 再返回给 Client</strong></li></ul><p>这里就回答了两个问题：Service 中通过 AIDL 提供的接口并不是线程安全的，同理 ContentProvider 底层也是使用 Binder，同样不是线程安全的，至于是否需要做多线程保护，看业务而定，最好是做好多线程同步，以防万一。</p><h3 id="使用-AIDL-实现-Binder-IPC"><a href="#使用-AIDL-实现-Binder-IPC" class="headerlink" title="使用 AIDL 实现 Binder IPC"></a>使用 AIDL 实现 Binder IPC</h3><p>Android 给了我们更好用的方式那就是 AIDL，假如我们要做一个上报数据的功能，运行在 Service 中，在后台上报数据，接口定义如下</p><h4 id="IReporter-aidl"><a href="#IReporter-aidl" class="headerlink" title="IReporter.aidl"></a>IReporter.aidl</h4><pre><code>package com.android.binder;interface IReporter {    int report(String values, int type);}</code></pre><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>AidlService.java</p><pre><code>public class AidlService extends Service {    public static final class Reporter extends IReporter.Stub {        @Override        public int report(String values, int type) throws RemoteException {            return type;        }    }    private Reporter mReporter;    public AidlService() {        mReporter = new Reporter();    }    @Override    public IBinder onBind(Intent intent) {        return mReporter;    }}</code></pre><p>继承了 AIDL 自动生成的 Stub 对象，它是什么呢？我们可以看下它的定义</p><h4 id="IReporter-java"><a href="#IReporter-java" class="headerlink" title="IReporter.java"></a>IReporter.java</h4><pre><code>public interface IReporter extends android.os.IInterface{    public static abstract class Stub extends android.os.Binder implements com.android.binder.IReporter {        ...        @Override        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException        {            switch (code)            {                case INTERFACE_TRANSACTION:                {                    reply.writeString(DESCRIPTOR);                    return true;                }                case TRANSACTION_report:                {                    data.enforceInterface(DESCRIPTOR);                    java.lang.String _arg0;                    _arg0 = data.readString();                    int _arg1;                    _arg1 = data.readInt();                    int _result = this.report(_arg0, _arg1);                    reply.writeNoException();                    reply.writeInt(_result);                    return true;                }            }            return super.onTransact(code, data, reply, flags);        }    }...}</code></pre><p>自动生成的 IReporter 类自动给我们处理了一些参数的组包和解包而已，在 case 语句中调用了 this.report 即可调用到自己的业务逻辑部分了。</p><h4 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h4><p>该部分已经被 Binder 类给封装了，暴露给开发者的已经是很简单的使用方式了，即继承 Binder，实现 onTransact 即可。</p><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>MainActivity.java</p><pre><code>private IReporter mReporterAidl;private class AidlConnection implements ServiceConnection {    @Override    public void onServiceConnected(ComponentName name, IBinder service) {        mReporterAidl = IReporter.Stub.asInterface(service);    }    @Override    public void onServiceDisconnected(ComponentName name) {        mReporterAidl = null;    }}...@Overrideprotected void onCreate(Bundle savedInstanceState) {    ...    Intent intent = new Intent(this, AidlService.class);    bindService(intent, new AidlConnection(), BIND_AUTO_CREATE);}</code></pre><p>这里调用了 Stub 对象的 asInterface，具体做了什么呢？</p><pre><code>public static com.android.binder.IReporter asInterface(android.os.IBinder obj){    if ((obj==null)) {        return null;    }    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);    if (((iin!=null)&amp;&amp;(iin instanceof com.android.binder.IReporter))) {        return ((com.android.binder.IReporter)iin);    }    return new com.android.binder.IReporter.Stub.Proxy(obj);}</code></pre><p>先查找本地接口是否存在，判断是否是本地调用，如果是则直接返回 IReporter 的对象，否则返回 Stub.Proxy 对象，这个 Proxy 对象是做什么的呢？</p><pre><code>private static class Proxy implements com.android.binder.IReporter{    private android.os.IBinder mRemote;    Proxy(android.os.IBinder remote)    {        mRemote = remote;    }    @Override public android.os.IBinder asBinder()    {        return mRemote;    }    public java.lang.String getInterfaceDescriptor()    {        return DESCRIPTOR;    }    @Override public int report(java.lang.String values, int type) throws android.os.RemoteException    {        android.os.Parcel _data = android.os.Parcel.obtain();        android.os.Parcel _reply = android.os.Parcel.obtain();        int _result;        try {            _data.writeInterfaceToken(DESCRIPTOR);            _data.writeString(values);            _data.writeInt(type);            mRemote.transact(Stub.TRANSACTION_report, _data, _reply, 0);            _reply.readException();            _result = _reply.readInt();        }        finally {            _reply.recycle();            _data.recycle();        }        return _result;    }}</code></pre><p>基本上已经很明了了，就是一个代理对象，对调用接口参数做组包而已，然后调用了 mRemote.transact 接口。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul><li><strong>AIDL 自动生成了 Stub 类</strong></li><li><strong>在 Service 端继承 Stub 类，Stub 类中实现了 onTransact 方法实现了「解包」的功能</strong></li><li><strong>在 Client 端使用 Stub 类的 Proxy 对象，该对象实现了「组包」并且调用 transact 的功能</strong></li></ul><p>有了 AIDL 之后，IReporter 接口就变得有意义了，Client 调用接口，Server 端实现接口，一切「组包」、「解包」的逻辑封装在了 Stub 类中，一切就是那么完美。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/bdef9e3178c9" target="_blank" rel="noopener">https://www.jianshu.com/p/bdef9e3178c9</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/6618363</a><br><a href="https://blog.csdn.net/Mr_LiaBill/article/details/49837851" target="_blank" rel="noopener">Android IBinder机制简单介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iBinder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常量池</title>
      <link href="/2019/05/29/java-constant-pool/"/>
      <url>/2019/05/29/java-constant-pool/</url>
      
        <content type="html"><![CDATA[<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享。</p><h3 id="Jvm虚拟内存分布"><a href="#Jvm虚拟内存分布" class="headerlink" title="Jvm虚拟内存分布"></a>Jvm虚拟内存分布</h3><p><img src="/2019/05/29/java-constant-pool/java_memory.png" alt><br> <strong>程序计数器</strong>是jvm执行程序的流水线，存放一些跳转指令。</p><p> <strong>本地方法栈</strong>是jvm调用操作系统方法所使用的栈。</p><p> <strong>虚拟机栈</strong>是jvm执行java代码所使用的栈。</p><p> <strong>方法区</strong>存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。</p><p> <strong>虚拟机堆</strong>是jvm执行java代码所使用的堆。</p><h3 id="Java常量池分类"><a href="#Java常量池分类" class="headerlink" title="Java常量池分类"></a>Java常量池分类</h3><p>Java中的常量池，实际上分为两种形态：<strong>静态常量池和运行时常量池</strong>。</p><p>所谓<strong>静态常量池，即*.class文件中的常量池</strong>，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。这种常量池主要用于存放两大类常量：<strong>字面量(Literal)和符号引用量(Symbolic References)</strong>，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><blockquote><p><strong>类和接口的全限定名<br>字段名称和描述符<br>方法名称和描述符</strong></p></blockquote><p>而<strong>运行时常量池</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。</p><h3 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h3><p>常量池是为了<strong>避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享</strong>。<br>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</p><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，减少对象数量从而改善应用所需的对象结构的方式。实现方式一般是通过HashMap完成。java常量池的设计初中也是为了减少内存占用，同时保证访问安全。继承Number的包装类常量池存储使用数组，String使用继承自HashTable的StringTable</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>接下来我们引用一些网络上流行的常量池例子，然后借以讲解。</p><pre><code> 1 String s1 = &quot;Hello&quot;; 2 String s2 = &quot;Hello&quot;; 3 String s3 = &quot;Hel&quot; + &quot;lo&quot;; 4 String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;); 5 String s5 = new String(&quot;Hello&quot;); 6 String s6 = s5.intern(); 7 String s7 = &quot;H&quot;; 8 String s8 = &quot;ello&quot;; 9 String s9 = s7 + s8;10           11 System.out.println(s1 == s2);  // true12 System.out.println(s1 == s3);  // true13 System.out.println(s1 == s4);  // false14 System.out.println(s1 == s9);  // false15 System.out.println(s4 == s5);  // false16 System.out.println(s1 == s6);  // true</code></pre><p> 首先说明一点，在java 中，直接使用==操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用String.equals()。</p><p> s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。</p><p> s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = “Hel” + “lo”;在class文件中被优化成String s3 = “Hello”，所以s1 == s3成立。只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。</p><p> s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</p><p>配上一张简图理清思路：</p><p><img src="/2019/05/29/java-constant-pool/constant_1.jpg" alt><br>s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，不能在编译期被确定，所以不做优化，只能等到运行时，在堆中创建s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同。</p><p><img src="/2019/05/29/java-constant-pool/constant_2.png" alt><br> s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。<br> s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。</p><p>特例1</p><pre><code>public static final String A = &quot;ab&quot;; // 常量Apublic static final String B = &quot;cd&quot;; // 常量Bpublic static void main(String[] args) {     String s = A + B;  // 将两个常量用+连接对s进行初始化      String t = &quot;abcd&quot;;       if (s == t) {            System.out.println(&quot;s等于t，它们是同一个对象&quot;);        } else {            System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);        }    } s等于t，它们是同一个对象</code></pre><p>A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：String s=A+B; 等同于：String s=”ab”+”cd”;</p><p>特例2</p><pre><code>public static final String A; // 常量Apublic static final String B;    // 常量Bstatic {        A = &quot;ab&quot;;        B = &quot;cd&quot;;    }    public static void main(String[] args) {       // 将两个常量用+连接对s进行初始化        String s = A + B;        String t = &quot;abcd&quot;;       if (s == t) {            System.out.println(&quot;s等于t，它们是同一个对象&quot;);        } else {            System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);        }    } s不等于t，它们不是同一个对象</code></pre><p>A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。</p><p>至此，我们可以得出三个非常重要的结论：</p><blockquote><p><strong>必须要关注编译期的行为，才能更好的理解常量池。<br>运行时常量池中的常量，基本来源于各个class文件中的常量池。<br>程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。</strong></p></blockquote><p>以上所讲仅涉及字符串常量池，实际上还有整型常量池、浮点型常量池(java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；两种浮点数类型的包装类Float,Double并没有实现常量池技术) 等等，但都大同小异，只不过数值类型的常量池不可以手动添加常量，程序启动时常量池中的常量就已经确定了，比如整型常量池中的常量范围：-128~127，（Byte,Short,Integer,Long,Character,Boolean）<strong>这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象</strong>。</p><p>例如在自动装箱时，把int变成Integer的时候，是有规则的，当你的int的值在-128-IntegerCache.high(127) 时，返回的不是一个新new出来的Integer对象，而是一个已经缓存在堆 中的Integer对象，（我们可以这样理解，系统已经把-128到127之 间的Integer缓存到一个Integer数组中去了，如果你要把一个int变成一个Integer对象，首先去缓存中找，找到的话直接返回引用给你就 行了，不必再新new一个），如果不在-128-IntegerCache.high(127) 时会返回一个新new出来的Integer对象。  </p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>说了这么多理论，接下来让我们触摸一下真正的常量池。</p><p>前文提到过，class文件中存在一个静态常量池，这个常量池是由编译器生成的，用来存储java源文件中的字面量(本文仅仅关注字面量)，假设我们有如下java代码：</p><pre><code>1 String s = &quot;hi&quot;;</code></pre><p>为了方便起见，就这么简单，没错！将代码编译成class文件后，用winhex打开二进制格式的class文件。如图：<br><img src="/2019/05/29/java-constant-pool/class.png" alt><br>简单讲解一下class文件的结构，开头的4个字节是class文件魔数，用来标识这是一个class文件，说白话点就是文件头，既：CA FE BA BE。</p><p>紧接着4个字节是java的版本号，这里的版本号是34，因为笔者是用jdk8编译的，版本号的高低和jdk版本的高低相对应，高版本可以兼容低版本，但低版本无法执行高版本。所以，如果哪天读者想知道别人的class文件是用什么jdk版本编译的，就可以看这4个字节。</p><p>接下来就是常量池入口，入口处用2个字节标识常量池常量数量，本例中数值为00 1A，翻译成十进制是26，也就是有25个常量，其中第0个常量是特殊值，所以只有25个常量。</p><p>常量池中存放了各种类型的常量，他们都有自己的类型，并且都有自己的存储规范，本文只关注字符串常量，字符串常量以01开头(1个字节)，接着用2个字节记录字符串长度，然后就是字符串实际内容。本例中为：01 00 02 68 69。</p><p>接下来再说说运行时常量池，由于运行时常量池在方法区中，我们可以通过jvm参数：-XX:PermSize、-XX:MaxPermSize来设置方法区大小，从而间接限制常量池大小。</p><p>假设jvm启动参数为：-XX:PermSize＝2M -XX:MaxPermSize＝2M，然后运行如下代码：</p><pre><code>1 //保持引用，防止自动垃圾回收2 List&lt;String&gt; list = new ArrayList&lt;String&gt;();3         4 int i = 0;5         6 while(true){7     //通过intern方法向常量池中手动添加常量8     list.add(String.valueOf(i++).intern());9 }</code></pre><p>程序立刻会抛出：Exception in thread “main” java.lang.outOfMemoryError: PermGen space异常。PermGen space正是方法区，足以说明常量池在方法区中。</p><p>在jdk8中，移除了方法区，转而用Metaspace区域替代，所以我们需要使用新的jvm参数：-XX:MaxMetaspaceSize=2M，依然运行如上代码，抛出：java.lang.OutOfMemoryError: Metaspace异常。同理说明运行时常量池是划分在Metaspace区域中。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/syp172654682/p/8082625.html" target="_blank" rel="noopener">https://www.cnblogs.com/syp172654682/p/8082625.html</a><br><a href="https://www.jianshu.com/p/aaa80665542d" target="_blank" rel="noopener">https://www.jianshu.com/p/aaa80665542d</a></p>]]></content>
      
      
      <categories>
          
          <category> Java知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解（Annotation）</title>
      <link href="/2019/05/28/java-annotation/"/>
      <url>/2019/05/28/java-annotation/</url>
      
        <content type="html"><![CDATA[<p>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。</p><p>注解<strong>本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类</strong>。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p><ul><li><p>@Documented – 注解是否将包含在JavaDoc中</p></li><li><p>@Retention – 什么时候使用该注解</p></li><li><p>@Target – 注解用于什么地方</p></li><li><p>@Inherited – 是否允许子类继承该注解</p></li></ul><p>1）@Retention —— 定义该注解的生命周期</p><ul><li><p>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</p></li><li><p>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</p></li><li><p>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p></li></ul><p>2）Target —— 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括</p><ul><li><p>ElementType.CONSTRUCTOR: 用于描述构造器</p></li><li><p>ElementType.FIELD: 成员变量、对象、属性（包括enum实例）</p></li><li><p>ElementType.LOCAL_VARIABLE: 用于描述局部变量</p></li><li><p>ElementType.METHOD: 用于描述方法</p></li><li><p>ElementType.PACKAGE: 用于描述包</p></li><li><p>ElementType.PARAMETER: 用于描述参数</p></li><li><p>ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</p></li></ul><p>3) @Documented —— 一个简单的Annotations 标记注解，没有成员，表示是否将注解信息添加在java 文档中。</p><p>4) @Inherited —— 定义该注释和子类的关系<br>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。</p><p>注意：Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。</p><p>当Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>自定义注解类编写的一些规则:</p><ol><li><p>Annotation 型定义为<strong>@interface</strong>, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</p></li><li><p>参数成员只能用public 或默认(default) 这两个访问权修饰</p></li><li><p>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</p></li><li><p>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</p></li><li><p>注解也可以没有定义成员,不过这样注解就没啥用了</p></li></ol><p>PS:自定义注解需要使用到元注解</p><h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><p>创建注解处理器，利用反射对注解加以处理。AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口。所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p><p>方法1：<t extends annotation> T getAnnotation(Class<t> annotationClass):返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</t></t></p><p>方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。</p><p>方法3：boolean is AnnotationPresent(Class annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.</p><p>方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>FruitName.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import static java.lang.annotation.ElementType.FIELD;</span><br><span class="line">import static java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 水果名称注解</span><br><span class="line"> */</span><br><span class="line">@Target(FIELD)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FruitName &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FruitColor.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import static java.lang.annotation.ElementType.FIELD;</span><br><span class="line">import static java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 水果颜色注解</span><br><span class="line"> */</span><br><span class="line">@Target(FIELD)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FruitColor &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 颜色枚举</span><br><span class="line">     */</span><br><span class="line">    public enum Color&#123; BLUE,RED,GREEN&#125;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 颜色属性</span><br><span class="line">     */</span><br><span class="line">    Color fruitColor() default Color.GREEN;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FruitProvider.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.annotation.Documented;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.annotation.Target;</span><br><span class="line">import static java.lang.annotation.ElementType.FIELD;</span><br><span class="line">import static java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 水果供应者注解</span><br><span class="line"> */</span><br><span class="line">@Target(FIELD)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FruitProvider &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 供应商编号</span><br><span class="line">     */</span><br><span class="line">    public int id() default -1;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 供应商名称</span><br><span class="line">     */</span><br><span class="line">    public String name() default &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 供应商地址</span><br><span class="line">     */</span><br><span class="line">    public String address() default &quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FruitInfoUtil.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注解处理器</span><br><span class="line"> */</span><br><span class="line">public class FruitInfoUtil &#123;</span><br><span class="line">    public static void getFruitInfo(Class&lt;?&gt; clazz)&#123;</span><br><span class="line">        </span><br><span class="line">        String strFruitName=&quot; 水果名称：&quot;;</span><br><span class="line">        String strFruitColor=&quot; 水果颜色：&quot;;</span><br><span class="line">        String strFruitProvicer=&quot;供应商信息：&quot;;</span><br><span class="line">        </span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        </span><br><span class="line">        for(Field field :fields)&#123;</span><br><span class="line">            if(field.isAnnotationPresent(FruitName.class))&#123;</span><br><span class="line">                FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class);</span><br><span class="line">                strFruitName=strFruitName+fruitName.value();</span><br><span class="line">                System.out.println(strFruitName);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(field.isAnnotationPresent(FruitColor.class))&#123;</span><br><span class="line">                FruitColor fruitColor= (FruitColor) field.getAnnotation(FruitColor.class);</span><br><span class="line">                strFruitColor=strFruitColor+fruitColor.fruitColor().toString();</span><br><span class="line">                System.out.println(strFruitColor);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(field.isAnnotationPresent(FruitProvider.class))&#123;</span><br><span class="line">                FruitProvider fruitProvider= (FruitProvider) field.getAnnotation(FruitProvider.class);</span><br><span class="line">                strFruitProvicer=&quot; 供应商编号：&quot;+fruitProvider.id()+&quot; 供应商名称：&quot;+fruitProvider.name()+&quot; 供应商地址：&quot;+fruitProvider.address();</span><br><span class="line">                System.out.println(strFruitProvicer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apple.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import test.FruitColor.Color;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注解使用</span><br><span class="line"> */</span><br><span class="line">public class Apple &#123;</span><br><span class="line">    </span><br><span class="line">    @FruitName(&quot;Apple&quot;)</span><br><span class="line">    private String appleName;</span><br><span class="line">    </span><br><span class="line">    @FruitColor(fruitColor=Color.RED)</span><br><span class="line">    private String appleColor;</span><br><span class="line">    </span><br><span class="line">    @FruitProvider(id=1,name=&quot;陕西红富士集团&quot;,address=&quot;陕西省西安市延安路89号红富士大厦&quot;)</span><br><span class="line">    private String appleProvider;</span><br><span class="line">    </span><br><span class="line">    public void setAppleColor(String appleColor) &#123;</span><br><span class="line">        this.appleColor = appleColor;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getAppleColor() &#123;</span><br><span class="line">        return appleColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAppleName(String appleName) &#123;</span><br><span class="line">        this.appleName = appleName;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getAppleName() &#123;</span><br><span class="line">        return appleName;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setAppleProvider(String appleProvider) &#123;</span><br><span class="line">        this.appleProvider = appleProvider;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getAppleProvider() &#123;</span><br><span class="line">        return appleProvider;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void displayName()&#123;</span><br><span class="line">        System.out.println(&quot;水果的名字是：苹果&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FruitRun.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 输出结果</span><br><span class="line"> */</span><br><span class="line">public class FruitRun &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FruitInfoUtil.getFruitInfo(Apple.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">水果名称：Apple</span><br><span class="line">水果颜色：RED</span><br><span class="line">供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路89号红富士大厦</span><br></pre></td></tr></table></figure></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/lylwo317/article/details/52163304" target="_blank" rel="noopener">Java注解（Annotation）原理详解</a><br><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener">https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器ClassLoader及Dex/Class</title>
      <link href="/2019/05/10/android-dex/"/>
      <url>/2019/05/10/android-dex/</url>
      
        <content type="html"><![CDATA[<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>顾名思义，类加载器用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例，每个这样的实例用来表示一个 Java 类，通过此实例的 newInstance()方法就可以创建出该类的一个对象。</p><p>类加载器是 Java 语言的一个创新。<strong>它使得动态安装和更新软件组件成为可能</strong>。</p><p><strong>Java 虚拟机是如何判定两个Java类是相同的：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样</strong>。只有两者都相同的情况，才认为两个类是相同的。</p><h4 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h4><p>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。</p><p>代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。</p><p><strong>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</strong></p><p>ClassLoader特点：<strong>遵循双亲委派模型</strong></p><blockquote><p>ClassLoader在加载一个class文件时：会询问当前ClassLoader是否已经加载过此类，如果已经加载过则直接返回，不再重复加载。如果没有加载过，会去查询当前ClassLoader的parent是否已经加载过。</p></blockquote><p>因为遵循双亲委派模型，Android中的classLoader具有两个特点：</p><ul><li>类加载共享<br>当一个class文件被任何一个ClassLoader加载过，就不会再被其他ClassLoader加载。</li><li>类加载隔离<br>不同ClassLoader加载的class文件肯定不是一个。举个栗子，一些系统层级的class文件在系统初始化的时候被加载，比如java.net.String，这个是在应用启动前就被系统加载好的。如果在一个应用里能简单地用一个自定义的String类把这个String类替换掉的话，将有严重的安全问题。</li></ul><h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p><h4 id="类加载器与-OSGi"><a href="#类加载器与-OSGi" class="headerlink" title="类加载器与 OSGi"></a>类加载器与 OSGi</h4><p>OSGi（开放服务网关协议，Open Service Gateway Initiative）是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse 就是基于 OSGi 技术来构建的。</p><p>OSGi 中的每个模块（bundle）都包含 Java 包和类。模块可以声明它所依赖的需要导入（import）的其它模块的 Java 包和类（通过 Import-Package），也可以声明导出（export）自己的包和类，供其它模块使用（通过 Export-Package）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。<strong>OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。</strong>模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性 org.osgi.framework.bootdelegation的值即可。</p><p>OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。下面提供几条比较好的建议：</p><ul><li>如果一个类库只有一个模块使用，把该类库的 jar 包放在模块中，在 Bundle-ClassPath中指明即可。</li><li>如果一个类库被多个模块共用，可以为这个类库单独的创建一个模块，把其它模块需要用到的 Java 包声明为导出的。其它模块声明导入这些类。</li><li>如果类库提供了 SPI 接口，并且利用线程上下文类加载器来加载 SPI 实现的 Java 类，有可能会找不到 Java 类。如果出现了 NoClassDefFoundError异常，首先检查当前线程的上下文类加载器是否正确。通过 Thread.currentThread().getContextClassLoader()就可以得到该类加载器。该类加载器应该是该模块对应的类加载器。如果不是的话，可以首先通过 class.getClassLoader()来得到模块对应的类加载器，再通过 Thread.currentThread().setContextClassLoader()来设置当前线程的上下文类加载器。</li></ul><h4 id="ClassLoader种类"><a href="#ClassLoader种类" class="headerlink" title="ClassLoader种类"></a>ClassLoader种类</h4><ul><li>BootClassLoader（Java的BootStrap ClassLoader）<br>用于加载Android Framework层class文件。</li><li>PathClassLoader（Java的App ClassLoader）<br>用于加载已经安装到系统中的apk中的class文件（要传入系统中apk的存放Path，所以只能加载已经安装的apk文件）。</li><li>DexClassLoader（Java的Custom ClassLoader）<br>用于加载指定目录中的class文件(可以加载jar/apk/dex，可以从SD卡中加载未安装的apk)。</li><li>BaseDexClassLoader<br>是PathClassLoader和DexClassLoader的父类。<br><img src="/2019/05/10/android-dex/class_loader.png" alt></li></ul><p>为了解决65535这个问题，Google提出了multidex方案，即一个apk文件可以包含多个dex文件。<br>不过值得注意的是，<strong>除了第一个dex文件以外，其他的dex文件都是以资源的形式被加载的， 换句话说就是在Application初始化前将dex文件注入到系统的ClassLoader中的。 </strong><br>根据Android虚拟机的类加载机制，同一个类只会被加载一次，所以热修复也使用了这样的机制，<strong>要让修复后的类替换原有的类就必须让补丁包的类被优先加载，也就是插入到原有dex之前。</strong></p><h4 id="PathClassLoader加载已安装的apk插件"><a href="#PathClassLoader加载已安装的apk插件" class="headerlink" title="PathClassLoader加载已安装的apk插件"></a>PathClassLoader加载已安装的apk插件</h4><p>使用PathClassLoader加载已安装的apk插件。sharedUserId要一致，简单的说，应用从一开始安装在Android系统上时，系统都会给它分配一个linux user id，之后该应用在今后都将运行在独立的一个进程中，其它应用程序不能访问它的资源，那么如果两个应用的sharedUserId相同，那么它们将共同运行在相同的linux进程中，从而便可以数据共享、资源访问了。所以我们在宿主app和插件app的manifest上都定义一个相同的sharedUserId。</p><p>下面看一个样例：加载包名为packageName的插件，然后获得插件内名为one.png的图片的资源id，进而供宿主app使用该图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 加载已安装的apk</span><br><span class="line">    * @param packageName 应用的包名</span><br><span class="line">    * @param pluginContext 插件app的上下文</span><br><span class="line">    * @return 对应资源的id</span><br><span class="line">    */</span><br><span class="line">   private int dynamicLoadApk(String packageName, Context pluginContext) throws Exception &#123;</span><br><span class="line">       //第一个参数为包含dex的apk或者jar的路径，第二个参数为父加载器</span><br><span class="line">       PathClassLoader pathClassLoader = new PathClassLoader(pluginContext.getPackageResourcePath(),ClassLoader.getSystemClassLoader());</span><br><span class="line">//Class&lt;?&gt; clazz = pathClassLoader.loadClass(packageName + &quot;.R$mipmap&quot;);//通过使用自身的加载器反射出mipmap类进而使用该类的功能</span><br><span class="line">       //参数：1、类的全名，2、是否初始化类，3、加载时使用的类加载器</span><br><span class="line">       Class&lt;?&gt; clazz = Class.forName(packageName + &quot;.R$mipmap&quot;, true, pathClassLoader);</span><br><span class="line">       //使用上述两种方式都可以，这里我们得到R类中的内部类mipmap，通过它得到对应的图片id，进而给我们使用</span><br><span class="line">       Field field = clazz.getDeclaredField(&quot;one&quot;);</span><br><span class="line">       int resourceId = field.getInt(R.mipmap.class);</span><br><span class="line">       return resourceId;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ul><li>首先就是new出一个PathClassLoader对象，它的构造方法为：public PathClassLoader(String dexPath, ClassLoader parent)。其中第一个参数是通过插件的上下文来获取插件apk的路径，其实获取到的就是/data/app/apkthemeplugin.apk，那么插件的上下文怎么获取呢？在宿主app中我们只有本app的上下文啊，答案就是为插件app创建一个上下文：Context plugnContext = this.createPackageContext(packageName, CONTEXT_IGNORE_SECURITY | CONTEXT_INCLUDE_CODE。<strong> 通过插件的包名来创建上下文，不过这种方法只适合获取已安装的app上下文</strong>。或者不需要通过反射直接通过插件上下文getResource().getxxx(R.<em>.</em>);也行，而这里用的是反射方法。第二个参数是父加载器，都是ClassLoader.getSystemClassLoader()。</li></ul><h4 id="DexClassLoader加载未安装的apk插件"><a href="#DexClassLoader加载未安装的apk插件" class="headerlink" title="DexClassLoader加载未安装的apk插件"></a>DexClassLoader加载未安装的apk插件</h4><p>关于动态加载未安装的apk，先描述下思路：首先我们得到事先知道我们的插件apk存放在哪个目录下，然后分别得到插件apk的信息（名称、包名等），然后显示可用的插件，最后动态加载apk获得资源。</p><p>按照上面这个思路，我们需要解决几个问题：<br>1、怎么得到未安装的apk的信息<br>2、怎么得到插件的context或者Resource，因为它是未安装的不可能通过createPackageContext(…);方法来构建出一个context，所以这时只有在Resource上下功夫。</p><p>现在我们就一一来解答这些问题吧：<br>1、得到未安装的apk信息可以通过mPackageManager.getPackageArchiveInfo()方法获得</p><pre><code>/** * 获取未安装apk的信息 * @param context * @param archiveFilePath apk文件的path * @return */private String[] getUninstallApkInfo(Context context, String archiveFilePath) {    String[] info = new String[2];    PackageManager pm = context.getPackageManager();    PackageInfo pkgInfo = pm.getPackageArchiveInfo(archiveFilePath, PackageManager.GET_ACTIVITIES);    if (pkgInfo != null) {        ApplicationInfo appInfo = pkgInfo.applicationInfo;        String versionName = pkgInfo.versionName;//版本号        Drawable icon = pm.getApplicationIcon(appInfo);//图标        String appName = pm.getApplicationLabel(appInfo).toString();//app名称        String pkgName = appInfo.packageName;//包名        info[0] = appName;        info[1] = pkgName;    }    return info;}</code></pre><p>2、得到对应未安装apk的Resource对象，我们需要通过反射来获得：</p><pre><code>/** * @param apkName  * @return 得到对应插件的Resource对象 */private Resources getPluginResources(String apkName) {    try {        AssetManager assetManager = AssetManager.class.newInstance();        Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);//反射调用方法addAssetPath(String path)        //第二个参数是apk的路径：Environment.getExternalStorageDirectory().getPath()+File.separator+&quot;plugin&quot;+File.separator+&quot;apkplugin.apk&quot;        addAssetPath.invoke(assetManager, apkDir+File.separator+apkName);//将未安装的Apk文件的添加进AssetManager中，第二个参数为apk文件的路径带apk名        Resources superRes = this.getResources();        Resources mResources = new Resources(assetManager, superRes.getDisplayMetrics(),                superRes.getConfiguration());        return mResources;    } catch (Exception e) {        e.printStackTrace();    }    return null;}</code></pre><p>通过得到AssetManager中的内部的方法addAssetPath，将未安装的apk路径传入从而添加进assetManager中，然后通过new Resource把assetManager传入构造方法中，进而得到未安装apk对应的Resource对象。</p><p>3、接下来就是加载未安装的apk获得它的内部资源</p><pre><code>/** * 加载apk获得内部资源 * @param apkDir apk目录 * @param apkName apk名字,带.apk * @throws Exception */private void dynamicLoadApk(String apkDir, String apkName, String apkPackageName) throws Exception {    File optimizedDirectoryFile = getDir(&quot;dex&quot;, Context.MODE_PRIVATE);//在应用安装目录下创建一个名为app_dex文件夹目录,如果已经存在则不创建    Log.v(&quot;zxy&quot;, optimizedDirectoryFile.getPath().toString());// /data/data/com.example.dynamicloadapk/app_dex    //参数：1、包含dex的apk文件或jar文件的路径，2、apk、jar解压缩生成dex存储的目录，3、本地library库目录，一般为null，4、父ClassLoader    DexClassLoader dexClassLoader = new DexClassLoader(apkDir+File.separator+apkName, optimizedDirectoryFile.getPath(), null, ClassLoader.getSystemClassLoader());    Class&lt;?&gt; clazz = dexClassLoader.loadClass(apkPackageName + &quot;.R$mipmap&quot;);//通过使用apk自己的类加载器，反射出R类中相应的内部类进而获取我们需要的资源id    Field field = clazz.getDeclaredField(&quot;one&quot;);//得到名为one的这张图片字段    int resId = field.getInt(R.id.class);//得到图片id    Resources mResources = getPluginResources(apkName);//得到插件apk中的Resource    if (mResources != null) {        //通过插件apk中的Resource得到resId对应的资源        findViewById(R.id.background).setBackgroundDrawable(mResources.getDrawable(resId));    }}</code></pre><p>其中通过new DexClassLoader()来创建未安装apk的类加载器，我们来看看它的参数：</p><pre><code>public class DexClassLoader extends BaseDexClassLoader {    public DexClassLoader(String dexPath, String optimizedDirectory,            String libraryPath, ClassLoader parent) {        super(dexPath, new File(optimizedDirectory), libraryPath, parent);    }}</code></pre><p>可以看到DexClassLoader的源码非常简单，只有一个构造方法。我们来看下其四个参数都是什么含义：</p><ul><li>dexPath：要加载的dex文件路径。</li><li>optimizedDirectory：dex文件要被copy到的目录路径。此位置一定要是可读写且仅该应用可读写（安全性考虑），所以只能放在data/data下。看官方文档：<br>This class loader requires an application-private, writable directory to cache optimized classes. Use Context.getDir(String, int) to create such a directory: File dexOutputDir = context.getDir(“dex”, 0);</li><li>libraryPath：apk文件中类要使用的c/c++代码，指向包含本地库(so)的文件夹路径，可以设为null。</li><li>parent：父装载器，也就是真正loadclass的装载器，一般可以通过Context.getClassLoader获取到，也可以通过ClassLoader.getSystemClassLoader()取到。<br>在Android中加载class，其实最终是通过DexPathList的findClass来加载的。</li></ul><h4 id="单DexClassLoader与多DexClassLoader"><a href="#单DexClassLoader与多DexClassLoader" class="headerlink" title="单DexClassLoader与多DexClassLoader"></a>单DexClassLoader与多DexClassLoader</h4><p>插件和主工程的互相调用涉及到以下两个问题：</p><p>1、<strong>插件调用主工程</strong><br>在构造插件的ClassLoader时会传入主工程的ClassLoader作为父加载器，所以插件是可以直接可以通过类名引用主工程的类。</p><p>2、<strong>主工程调用插件</strong><br>1）若使用多ClassLoader机制，主工程引用插件中类需要先通过插件的ClassLoader加载该类再通过反射调用其方法。插件化框架一般会通过统一的入口去管理对各个插件中类的访问，并且做一定的限制。<br>2）若使用单ClassLoader机制，主工程则可以直接通过类名去访问插件中的类。该方式有个弊病，若两个不同的插件工程引用了一个库的不同版本，则程序可能会出错，所以要通过一些规范去避免该情况发生。</p><h3 id="Dex文件"><a href="#Dex文件" class="headerlink" title="Dex文件"></a>Dex文件</h3><p>定义：能够被DVM或者Art虚拟机执行并且加载的文件格式。</p><p>作用：<strong>dex文件的作用是记录整个工程（通常是一个Android工程）的所有类文件的信息</strong>。</p><p>Android支持动态加载的两种方式是：DexClassLoader和PathClassLoader。DexClassLoader可加载jar/apk/dex，且支持从SD卡加载；PathClassLoader据说只能加载已经安装在Android系统内APK文件,以下这一段是摘录：PathClassLoader 的限制要更多一些，它只能加载已经安装到 Android 系统中的 apk 文件，也就是 /data/app 目录下的 apk 文件。其它位置的文件加载的时候都会出现 ClassNotFoundException。</p><p>dex文件的生成：</p><pre><code>先生成class文件（注意执行低版本的JDK版本，否则手机无法运行），然后执行：dx --dex --output Test.dex Test.class然后把生成的dex文件拷贝到手机：adb push C:\Users\Administrator\Desktop\Test.dex /storage/emulated/0adb shelldalvikvm -cp /sdcard/Test.dex Test</code></pre><p>dex文件的结构：</p><pre><code>8位字节的二进制流文件各个数据紧密排列，无间隙，减少了文件体积，加快加载速度整个工程的类信息都存放在一个dex文件中（不考虑dex分包的情况下）</code></pre><p><img src="/2019/05/10/android-dex/dex.webp" alt><br>注意：<br>文件头包含了dex文件的信息，所有数据的大致分布情况<br>链接数据区：主要是指so库</p><h4 id="Dex文件头格式"><a href="#Dex文件头格式" class="headerlink" title="Dex文件头格式"></a>Dex文件头格式</h4><p><img src="/2019/05/10/android-dex/dex_data.png" alt title="数据格式"><br><img src="/2019/05/10/android-dex/dex_data_des.png" alt><br>上图和上表就是dex的文件头的结构和各个位置的意思。其中最开始的64 65 78 0A 30 33 3500（dex.035.）表示这是按照dex解析的。</p><h3 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h3><p>定义：能够被JVM识别，加载并执行的文件格式。</p><p>作用：记录一个类文件的所有信息，记住所有。例如记住了当前类的引用this、父类super等等。class文件记录的信息往往比java文件多。</p><p>class文件的结构:</p><pre><code>8位字节的二进制流文件各个数据紧密排列，无间隙，减少了文件体积，加快加载速度每个类或者接口单独占据一个class文件，每个类单独管理，没有交叉</code></pre><p>class文件中的字段如下所示：</p><pre><code>magic 加密字段，虚拟机判断当前的class文件是否被篡改过minor_version 支持最低版本的jdkmajor_version 编译使用的jdk版本constant_pool_count 常量池的数量，一般为一个cp_info constant_pool 常量池的结构体，数量不定（类型是cp_info结构体）access_flags 访问级别，例如public等this_class 当前类super_class 父类interfaces_count 类实现接口的数量fields_count 类成员变量的数量methods_count 类方法的数量method_info methods 类方法的结构体attributes_count 类属性的数量attribute_info attributes 类属性的结构体</code></pre><p>constant_pool包括：</p><pre><code>CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_String_info等等 CONSTANT_Class_info：类的相关信息，包括当前类、引用到的类的信息 CONSTANT_Fieldref_info：类的域信息 CONSTANT_Methodref_info：类的方法信息</code></pre><p>class文件的弊端：</p><pre><code>内存占用大，不适合移动端堆栈的加栈模式，加载速度慢。文件IO操作多，类加载慢。</code></pre><h3 id="Class文件与Dex文件的比较"><a href="#Class文件与Dex文件的比较" class="headerlink" title="Class文件与Dex文件的比较"></a>Class文件与Dex文件的比较</h3><p>本质上都是一样的，都是二进制流文件格式，dex文件是从class文件演变而来的。<br><strong>class文件存在冗余信息，dex文件则去掉了冗余，并且整合了整个工程的类信息。</strong><br><img src="/2019/05/10/android-dex/dex_class.png" alt></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="noopener">深入探讨 Java 类加载器</a><br><a href="https://blog.csdn.net/u010687392/article/details/47121729?hmsr=toutiao.io" target="_blank" rel="noopener">插件化开发—动态加载技术加载已安装和未安装的apk</a><br><a href="https://blog.csdn.net/ll458524906/article/details/78303557" target="_blank" rel="noopener">Android_dex详解</a><br><a href="https://blog.csdn.net/colinandroid/article/details/80712045" target="_blank" rel="noopener">ClassLoader详解</a><br><a href="https://blog.csdn.net/developandroid/article/details/81780477" target="_blank" rel="noopener">class文件和dex文件</a></p>]]></content>
      
      
      <categories>
          
          <category> Android插件化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dex </tag>
            
            <tag> ClassLoader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可扩展架构</title>
      <link href="/2019/05/05/architecture-extensible/"/>
      <url>/2019/05/05/architecture-extensible/</url>
      
        <content type="html"><![CDATA[<p>可扩展架构的基本思想是：拆</p><p>不同的拆分方式，本质上决定了系统的可扩展性。常见的拆分思路有三种：</p><p>1）面向流程拆分：分层架构<br>分层架构的本质：固定的内核，移动的数据。<br>扩展时大部分情况只需要修改其一层，少部分情况可能修改关联的两层，不会出现所有层都同时要修改。<br>以简单的学生信息管理系统为例：展示层–&gt;业务层–&gt;数据层–&gt;存储层</p><p>2）面向服务拆分：SOA、微服务<br>服务是一组相似功能的集合。<br>对于某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可。<br>以简单的学生信息管理系统为例：将系统拆分为注册、登录、信息管理、安全设置等服务</p><p>3）面向功能拆分:微内核架构<br>以简单的学生信息管理系统为例：每个服务都可以拆分为更多细粒度的功能</p><p>当然，这几个系统架构并不是非彼既此的，而是可以组合使用。</p><h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>分层架构也叫N层架构，通常情况下，N至少是两层。</p><p>分层架构的本质在于<strong>隔离关注点</strong>（separation of concerns），即每个层中的组件只会处理本层的逻辑，核心就是需要<strong>保证各层之间的差异足够清晰，边界足够明显，</strong>让人看到架构图后就能看懂整个架构。</p><p>根据不同的划分维度和对象，可以得到多种不同的分层架构：<br>1）C/S、B/S架构<br>2）MVC、MVP架构<br>3）逻辑分层架构<br>逻辑分层架构中的层是自顶向下依赖的，如andoid操作系统的架构</p><h3 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h3><p>SOA(Service Oriented Architecture)提出来三个关键概念：</p><p>1）服务<br>所有业务功能都是一项服务，服务意味着要对外提供开发的能力，当其他系统需要使用这项功能时，无须定制化开发。</p><p>2）ESB(Enterprise Service Bus)<br>ESB是将企业中各个不同的服务连接到一起。SOA使用ESB来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。</p><p>3）松耦合<br>目的是减少各个服务间的依赖和相互影响。</p><p>SOA架构是集成的思想，是解决服务孤岛打通链条，是无奈之举。ESB集中化的管理带来了性能不佳、厚重等问题，也无法快速扩展。所以不适合互联网的业务特点。</p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务是一种和SOA相似但本质上不同的架构理念。两者都关注于“服务”，都是通过服务的拆分来解决可扩展性问题。本质上不同在于几个核心理念的差异：是否有ESB、服务的粒度、架构设计的目标（<strong>small、lightweight、automated</strong>）等。</p><p>微服务架构其实相当复杂，可以分成几个阶段理解：<br>1）第一阶段，微服务架构就是去掉了ESB的SOA架构，只不过是通信的方式和结构变了。对于初级的使用者而言，这样理解没有太大问题。<br>2）第二阶段，没有了ESB，原本很多由ESB组件做的事儿，转到服务的提供者和调用者这里了。他们需要考虑服务的拆分粒。大体仍然算是SOA架构。<br>3）第三阶段，随着服务的数量大幅增加，服务的管理越来越困难，此时DevOps出现了。这个阶段的微服务架构，已经是跟SOA架构完全不同的东西了。<br>要逐步演进和迭代，不要过于激进，更不要拆分过细，拆分的粒度，要与团队的架构相互匹配。（康威定律）</p><p>SOA和微服务的区别：<br>1）服务粒度<br>2）服务通讯<br>微服务推荐使用统一的协议和格式。<br>3）服务交付<br>SOA更多的是考虑兼容已有的系统；微服务的架构理念要求“快速交付”，相应的要求自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践。<br>4）应用场景<br>SOA更适合庞大、复杂、异构的企业级系统，这也是SOA诞生的背景。<br>微服务更适合快速、轻量级、基于Web的物联网系统。</p><h4 id="微服务的陷阱及问题"><a href="#微服务的陷阱及问题" class="headerlink" title="微服务的陷阱及问题"></a>微服务的陷阱及问题</h4><p>1）服务划分过细，服务间关系复杂<br>2）服务数量太多，团队效率急剧下降<br>3）调用链太长，性能下降<br>4）调用链太长，问题定位困难<br>5）没有自动化支撑，无法快速交付<br>6）没有服务治理，数量多了之后管理混乱</p><h4 id="微服务架构实践"><a href="#微服务架构实践" class="headerlink" title="微服务架构实践"></a>微服务架构实践</h4><p>1.服务粒度<br>三个火枪手原则。亚马逊CEO Jeff Bezos有个一个经验法则：如果两个披萨对于一个团队来说不够，那么这个团队就太大了。</p><p>2.拆分方法<br>1）基于业务逻辑拆分</p><p>2）基于可扩展拆分：区分稳定服务、可变服务</p><p>3）基于可靠性拆分<br>好处：避免非核心业务故障影响核心业务；核心服务高可用方案可以更简单；能够降低高可用成本</p><p>4）基于性能拆分<br>将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务。</p><p>以上方案可自由排列组合。</p><p>3.基础设施<br>1）服务发现、服务路由、服务容错：这是最基本的微服务基础设施</p><p>2）接口框架、API网关：主要是为了提升开发效率</p><p>3）自动化部署、自动化测试、配置中心：主要为了提升测试和运维效率</p><p>4）服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率</p><p>以上3、4会随着微服务节点数量增加而越来越重要，当节点较少时，可以通过人工支撑，虽然效率不高，但也基本能够顶得住。</p><h3 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h3><p>微内核架构也被称为插件化架构，是一种面向功能进行拆分的可扩展性架构。</p><p>微内核架构包含两类组件：核心系统和插件模块。核心模块负责和具体业务功能无关的通用功能，如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑。</p><p>微内核的核心系统设计的关键技术有：插件管理、插件链接和插件通信。</p><p>常见架构有：OSGI、规则引擎架构、Atlas容器化框架等。</p><p>android架构模式参考：<br>1.<a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247488375&amp;idx=1&amp;sn=3af36be489393783a95d5c5e3fc73b65&amp;source=41#wechat_redirect" target="_blank" rel="noopener">Atlas：手淘Native容器化框架和思考</a><br>2.<a href="https://www.infoq.cn/article/wechat-android-app-architecture" target="_blank" rel="noopener">微信 Android 客户端架构演进之路</a></p><h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><p>微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是康威定律（Conway’s Law）。</p><p>在康威的这篇文章中，最有名的一句话就是：</p><blockquote><p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - Melvin Conway(1967)</p></blockquote><p>中文直译大概的意思就是：<strong>设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。</strong></p><p>Mike从他的角度归纳这篇论文中的其他一些核心观点，如下：</p><ul><li>第一定律：企业沟通方式会通过系统设计表达出来——Communication dictates design</li><li>第二定律：再多的时间也没办法让任务完美至极，但总有时间能将它完成——There is never enough time to do something right, but there is always enough time to do it over</li><li>第三定律：线型系统和线型组织架构间有潜在的异质同态特性——There is a homomorphism from the linear graph of a system to the linear graph of its design organization</li><li>第四定律：大系统比小系统更适用于任务分解——The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems</li></ul><h4 id="康威第一定律"><a href="#康威第一定律" class="headerlink" title="康威第一定律"></a>康威第一定律</h4><p>“人类是复杂的社会动物。”</p><p>《The Mythical Man-Month》 这本书里有一句令人难忘的话：在应用项目后期加大人员的投资，会更加拖慢它的速度。——Fred Brooks（1975）</p><p>沟通的问题会影响系统设计，进而影响整个系统的开发效率以及最终结果。</p><h4 id="康威第二定律"><a href="#康威第二定律" class="headerlink" title="康威第二定律"></a>康威第二定律</h4><p>罗马不是一天建成的，学会先解决首要问题。</p><p>敏捷开发巨头之一Erik Hollnagel 在他的书中阐述了类似的观点：</p><blockquote><p>问题太复杂？那么不妨忽略不必要的细节。<br>没有足够的资源？放弃无用的功能。<br>——Erik Hollnagel（2009）</p></blockquote><p>系统的复杂性、功能数量、市场竞争以及投资人的期望值都在增加，而人的智力是有上限的，没有企业能说一定能找到合适的人，对于一个极其复杂的系统，总会有考虑不周全的地方，Erik认为这个问题最好的解决办法就是：不去管它。</p><p>最佳解决方案不是消除所有问题，而是允许它们存在，在发生故障时实现自动恢复。<br>在由微服务组成的系统中，每个微服务都可能停止响应，这是完全正常的，只需要确保足够的冗余和备份，这就是弹性或高可用性设计。</p><h4 id="康威第三定律"><a href="#康威第三定律" class="headerlink" title="康威第三定律"></a>康威第三定律</h4><p>创建独立的子系统，减少沟通成本。</p><p>团队中微服务的理念应是Inter-Operate，而不是Integrate ，Inter-Operate是指定义系统边界和接口，并为整个团队提供完整的堆栈，实现完全的自制。如此就能降低系统间的依赖性，减少通信成本。</p><h4 id="康威第四定律"><a href="#康威第四定律" class="headerlink" title="康威第四定律"></a>康威第四定律</h4><p>前面提到，人类是复杂的社会动物，人与人之间的交流是非常复杂的，当涉及到一个系统时，人们经常选择增加人力去减少复杂性，对于企业来说，该如何处理这样的沟通问题？答案是：分而治之。</p><h4 id="康威定律与微服务"><a href="#康威定律与微服务" class="headerlink" title="康威定律与微服务"></a>康威定律与微服务</h4><p>再来看一下康威定律是如何在半个世纪前就奠定了微服务理论基础的。</p><ul><li>人与人之间的交流很复杂，每个人的精力是有限的，因此当问题很复杂，需要协调地去解决时，需要将组织划分进而提高沟通效率。</li><li>团队成员工作的系统设计依赖于成员之间的沟通，管理人员可以调整划分模式，实现团队之间的不同沟通方式，这也会影响系统的设计。</li><li>如果子系统有清晰的外部通信便捷，那么就可以有效地降低通信成本，响应地设计将更加适合和有效。</li><li>需要不断优化一个复杂的系统，并容错性和故障恢复率的帮助下进行优化，不要期望大而全面的设计或架构，因为它们的开发以迭代的方式发生。</li></ul><p>以下是一些具体的实践建议：</p><ul><li>利用一切手段提高通信效率，如Slack、Github和Wiki，且只与相关人员进行沟通，每个人和每个系统必须有明确的职责，在遇到问题时，知道该找谁去解决。</li><li>在MVP模式下设计一套系统，以迭代的方式优化及验证，并确保系统的弹性。</li><li>采用与系统设计相一致的团队，以扁平化和以业务为基准的方式去简化团队，每个小团队之间必须有对应负责的模块，避免模糊的界限，以免在发生问题时互相推卸责任。</li><li>要做小而美的团队，人员数量的增加会降低效率以及加大成本，亚马逊CEO Jeff Bezos有个一个经验法则：如果两个披萨对于一个团队来说不够，那么这个团队就太大了。一般来说，一家互联网公司的产品团队由7到8个人组成（包括前端和后端测试、交互和用户体验师，一些人可能身兼数职）。</li></ul><p>在查看以下微服务标准时，我们可以很容易地看到微服务与康威定律之间的密切关系：</p><ul><li>由分布式服务组成的系统</li><li>企业部门的业务线</li><li>开发优秀的产品</li><li>Smart endpoints and dumb pipes</li><li>DevOps</li><li>容错</li><li>快速发展</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://segmentfault.com/a/1190000011118897" target="_blank" rel="noopener">康威定律</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库高性能</title>
      <link href="/2019/04/29/architecture-high-performance/"/>
      <url>/2019/04/29/architecture-high-performance/</url>
      
        <content type="html"><![CDATA[<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读写分离的基本原理是将数据库读写操作分散到不同的节点上。</p><p>读写分离适用单机并发无法支撑并且读的请求更多的情形。在单机数据库情况下，表上加索引一般对查询有优化作用却影响写入速度，读写分离后可以单独对读库进行优化，写库上减少索引，对读写的能力都有提升，且读的提升更多一些。<br>不适用的情况:<br>1）如果并发写入特别高，单机写入无法支撑，就不适合这种模式。<br>2）通过缓存技术或者程序优化能够满足要求</p><p>读写分离的基本实现是：<br>1）数据库服务器搭建主从集群，一主一从，一主多从都可以<br>2）数据库主机负责写操作，从机负责读操作<br>3）数据库主机通过复制将数据同步到数据库从机，每台数据库服务器都存储了所有的业务数据<br>4）业务服务器将写操作发给数据库主机，将读操作发给数据库从机</p><p>但有两个细节点引入了复杂度：<strong>主从复制延时</strong>和<strong>分配机制</strong>，以下为解决方案</p><p>复制延时：<br>1）写操作后的读操作指定发给数据库主机<br>2）读从机失败后再度一次主机<br>3）关键业务读写操作全部指向主机，非关键业务采用读写分离</p><p>分配机制：<br>将读写操作区分开来，然后访问不同的数据库，一般有两种方式：<strong>程序代码封装</strong>和<strong>中间件封装</strong></p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>分库分表会带来很多复杂度。在引入分库分表之前，应该是这些操作依次尝试：<br>1.做硬件优化，例如从机械硬盘改成使用固态硬盘，当然固态硬盘不适合服务器使用，只是举个例子<br>2.先做数据库服务器的调优操作，例如增加索引，oracle有很多的参数调整;<br>3.引入缓存技术，例如Redis，减少数据库压力<br>4.程序与数据库表优化，重构，例如根据业务逻辑对程序逻辑做优化，减少不必要的查询;<br>5.在这些操作都不能大幅度优化性能的情况下，不能满足将来的发展，再考虑分库分表，也要有预估性</p><h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>业务分库是指按照业务模块将数据分散到不同的数据库服务器。</p><p>存在问题：<br>1）join问题<br>2）事务问题<br>3）成本问题</p><h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>分两种方式：垂直分表、水平分表</p><p>水平分表：<br>水平分表后，某条数据具体属于哪个子表，需要增加路由算法进行计算，这个算法会引入一定的复杂性。<br>常见的路由算法有：<br>1）范围路由<br>2）hash路由<br>3）配置路由</p><p>其他常见的复杂性问题：join，count，order by等</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>架构设计流程</title>
      <link href="/2019/04/28/architecture-design-flow/"/>
      <url>/2019/04/28/architecture-design-flow/</url>
      
        <content type="html"><![CDATA[<h3 id="如何识别复杂度"><a href="#如何识别复杂度" class="headerlink" title="如何识别复杂度"></a>如何识别复杂度</h3><p>架构设计由需求所驱动，本质目的是为了解决软件系统的复杂性；为此，我们在进行架构设计时，需要以理解需求为前提，首要进行系统复杂性的分析。具体做法是：</p><p>（1）构建复杂度的来源清单——高性能、可用性、扩展性、安全、低成本、规模等。</p><p>（2）结合需求、技术、团队、资源等对上述复杂度逐一分析是否需要？是否关键？</p><p>“高性能”主要从软件系统未来的TPS、响应时间、服务器资源利用率等客观指标，也可以从用户的主观感受方面去考虑。</p><p>“可用性”主要从服务不中断等质量属性，符合行业政策、国家法规等方面去考虑。</p><p>“扩展性”则主要从功能需求的未来变更幅度等方面去考虑。</p><p>（3）按照上述的分析结论，得到复杂度按照优先级的排序清单，越是排在前面的复杂度，就越关键，就越优先解决。</p><p>需要特别注意的是：随着所处的业务阶段不同、外部的技术条件和环境的不同，得到的复杂度问题的优先级排序就会有所不同。一切皆变化。</p><h3 id="备选方案设计"><a href="#备选方案设计" class="headerlink" title="备选方案设计"></a>备选方案设计</h3><p>经过架构设计流程第 1 步——识别复杂度，确定了系统面临的主要复杂度问题，进而明确了设计方案的目标，就可以开展架构设计流程第 2 步——设计备选方案。架构设计备选方案的工作更多的是从需求、团队、技术、资源等综合情况出发，对主流、成熟的架构模式进行选择、组合、调整、创新。</p><p>1.几种常见的架构设计误区</p><p>（1）设计最优秀的方案。不要面向“简历”进行架构设计，而是要根据“合适”、“简单”、“演进”的架构设计原则，决策出与需求、团队、技术能力相匹配的合适方案。</p><p>（2）只做一个方案。一个方案容易陷入思考问题片面、自我坚持的认知陷阱。</p><p>2.备选方案设计的注意事项</p><p>（1）备选方案不要过于详细。备选阶段解决的是技术选型问题，而不是技术细节。</p><p>（2）备选方案的数量以 3~5个为最佳。</p><p>（3）备选方案的技术差异要明显。</p><p>（4）备选方案不要只局限于已经熟悉的技术。</p><p>3.问题思考</p><p>可以从开源、自研的角度提出架构设计方案</p><p>如果是创业公司的业务早、中期阶段，可直接考虑采用阿里云/腾讯云，性能、HA、伸缩性都有保证。</p><p>最大的感悟是：做事情永远都要有B方案。</p><h3 id="评估和选择备选方案"><a href="#评估和选择备选方案" class="headerlink" title="评估和选择备选方案"></a>评估和选择备选方案</h3><p>1 评估和选择备选方案的方法<br><strong>列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。</strong>常见的质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性。<br>按优先级选择，即架构师综合当前的业务发展情况、团队人员规模和技能、业务发展预测等因素，将质量属性按照优先级排序，首先挑选满足第一优先级的，如果方案都满足，那就再看第二优先级……以此类推。</p><p>2 RocketMQ 和 Kafka 有什么区别？</p><p>（1） 适用场景<br>Kafka适合日志处理；RocketMQ适合业务处理。</p><p>（2） 性能<br>Kafka单机写入TPS号称在百万条/秒；RocketMQ大约在10万条/秒。Kafka单机性能更高。</p><p>（3） 可靠性<br>RocketMQ支持异步/同步刷盘;异步/同步Replication；Kafka使用异步刷盘方式，异步Replication。RocketMQ所支持的同步方式提升了数据的可靠性。</p><p>（4） 实时性<br>均支持pull长轮询，RocketMQ消息实时性更好</p><p>（5） 支持的队列数<br>Kafka单机超过64个队列/分区，消息发送性能降低严重；RocketMQ单机支持最高5万个队列，性能稳定（这也是适合业务处理的原因之一）</p><p>3 为什么阿里会自研RocketMQ？</p><p>（1） Kafka的业务应用场景主要定位于日志传输；对于复杂业务支持不够<br>（2） 阿里很多业务场景对数据可靠性、数据实时性、消息队列的个数等方面的要求很高<br>（3）当业务成长到一定规模，采用开源方案的技术成本会变高（开源方案无法满足业务的需要；旧版本、自开发代码与新版本的兼容等）<br>（4） 阿里在团队、成本、资源投入等方面约束性条件几乎没有</p><h3 id="详细设计方案"><a href="#详细设计方案" class="headerlink" title="详细设计方案"></a>详细设计方案</h3><p>完成备选方案的设计和选择后，接下来需要将确定的备选方案细化，使得备选方案变成一个可以落地的设计方案。</p><p>1）架构师不但要进行备选方案的设计和选型，还需要对备选方案的关键细节有较深入的理解。<br>2）通过分步骤、分阶段、分系统等方式，尽量减低方案复杂度，方案本身的复杂度越高，某个细节推翻整个方案的可能性就越大，适当降低复杂度，可以降低这种风险。<br>3）如果方案本身就很复杂，那就采取设计团队的方式来进行设计，博采众长，防止可能出现的盲点或经验误区。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter APP体积为何比较大</title>
      <link href="/2019/04/26/flutter-package-size/"/>
      <url>/2019/04/26/flutter-package-size/</url>
      
        <content type="html"><![CDATA[<p>flutter构建的App体积比native的大一些，是什么原因造成App体积大呢？</p><p>其实flutter 在release时App体积和native的大小差不多，而debug时体积通常会大。debug版本体积较大是为了Hot reload和快速编译。如果有flutter开发经验的朋友都体验过，如果您修改一下App的背景颜色，只需save一下就可以立刻看到修改后效果。我称之为“像艺术家一样在创造App”，因此为了实现这些目标，提高开发的效率，debug将占用全部资源。而当我们构建release版时，flutter又会采用AOT策略，提高App运行效率，release版只打包必需的资源，因而体积又会减少。</p><p>另外，flutter团队也一直在寻找减小程序大小的方法。</p><p>现在开发 App 的方式非常多，原生、ReactNative、Flutter 都是不错的选择。那你有没有关注过，使用不同的方式，编译生成的 Apk ，大小是否会有什么影响呢？本文就以一个最简单的 Hello World App，来看看不同的框架，编译出来的 Apk 大小，有什么区别。</p><h3 id="Java（539-KB）"><a href="#Java（539-KB）" class="headerlink" title="Java（539 KB）"></a>Java（539 KB）</h3><p>首先使用 Java 来开始这次实验，使用 Java 开发 Android 算是最常规也是最简单的一种方式。正如前面描述的那样，由于我们仅仅使用了 Java 和 Android 框架来创建这个应用程序，所以它将是最小的，唯一的依赖是 Android 支持库，它占用了整个 Apk 内相当多的空间。</p><h3 id="Flutter（7-5MB）"><a href="#Flutter（7-5MB）" class="headerlink" title="Flutter（7.5MB）"></a>Flutter（7.5MB）</h3><p>由 Flutter 的 cli 生成的 Release 版本的应用程序中，包含 C / C ++ 引擎和 Dart VM，它们构成了 Apk 的几乎所有部分。该应用程序直接使用本机指令集运行，不涉及任何解释器。<br><img src="/2019/04/26/flutter-package-size/flutter_app_size.jpg" alt><br>本文里介绍的几种编写 App 的方法，都存在优缺点，在实际工作中，应该根据需求选择适合的方式。你还可以混合搭配这些框架，仅仅用它们的优点来开发 App 的部分功能。</p><h3 id="React-Native（7MB）"><a href="#React-Native（7MB）" class="headerlink" title="React Native（7MB）"></a>React Native（7MB）</h3><p>如果你有前端（Web）的开发经验，并希望使用 JavaScript 来开发 App，那么 React Native 是一个不错的选择。</p><p>如果你希望在已发布的 App 上，进行更快的功能迭代，使用 React Native 也可以让你不必为每个小改动都发布应用市场。</p><p>由 React Native 生成的 Release apk 在 classes.dex 文件中有几个类，这些类有 12193 个针对此应用程序的引用方法。<br>它还在 x86 和 armeabi-v7a 的 lib 目录中添加了一些 so 库。总共添加了大约 6.4 MB 的空间。</p><hr><p>ReactNative 和 Flutter 因为其内部还需要包含一些解析器和引擎，本身就会有一些基础库在其内，所以变大也是符合预期的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/0e223b472f41" target="_blank" rel="noopener">https://www.jianshu.com/p/0e223b472f41</a><br><a href="https://www.cnblogs.com/plokmju/p/release_apk.html" target="_blank" rel="noopener">https://www.cnblogs.com/plokmju/p/release_apk.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Hybrid Develop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构的概念</title>
      <link href="/2019/04/25/architecture-basics/"/>
      <url>/2019/04/25/architecture-basics/</url>
      
        <content type="html"><![CDATA[<p><strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题。</strong>个人感悟是：架构及（重要）决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体（人、财、时间等）。架构无优劣，但是存在恰当的架构用在合适的系统中，而这些就是决策的结果。不要过分设计。</p><h3 id="架构概念"><a href="#架构概念" class="headerlink" title="架构概念"></a>架构概念</h3><p>软件架构指软件系统的顶层结构；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。</p><p>软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。</p><p>软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。</p><p>软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。</p><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>性能是软件的一个重要质量属性。衡量软件性能包括了响应时间、TPS、服务器资源利用率等客观指标，也可以是用户的主观感受（从程序员、业务用户、终端用户/客户不同的视角，可能会得出不同的结论）。</p><p>在说性能的时候，有一个概念与之紧密相关—伸缩性，这是两个有区别的概念。性能更多的是衡量软件系统处理一个请求或执行一个任务需要耗费的时间长短；而伸缩性则更加关注软件系统在不影响用户体验的前提下，能够随着请求数量或执行任务数量的增加（减少）而相应地拥有相适应的处理能力。</p><p>但是，什么是“高”性能？这可能是一个动态概念，与当前的技术发展状况与业务所处的阶段紧密相关。比如，现在在行业/企业内部认为的高性能，站在5年后来看，未必是高性能。因此，站在架构师、设计师的角度，高性能需要和业务所处的阶段来衡量。高到什么程度才能与当前或可预见的未来业务增长相匹配。一味去追求绝对意义上的高，没有太大的实际意义。因为，伴随性能越来越高，相应的方法和系统复杂度也是越来越高，而这可能会与当前团队的人力、技术、资源等不相匹配。但是什么才合适的高性能了？这可能需要从国、内外的同行业规模相当、比自己强的竞争者、终端用户使用反馈中获取答案并不断迭代发展。</p><p>软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。</p><p>2 WHY 为什么需要高性能？<br>追求良好的用户体验；<br>满足业务增长的需要。</p><p>3 HOW 如何做好高性能？<br>可以从垂直与水平两个维度来考虑。垂直维度主要是针对单台计算机，通过升级软、硬件能力实现性能提升；水平维度则主要针对集群系统，利用合理的任务分配与任务分解实现性能的提升。</p><p>垂直维度可包括以下措施：<br>增大内存减少I/O操作<br>更换为固态硬盘（SSD）提升I/O访问速度<br>使用RAID增加I/O吞吐能力<br>置换服务器获得更多的处理器或分配更多的虚拟核<br>升级网络接口或增加网络接口</p><p>水平维度可包括以下措施：<br>功能分解：基于功能将系统分解为更小的子系统<br>多实例副本：同一组件重复部署到多台不同的服务器<br>数据分割：在每台机器上都只部署一部分数据</p><p>垂直维度方案比较适合业务阶段早期和成本可接受的阶段，该方案是提升性能最简单直接的方式，但是受成本与硬件能力天花板的限制。</p><p>水平维度方案所带来的好处要在业务发展的后期才能体现出来。起初，该方案会花费更多的硬件成本，另外一方面对技术团队也提出了更高的要求；但是，没有垂直方案的天花板问题。一旦达到一定的业务阶段，水平维度是技术发展的必由之路。因此，作为技术部门，需要提前布局 ，未雨绸缪，不要被业务抛的太远。</p><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p><strong>高可用基础是“状态决策”。本质上是通过“冗余”来实现高可用。</strong></p><p>高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。保证系统高可用，架构设计的核心准则是：冗余。有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p><strong>核心是：封装变化，隔离可变性。</strong></p><p>应对变化方案：<br>1）将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”<br>2）提炼出一个“抽象层”和一个“实现层”。抽象层是稳定的，而实现层是根据业务进行定制的，当加入新功能时，只需要更改实现层，无须修改抽象层。</p><h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><p>当前大型互联网网站需要面对大量用户高并发访问、存储更多数据、处理更高频次的用户交互。网站系统一般通过多种分布式技术将多台服务器组成集群对外提供服务。<strong>伸缩性一般是系统可以根据需求和成本调整自身处理能力的一种能力</strong>。伸缩性常意味着系统可以通过低成本并能够快速改变自身的处理能力以满足更多用户访问、处理更多数据而不会对用户体验造成任何影响。</p><p>伸缩性度量指标包括（1）处理更高并发；（2）处理更多数据；（3）处理更高频次的用户交互。</p><p>其复杂度体现在（1）伸——增强系统在上述三个方面的处理能力；（2）缩——缩减系统处理能力；（3）上述伸缩过程还必须相对低成本和快速。</p><h3 id="成本、安全、规模"><a href="#成本、安全、规模" class="headerlink" title="成本、安全、规模"></a>成本、安全、规模</h3><p>低成本是架构设计中需要考虑一个约束条件，但不会是首要目标。低成本本质上是与高性能和高可用冲突的，当无法设计出满足成本要求的方案，就只能协调并调整成本目标。<br>往往只有“创新”才能达到低成本目标。1）引入新技术。主要复杂度在于需要去熟悉新技术，并且将新技术与已有技术结合；一般中小型公司基本采用该方式达到目标。2）开创一个全新技术领域。主要复杂度在于需要去创造全新的理念和技术，并且与旧技术相比，需要有质的飞跃，复杂度更高；一般大公司拥有更多的资源、技术实力会采用该方式来达到低成本的目标。</p><p>安全在技术角度上将包括功能安全和架构安全。1）功能安全-“防小偷”，减少系统潜在的缺陷（是一个逐步完善的过程，而且往往都是在问题出现后才能有针对性的提出解决方案，与编码实现有关），阻止黑客的破坏行为。2）架构安全-“防强盗”，保护系统不受恶意访问与攻击，保护系统的重要数据不被窃取（传统企业主要通过防火墙实现不同区域的访问控制，功能强大、性能一般，但是成本更高；互联网企业更多的是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现）。</p><p>规模带来复杂度的主要原因是“量变引起质变”。1）功能越来越多，调用逻辑越来越复杂，会导致系统复杂度指数级上升。2）数据容量、类型、关联关系越来越多。<br>规模问题需要与高性能、高可用、高扩展、高伸缩性统一考虑。常采用“分而治之，各个击破”的方法策略。</p><h3 id="架构设计三原则"><a href="#架构设计三原则" class="headerlink" title="架构设计三原则"></a>架构设计三原则</h3><p><strong>不断演化是架构发展的主旋律，而满足适合、追求简单是架构决策的重要依据。</strong>需求驱动技术的创新演化；技术反哺业务的发展升级。<br>1）合适原则<br>合适原则宣言：合适优于业界领先<br>失败原因：没有那么多人，却想干那么多活；没有那么多积累，却想一步登天；没有卓越的业务场景，却幻想灵光一闪成为天才。设计的目的不是为了证明自己，而是更快更好的满足业务需求。</p><p>2）简单原则<br>简单原则宣言：简单优于复杂<br>定位一个复杂系统中的问题总是比简单系统更为复杂</p><p>3）演化原则<br>演化原则宣言：演化优于一步到位<br><strong>对于软件来说，变化才是主题</strong>。罗马不是一天建成的，架构也不是一开始就设计成完美的样子，然后可以一劳永逸的用下去。</p><p>各个公司的架构都是逐渐演进成当前的样子，在达到同样目的的过程中实现手段确并不完全相同，蚂蚁和阿里都进行了多地多中心部署的架构改造，但二者在诸如配置中心、跨ldc访问管控等方面都不尽相同，即使在蚂蚁内部也出现了后续实现推翻原始规划的情况。在多地多中心部署架构改造完成后，为进一步降低成本，避免大促活动中机器的浪费，又开始了弹性部署的改造，希望能够在大促高峰来临的前几个小时再临时增加服务器，等活动结束服务器就立即回收。等这个搞定，又开始在线离线混布的改造，进一步降低整体成本。<br>这些改造之所以一个接一个的能够实现，也在于使用的主要中间件和框架都是自研的，知根知底，可以快速迭代修改，如果是使用第三方的或者购买的，一方面可能非常贵，另一方面可能根本不支持，要重新设计改造部署所需的时间要远远大于自研的成本。</p><h3 id="软件活动中没有“银弹”"><a href="#软件活动中没有“银弹”" class="headerlink" title="软件活动中没有“银弹”"></a>软件活动中没有“银弹”</h3><p>在古代的狼人传说中，只有用银质子弹（银弹）才能制服这些异常凶残的怪兽。在软件开发活动中，“银弹”特指人们渴望找到用于制服软件项目这头难缠的“怪兽”的“万能钥匙”。</p><p>软件开发过程包括了分析、设计、实现、测试、验证、部署、运维等多个环节。从IT技术的发展历程来看，先辈们在上述不同的环节中提出过很多在当时看来很先进的方法与理念。但是，这些方法、理念在摩尔定律、业务创新、技术发展面前都被一一验证了以下观点：我们可以通过诸多方式去接近“银弹”，但很遗憾，软件活动中没有“银弹”。</p><p>布鲁克斯发表《人月神话》三十年后，又写了《设计原本》。他认为一个成功的软件项目的最重要因素就是设计，架构师、设计师需要在业务需求和IT技术中寻找到一个平衡点。个人觉得，对这个平衡点的把握，就是架构设计中的取舍问题。而这种决策大部分是靠技术，但是一定程度上也依赖于架构师的“艺术”，技术可以依靠新工具、方法论、管理模式去提升，但是“艺术”无法量化 ，是一种权衡。</p><p><strong>软件设计过程中，模块、对象、组件本质上是对一定规模软件在不同粒度和层次上的“拆分”方法论，软件架构是一种对软件的“组织”方法论。一分一合，其目的是为了软件研发过程中的成本、进度、质量得到有效控制</strong>。但是，一个成功的软件设计是要适应并满足业务需求，同时不断“演化”的。设计需要根据业务的变化、技术的发展不断进行“演进”，这就决定了这是一个动态活动，出现新问题，解决新问题，没有所谓的“一招鲜”。</p><p>以上只是针对设计领域的银弹讨论，放眼到软件全生命周期，银弹问题会更加突出。</p><p>小到一个软件开发团队，大到一个行业，没有银弹，但是“行业最佳实践”可以作为指路明灯，这个可以有。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android Retrofit 2详解</title>
      <link href="/2019/04/11/android-retrofit/"/>
      <url>/2019/04/11/android-retrofit/</url>
      
        <content type="html"><![CDATA[<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>以下就是实现一个登录Login接口的小功能 ，先了解一下Retrofit的基本用法:</p><pre><code>private  void getLogin() {Retrofit retrofit = new Retrofit.Builder()        .baseUrl(&quot;//localhost:8080/&quot;)        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())        .addConverterFactory(GsonConverterFactory.create())        .build();ApiManager apiService = retrofit.create(ApiManager.class);Call&lt;LoginResult&gt; call = apiService.getData(&quot;lyk&quot;, &quot;1234&quot;);call.enqueue(new Callback&lt;LoginResult&gt;() {   @Override   public void onResponse(Call&lt;LoginResult&gt; call, Response&lt;LoginResult&gt; response) {       if (response.isSuccess()) {           // 请求成功       } else {          //直接操作UI 或弹框提示请求失败       }   }   @Override   public void onFailure(Call&lt;LoginResult&gt; call, Throwable t) {       //错误处理代码   }   });}</code></pre><p>ApiManager接口:</p><pre><code>public interface ApiManager { @GET(&quot;login/&quot;) Call&lt;LoginResult&gt; getData(@Query(&quot;name&quot;) String name, @Query(&quot;password&quot;) String pw);}</code></pre><h2 id="Retrofit支持异步和同步"><a href="#Retrofit支持异步和同步" class="headerlink" title="Retrofit支持异步和同步"></a>Retrofit支持异步和同步</h2><p>call.enqueue(new Callback<loginresult>）采用异步请求；<br>call.execute() 采用同步方式。</loginresult></p><p>call.cancel() 取消请求</p><h2 id="CallAdapterFactory"><a href="#CallAdapterFactory" class="headerlink" title="CallAdapterFactory"></a>CallAdapterFactory</h2><p>.addCallAdapterFactory(RxJava2CallAdapterFactory.create())这个是用来决定你的返回值是Observable还是Call。</p><pre><code>// 使用call的情况Call&lt;String&gt; login();  // 使用Observable的情况Observable&lt;String&gt; login();  </code></pre><p>如果返回为Call那么可以不添加这个配置。如果使用Observable那就必须添加这个配置。否则就会请求的时候就会报错！</p><p>Retrofit中使用RxJava：由于Retrofit设计的扩展性非常强，你只需要添加一个 CallAdapter 就可以了</p><h2 id="ConverterFactory"><a href="#ConverterFactory" class="headerlink" title="ConverterFactory"></a>ConverterFactory</h2><p>addConverterFactory <strong>制定数据解析器</strong>，上面添加依赖的gson就是用在这里做默认数据返回的， 之后通过build()创建出来。</p><p>Retrofit内部自带如下格式：</p><blockquote><p>Gson: com.squareup.retrofit2:converter-gson<br>Jackson: com.squareup.retrofit2:converter-jackson<br>Moshi: com.squareup.retrofit2:converter-moshi<br>Protobuf: com.squareup.retrofit2:converter-protobuf<br>Wire: com.squareup.retrofit2:converter-wire<br>Simple XML: com.squareup.retrofit2:converter-simplexml<br>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</p></blockquote><h2 id="网络请求参数"><a href="#网络请求参数" class="headerlink" title="网络请求参数"></a>网络请求参数</h2><p>@Path:所有在网址中的参数(URL的问号前面),如://192.168.1.1/api/Accounts/{accountId}</p><p>@Query:URL问号后面的参数,如://192.168.1.1/api/Comments?access_token={access_token}</p><p>@QueryMap:相当于多个@Query</p><p>@Field:用于POST请求,提交单个数据</p><p>@FieldMap:以map形式提交多个Field(Retrofit2.0之后添加)</p><p>@Body:相当于多个@Field,以对象的形式提交</p><p>注意：</p><ol><li><p>使用@Field时记得添加@FormUrlEncoded</p></li><li><p>若需要重新定义接口地址,可以使用@Url,将地址以参数的形式传入即可。</p></li><li><p>@Path 和@Query的区别<br>相同点:都是请求头中的带有的数据<br>不同点:前者是请求头中问号之前用于替换URL中变量的字段,后者是请求头问号之后用于查询数据的字段,作用和应用场景都不同</p></li></ol><h2 id="进阶功能"><a href="#进阶功能" class="headerlink" title="进阶功能"></a>进阶功能</h2><h3 id="开启Log"><a href="#开启Log" class="headerlink" title="开启Log"></a>开启Log</h3><p>用拦截器实现， retrofit已经提供了 HttpLoggingInterceptor 里面有四种级别，输出的格式，可以看下面介绍：</p><pre><code>public enum Level {/** No logs. */NONE,/** * Logs request and response lines. * * &lt;p&gt;Example: * &lt;pre&gt;{@code * --&gt; POST /greeting  *  *  * /1.1 (3-byte body) * * &lt;-- 200 OK (22ms, 6-byte body) * }&lt;/pre&gt; */BASIC,/** * Logs request and response lines and their respective headers. * * &lt;p&gt;Example: * &lt;pre&gt;{@code * --&gt; POST /greeting http/1.1 * Host: example.com * Content-Type: plain/text * Content-Length: 3 * --&gt; END POST * * &lt;-- 200 OK (22ms) * Content-Type: plain/text * Content-Length: 6 * &lt;-- END HTTP * }&lt;/pre&gt; */HEADERS,/** * Logs request and response lines and their respective headers and bodies (if present). * * &lt;p&gt;Example: * &lt;pre&gt;{@code * --&gt; POST /greeting http/1.1 * Host: example.com * Content-Type: plain/text * Content-Length: 3 * * Hi? * --&gt; END GET * * &lt;-- 200 OK (22ms) * Content-Type: plain/text * Content-Length: 6 * * Hello! * &lt;-- END HTTP * }&lt;/pre&gt; */BODY}</code></pre><p>例如，开启请求头添加拦截器:</p><pre><code>Retrofit retrofit = new Retrofit.Builder().client(new OkHttpClient.Builder()                         .addNetworkInterceptor(new  HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.HEADERS))                                .build())</code></pre><h3 id="增加头部信息"><a href="#增加头部信息" class="headerlink" title="增加头部信息"></a>增加头部信息</h3><pre><code>new Retrofit.Builder()       .addConverterFactory(GsonConverterFactory.create())       .client(new OkHttpClient.Builder()               .addInterceptor(new Interceptor() {                   @Override                   public Response intercept(Chain chain) throws IOException {                       Request request = chain.request()                               .newBuilder()                               .addHeader(&quot;mac&quot;, &quot;f8:00:ea:10:45&quot;)                               .addHeader(&quot;uuid&quot;, &quot;gdeflatfgfg5454545e&quot;)                               .addHeader(&quot;userId&quot;, &quot;Fea2405144&quot;)                               .addHeader(&quot;netWork&quot;, &quot;wifi&quot;)                               .build();                       return chain.proceed(request);                   }               })               .build()</code></pre><p>特殊API接口单独加入,方法上注释@Headers:</p><pre><code>@Headers({ &quot;Accept: application/vnd.github.v3.full+json&quot;, &quot;User-Agent: Retrofit-your-App&quot;})@get(&quot;users/{username}&quot;)Call&lt;User&gt;   getUser(@Path(&quot;username&quot;) String username);</code></pre><h3 id="添加证书Pinning"><a href="#添加证书Pinning" class="headerlink" title="添加证书Pinning"></a>添加证书Pinning</h3><p>证书可以在自定义的OkHttpClient加入certificatePinner 实现：</p><pre><code>OkHttpClient client = new OkHttpClient.Builder().certificatePinner(new CertificatePinner.Builder()        .add(&quot;YOU API.com&quot;, &quot;sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=&quot;)        .add(&quot;YOU API..com&quot;, &quot;sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=&quot;)        .add(&quot;YOU API..com&quot;, &quot;sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=&quot;)        .add(&quot;YOU API..com&quot;, &quot;sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=&quot;)        .build())</code></pre><h3 id="支持https"><a href="#支持https" class="headerlink" title="支持https"></a>支持https</h3><p>加密和普通http客户端请求支持https一样，证书同样可以设置到okhttpclient中.详细可以参考我之前的文章：<a href="https://zhaoshuming.github.io/2019/03/18/android-https/" target="_blank" rel="noopener">android中使用https</a></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="url被转义"><a href="#url被转义" class="headerlink" title="url被转义"></a>url被转义</h3><pre><code>https://api.myapi.com/http%3A%2F%2Fapi.mysite.com%2Fuser%2Flist</code></pre><p>请将@path改成@url</p><pre><code>public interface APIService { @GET Call&lt;Users&gt; getUsers(@Url String url);}</code></pre><p>或者：</p><pre><code>public interface APIService {    @GET(&quot;{fullUrl}&quot;)    Call&lt;Users&gt; getUsers(@Path(value = &quot;fullUrl&quot;, encoded = true) String fullUrl);}</code></pre><h3 id="Method方法找不到"><a href="#Method方法找不到" class="headerlink" title="Method方法找不到"></a>Method方法找不到</h3><pre><code>java.lang.IllegalArgumentException: Method must not be null</code></pre><p>请指定具体请求类型@get @post等</p><pre><code>public interface APIService {    @GET Call&lt;Users&gt; getUsers(@Url String url);}</code></pre><h3 id="Url编码不对，-fieldMap-parameters-must-be-use-FormUrlEncoded"><a href="#Url编码不对，-fieldMap-parameters-must-be-use-FormUrlEncoded" class="headerlink" title="Url编码不对，@fieldMap parameters must be use FormUrlEncoded"></a>Url编码不对，@fieldMap parameters must be use FormUrlEncoded</h3><p>如果用fieldMap加上FormUrlEncoded编码</p><pre><code>@POST()@FormUrlEncodedObservable&lt;ResponseBody&gt; executePost(@FieldMap Map&lt;String, Object&gt; maps);</code></pre><p>上层需要转换将自己的map转换为FieldMap</p><pre><code>@FieldMap(encoded = true) Map&lt;String, Object&gt; parameters,</code></pre><h3 id="path和url一起使用"><a href="#path和url一起使用" class="headerlink" title="path和url一起使用"></a>path和url一起使用</h3><pre><code>Using @Path and @Url paramers together with retrofit2 java.lang.IllegalArgumentException: @Path parameters may not be used with @Url. (parameter #4</code></pre><p>如果你是这样的：</p><pre><code>@GETCall&lt;DataResponse&gt; getOrder(@Url String url, @Path(&quot;id&quot;) int id);</code></pre><p>请在你的url指定占位符.url:</p><pre><code>www.myAPi.com/{Id}</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Retrofit就像一个适配器（Adapter）的角色，将一个Java接口转换成一个Http请求并返回一个Call对象，简单的调用接口方法就可以发送API请求，Retrofit完全隐藏了Request 的请求体，并使用okhttp执行请求。</p><p>Retrofit 是怎么实现的呢？答案就是：Java的动态代理。<strong>Java动态代理，是一种结构性设计模式，可以在要调用的Class方法前或后，插入想要执行的代码进行改造。</strong></p><p>案例中关键两行代码：</p><pre><code>ApiManager apiService = retrofit.create(ApiManager.class); //2、retrofit对象创建一个API接口对象Call&lt;LoginResult&gt; call = apiService.getData(&quot;lyk&quot;, &quot;1234&quot;); //返回响应接口回调</code></pre><p>这简短的两行代码，隐藏了Request请求体并拿到Response返回Call对象。看下源码，这几行代码才是 Retrofit 精妙之处：</p><pre><code>/** Create an implementation of the API defined by the {@code service} interface. */public &lt;T&gt; T create(final Class&lt;T&gt; service) {  Utils.validateServiceInterface(service);  if (validateEagerly) {     eagerlyValidateMethods(service);  }  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },    new InvocationHandler() {      private final Platform platform = Platform.get();      @Override public Object invoke(Object proxy, Method method, Object... args)          throws Throwable {        // If the method is a method from Object then defer to normal invocation.        if (method.getDeclaringClass() == Object.class) {          return method.invoke(this, args);        }        if (platform.isDefaultMethod(method)) {          return platform.invokeDefaultMethod(method, service, proxy, args);        }        ServiceMethod serviceMethod = loadServiceMethod(method);        OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);        return serviceMethod.callAdapter.adapt(okHttpCall);      }    });}</code></pre><p>源码分析：<br>当 apiService 对象调用 getData方法时，就会被这个动态代理拦截并在内部做些小动作，它会调用 Proxy.newProxyInstance方法 中的 InvocationHandler 对象，它的 invoke方法 会传入3个参数：</p><blockquote><p>Object proxy     ：代理对象 ，即APIManner.class<br>Method method ：调用方法，即getData方法<br>Object… args    ： 参数对象，即 “lyk”,”1234”</p></blockquote><p>Retrofit 得到了 method 和 参数args 。接下去 Retrofit 就会用 Java反射 获取到 getData方法 的注解信息，配合args参数，创建一个ServiceMethod对象。</p><p>ServiceMethod 是服务于请求方法的，服务于传入Retrofit的proxy对象的method方法，即getData方法。如何服务呢？它可以将method通过各种内部接口解析器进行组装拼凑，最终生成一个Request请求体。这个Request 包含 api域名、path、http请求方法、请求头、是否有body、是否是multipart等等。最后返回一个Call对象，Retrofit2中Call接口的默认实现是OkHttpCall，它默认使用OkHttp3作为底层http请求client。一句话就是：<strong>Retrofit 使用Java动态代理就是要拦截被调用的Java方法，然后解析这个Java方法的注解，最后生成Request由OkHttp发送Http请求。</strong></p><p>想要弄清楚Retrofit的细节，先来简单了解一下Retrofit源码组成结构：</p><p><img src="/2019/04/11/android-retrofit/retrofit2_dir.png" alt><br>一个retrofit2.http包，里面全部是定义HTTP请求的Java注解，比如GET、POST、PUT、DELETE、Headers、Path、Query等；</p><p>余下的retrofit2包中，几个类和接口retrofit的代码真的很少很简单，因为retrofit把网络请求这部分功能全部交给了OkHttp。</p><h3 id="Retrofit接口"><a href="#Retrofit接口" class="headerlink" title="Retrofit接口"></a>Retrofit接口</h3><p>Retrofit的设计使用插件化而且轻量级，高内聚而且低耦合，这都和它的接口设计有关。Retrofit中定义了四个接口：</p><ul><li>Callback<t></t></li><li>Converter&lt;F, T&gt;</li><li>Call<t></t></li><li>CallAdapter<t></t></li></ul><p>1、Callback<t><br>这个接口就是retrofit请求数据返回的接口，只有两个方法：</t></p><pre><code>void onResponse(Response&lt;T&gt; response);void onFailure(Throwable t);</code></pre><p>2、Converter&lt;F, T&gt;<br>这个接口主要的作用就是将HTTP返回的数据解析成Java对象，主要有Xml、Gson、protobuf等。你可以在创建Retrofit对象时添加你需要使用的Converter实现。</p><p>3、Call<t><br>这个接口主要的作用就是发送一个HTTP请求，Retrofit默认的实现是OkHttpCall<t>，你可以根据实际情况实现你自己的Call类。这个设计和Volley的HttpStack接口设计的思想非常相似，子类可以实现基于HttpClient或HttpUrlConnetction的HTTP请求工具。</t></t></p><p>4、CallAdapter<t><br>这个借口的属性只有responseType一个；这个接口的实现类也只有DefaultCallAdapter一个。这个方法的主要作用就是将Call对象转换成另一个对象，为了支持RxJava才设计这个类的吧。</t></p><h3 id="Retrofit的运行过程"><a href="#Retrofit的运行过程" class="headerlink" title="Retrofit的运行过程"></a>Retrofit的运行过程</h3><p>上面讲的案例代码，返回了一个动态代理对象。而执行这段代码时，返回了一个OkHttpCall对象，拿到这个 Call 对象才能真正执行 HTTP 请求。</p><pre><code>ApiManager apiService = retrofit.create(ApiManager.class); //2、retrofit对象创建一个API接口对象Call&lt;LoginResult&gt; call = apiService.getData(&quot;lyk&quot;, &quot;1234&quot;); //返回响应接口回调</code></pre><p>上面代码中 apiService 对象其实是一个动态代理对象。当 apiService 对象调用 getData方法 时会被动态代理拦截，然后调用 Proxy.newProxyInstance 方法中的 InvocationHandler 对象， 创建一个  ServiceMethod对象：</p><pre><code>ServiceMethod serviceMethod = loadServiceMethod(method);OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);return serviceMethod.callAdapter.adapt(okHttpCall);</code></pre><h3 id="创建ServiceMethod"><a href="#创建ServiceMethod" class="headerlink" title="创建ServiceMethod"></a>创建ServiceMethod</h3><p>刚才说到 ServiceMethod 是服务于方法的，具体来看一下创建这个ServiceMethod的过程是怎么样的：<br>首先，获取到上面说到的 Retrofit的接口：</p><pre><code>callAdapter = createCallAdapter();responseType = callAdapter.responseType();responseConverter = createResponseConverter();</code></pre><p>然后，解析Method方法的注解，其实就是想获取Http请求的方法。比如请求方法是GET还是POST形式，如果没有程序就会报错。还会做一系列的检查，比如在方法上注解了@Multipart，但是Http请求方法是GET，同样也会报错。</p><pre><code>for (Annotation annotation : methodAnnotations) {    parseMethodAnnotation(annotation);}if (httpMethod == null) {   throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);}</code></pre><p>其次，比如上面 apiService 接口的方法中带有参数{name,password}，这都占位符，而参数值是在Java方法调用中传入的。那么 Retrofit 会使用一个 ParameterHandler 来进行替换：</p><pre><code>int parameterCount = parameterAnnotationsArray.length;parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];</code></pre><p>最后，ServiceMethod 还会做其他的检查。比如用了 @FormUrlEncoded 注解，那么方法参数中必须至少有一个 @Field 或 @FieldMap。</p><h3 id="执行Http请求"><a href="#执行Http请求" class="headerlink" title="执行Http请求"></a>执行Http请求</h3><p>之前讲到，OkHttpCall是实现了Call接口的，并且是真正调用 OkHttp3 发送Http请求的类。OkHttp3发送一个Http请求需要一个Request对象，而这个Request对象就是从 ServiceMethod 的 toRequest 返回的。</p><p>总之，OkHttpCall 就是调用 ServiceMethod 获得一个可以执行的 Request 对象，然后等到 Http 请求返回后，再将 response body 传入 ServiceMethod 中，ServiceMethod 就可以调用 Converter 接口将 response body 转成一个Java对象。</p><p>综上所述，<strong>ServiceMethod 中几乎保存了一个api请求所有需要的数据，OkHttpCall需要从ServiceMethod中获得一个Request对象，然后得到response后，还需要传入 ServiceMethod 用 Converter 转换成Java对象。</strong></p><p>你可能会觉得我只要发送一个HTTP请求，你要做这么多事情不会很“慢”吗？不会很浪费性能吗？<br>我觉得，首先现在手机处理器主频非常高了，解析这个接口可能就花1ms可能更少的时间（我没有测试过），面对一个HTTP本来就需要几百ms，甚至几千ms来说不值得一提；而且Retrofit会对解析过的请求进行缓存，就在Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;()这个对象中</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Retrofit非常巧妙的用注解来描述一个HTTP请求，将一个HTTP请求抽象成一个Java接口，然后用了Java动态代理的方式，动态的将这个接口的注解“翻译”成一个HTTP请求，最后再执行这个HTTP请求</strong></p><p>Retrofit的功能非常多的依赖Java反射，代码中其实还有很多细节，比如异常的捕获、抛出和处理，大量的Factory设计模式（为什么要这么多使用Factory模式？）</p><p>Retrofit中接口设计的恰到好处，在你创建Retrofit对象时，让你有更多更灵活的方式去处理你的需求，比如使用不同的Converter、使用不同的CallAdapter，这也就提供了你使用RxJava来调用Retrofit的可能</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/csdn_aiyang/article/details/72303367" target="_blank" rel="noopener">Android Retrofit 2.0</a><br><a href="https://blog.csdn.net/jiankeufo/article/details/73186929" target="_blank" rel="noopener">https://blog.csdn.net/jiankeufo/article/details/73186929</a><br><a href="https://www.jianshu.com/p/2e8b400909b7" target="_blank" rel="noopener">https://www.jianshu.com/p/2e8b400909b7</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> retrofit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中的CAS</title>
      <link href="/2019/03/29/java-cas/"/>
      <url>/2019/03/29/java-cas/</url>
      
        <content type="html"><![CDATA[<h4 id="无锁的概念"><a href="#无锁的概念" class="headerlink" title="无锁的概念"></a>无锁的概念</h4><p>加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程序来说，它们总是认为每次访问共享资源时总会发生冲突，因此必须对每一次数据操作实施加锁策略。而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，<strong>无锁策略则采用一种称为CAS的技术来保证线程执行的安全性</strong>，这项CAS技术就是无锁策略实现的关键。</p><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下:</p><blockquote><p>执行函数：CAS(V,E,N)</p></blockquote><p>其包含3个参数:<br>V表示要更新的变量<br>E表示预期值<br>N表示新值<br>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，<strong>当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作</strong>，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作，原理图如下:<br><img src="/2019/03/29/java-cas/cas.png" alt><br>示例如下：</p><pre><code>//加一并返回值public final int incrementAndGet() {        for (;;) {            int current = get();            int next = current + 1;            if (compareAndSet(current, next))                return next;        }   }//返回CAS操作成功与否public final boolean compareAndSet(int expect, int update) {        //根据变量在内存中的偏移地址valueOffset获取原值，然后和预期值except进行比，如果符合，用update值进行更新，这个过程是原子操作        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);    }</code></pre><p>如果此时有两个线程，线程A得到current值为1，线程B得到current值也为2，此时线程A执行CAS操作，成功将值改为2，而此时线程B执行CAS操作，发现此时内存中的值并不是读到current值1，所以返回false，此时线程B继续进行循环，最后成功加1</p><h4 id="CAS的原子性"><a href="#CAS的原子性" class="headerlink" title="CAS的原子性"></a>CAS的原子性</h4><p>或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为<strong>CAS是一种系统原语</strong>，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说<strong>CAS是一条CPU的原子指令</strong>，不会造成所谓的数据不一致问题。</p><h4 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h4><p>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务<br>CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作CAS基于以下3个方法实现：</p><pre><code>//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);                                                                                                  public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x);</code></pre><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://blog.csdn.net/mmoren/article/details/79185862" target="_blank" rel="noopener">JAVA中的CAS</a></p>]]></content>
      
      
      <categories>
          
          <category> 同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中使用RSA/AES加解密</title>
      <link href="/2019/03/29/java-rsa/"/>
      <url>/2019/03/29/java-rsa/</url>
      
        <content type="html"><![CDATA[<p><strong>RSA加密明文最大长度245字节，解密要求密文最大长度为256字节，所以在加密和解密的过程中需要分块进行</strong>。(RSA密钥长度随着保密级别提高，增加很快)<br>RSA加密对明文的长度是有限制的，如果加密数据过大会抛出如下异常：</p><pre><code>Exception in thread &quot;main&quot; javax.crypto.IllegalBlockSizeException: Data must not be longer than 117 bytes  at com.sun.crypto.provider.RSACipher.a(DashoA13*..)  at com.sun.crypto.provider.RSACipher.engineDoFinal(DashoA13*..)  at javax.crypto.Cipher.doFinal(DashoA13*..) </code></pre><p>1.密钥长度<br>rsa算法初始化的时候一般要填入密钥长度,在96-2048bits间<br>(1)为啥下限是96bits(12bytes)?因为加密1byte的明文,需要至少1+11=12bytes的密钥(不懂?看下面的明文长度),低于下限96bits时,一个byte都加密不了,当然没意义啦<br>(2)为啥上限是2048(256bytes)?这是算法本身决定的。另RSA密钥长度随着保密级别提高，增加很快</p><p>2.明文长度<br>明文长度(bytes) &lt;= 密钥长度(bytes)-11.这样的话,对于上限密钥长度1024bits能加密的明文上限就是117bytes了.<br>所以就出现了分片加密,网上很流行这个版本.很简单,如果明文长度大于那个最大明文长度了,我就分片吧,保证每片都别超过那个值就是了.<br>片数=(明文长度(bytes)/(密钥长度(bytes)-11))的整数部分+1,就是不满一片的按一片算</p><p>3.密文长度<br>密文长度等于密钥长度.当然这是不分片情况下的.<br>分片后,密文长度=密钥长度*片数</p><p>例如96bits的密钥,明文4bytes<br>每片明文长度=96/8-11=1byte,片数=4,密文长度=96/8*4=48bytes</p><p>又例如128bits的密钥,明文8bytes<br>每片明文长度=128/8-11=5bytes,片数=8/5取整+1=2,密文长度=128/8*2=32</p><p>注意,对于指定长度的明文,其密文长度与密钥长度非正比关系.如4bytes的明文,在最短密钥96bites是,密文长度48bytes,128bits米密钥时,密文长度为16bytes,1024bits密钥时,密文长度128bytes.<br>因为分片越多,密文长度显然会变大,所以有人说,那就一直用1024bits的密钥吧…拜托,现在的机器算1024bits的密钥还是要点时间滴,别以为你的cpu很牛逼…那么选个什么值比较合适呢?个人认为是600bits,因为我们对于一个字符串的加密,一般不是直接加密,而是将字符串hash 后,对hash值加密.现在的hash值一般都是4bytes,很少有8bytes,几十年内应该也不会超过64bytes.那就用64bytes算吧, 密钥长度就是(64+11)*8=600bits了.</p><p>RSAUtils.java</p><pre><code>package security;import java.io.ByteArrayOutputStream;import java.security.Key;import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PrivateKey;import java.security.PublicKey;import java.security.Signature;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.HashMap;import java.util.Map;import javax.crypto.Cipher;/** *//** * RSA公钥/私钥/签名工具包 *  * 罗纳德·李维斯特（Ron [R]ivest）、阿迪·萨莫尔（Adi [S]hamir）和伦纳德·阿德曼（Leonard [A]dleman） *  * 字符串格式的密钥在未在特殊说明情况下都为BASE64编码格式&lt;br/&gt; * 由于非对称加密速度极其缓慢，一般文件不使用它来加密而是使用对称加密，&lt;br/&gt; * 非对称加密算法可以用来对对称加密的密钥加密，这样保证密钥的安全也就保证了数据的安全 *  * @author IceWee * @date 2012-4-26 * @version 1.0 */public class RSAUtils {    /** *//**     * 加密算法RSA     */    public static final String KEY_ALGORITHM = &quot;RSA&quot;;    /** *//**     * 签名算法     */    public static final String SIGNATURE_ALGORITHM = &quot;MD5withRSA&quot;;    /** *//**     * 获取公钥的key     */    private static final String PUBLIC_KEY = &quot;RSAPublicKey&quot;;    /** *//**     * 获取私钥的key     */    private static final String PRIVATE_KEY = &quot;RSAPrivateKey&quot;;    /** *//**     * RSA最大加密明文大小     */    private static final int MAX_ENCRYPT_BLOCK = 117;    /** *//**     * RSA最大解密密文大小     */    private static final int MAX_DECRYPT_BLOCK = 128;    /** *//**     * 生成密钥对(公钥和私钥)     *      * @return     * @throws Exception     */    public static Map&lt;String, Object&gt; genKeyPair() throws Exception {        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM);        keyPairGen.initialize(1024);        KeyPair keyPair = keyPairGen.generateKeyPair();        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();        Map&lt;String, Object&gt; keyMap = new HashMap&lt;String, Object&gt;(2);        keyMap.put(PUBLIC_KEY, publicKey);        keyMap.put(PRIVATE_KEY, privateKey);        return keyMap;    }    /** *//**     * 用私钥对信息生成数字签名     *      * @param data 已加密数据     * @param privateKey 私钥(BASE64编码)     *      * @return     * @throws Exception     */    public static String sign(byte[] data, String privateKey) throws Exception {        byte[] keyBytes = Base64Utils.decode(privateKey);        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);        PrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec);        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);        signature.initSign(privateK);        signature.update(data);        return Base64Utils.encode(signature.sign());    }    /** *//**     * 校验数字签名     *      * @param data 已加密数据     * @param publicKey 公钥(BASE64编码)     * @param sign 数字签名     *      * @return     * @throws Exception     *      */    public static boolean verify(byte[] data, String publicKey, String sign)            throws Exception {        byte[] keyBytes = Base64Utils.decode(publicKey);        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);        PublicKey publicK = keyFactory.generatePublic(keySpec);        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);        signature.initVerify(publicK);        signature.update(data);        return signature.verify(Base64Utils.decode(sign));    }    /** *//**     * &lt;P&gt;     * 私钥解密     * &lt;/p&gt;     *      * @param encryptedData 已加密数据     * @param privateKey 私钥(BASE64编码)     * @return     * @throws Exception     */    public static byte[] decryptByPrivateKey(byte[] encryptedData, String privateKey)            throws Exception {        byte[] keyBytes = Base64Utils.decode(privateKey);        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);        Key privateK = keyFactory.generatePrivate(pkcs8KeySpec);        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());        cipher.init(Cipher.DECRYPT_MODE, privateK);        int inputLen = encryptedData.length;        ByteArrayOutputStream out = new ByteArrayOutputStream();        int offSet = 0;        byte[] cache;        int i = 0;        // 对数据分段解密        while (inputLen - offSet &gt; 0) {            if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) {                cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);            } else {                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);            }            out.write(cache, 0, cache.length);            i++;            offSet = i * MAX_DECRYPT_BLOCK;        }        byte[] decryptedData = out.toByteArray();        out.close();        return decryptedData;    }    /** *//**     * &lt;p&gt;     * 公钥解密     * &lt;/p&gt;     *      * @param encryptedData 已加密数据     * @param publicKey 公钥(BASE64编码)     * @return     * @throws Exception     */    public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey)            throws Exception {        byte[] keyBytes = Base64Utils.decode(publicKey);        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);        Key publicK = keyFactory.generatePublic(x509KeySpec);        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());        cipher.init(Cipher.DECRYPT_MODE, publicK);        int inputLen = encryptedData.length;        ByteArrayOutputStream out = new ByteArrayOutputStream();        int offSet = 0;        byte[] cache;        int i = 0;        // 对数据分段解密        while (inputLen - offSet &gt; 0) {            if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) {                cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);            } else {                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);            }            out.write(cache, 0, cache.length);            i++;            offSet = i * MAX_DECRYPT_BLOCK;        }        byte[] decryptedData = out.toByteArray();        out.close();        return decryptedData;    }    /** *//**     * &lt;p&gt;     * 公钥加密     * &lt;/p&gt;     *      * @param data 源数据     * @param publicKey 公钥(BASE64编码)     * @return     * @throws Exception     */    public static byte[] encryptByPublicKey(byte[] data, String publicKey)            throws Exception {        byte[] keyBytes = Base64Utils.decode(publicKey);        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);        Key publicK = keyFactory.generatePublic(x509KeySpec);        // 对数据加密        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());        cipher.init(Cipher.ENCRYPT_MODE, publicK);        int inputLen = data.length;        ByteArrayOutputStream out = new ByteArrayOutputStream();        int offSet = 0;        byte[] cache;        int i = 0;        // 对数据分段加密        while (inputLen - offSet &gt; 0) {            if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) {                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);            } else {                cache = cipher.doFinal(data, offSet, inputLen - offSet);            }            out.write(cache, 0, cache.length);            i++;            offSet = i * MAX_ENCRYPT_BLOCK;        }        byte[] encryptedData = out.toByteArray();        out.close();        return encryptedData;    }    /** *//**     * &lt;p&gt;     * 私钥加密     * &lt;/p&gt;     *      * @param data 源数据     * @param privateKey 私钥(BASE64编码)     * @return     * @throws Exception     */    public static byte[] encryptByPrivateKey(byte[] data, String privateKey)            throws Exception {        byte[] keyBytes = Base64Utils.decode(privateKey);        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);        Key privateK = keyFactory.generatePrivate(pkcs8KeySpec);        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());        cipher.init(Cipher.ENCRYPT_MODE, privateK);        int inputLen = data.length;        ByteArrayOutputStream out = new ByteArrayOutputStream();        int offSet = 0;        byte[] cache;        int i = 0;        // 对数据分段加密        while (inputLen - offSet &gt; 0) {            if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) {                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);            } else {                cache = cipher.doFinal(data, offSet, inputLen - offSet);            }            out.write(cache, 0, cache.length);            i++;            offSet = i * MAX_ENCRYPT_BLOCK;        }        byte[] encryptedData = out.toByteArray();        out.close();        return encryptedData;    }    /** *//**     * &lt;p&gt;     * 获取私钥     * &lt;/p&gt;     *      * @param keyMap 密钥对     * @return     * @throws Exception     */    public static String getPrivateKey(Map&lt;String, Object&gt; keyMap)            throws Exception {        Key key = (Key) keyMap.get(PRIVATE_KEY);        return Base64Utils.encode(key.getEncoded());    }    /** *//**     * &lt;p&gt;     * 获取公钥     * &lt;/p&gt;     *      * @param keyMap 密钥对     * @return     * @throws Exception     */    public static String getPublicKey(Map&lt;String, Object&gt; keyMap)            throws Exception {        Key key = (Key) keyMap.get(PUBLIC_KEY);        return Base64Utils.encode(key.getEncoded());    }}</code></pre><p>Base64Utils.java</p><pre><code>package security;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import it.sauronsoftware.base64.Base64;/** *//** * &lt;p&gt; * BASE64编码解码工具包 * &lt;/p&gt; * &lt;p&gt; * 依赖javabase64-1.3.1.jar * &lt;/p&gt; *  * @author IceWee * @date 2012-5-19 * @version 1.0 */public class Base64Utils {    /** *//**     * 文件读取缓冲区大小     */    private static final int CACHE_SIZE = 1024;    /** *//**     * &lt;p&gt;     * BASE64字符串解码为二进制数据     * &lt;/p&gt;     *      * @param base64     * @return     * @throws Exception     */    public static byte[] decode(String base64) throws Exception {        return Base64.decode(base64.getBytes());    }    /** *//**     * &lt;p&gt;     * 二进制数据编码为BASE64字符串     * &lt;/p&gt;     *      * @param bytes     * @return     * @throws Exception     */    public static String encode(byte[] bytes) throws Exception {        return new String(Base64.encode(bytes));    }    /** *//**     * &lt;p&gt;     * 将文件编码为BASE64字符串     * &lt;/p&gt;     * &lt;p&gt;     * 大文件慎用，可能会导致内存溢出     * &lt;/p&gt;     *      * @param filePath 文件绝对路径     * @return     * @throws Exception     */    public static String encodeFile(String filePath) throws Exception {        byte[] bytes = fileToByte(filePath);        return encode(bytes);    }    /** *//**     * &lt;p&gt;     * BASE64字符串转回文件     * &lt;/p&gt;     *      * @param filePath 文件绝对路径     * @param base64 编码字符串     * @throws Exception     */    public static void decodeToFile(String filePath, String base64) throws Exception {        byte[] bytes = decode(base64);        byteArrayToFile(bytes, filePath);    }    /** *//**     * &lt;p&gt;     * 文件转换为二进制数组     * &lt;/p&gt;     *      * @param filePath 文件路径     * @return     * @throws Exception     */    public static byte[] fileToByte(String filePath) throws Exception {        byte[] data = new byte[0];        File file = new File(filePath);        if (file.exists()) {            FileInputStream in = new FileInputStream(file);            ByteArrayOutputStream out = new ByteArrayOutputStream(2048);            byte[] cache = new byte[CACHE_SIZE];            int nRead = 0;            while ((nRead = in.read(cache)) != -1) {                out.write(cache, 0, nRead);                out.flush();            }            out.close();            in.close();            data = out.toByteArray();         }        return data;    }    /** *//**     * &lt;p&gt;     * 二进制数据写文件     * &lt;/p&gt;     *      * @param bytes 二进制数据     * @param filePath 文件生成目录     */    public static void byteArrayToFile(byte[] bytes, String filePath) throws Exception {        InputStream in = new ByteArrayInputStream(bytes);           File destFile = new File(filePath);        if (!destFile.getParentFile().exists()) {            destFile.getParentFile().mkdirs();        }        destFile.createNewFile();        OutputStream out = new FileOutputStream(destFile);        byte[] cache = new byte[CACHE_SIZE];        int nRead = 0;        while ((nRead = in.read(cache)) != -1) {               out.write(cache, 0, nRead);            out.flush();        }        out.close();        in.close();    }}</code></pre><p>RSATester.java</p><pre><code>package security;import java.util.Map;public class RSATester {    static String publicKey;    static String privateKey;    static {        try {            Map&lt;String, Object&gt; keyMap = RSAUtils.genKeyPair();            publicKey = RSAUtils.getPublicKey(keyMap);            privateKey = RSAUtils.getPrivateKey(keyMap);            System.err.println(&quot;公钥: \n\r&quot; + publicKey);            System.err.println(&quot;私钥： \n\r&quot; + privateKey);        } catch (Exception e) {            e.printStackTrace();        }    }    public static void main(String[] args) throws Exception {        test();        testSign();    }    static void test() throws Exception {        System.err.println(&quot;公钥加密——私钥解密&quot;);        String source = &quot;这是一行没有任何意义的文字，你看完了等于没看，不是吗？&quot;;        System.out.println(&quot;\r加密前文字：\r\n&quot; + source);        byte[] data = source.getBytes();        byte[] encodedData = RSAUtils.encryptByPublicKey(data, publicKey);        System.out.println(&quot;加密后文字：\r\n&quot; + new String(encodedData));        byte[] decodedData = RSAUtils.decryptByPrivateKey(encodedData, privateKey);        String target = new String(decodedData);        System.out.println(&quot;解密后文字: \r\n&quot; + target);    }    static void testSign() throws Exception {        System.err.println(&quot;私钥加密——公钥解密&quot;);        String source = &quot;这是一行测试RSA数字签名的无意义文字&quot;;        System.out.println(&quot;原文字：\r\n&quot; + source);        byte[] data = source.getBytes();        byte[] encodedData = RSAUtils.encryptByPrivateKey(data, privateKey);        System.out.println(&quot;加密后：\r\n&quot; + new String(encodedData));        byte[] decodedData = RSAUtils.decryptByPublicKey(encodedData, publicKey);        String target = new String(decodedData);        System.out.println(&quot;解密后: \r\n&quot; + target);        System.err.println(&quot;私钥签名——公钥验证签名&quot;);        String sign = RSAUtils.sign(encodedData, privateKey);        System.err.println(&quot;签名:\r&quot; + sign);        boolean status = RSAUtils.verify(encodedData, publicKey, sign);        System.err.println(&quot;验证结果:\r&quot; + status);    }}</code></pre><h4 id="AES对称加密和解密"><a href="#AES对称加密和解密" class="headerlink" title="AES对称加密和解密"></a>AES对称加密和解密</h4><pre><code>package demo.security;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.Base64;import java.util.Scanner;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.KeyGenerator;import javax.crypto.NoSuchPaddingException;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;/* * AES对称加密和解密 */public class SymmetricEncoder {  /*   * 加密   * 1.构造密钥生成器   * 2.根据ecnodeRules规则初始化密钥生成器   * 3.产生密钥   * 4.创建和初始化密码器   * 5.内容加密   * 6.返回字符串   */    public static String AESEncode(String encodeRules,String content){        try {            //1.构造密钥生成器，指定为AES算法,不区分大小写            KeyGenerator keygen=KeyGenerator.getInstance(&quot;AES&quot;);            //2.根据ecnodeRules规则初始化密钥生成器            //生成一个128位的随机源,根据传入的字节数组            keygen.init(128, new SecureRandom(encodeRules.getBytes()));              //3.产生原始对称密钥            SecretKey original_key=keygen.generateKey();              //4.获得原始对称密钥的字节数组            byte [] raw=original_key.getEncoded();            //5.根据字节数组生成AES密钥            SecretKey key=new SecretKeySpec(raw, &quot;AES&quot;);              //6.根据指定算法AES自成密码器            Cipher cipher=Cipher.getInstance(&quot;AES&quot;);              //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密解密(Decrypt_mode)操作，第二个参数为使用的KEY            cipher.init(Cipher.ENCRYPT_MODE, key);            //8.获取加密内容的字节数组(这里要设置为utf-8)不然内容中如果有中文和英文混合中文就会解密为乱码            byte [] byte_encode=content.getBytes(&quot;utf-8&quot;);            //9.根据密码器的初始化方式--加密：将数据加密            byte [] byte_AES=cipher.doFinal(byte_encode);          //10.将加密后的数据转换为字符串            //这里用Base64Encoder中会找不到包            //解决办法：            //在项目的Build path中先移除JRE System Library，再添加库JRE System Library，重新编译后就一切正常了。            String AES_encode=new String(new BASE64Encoder().encode(byte_AES));          //11.将字符串返回            return AES_encode;        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        } catch (NoSuchPaddingException e) {            e.printStackTrace();        } catch (InvalidKeyException e) {            e.printStackTrace();        } catch (IllegalBlockSizeException e) {            e.printStackTrace();        } catch (BadPaddingException e) {            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        }        //如果有错就返加nulll        return null;             }    /*     * 解密     * 解密过程：     * 1.同加密1-4步     * 2.将加密后的字符串反纺成byte[]数组     * 3.将加密内容解密     */    public static String AESDncode(String encodeRules,String content){        try {            //1.构造密钥生成器，指定为AES算法,不区分大小写            KeyGenerator keygen=KeyGenerator.getInstance(&quot;AES&quot;);            //2.根据ecnodeRules规则初始化密钥生成器            //生成一个128位的随机源,根据传入的字节数组            keygen.init(128, new SecureRandom(encodeRules.getBytes()));              //3.产生原始对称密钥            SecretKey original_key=keygen.generateKey();              //4.获得原始对称密钥的字节数组            byte [] raw=original_key.getEncoded();            //5.根据字节数组生成AES密钥            SecretKey key=new SecretKeySpec(raw, &quot;AES&quot;);              //6.根据指定算法AES自成密码器            Cipher cipher=Cipher.getInstance(&quot;AES&quot;);              //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密(Decrypt_mode)操作，第二个参数为使用的KEY            cipher.init(Cipher.DECRYPT_MODE, key);            //8.将加密并编码后的内容解码成字节数组            byte [] byte_content= new BASE64Decoder().decodeBuffer(content);            /*             * 解密             */            byte [] byte_decode=cipher.doFinal(byte_content);            String AES_decode=new String(byte_decode,&quot;utf-8&quot;);            return AES_decode;        } catch (NoSuchAlgorithmException e) {            e.printStackTrace();        } catch (NoSuchPaddingException e) {            e.printStackTrace();        } catch (InvalidKeyException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } catch (IllegalBlockSizeException e) {            e.printStackTrace();        } catch (BadPaddingException e) {            e.printStackTrace();        }        //如果有错就返加nulll        return null;             }    public static void main(String[] args) {        SymmetricEncoder se=new SymmetricEncoder();        Scanner scanner=new Scanner(System.in);        /*         * 加密         */        System.out.println(&quot;使用AES对称加密，请输入加密的规则&quot;);        String encodeRules=scanner.next();        System.out.println(&quot;请输入要加密的内容:&quot;);        String content = scanner.next();        System.out.println(&quot;根据输入的规则&quot;+encodeRules+&quot;加密后的密文是:&quot;+se.AESEncode(encodeRules, content));        /*         * 解密         */        System.out.println(&quot;使用AES对称解密，请输入加密的规则：(须与加密相同)&quot;);         encodeRules=scanner.next();        System.out.println(&quot;请输入要解密的内容（密文）:&quot;);         content = scanner.next();        System.out.println(&quot;根据输入的规则&quot;+encodeRules+&quot;解密后的明文是:&quot;+se.AESDncode(encodeRules, content));    }}</code></pre><p>测试结果：</p><pre><code>使用AES对称加密，请输入加密的规则使用AES对称加密请输入要加密的内容:使用AES对称加密根据输入的规则使用AES对称加密加密后的密文是:Z0NwrNPHghgXHN0CqjLS58YCjhMcBfeR33RWs7Lw+AY=使用AES对称解密，请输入加密的规则：(须与加密相同)使用AES对称加密请输入要解密的内容（密文）:Z0NwrNPHghgXHN0CqjLS58YCjhMcBfeR33RWs7Lw+AY=根据输入的规则使用AES对称加密解密后的明文是:使用AES对称加密</code></pre><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.cnblogs.com/jiafuwei/p/7054500.html" target="_blank" rel="noopener">java RSA加密解密实现（含分段加密）</a><br><a href="https://www.cnblogs.com/liunanjava/p/4297854.html" target="_blank" rel="noopener">AES对称加密和解密</a><br><a href="https://blog.csdn.net/huangxiaoguo1/article/details/78237359" target="_blank" rel="noopener">Android: AndroidKeyStore 非对称RSA加密解密</a><br><a href="https://www.cnblogs.com/zuge/p/5430362.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuge/p/5430362.html</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RSA </tag>
            
            <tag> AES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android dagger2使用心得</title>
      <link href="/2019/03/22/android-dagger2/"/>
      <url>/2019/03/22/android-dagger2/</url>
      
        <content type="html"><![CDATA[<h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>Scope 是用来确定注入的实例的生命周期的，如果没有使用 Scope 注解，Component 每次调用 Module 中的 provide 方法或 Inject 构造函数生成的工厂时都会创建一个新的实例，而使用 Scope 后可以复用之前的依赖实例。</p><p>在Dagger 2中<br>1、@Singleton可以保持类的单例。<br>2、@ApplicationScope注解的Component类与Applicaiton对象的生命周期一致。<br>3、@ActivityScope注解的Component类与Activity的生命周期一致<br>scope可以给我们带来“<strong>局部单例</strong>”，生命周期取决于scope自己。</p><p>在 Dagger 2 官方文档中我找到一句话，非常清楚地描述了@Scope的原理：<br>When a binding uses a scope annotation, that means that the component object holds a reference to the bound object until the component object itself is garbage-collected.<br>Scope 作用域的本质：Component 间接持有依赖实例的引用，把实例的作用域与 Component 绑定，它们不是同年同月同日生，但是同年同月死。</p><h4 id="自定义-Scope"><a href="#自定义-Scope" class="headerlink" title="自定义@Scope"></a>自定义@Scope</h4><p>对于Android，我们通常会定义一个针对整个Activity的注解,通过仿照@Singleton</p><pre><code>@Scope@Documented@Retention(RUNTIME)public @interface ActivityScope {}</code></pre><p>你可能会发现，这个自定义的@Scope和@Singleton代码完全一样，具有实现单例模式的功能。那干嘛还自定义@Scope，好处如下：</p><blockquote><p>更好的管理ApplicationComponent和Module之间的关系，Component和Component之间的依赖和继承关系。如果关系不匹配，在编译期间会报错，详细下面会介绍。<br>代码可读性，让程序猿更好的了解Module中创建的类实例的使用范围。</p></blockquote><h4 id="使用-Scope的一些经验："><a href="#使用-Scope的一些经验：" class="headerlink" title="使用@Scope的一些经验："></a>使用@Scope的一些经验：</h4><p>1、<strong>@Component关联的@Module中的任何一个@Provides有@scope，则该整个@Component要加上这个scope</strong>。否则在暴露或者注入时（不暴露且不注入时，既不使用它构造对象时，不报错），会有如下错误:</p><pre><code>Error:(13, 1) 错误: cn.xuexuan.newui.di.component.ActivityComponent (unscoped) may not reference scoped bindings:@Singleton @Provides android.app.Activity cn.xuexuan.newui.di.module.ActivityModule.getActivity()</code></pre><p>2、@Component的dependencies与@Component自身的scope不能相同，即<strong>dependencies组件之间的scope不能相同</strong>,否则出现下面错误<br>3、<strong>@Singleton的组件不能依赖其他scope的组件</strong>，但是其他scope的组件可以依赖@Singleton组件。否则出现下面错误<br>4、<strong>没有scope的不能依赖有scope的组件</strong>。否则出现下面错误:</p><pre><code>Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) cannot depend on scoped components:@com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.di.component.MyTestComponentX</code></pre><p>5、<strong>一个component不能同时有多个scope(Subcomponent除外)</strong>，否则出现下面的错误</p><pre><code>Error:Execution failed for task ‘:app:compileDebugJavaWithJavac’.java.lang.IllegalArgumentException: com.android.example.devsummit.archdemo.di.component.MyTestComponent was annotated with more than one @Scope annotation</code></pre><h2 id="Binds"><a href="#Binds" class="headerlink" title="@Binds"></a>@Binds</h2><p>@Binds：可以理解为关联，首先它是跟@Provides使用地方是一样的，不同的在于<strong>@Provides 注解的方法都是有具体实现的，而@Binds修饰的只有方法定义，并没有具体的实现的，在方法定义中方法参数必须是 返回值的实现类</strong>。这样创建实体类的地方就不用在Modules 中实现了，例如：</p><pre><code>@Binds@Singletonabstract AccountManagerDelegate accountManagerDelegate(AccountManagerDelegateImpl delegate);</code></pre><p>Module 中不一定要具体实现，可以用@Binds关联实体，这样在编译过程中会自动创建Fractory 以及实现的，AccountManagerDelegate中还可以使用该Module中 @Provides 提供的实体类</p><h2 id="BindsInstance"><a href="#BindsInstance" class="headerlink" title="@BindsInstance"></a>@BindsInstance</h2><p>Component 可以在<strong>创建 Component 的时候绑定依赖实例</strong>，用以注入。这就是@BindsInstance注解的作用，只能在 Component.Builder 中使用。</p><pre><code>@Modulepublic final class HomeActivityModule {    private final HomeActivity activity;    public HomeActivityModule(HomeActivity activity) {        this.activity = activity;    }    @Provides    @ActivityScope  // 自定义作用域    Activity provideActivity() {        return activity;    }}</code></pre><p>而使用@BindsInstance的话会更加简单:</p><pre><code>@ActivityScope@Componentpublic interface HomeActivityComponent {    @Component.Builder    interface Builder {        @BindsInstance        Builder activity(Activity activity);        HomeActivityComponent build();    }}</code></pre><p>注意在调用build()创建 Component 之前，所有@BindsInstance方法必须先调用。上面例子中 HomeActivityComponent 还可以注入 Activity 类型的依赖，但是不能注入 HomeActivity，因为 <strong>Dagger 2 是使用具体类型作为依据的</strong>（也就是只能使用@Inject Activity activity而不是@Inject HomeActivity activity）。</p><p>如果@BindsInstance方法的参数可能为 null，需要再用@Nullable标记，同时标注 Inject 的地方也需要用@Nullable标记。这时 Builder 也可以不调用@BindsInstance方法，这样 Component 会默认设置 instance 为 null</p><p>注意：<strong>dagger.android</strong> 扩展库可以极大地简化在 Android 项目中使用 Dagger 2 的过程，但是还是有些限制，<strong>SubComponent.Builder 不能自定义 @BindsInstance 方法，SubCompoennt 的 Module 不能有含参数的构造函数</strong>，否则AndroidInjection.inject(this)在创建 SubComponent 时无法成功。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/9703a931c7e7" target="_blank" rel="noopener">Dagger 2 完全解析</a><br><a href="https://blog.csdn.net/mq2553299/article/details/77485800" target="_blank" rel="noopener">打破Dagger2使用窘境：Dagger-Android详解</a>（<a href="https://github.com/qingmei2/Sample_dagger2）" target="_blank" rel="noopener">https://github.com/qingmei2/Sample_dagger2）</a><br><a href="https://github.com/AnyLifeZLB/MVP-Dagger2-Rxjava2" target="_blank" rel="noopener">dagger组件化</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dagger2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP基础</title>
      <link href="/2019/03/20/java-http/"/>
      <url>/2019/03/20/java-http/</url>
      
        <content type="html"><![CDATA[<p>HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。</p><p>为了理解HTTP，我们有必要事先了解一下TCP/IP协议族。其是互联网相关联的协议集合的总称，通常使用的网络就是在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集，除此之外，还包括大家所熟知的FTP，DNS，TCP，UDP，IP等等协议。</p><h4 id="OSI的七层协议"><a href="#OSI的七层协议" class="headerlink" title="OSI的七层协议"></a>OSI的七层协议</h4><p><img src="/2019/03/20/java-http/osi_seven.png" alt><br>其<strong>核心思想就是把数据信息包装起来，即封装：发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去</strong>。值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输线路是怎样的、是否能确保传输送达等问题。</p><p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。<br>下面的图表试图显示不同的TCP/IP和其他的协议在最初OSI（Open System Interconnect）模型中的位置：<br><img src="/2019/03/20/java-http/osi.webp" alt></p><h4 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h4><p>下面的表格比较了两种 HTTP 方法：GET 和 POST<br><img src="http_get_post.png" alt><br>HTTP 请求方法<br><img src="http_method.png" alt></p><h4 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h4><p>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。<br>为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其<strong>特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态</strong>。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。</p><h4 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h4><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到<strong>同时并行发送多个请求</strong>，而不需要一个接一个地等待响应了。<br>比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。<br>可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以<strong>管理状态</strong>了。<br>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。<br>Cookie是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。</p><h5 id="cookie的用途"><a href="#cookie的用途" class="headerlink" title="cookie的用途"></a>cookie的用途</h5><ol><li><p>会话管理<br>1.1 记录用户的登录状态是cookie最常用的用途。通常web服务器会在用户登录成功后下发一个签名来标记session的有效性，这样免去了用户多次认证和登录网站。<br>1.2 记录用户的访问状态，例如导航啊，用户的注册流程啊。</p></li><li><p>个性化信息<br>2.1 Cookie也经常用来记忆用户相关的信息，以方便用户在使用和自己相关的站点服务。例如：ptlogin会记忆上一次登录的用户的QQ号码，这样在下次登录的时候会默认填写好这个QQ号码。<br>2.2 Cookie也被用来记忆用户自定义的一些功能。用户在设置自定义特征的时候，仅仅是保存在用户的浏览器中，在下一次访问的时候服务器会根据用户本地的cookie来表现用户的设置。例如google将搜索设置（使用语言、每页的条数，以及打开搜索结果的方式等等）保存在一个COOKIE里。</p></li><li><p>记录用户的行为<br>最典型的是公司的TCSS系统。它使用Cookie来记录用户的点击流和某个产品或商业行为的操作率和流失率。当然功能可以通过IP或http header中的referrer实现，但是Cookie更精准一些。</p></li></ol><h5 id="WebView中的Cookie机制"><a href="#WebView中的Cookie机制" class="headerlink" title="WebView中的Cookie机制"></a>WebView中的Cookie机制</h5><p>WebView是基于webkit内核的UI控件，相当于一个浏览器客户端。它会在本地维护每次会话的cookie(保存在data/data/package_name/app_WebView/Cookies)<br>数据就保存在Cookies那个文件里，其实是个数据库，把后缀改成.db用数据库打开可以看到里面的表结构，主要有host_key, name, value, path等，host_key其实就是domain.<br>当WebView加载URL的时候,WebView会从本地读取该URL对应的cookie，并携带该cookie与服务器进行通信。WebView通过android.webkit.CookieManager类来维护cookie。CookieManager是 WebView的cookie管理类。</p><h5 id="okhttp中的cookie"><a href="#okhttp中的cookie" class="headerlink" title="okhttp中的cookie"></a>okhttp中的cookie</h5><p>详见之前的文章：<a href="https://zhaoshuming.github.io/2019/02/27/OKHttp%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">OKHttp深入理解</a></p><h5 id="Cookie的缺陷"><a href="#Cookie的缺陷" class="headerlink" title="Cookie的缺陷"></a>Cookie的缺陷</h5><p>cookie会被附加在每个HTTP请求中，所以无形中增加了流量。<br>由于在HTTP请求中的cookie是明文传递的，所以安全性成问题。（除非用HTTPS)<br>Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。</p><h4 id="HTTP报文简介"><a href="#HTTP报文简介" class="headerlink" title="HTTP报文简介"></a>HTTP报文简介</h4><p>HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。</p><h5 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h5><p><img src="/2019/03/20/java-http/message_request.webp" alt><br>请求报文的首部内容由以下数据组成：</p><blockquote><p>请求行 —— 包含用于请求的方法、请求 URI 和 HTTP 版本。<br>首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及RFC里未定义的首部如 Cookie 等）</p></blockquote><p>请求报文的示例，如下：<br><img src="/2019/03/20/java-http/message_request_demo.webp" alt></p><h5 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h5><p><img src="/2019/03/20/java-http/message_response.webp" alt><br>响应报文的首部内容由以下数据组成：</p><blockquote><p>状态行 —— 包含表明响应结果的状态码、原因短语和 HTTP 版本。<br>首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及RFC里未定义的首部如 Cookie 等）</p></blockquote><p>响应报文的示例，如下：<br><img src="/2019/03/20/java-http/message_response_demo.webp" alt></p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>HTTP 状态码的职责是当客户端向服务端发送请求时，描述返回的请求结果。<br>状态码类型:</p><blockquote><p>1XX：Informational(信息性状态码)，接收的请求正在处理<br>2XX：Success(成功状态码)，请求正常处理完毕<br>3XX：Redirection(重定向状态码)，需要进行附加操作以完成请求<br>4XX：Client Error(客户端错误状态码)，服务器无法处理请求<br>5XX：Server Error(服务器错误状态码)，服务器处理请求出错</p></blockquote><h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><p>在TCP/IP协议中，TCP协议<strong>提供可靠的连接服务</strong>，采用三次握手建立一个连接。 </p><p>如下图所示，SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。</p><p><img src="/2019/03/20/java-http/tcp_handshake.jpg" alt><br>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p><p>四次挥手:<br><img src="/2019/03/20/java-http/tcp_handwave.png" alt></p><p>第一次挥手:客户端A发送一个FIN.用来关闭客户A到服务器B的数据传送</p><p>第二次挥手:服务器B收到这个FIN. 它发回一个ACK，确认序号为收到的序号+1。和SYN一样，一个FIN将占用一个序号</p><p>第三次挥手:服务器B关闭与客户端A的连接，发送一个FIN给客户端A</p><p>第四次挥手:客户端A发回ACK报文确认，并将确认序号设置为序号加1</p><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p>我这里简单列举几个:<br>  1、基于连接与无连接;UDP是无连接的，即发送数据之前不需要建立连接</p><p>  2、TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付 ，即不保证可靠交付Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</p><p>  3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</p><p>  4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</p><p>  5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h4><p>目标是改善用户在Web时的速度体验。可以说HTTP 2.0是SPDY的升级版(其实也是基于SPDY设计的)。<br><img src="http_2_1_diff.png" alt></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.jianshu.com/p/8962f1f175e8" target="_blank" rel="noopener">HTTP基础</a><br><a href="https://blog.csdn.net/kelaker/article/details/82751287" target="_blank" rel="noopener">Cookie介绍及在Android中的使用</a><br><a href="https://www.cnblogs.com/qdhxhz/p/8470997.html" target="_blank" rel="noopener">TCP三次握手和四次挥手</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>https加密解析</title>
      <link href="/2019/03/19/java-https/"/>
      <url>/2019/03/19/java-https/</url>
      
        <content type="html"><![CDATA[<p>HTTPS全称为Hypertext Transfer Protocol over Secure Socket Layer，中文含义为“超文本传输安全协议”。</p><p>HTTP协议是没有加密无状态的明文传输协议，如果APP采用HTTP传输数据，则会泄露传输内容，可能被中间人劫持，修改传输的内容。HTTPS相当于HTTP的安全版本，作用如下：</p><blockquote><p>认证用户和服务器，确保数据发送到正确的客户机和服务器；(身份认证)<br>加密数据以防止数据中途被窃取；（内容加密）<br>维护数据的完整性，确保数据在传输过程中不被改变。（数据完整性）</p></blockquote><h2 id="Https通讯原理"><a href="#Https通讯原理" class="headerlink" title="Https通讯原理"></a>Https通讯原理</h2><p>HTTPS是HTTP over SSL/TLS，HTTP是应用层协议，TCP是传输层协议，在应用层和传输层之间，增加了一个安全套接层SSL/TLS：<br><img src="https.png" alt><br>TLS协议主要有五部分：应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS协议本身又是有record协议传输的，record协议的格式如上图最右所示。<br>SSL/TLS层负责客户端和服务器之间的加解密算法协商、密钥交换、通信连接的建立，安全连接的建立过程如下所示：<br><img src="https_hand.jpg" alt><br>简单描述如下：</p><ol><li>浏览器将自己支持的一套加密算法、HASH算法发送给网站。</li><li>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li><li>浏览器获得网站证书之后，开始验证证书的合法性，如果证书信任，则生成一串随机数字作为通讯过程中对称加密的秘钥。然后取出证书中的公钥，将这串数字以及HASH的结果进行加密，然后发给网站。</li><li>网站接收浏览器发来的数据之后，通过私钥进行解密，然后HASH校验，如果一致，则使用浏览器发来的数字串使加密一段握手消息发给浏览器。</li><li>浏览器解密，并HASH校验，没有问题，则握手结束。接下来的传输过程将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li></ol><h2 id="数字证书、CA"><a href="#数字证书、CA" class="headerlink" title="数字证书、CA"></a>数字证书、CA</h2><p>信息安全的基础依赖密码学，密码学涉及算法和密钥，算法一般是公开的，而密钥需要得到妥善的保护，密钥如何产生、分配、使用和回收，这涉及公钥基础设施。</p><p>公钥基础设施（PKI）是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。公钥存储在数字证书中，标准的数字证书一般由可信数字证书认证机构(CA，根证书颁发机构)签发，此证书将用户的身份跟公钥链接在一起。CA必须保证其签发的每个证书的用户身份是唯一的。</p><p>链接关系（证书链）通过注册和发布过程创建，取决于担保级别，链接关系可能由CA的各种软件或在人为监督下完成。PKI的确定链接关系的这一角色称为注册管理中心（RA，也称中级证书颁发机构或者中间机构）。RA确保公钥和个人身份链接，可以防抵赖。如果没有RA，CA的Root 证书遭到破坏或者泄露，由此CA颁发的其他证书就全部失去了安全性，所以现在主流的商业数字证书机构CA一般都是提供三级证书，Root 证书签发中级RA证书，由RA证书签发用户使用的证书。</p><p>X509证书链，左边的是CA根证书，中间的是RA中间机构，右边的是用户：<br><img src="/2019/03/19/java-https/ca.jpg" alt></p><h3 id="pfx格式和-cer格式的区别"><a href="#pfx格式和-cer格式的区别" class="headerlink" title=".pfx格式和.cer格式的区别"></a>.pfx格式和.cer格式的区别</h3><p>购买的证书，格式为.pfx，带有公钥和私钥，附带一个密码。还有一种格式为.cer的证书，这种证书是没有私钥的。 </p><ol><li><p>带有私钥的证书<br>　　由Public Key Cryptography Standards #12，PKCS#12标准定义，包含了公钥和私钥的二进制格式的证书形式，以pfx作为证书文件后缀名(导出私钥,是需要输入密码的)。</p></li><li><p>二进制编码的证书<br>　　证书中没有私钥，DER 编码二进制格式的证书文件，以cer作为证书文件后缀名。</p></li><li><p>Base64编码的证书<br>证书中没有私钥，BASE64 编码格式的证书文件，也是以cer作为证书文件后缀名。</p></li></ol><h2 id="https加密"><a href="#https加密" class="headerlink" title="https加密"></a>https加密</h2><p>加密算法一般分为对称加密与非对称加密。HTTPS一般使用的加密与HASH算法如下：</p><blockquote><p>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，3DES<br>HASH算法：MD5，SHA1，SHA256</p></blockquote><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>客户端与服务器使用相同的密钥对消息进行加密<br>优点：1.加密强度高，很难被破解 2.计算量小，仅为非对称加密计算量的 0.1%<br>缺点：1.无法安全的生成和管理密钥 2.服务器管理大量客户端密钥复杂</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>非对称指加密与解密的密钥为两种密钥。服务器提供公钥，客户端通过公钥对消息进行加密，并由服务器端的私钥对密文进行解密。<br>优点：安全<br>缺点： 1. 性能低下，CPU 计算资源消耗巨大，一次完全的 TLS 握手，密钥交换时的非对称加密解密占了整个握手过程的 90% 以上。而对称加密的计算量只相当于非对称加密的 0.1%，因此如果对应用层使用非对称加密，性能开销过大，无法承受。2. 非对称加密对加密内容长度有限制，不能超过公钥的长度。比如现在常用的公钥长度是 2048 位，意味着被加密消息内容不能超过 256 字节。</p><p>其中<strong>非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性</strong>。</p><p>非对称密钥加密最大的一个问题，就是无法证明公钥本身就是货真价实的公钥。比如，正准备和某台服务器建立非对称密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。<br>为了解决上述问题，可以使用由数字证书认证机构(CA，Certificate Authority)和其相关机关颁发的公开密钥证书。</p><h3 id="Hash算法（摘要算法）"><a href="#Hash算法（摘要算法）" class="headerlink" title="Hash算法（摘要算法）"></a>Hash算法（摘要算法）</h3><p>Hash算法特别的地方在于它是一种<strong>单向算法</strong>，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。</p><p>常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA</p><h3 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h3><p>HTTPS采用对称密钥加密和非对称密钥加密两者并用的混合加密机制，在交换密钥环节使用非对称密钥加密方式（安全地交换在稍后的对称密钥加密中要使用的密钥），之后的建立通信交换报文阶段则使用对称密钥加密方式。</p><p><img src="/2019/03/19/java-https/aes_rsa.png" alt><br>所以，AES+RSA结合才更好，AES加密数据，且密钥随机生成，RSA用对方（服务器）的公钥加密随机生成的AES密钥。传输时要把密文，加密的AES密钥和自己的公钥传给对方（服务器）。对方（服务器）接到数据后，用自己的私钥解密AES密钥，再拿AES密钥解密数据得到明文。这样就综合了两种加密体系的优点。下面代码展示OkHttp添加拦截器实现（要对response.code()做处理，只有在和后台约定好的返回码下才走解密的逻辑，具体看自己的需求）：</p><pre><code>public class DataEncryptInterceptor implements Interceptor {    @Override    public Response intercept(Chain chain) throws IOException {        //请求        Request request = chain.request();        RequestBody oldRequestBody = request.body();        Buffer requestBuffer = new Buffer();        oldRequestBody.writeTo(requestBuffer);        String oldBodyStr = requestBuffer.readUtf8();        requestBuffer.close();        MediaType mediaType = MediaType.parse(&quot;text/plain; charset=utf-8&quot;);        //生成随机AES密钥并用serverPublicKey进行RSA加密        SecretKeySpec appAESKeySpec = EncryptUtils.generateAESKey(256);        String appAESKeyStr = EncryptUtils.covertAESKey2String(appAESKeySpec);        String appEncryptedKey = RSAUtils.encryptDataString(appAESKeyStr, serverPublicKey);        //计算body 哈希 并使用app私钥RSA签名        String appSignature = RSAUtils.signature(oldBodyStr, appPrivateKey);        //随机AES密钥加密oldBodyStr        String newBodyStr = EncryptUtils.encryptAES(appAESKeySpec, oldBodyStr);        RequestBody newBody = RequestBody.create(mediaType, newBodyStr);        //构造新的request        request = request.newBuilder()                .header(&quot;Content-Type&quot;, newBody.contentType().toString())                .header(&quot;Content-Length&quot;, String.valueOf(newBody.contentLength()))                .method(request.method(), newBody)                .header(&quot;appEncryptedKey&quot;, appEncryptedKey)                .header(&quot;appSignature&quot;, appSignature)                .header(&quot;appPublicKey&quot;, appPublicKeyStr)                .build();        //响应        Response response = chain.proceed(request);        if (response.code() == 200) {//只有约定的返回码才经过加密，才需要走解密的逻辑            //获取响应头            String serverEncryptedKey = response.header(&quot;serverEncryptedKey&quot;);            //用app的RSA私钥解密AES加密密钥            String serverDecryptedKey = RSAUtils.decryptDataString(serverEncryptedKey, appPrivateKey);            SecretKeySpec serverAESKeySpec = EncryptUtils.covertString2AESKey(serverDecryptedKey);            //用AES密钥解密oldResponseBodyStr            ResponseBody oldResponseBody = response.body();            String oldResponseBodyStr = oldResponseBody.string();            String newResponseBodyStr = EncryptUtils.decryptAES(serverAESKeySpec, oldResponseBodyStr);            oldResponseBody.close();            //构造新的response            ResponseBody newResponseBody = ResponseBody.create(mediaType, newResponseBodyStr);            response = response.newBuilder().body(newResponseBody).build();        }        response.close();        //返回        return response;    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/alisecurity/p/5939336.html" target="_blank" rel="noopener">https://www.cnblogs.com/alisecurity/p/5939336.html</a><br><a href="https://blog.csdn.net/weixin_35973945/article/details/82021116" target="_blank" rel="noopener">Https原理和实现</a><br><a href="https://www.jianshu.com/p/25525e8180e6" target="_blank" rel="noopener">Android Okhttp网络请求加解密实现方案</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android中使用https</title>
      <link href="/2019/03/18/android-https/"/>
      <url>/2019/03/18/android-https/</url>
      
        <content type="html"><![CDATA[<p>本案例将ca证书放在本地，这里使用.pfx格式的证书</p><h3 id="单向验证"><a href="#单向验证" class="headerlink" title="单向验证"></a>单向验证</h3><p>有两种写法，先展示一种接近okhttp官方写法的方法:</p><pre><code>private void setCertificates(Context context) {    try {        //将ca证书导入输入流        InputStream inputStream = context.getResources().openRawResource(R.raw.aaa);        //keystore添加证书内容和密码        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());        keyStore.load(inputStream, CLIENT_KET_PASSWORD.toCharArray());        //证书工厂类，生成证书        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);        //生成证书，添加别名        keyStore.setCertificateEntry(&quot;test1&quot;, certificateFactory.generateCertificate(inputStream));        //信任管理器工厂        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());        trustManagerFactory.init(keyStore);        //构建一个ssl上下文，加入ca证书格式，与后台保持一致        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);        //参数，添加受信任证书和生成随机数        sslContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());        //获得scoket工厂        SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();        mOkHttpClient.sslSocketFactory(sslSocketFactory);        //设置ip授权认证：如果已经安装该证书，可以不设置，否则需要设置        mOkHttpClient.hostnameVerifier(new HostnameVerifier() {            @Override            public boolean verify(String hostname, SSLSession session) {                return true;            }        });        inputStream.close();    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><p>第二种写法，同样有效:</p><pre><code>private void setCertificates(Context context) {    try {        //将ca证书导入输入流        InputStream inputStream = context.getResources().openRawResource(R.raw.aaa);        //keystore添加证书内容和密码        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());        keyStore.load(inputStream, CLIENT_KET_PASSWORD.toCharArray())        //key管理器工厂        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());        keyManagerFactory.init(keyStore, CLIENT_KET_PASSWORD.toCharArray());        //构建一个ssl上下文，加入ca证书格式，与后台保持一致        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);        //参数，添加受信任证书和生成随机数        sslContext.init(keyManagerFactory.getKeyManagers(), null, new SecureRandom());        //获得scoket工厂        SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();        mOkHttpClient.sslSocketFactory(sslSocketFactory);        //设置ip授权认证：如果已经安装该证书，可以不设置，否则需要设置        mOkHttpClient.hostnameVerifier(new HostnameVerifier() {            @Override            public boolean verify(String hostname, SSLSession session) {                return true;            }        });        inputStream.close();    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><p>值得注意的是，keystore的格式，keystore拓展名对应格式：</p><blockquote><p>JKS:.jks/.ks<br>JCEKS:.jce<br>PKCS12:.p12/.pfx<br>BKS:.bks<br>UBER:.ubr</p></blockquote><p>所以，如果ca证书用的是.pfx，那么可以这样写：</p><pre><code>KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;);</code></pre><p>如果是.cer的话那么，就用:</p><pre><code>KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</code></pre><h3 id="双向验证"><a href="#双向验证" class="headerlink" title="双向验证"></a>双向验证</h3><p>双向验证的前提是，你的app同样生成一个jks的密钥文件，服务器那边会同时有个“cer文件”与之对应。<br>注意： Java平台默认识别jks格式的证书文件，但是android平台只识别bks格式的证书文件，所以这里还需要将jks的文件转成bks</p><p>通过jks文件生成对应的cer文件：</p><blockquote><p>keytool -export -alias test1.jks -file test2.cer -keystore test1.jks -storepass 123456</p></blockquote><p>如果服务端报错keystore文件格式不正确，则我们再将cer文件转换成jks文件：</p><blockquote><p>keytool -import -alias test2.cer -file test2.cer -keystore test3.jks</p></blockquote><p>客户端代码如下：</p><pre><code>private void setCertificates(Context context) {    try {        //将ca证书导入输入流        InputStream inputStream = context.getResources().openRawResource(R.raw.aaa);        //keystore添加证书内容和密码        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());        keyStore.load(inputStream, CLIENT_KET_PASSWORD.toCharArray());        //证书工厂类，生成证书        CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);        //生成证书，添加别名        keyStore.setCertificateEntry(&quot;test1&quot;, certificateFactory.generateCertificate(inputStream));        //信任管理器工厂        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());        trustManagerFactory.init(keyStore);        //双向验证，配置服务器验证客户端的证书        InputStream inputStream1 = context.getResources().openRawResource(R.raw.bbb);        KeyStore keyStore1 = KeyStore.getInstance(KeyStore.getDefaultType());        keyStore1.load(inputStream1, CLIENT_KET_PASSWORD_1.toCharArray());        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());        keyManagerFactory.init(keyStore1, CLIENT_KET_PASSWORD_1.toCharArray());        //构建一个ssl上下文，加入ca证书格式，与后台保持一致        SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);        //参数，添加受信任证书和生成随机数        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());        //获得scoket工厂        SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();        mOkHttpClient.sslSocketFactory(sslSocketFactory);        //设置ip授权认证：如果已经安装该证书，可以不设置，否则需要设置        mOkHttpClient.hostnameVerifier(new HostnameVerifier() {            @Override            public boolean verify(String hostname, SSLSession session) {                return true;            }        });        inputStream.close();    } catch (Exception e) {        e.printStackTrace();    }}</code></pre><h3 id="中间人劫持攻击"><a href="#中间人劫持攻击" class="headerlink" title="中间人劫持攻击"></a>中间人劫持攻击</h3><p>https也不是绝对安全的，如下图所示为中间人劫持攻击，中间人可以获取到客户端与服务器之间所有的通信内容:<br><img src="/2019/03/18/android-https/center_attack.jpg" alt><br>中间人截取客户端发送给服务器的请求，然后伪装成客户端与服务器进行通信;将服务器返回给客户端的内容发送给客户端，伪装成服务器与客户端进行通信。<br>通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。<br>使用中间人攻击手段，必须要让客户端信任中间人的证书，如果客户端不信任，则这种攻击手段也无法发挥作用。</p><p>造成中间人劫持的原因是：<strong>没有对服务端证书及域名做校验或者校验不完整</strong>。下面是错误的写法：<br><img src="/2019/03/18/android-https/unsafe.jpg" alt><br>正确的写法是真正实现TrustManger的checkServerTrusted()，对服务器证书域名进行强校验或者真正实现HostnameVerifier的verify()方法。<br>真正实现TrustManger的checkServerTrusted()代码如下:<br><img src="/2019/03/18/android-https/checkServer.jpg" alt><br>其中serverCert是APP中预埋的服务器端公钥证书</p><p>对服务器证书域名进行强校验:<br><img src="/2019/03/18/android-https/hostname_strict.jpg" alt><br>真正实现HostnameVerifier的verify()方法：<br><img src="/2019/03/18/android-https/hostname_verifier.jpg" alt></p><p>另外一种写法证书锁定，直接用预埋的证书来生成TrustManger，过程如上面介绍okhttp使用https方式</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/yehui928186846/article/details/78321769" target="_blank" rel="noopener">okhttp实现https请求</a><br><a href="https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/CustomTrust.java" target="_blank" rel="noopener">okhttp官方https的api方法</a><br><a href="https://www.cnblogs.com/zery/p/5164795.html" target="_blank" rel="noopener">手机如何抓取HTTPS的请求数据</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MpAndroidChart实现多点的特殊标记</title>
      <link href="/2019/03/12/mpchart-point-label/"/>
      <url>/2019/03/12/mpchart-point-label/</url>
      
        <content type="html"><![CDATA[<p>最近在开发时遇到这样一种需求，为一些特殊点显示标签，类似默认显示多个markview。如下图（demo）：</p><p><img src="/2019/03/12/mpchart-point-label/chart_label.png" alt><br>在网上并没有相关资料，在此做下记录分享</p><p>下面上代码:</p><p>首先创建一个类继承LineChart,重写init()方法：</p><pre><code>@Overrideprotected void init() {    super.init();    //获取屏幕宽度,上图最边上标签，会根据屏幕宽度适配    WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);    DisplayMetrics metrics = new DisplayMetrics();    wm.getDefaultDisplay().getMetrics(metrics);    mRenderer = new HbFundLineChartRenderer(this, mAnimator, mViewPortHandler, metrics.widthPixels);}</code></pre><p>接下来是主要内容,也就是自己实现的LineChartRenderer即渲染器,用来画点、线等.<br>首先是一些变量,分别是标记控件的宽高边距等,这里写的是一些根据我们需求来的默认值：</p><pre><code>private int mWidth;//屏幕宽度,在构造方法中传进来赋值private float hViewLength = Utils.convertDpToPixel(30f);//vie宽30dpprivate float vViewLength = Utils.convertDpToPixel(20f);//view高20dpprivate float viewRect= Utils.convertDpToPixel(4f);//矩形高低差</code></pre><p>然后,在LineChartRenderer中有一个drawValues,它是主要负责根据值来画点的,我们要做的就是在super()之后加上我们自己的东西：</p><pre><code>@Overridepublic void drawValues(Canvas c) {    super.drawValues(c);    if (isShowLabel) {        LineDataSet dataSetByIndex = (LineDataSet) mChart.getLineData().getDataSetByIndex(0);        Transformer trans = mChart.getTransformer(dataSetByIndex.getAxisDependency());        Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);//抗锯齿画笔        paint.setTextSize(Utils.convertDpToPixel(textSixe));//设置字体大小        //画首中尾三个label        float[] firstFloat = getFloat(dataSetByIndex.getValues(), 0);//根据数据集获取点        drawPointLabel(trans, paint, c, firstFloat);        float[] middleFloat = getFloat(dataSetByIndex.getValues(), (dataSetByIndex.getValues().size() - 1) / 2);        drawPointLabel(trans, paint, c, middleFloat);        float[] endFloat = getFloat(dataSetByIndex.getValues(), dataSetByIndex.getValues().size() - 1);        drawPointLabel(trans, paint, c, endFloat);    }}</code></pre><p>首先获取点的数据集,然后得到Transformer,它可以根据点数据集里的某一点来得到这个点在屏幕中的位置<br>然后分别传入transformer、画笔、画布对象、点,进行绘制：</p><pre><code>private void drawPointLabel(Transformer trans, Paint paint, Canvas c, float[] floatPosition) {    MPPointD maxPoint = trans.getPixelForValues(floatPosition[0], floatPosition[1]);    float highX = (float) maxPoint.x;    float highY = (float) maxPoint.y;    TextView view = (TextView) LayoutInflater.from(mContext).inflate(R.layout.mark_view, null, false);    if (highX &gt; mWidth - mWidth / 4) {//标识朝左        view.setBackgroundResource(R.mipmap.sm_lable_bg_buy_r);        Bitmap bitmap = createBitmap(view, (int) hViewLength, (int) vViewLength);        c.drawBitmap(bitmap, (int) (highX - hViewLength), (int) (highY - vViewLength - viewRect), paint);    } else if (highX &lt; mWidth / 4) {//标识朝右        view.setBackgroundResource(R.mipmap.sm_lable_bg_buy_l);        Bitmap bitmap = createBitmap(view, (int) hViewLength, (int) vViewLength);        c.drawBitmap(bitmap, (int) (highX), (int) (highY - vViewLength - viewRect), paint);    } else {//标识居中        view.setBackgroundResource(R.mipmap.sm_lable_bg_buy_c);        Bitmap bitmap = createBitmap(view, (int) hViewLength, (int) vViewLength);        c.drawBitmap(bitmap, (int) (highX - hViewLength / 2), (int) (highY - vViewLength - viewRect), paint);    }}</code></pre><p>此处，我们随意定义几个点，可以根据实际需求进行设置：</p><pre><code>private float[] getFloat(List&lt;Entry&gt; lists, int index) {    float[] maxEntry = new float[2];    maxEntry[0] = lists.get(index).getX();    maxEntry[1] = lists.get(index).getY();    return maxEntry;}</code></pre><p>view转bitmap方法如下：</p><pre><code>private Bitmap createBitmap(View v, int width, int height) {    //测量使得view指定大小    int measuredWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY);    int measuredHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY);    v.measure(measuredWidth, measuredHeight);    //调用layout方法布局后，可以得到view的尺寸大小    v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());    Bitmap bmp = Bitmap.createBitmap(v.getWidth(), v.getHeight(), Bitmap.Config.ARGB_8888);    Canvas c = new Canvas(bmp);    v.draw(c);    return bmp;}</code></pre><p>最后附上<a href="https://github.com/zhaoshuming/TestAcharView" target="_blank" rel="noopener">代码（内部测试demo，多余功能请忽略）</a></p><p>参考资料：<br><a href="https://www.jianshu.com/p/1877b8c2fc6c" target="_blank" rel="noopener">https://www.jianshu.com/p/1877b8c2fc6c</a></p>]]></content>
      
      
      <categories>
          
          <category> Android UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chart </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Lock</title>
      <link href="/2019/03/07/java-reentrantlock/"/>
      <url>/2019/03/07/java-reentrantlock/</url>
      
        <content type="html"><![CDATA[<p>synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？</p><p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁会有三种情况：</p><blockquote><p>1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有<br>2）线程执行发生异常，此时JVM会让线程自动释放锁<br>3）这个主要是在等待唤醒机制里面的wait()方法，在等待的时候立即释放锁，方便其他的线程使用锁。</p></blockquote><p>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此<strong>我们需要不论程序的代码块执行的如何最终都将锁对象进行释放，方便其他线程的执行</strong>。</p><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，同时为了更好地释放锁。为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。</p><p>总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点：</p><blockquote><p>1）<strong>Lock不是Java语言内置的</strong>，synchronized是Java语言的关键字，因此是内置特性。<br>2）synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，<strong>lock是通过代码实现的，必须要手动释放锁</strong><br>3）在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在<strong>资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态</strong><br>4）<strong>Lock可以让等待锁的线程响应中断</strong>，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；<br>5）通过<strong>Lock可以知道有没有成功获取锁</strong>，而synchronized却无法办到。<br>6）Lock可以<strong>提高多个线程进行读操作的效率</strong>。</p></blockquote><h2 id="locks包结构"><a href="#locks包结构" class="headerlink" title="locks包结构"></a>locks包结构</h2><p>java.util.concurrent.locks包为锁和等待条件提供一个框架的接口和类，结构如下图所示：</p><p><img src="/2019/03/07/java-reentrantlock/lock.png" alt></p><ol><li><p>Lock和ReadWriteLock是两大锁根接口，Lock代表实现类是ReentrantLock（可重入锁），ReadWriteLock（读写锁）的代表实现类是ReentrantReadWriteLock。<br>Lock 接口支持那些语义不同（重入、公平等）的锁规则，可以在非阻塞式结构的上下文（包括 hand-over-hand 和锁重排算法）中使用这些规则。主要的实现是 ReentrantLock。<br>ReadWriteLock 接口以类似方式定义了一些读取者可以共享而写入者独占的锁。此包只提供了一个实现，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。</p></li><li><p><strong>Condition 接口描述了可能会与锁有关联的条件变量</strong>。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</p></li></ol><h2 id="Lock的使用"><a href="#Lock的使用" class="headerlink" title="Lock的使用"></a>Lock的使用</h2><p>下面我们就来探讨一下java.util.concurrent.locks包中常用的类和接口。通过查看Lock的源码可知，Lock是一个接口：</p><pre><code>public interface Lock {    void lock();    void lockInterruptibly() throws InterruptedException;    boolean tryLock();    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;    void unlock();    Condition newCondition();}</code></pre><p>由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><pre><code>Lock lock = ...;lock.lock();try{    //处理任务}catch(Exception ex){}finally{    lock.unlock();   //释放锁}</code></pre><p>tryLock()方法是有返回值的，它表示用<strong>来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false</strong>，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。<br>tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><pre><code>Lock lock = ...;if(lock.tryLock()) {     try{         //处理任务     }catch(Exception ex){     }finally{         lock.unlock();   //释放锁     } }else {    //如果不能获取锁，则直接做其他事情}</code></pre><p>lockInterruptibly()方法比较特殊，当通过这个方法去<strong>获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态</strong>。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。<br>由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。因此lockInterruptibly()一般的使用形式如下：</p><pre><code>public void method() throws InterruptedException {    lock.lockInterruptibly();    try {       //.....    }catch (InterruptedException e){      }    finally {        lock.unlock();    }  }</code></pre><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。调用interrupt()方法不能中断正在运行过程中的线程，<strong>只能中断阻塞过程中的线程</strong>。<br>因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有在进行等待的情况下，是可以响应中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock，意思是“可重入锁”。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。</p><p>ReentrantLock的类图如下：<br><img src="/2019/03/07/java-reentrantlock/reentrantlock.png" alt><br>ReentrantLock的内部类Sync继承了AQS(AQS根本上是通过一个双向队列来实现的;线程构造成一个节点，一个线程先尝试获得锁，如果获取锁失败，就将该线程加到队列尾部)，<strong>分为公平锁FairSync和非公平锁NonfairSync</strong>。公平锁的获取，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock的公平与否，可以通过它的构造函数来决定。</p><p>在获取锁的tryAcquire（）方法中，非公平锁与公平锁唯一不同是多了以下判断hasQueuedPredecessors()。该方法主要是对同步队列中当前节点是否有前驱节点进行判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。方法如下：</p><pre><code>public final boolean hasQueuedPredecessors() {    // The correctness of this depends on head being initialized    // before tail and on head.next being accurate if the current    // thread is first in queue.    // 同步队列尾节点    Node t = tail; // Read fields in reverse initialization order    // 同步队列头节点    Node h = head;    Node s;    return h != t &amp;&amp;        ((s = h.next) == null || s.thread != Thread.currentThread());}</code></pre><p>事实上，<strong>公平锁往往没有非公平锁的效率高</strong>，但是，并不是任何场景都是以TPS作为唯一指标，<strong>公平锁能够减少“饥饿”发生的概率，等待越久的请求越能够得到优先满足</strong>。</p><p>平锁与非公平锁相比，耗时更多，线程上下文切换次数更多。公平锁保证了锁的获取按照FIFO原则，而代价则是进行大量的线程切换。非<strong>公平锁虽然可能导致线程饥饿，但却有极少的线程切换，保证了其更大的吞吐量</strong>。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>同jdk中的等待/通知机制类似，只不过Condition是用在重入锁这里的。有了Condition，线程就可以在合适的时间等待，在合适的时间继续执行。</p><p>Condition接口包含以下方法：</p><pre><code>// 让当前线程等待，并释放锁void await() throws InterruptedException;// 和await类似，但在等待过程中不会相应中断void awaitUninterruptibly();long awaitNanos(long nanosTimeout) throws InterruptedException;boolean await(long time, TimeUnit unit) throws InterruptedException;boolean awaitUntil(Date deadline) throws InterruptedException;// 唤醒等待中的线程void signal();// 唤醒等待中的所有线程void signalAll();</code></pre><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p><pre><code>public interface ReadWriteLock {    Lock readLock();    Lock writeLock();}</code></pre><p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock实现了ReadWriteLock接口。ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</p><p>thread1和thread2<strong>可以同时进行读操作</strong>，这样就大大提升了读操作的效率。</p><p>不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p><h2 id="锁的相关概念"><a href="#锁的相关概念" class="headerlink" title="锁的相关概念"></a>锁的相关概念</h2><ol><li><p>可重入锁<br>&#160;&#160;&#160;&#160;如果锁具备可重入性，则称作为可重入锁。像synchronized和Lock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。<br>&#160;&#160;&#160;&#160;我们在之前文章已经讲解过，详见： <a href="https://zhaoshuming.github.io/2019/03/01/Java-Synchronized/" target="_blank" rel="noopener">Java Synchronized探究</a></p></li><li><p>可中断锁<br>&#160;&#160;&#160;&#160;顾名思义，就是可以相应中断的锁。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。<br>&#160;&#160;&#160;&#160;前面的lockInterruptibly()已经体现了Lock的可中断性。</p></li><li><p>公平锁<br>&#160;&#160;&#160;&#160;公平锁即<strong>尽量以请求锁的顺序来获取锁</strong>。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。<br>&#160;&#160;&#160;&#160;非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br>&#160;&#160;&#160;&#160;在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。<br>&#160;&#160;&#160;&#160;而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p></li><li><p>读写锁<br>&#160;&#160;&#160;&#160;读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。<br>&#160;&#160;&#160;&#160;ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。</p></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/dolphin0520/p/3923167.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3923167.html</a><br><a href="https://blog.csdn.net/chengyuqiang/article/details/79181229" target="_blank" rel="noopener">https://blog.csdn.net/chengyuqiang/article/details/79181229</a><br><a href="https://www.cnblogs.com/fuck1/p/5432806.html" target="_blank" rel="noopener">https://www.cnblogs.com/fuck1/p/5432806.html</a><br><a href="https://blog.csdn.net/qq_38293564/article/details/80515718#t3" target="_blank" rel="noopener">https://blog.csdn.net/qq_38293564/article/details/80515718#t3</a><br><a href="https://blog.csdn.net/i_am_kop/article/details/80958856" target="_blank" rel="noopener">https://blog.csdn.net/i_am_kop/article/details/80958856</a></p>]]></content>
      
      
      <categories>
          
          <category> 同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的volatile</title>
      <link href="/2019/03/04/java-volatile/"/>
      <url>/2019/03/04/java-volatile/</url>
      
        <content type="html"><![CDATA[<p>volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。同synchronized相比（synchronized通常称为重量级锁），volatile更轻量级。</p><p>volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>首先来看看如下代码</p><pre><code>public class TestVolatile {    boolean status = false;    /**     * 状态切换为true     */    public void changeStatus(){        status = true;    }    /**     * 若状态为true，则running。     */    public void run(){        if(status){            System.out.println(&quot;running....&quot;);        }    }}</code></pre><p>上面这个例子，在多线程环境里，假设线程1执行changeStatus()方法后,线程2运行run()方法，可以保证输出”running…..”吗？答案是NO! 因为对于共享变量status来说，线程A的修改，对于线程B来讲，是”不可见”的。也就是说，线程B此时可能无法观测到status已被修改为true。那么什么是可见性呢？<br>所谓<strong>可见性，是指当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的</strong>。很显然，上述的例子中是没有办法做到内存可见性的。</p><p>java虚拟机有自己的内存模型（Java Memory Model，JMM），<strong>JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果</strong>。</p><p>JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：<strong>共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量</strong>。这三者之间的交互关系如下<br><img src="/2019/03/04/java-volatile/volatile_memory.png" alt><br>需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。当然如果是出于理解的目的，这样对应起来也无不可。</p><p>大概了解了JMM的简单定义后，问题就很容易理解了，对于普通的共享变量来讲，比如我们上文中的status，线程1将其修改为true这个动作发生在线程1的本地内存中，此时还未同步到主内存中去；而线程2缓存了status的初始值false，此时可能没有观测到status的值被修改了，所以就导致了上述的问题。那么这种共享变量在多线程模型中的不可见性如何解决呢？比较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了。比较合理的方式其实就是volatile</p><p>volatile具备两种特性：</p><blockquote><p>1.<strong>保证此变量对所有的线程的可见性</strong>。 当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去，这个写会操作会导致其他线程中的缓存无效<br>2.<strong>禁止指令重排序优化</strong>。 有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置；指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）</p></blockquote><p>上面的例子只需将status声明为volatile，即可保证在线程A将其修改为true时，线程B可以立刻得知</p><pre><code>volatile boolean status = false;</code></pre><ol><li>可见性：</li></ol><p>　　通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p><p>　　<strong>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的</strong>。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p><p>　　在Java 中 volatile、synchronized 和 final 实现可见性。</p><ol start="2"><li>原子性：</li></ol><p>　　<strong>原子是世界上的最小单位，具有不可分割性</strong>。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。再比如y = x;实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p><p>　　在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p><ol start="3"><li>有序性：</li></ol><p>　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，<strong>volatile 是因为其本身包含“禁止指令重排序”</strong>的语义，<strong>synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”</strong>这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</p><h2 id="Volatile原理"><a href="#Volatile原理" class="headerlink" title="Volatile原理"></a>Volatile原理</h2><p>　　Java语言提供了一种稍弱的同步机制，即volatile变量，用来<strong>确保将变量的更新操作通知到其他线程</strong>。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此<strong>不会将该变量上的操作与其他内存操作一起重排序</strong>。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>　　在<strong>访问volatile变量时不会执行加锁操作</strong>，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p><p>　　当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。</p><p>　　而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过上图的 CPU cache 这一步。</p><p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p><h2 id="留意复合类操作"><a href="#留意复合类操作" class="headerlink" title="留意复合类操作"></a>留意复合类操作</h2><p>需要注意的是，我们一直在拿volatile和synchronized做对比，仅仅是因为这两个关键字在某些内存语义上有共通之处，volatile并不能完全替代synchronized，它依然是个轻量级锁，在很多场景下，volatile并不能胜任。看下这个例子：</p><pre><code>public class Counter {    public static volatile int num = 0;    //使用CountDownLatch来等待计算线程执行完    static CountDownLatch countDownLatch = new CountDownLatch(30);    public static void main(String []args) throws InterruptedException {        //开启30个线程进行累加操作        for(int i=0;i&lt;30;i++){            new Thread(){                public void run(){                    for(int j=0;j&lt;10000;j++){                        num++;//自加操作                    }                    countDownLatch.countDown();                }            }.start();        }        //等待计算线程执行完        countDownLatch.await();        System.out.println(num);    }}</code></pre><p>执行结果： 238921</p><p>针对这个示例，一些同学可能会觉得疑惑，如果用volatile修饰的共享变量可以保证可见性，那么结果不应该是300000么?</p><p>问题就出在num++这个操作上，因为<strong>num++不是个原子性的操作，而是个复合操作</strong>。我们可以简单讲这个操作理解为由这三步组成:</p><p>　　1.读取</p><p>　　2.加一</p><p>　　3.赋值</p><p>所以，在多线程环境下，有可能线程A将num读取到本地内存中，此时其他线程可能已经将num增大了很多，线程A依然对过期的num进行自加，重新写到主存中，最终导致了num的结果不合预期，而是小于30000。</p><h2 id="解决num-操作的原子性问题"><a href="#解决num-操作的原子性问题" class="headerlink" title="解决num++操作的原子性问题"></a>解决num++操作的原子性问题</h2><p>针对num++这类复合类的操作，<strong>可以使用java并发包中的原子操作类原子操作类是通过循环CAS的方式来保证其原子性的</strong>。</p><pre><code>public class Counter {　　//使用原子操作类    public static AtomicInteger num = new AtomicInteger(0);    //使用CountDownLatch来等待计算线程执行完    static CountDownLatch countDownLatch = new CountDownLatch(30);    public static void main(String []args) throws InterruptedException {        //开启30个线程进行累加操作        for(int i=0;i&lt;30;i++){            new Thread(){                public void run(){                    for(int j=0;j&lt;10000;j++){                        num.incrementAndGet();//原子性的num++,通过循环CAS方式                    }                    countDownLatch.countDown();                }            }.start();        }        //等待计算线程执行完        countDownLatch.await();        System.out.println(num);    }}</code></pre><p>执行结果: 300000</p><h2 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h2><p>volatile还有一个特性：禁止指令重排序优化。</p><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。但是重排序也需要遵守一定规则：</p><p>  <strong>1.重排序操作不会对存在数据依赖关系的操作进行重排序。</strong></p><p>　　　　比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</p><p><strong>2.重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</strong></p><p>　　　　比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</p><p>　　重排序在单线程模式下是一定会保证最终结果的正确性，但是在多线程环境下，问题就出来了，来开个例子，我们对第一个TestVolatile的例子稍稍改进，再增加个共享变量a</p><pre><code>public class TestVolatile {    int a = 1;    boolean status = false;    /**     * 状态切换为true     */    public void changeStatus(){        a = 2;//1        status = true;//2    }    /**     * 若状态为true，则running。     */    public void run(){        if(status){//3            int b = a+1;//4            System.out.println(b);        }    }}</code></pre><p>假设线程A执行changeStatus后，线程B执行run，我们能保证在4处，b一定等于3么？ 答案依然是无法保证！<br>上面我们提到过，为了提供程序并行度，编译器和处理器可能会对指令进行重排序，而上例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</p><p>使用volatile关键字修饰共享变量便可以禁止这种重排序。<strong>若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</strong></p><p>　　volatile禁止指令重排序也有一些规则，简单列举一下：</p><pre><code>　　1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序　　2.当地一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序　　3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序</code></pre><h2 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h2><p>ynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p><blockquote><p>1）对变量的写操作不依赖于当前值<br>2）该变量没有包含在具有其他变量的不变式中</p></blockquote><p>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>事实上，我的理解就是上面的2个条件<strong>需要保证操作是原子性操作</strong>，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>下面代码显示了一个非线程安全的数值范围类。它包含了一个不变式 —— 下界总是小于或等于上界：</p><pre><code>@NotThreadSafe public class NumberRange {    private int lower, upper;    public int getLower() { return lower; }    public int getUpper() { return upper; }    public void setLower(int value) {         if (value &gt; upper)             throw new IllegalArgumentException(...);        lower = value;    }    public void setUpper(int value) {         if (value &lt; lower)             throw new IllegalArgumentException(...);        upper = value;    }}</code></pre><p>这种方式限制了范围的状态变量，因此将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全；从而仍然需要使用同步。否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是 (0, 5)，同一时间内，线程 A 调用 setLower(4) 并且线程 B 调用 setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是 (4, 3) —— 一个无效值。至于针对范围的其他操作，我们需要使 setLower() 和 setUpper() 操作原子化 —— 而将字段定义为 volatile 类型是无法实现这一目的的。</p><p>　　下面列举几个Java中使用volatile的几个场景。</p><p>1.状态标记量</p><pre><code>volatile boolean flag = false;while(!flag){    doSomething();}public void setFlag() {    flag = true;}volatile boolean inited = false;//线程1:context = loadContext();  inited = true;            //线程2:while(!inited ){sleep()}doSomethingwithconfig(context);    </code></pre><p>2.double check</p><pre><code>class Singleton{    private volatile static Singleton instance = null;    private Singleton() {    }    public static Singleton getInstance() {        if(instance==null) {            synchronized (Singleton.class) {                if(instance==null)                    instance = new Singleton();            }        }        return instance;    }}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　简单总结下，volatile是一种轻量级的同步机制，它主要有两个特性：<strong>一是保证共享变量对所有线程的可见性；二是禁止指令重排序优化</strong>。同时需要注意的是，volatile对于单个的共享变量的读/写具有原子性，但是像num++这种复合操作，volatile无法保证其<strong>原子性</strong>，当然文中也提出了解决方案，就是使用并发包中的原子操作类，通过循环CAS地方式来保证num++操作的原子性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhengbin/p/5654805.html</a><br><a href="https://www.cnblogs.com/chengxiao/p/6528109.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6528109.html</a><br><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">不变式举例</a></p>]]></content>
      
      
      <categories>
          
          <category> 同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Synchronized探究</title>
      <link href="/2019/03/01/Java-Synchronized/"/>
      <url>/2019/03/01/Java-Synchronized/</url>
      
        <content type="html"><![CDATA[<p>在java中，每一个对象都有一把内置锁，当程序中的某一块代码被同步块包起来的时候（synchronized(this){…}），相当于电脑用this指向的对象的内置锁把这块代码锁起来了，只有拥有能解开着这把锁钥匙的线程才能进入到同步块，其他的线程只能在同步块外面排队，只有等拥有钥匙的人执行完同步块归还钥匙的时候，电脑在把钥匙随机分配给外面等待的一个线程。</p><p>根据锁的对象不同可以分为两种：<strong>对象锁和类锁</strong>，对象锁指的是java中的实例对象，类锁指的是Class对象（说到底，不管是对象锁还是类锁，其实锁的都是对象，只是<strong>类锁锁的对象是全局唯一的</strong>；类锁如static函数和class literals）。但归根结底还是<strong>一个对象对应一把内置锁</strong>。</p><p>需要明确的几个问题：</p><ol><li>synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果 再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。</li><li>无论synchronized关键字加在方法上还是对象上，它<strong>取得的锁都是对象</strong>，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。</li><li><strong>每个对象只有一个锁（lock）与之相关联</strong>。被synchronized修饰的方法被锁的对象不同，则实际运行中线程之间互不干扰。</li><li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制</li><li>synchronized在修饰方法的时候如果没有使用“（）”指明被锁的对象，默认是调用这个方法的对象</li></ol><h2 id="synchronized-代码块"><a href="#synchronized-代码块" class="headerlink" title="synchronized 代码块"></a>synchronized 代码块</h2><p>若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。Java 为我们提供了更好的解决办法，那就是 synchronized 块。<br>除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象。<br>这时锁就是对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁：</p><pre><code>class Foo implements Runnable {       private byte[] lock = new byte[0]; // 特殊的instance变量           Public void methodA() {               synchronized(lock) { //… }       }       //…..}</code></pre><p>注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。</p><h2 id="synchronized-静态方法"><a href="#synchronized-静态方法" class="headerlink" title="synchronized 静态方法"></a>synchronized 静态方法</h2><p>将synchronized作用于static 函数，示例代码如下：</p><pre><code>Class Foo {  // 同步的static 函数  public synchronized static void methodAAA()  {  //….  }  public void methodBBB() {       synchronized(Foo.class)   // class literal(类名称字面常量)  }    }</code></pre><p>代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。</p><h2 id="synchronized底层原理"><a href="#synchronized底层原理" class="headerlink" title="synchronized底层原理"></a>synchronized底层原理</h2><p>Java 虚拟机中的同步(Synchronization)基于进入和退出Monitor对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。同步方法是由方法调用指令读取运行时常量池中方法表结构的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。</p><p>同步代码块：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。<strong>任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态</strong>。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例变量和填充数据。如下：<br><img src="/2019/03/01/Java-Synchronized/heap-memory.png" alt><br>实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。</p><p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。</p><p>对象头：Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。</p><p>Mark Word：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。</p><p>Monitor：我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，<strong>每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表</strong>。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：<br><img src="/2019/03/01/Java-Synchronized/monitor.png" alt><br>Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；<br>EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。<br>RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。<br>Nest:用来实现重入锁的计数。<br>HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。<br>Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</p><h3 id="Java虚拟机对synchronize的优化："><a href="#Java虚拟机对synchronize的优化：" class="headerlink" title="Java虚拟机对synchronize的优化："></a>Java虚拟机对synchronize的优化：</h3><p>锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段。</p><ol><li>偏向锁<br>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，<strong>在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能</strong>。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</li><li>轻量级锁<br>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“<strong>对绝大部分的锁，在整个同步周期内都不存在竞争</strong>”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</li><li>自旋锁<br>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于<strong>在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失</strong>，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此<strong>虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)</strong>，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</li><li>锁消除<br>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，<strong>去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间</strong>，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。</li><li><p>锁膨胀<br>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。 如果虚拟机探测到有这样<strong>一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（膨胀）到整个操作序列的外部</strong>（由多次加锁编程只加锁一次）。</p><pre><code>/*** 消除StringBuffer同步锁* /public class StringBufferRemoveSync {    public void add(String str1, String str2) {        //StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用        //因此sb属于不可能共享的资源,JVM会自动消除内部的锁        StringBuffer sb = new StringBuffer();        sb.append(str1).append(str2);    }    public static void main(String[] args) {        StringBufferRemoveSync rmsync = new StringBufferRemoveSync();        for (int i = 0; i &lt; 10000000; i++) {            rmsync.add(&quot;abc&quot;, &quot;123&quot;);        }    }}</code></pre><p><img src="/2019/03/01/Java-Synchronized/java_synchronized.png" alt title="锁关系图"></p></li></ol><h3 id="synchronize的可重入性："><a href="#synchronize的可重入性：" class="headerlink" title="synchronize的可重入性："></a>synchronize的可重入性：</h3><p>从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但<strong>当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的</strong>，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。如下：</p><pre><code>public class AccountingSync implements Runnable{    static AccountingSync instance=new AccountingSync();    static int i=0;    static int j=0;    @Override    public void run() {        for(int j=0;j&lt;1000000;j++){            //this,当前实例对象锁            synchronized(this){                i++;                increase();//synchronized的可重入性            }        }    }    public synchronized void increase(){        j++;    }    public static void main(String[] args) throws InterruptedException {        Thread t1=new Thread(instance);        Thread t2=new Thread(instance);        t1.start();t2.start();        t1.join();t2.join();        System.out.println(i);    }}</code></pre><p>正如代码所演示的，在获取当前实例对象锁后进入synchronized代码块执行同步代码，并在代码块中调用了当前实例对象的另外一个synchronized方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现，需要特别注意另外一种情况，当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意<strong>由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1</strong>。</p><h3 id="线程中断："><a href="#线程中断：" class="headerlink" title="线程中断："></a>线程中断：</h3><p>正如中断二字所表达的意义，在线程运行(run方法)中间打断它，在Java中，提供了以下3个有关线程中断的方法</p><pre><code>//中断线程（实例方法）public void Thread.interrupt();//判断线程是否被中断（实例方法）public boolean Thread.isInterrupted();//判断是否被中断并清除当前中断状态（静态方法）public static boolean Thread.interrupted();</code></pre><p>等待唤醒机制与synchronize：所谓等待唤醒机制本篇主要指的是notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说<strong>notify/notifyAll和wait方法依赖于monitor对象</strong>，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，<strong>而synchronized关键字可以获取 monitor</strong> ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。</p><h2 id="多线程下数据同步"><a href="#多线程下数据同步" class="headerlink" title="多线程下数据同步"></a>多线程下数据同步</h2><p>这类锁/关键字主要是为了维护数据在高并发情况下的一致性/稳定性。</p><h3 id="数据库中的锁"><a href="#数据库中的锁" class="headerlink" title="数据库中的锁"></a>数据库中的锁</h3><p><strong>共享锁(Share Lock)</strong></p><blockquote><p>又称为读锁</p></blockquote><p>多个线程可并发的获得某个数据的共享锁锁，并行读取数据。在数据存在共享锁期间，不能修改数据，不能加排他锁。<br>如MySQL中，在查询语句最后加上LOCK IN SHARE MODE。</p><p><strong>排他锁(eXclusive Lock)</strong></p><blockquote><p>又称为写锁</p></blockquote><p>同能只能有一个线程可以获得某个数据的排他锁。在线程获取排他锁后，该线程可对数据读写，但是其他线程不能对该数据添加任何锁。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>如果一个共享变量被声明成volatile，java线程内存模型将会确保所有线程看到这个变量的值是一致的。</p></blockquote><p>基本策略: 写操作时，会有Lock前缀指定，处理器会立马将修改直接写回系统内存，并且其他处理器会将该值在其上的高速缓存标为无效。<br>可能带来的性能消耗: 写操作实时写回内存，锁总线/锁内存。<br>优势: 一些场景上相比synchronized，执行成本更低(不会引起线程上下文切换以及调度)，使用更方便。</p><p>关于volatile的详细理解，可以参考我的这篇文章： <a href="https://zhaoshuming.github.io/2019/03/04/java-volatile/" target="_blank" rel="noopener">Java中的volatile</a></p><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p>synchronized存在问题：如果获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此我们需要不论程序的代码块执行的如何最终都将锁对象进行释放，方便其他线程的执行。</p><p>Lock提供了比synchronized更多的功能，但并非内置特性。详见：<a href="https://zhaoshuming.github.io/2019/03/07/java-reentrantlock/" target="_blank" rel="noopener">Java Lock</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ea9a482ece5f" target="_blank" rel="noopener">https://www.jianshu.com/p/ea9a482ece5f</a><br><a href="https://www.cnblogs.com/mingyao123/p/7424911.html" target="_blank" rel="noopener">https://www.cnblogs.com/mingyao123/p/7424911.html</a><br><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">https://blog.dreamtobe.cn/2015/11/13/java_synchronized/</a></p>]]></content>
      
      
      <categories>
          
          <category> 同步 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OKHttp深入理解</title>
      <link href="/2019/02/27/OKHttp%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/2019/02/27/OKHttp%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="OKHttp请求流程"><a href="#OKHttp请求流程" class="headerlink" title="OKHttp请求流程"></a>OKHttp请求流程</h3><p>OKHttp的请求流程图如下所示：</p><p><img src="okhttp.png" alt></p><p>如下为使用OKHttp进行Get请求的步骤：</p><pre><code>//1.新建OKHttpClient客户端OkHttpClient client = new OkHttpClient();//新建一个Request对象Request request = new Request.Builder()        .url(url)        .build();//2.Response为OKHttp中的响应Response response = client.newCall(request).execute();</code></pre><p>首先，我们会在请求的时候初始化一个Call的实例，然后<strong>根据同步和异步的不同，分别调用它的 execute() 和 enqueue()</strong> 方法，但是它们进行网络访问的逻辑都是一样的，内部最后都会执行到getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器以及访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。</p><p><img src="/2019/02/27/OKHttp深入理解/realcall.png" alt title="请求时序图"></p><h3 id="分发器Dispatcher"><a href="#分发器Dispatcher" class="headerlink" title="分发器Dispatcher"></a>分发器Dispatcher</h3><p>使用 OkHttp 的时候，我们会创建一个 RealCall 并将其加入到双端队列中。但是请注意这里的双端队列的名称是 runningSyncCalls，也就是说这种请求是同步请求，会在当前的线程中立即被执行。所以，下面的 getResponseWithInterceptorChain() 就是这个同步的执行过程。而当我们执行完毕的时候，又会调用 Dispatcher 的 finished(RealCall) 方法把该请求从队列中移除。所以，这种<strong>同步的请求无法体现分发器的“分发”功能。</strong></p><p>除了同步的请求，还有异步类型的请求：当我们拿到了 RealCall 的时候，调用它的 enqueue(Callback responseCallback) 方法并设置一个回调即可。该方法会执行下面这行代码：</p><pre><code>client.dispatcher().enqueue(new AsyncCall(responseCallback));</code></pre><p>当我们调用了 Dispatcher 的 enqueue(AsyncCall) 方法的时候也会将 AsyncCall 加入到一个队列中，并会在请求执行完毕的时候从该队列中移除，只是这里的队列是 <strong>runningAsyncCalls 或者 readyAsyncCalls</strong>。它们都是一个双端队列，并用来存储异步类型的请求。它们的<br>区别是，runningAsyncCalls 是正在执行的队列，当正在执行的队列达到了限制的时候，就会将其放置到就绪队列 readyAsyncCalls 中：</p><pre><code>synchronized void enqueue(AsyncCall call) {    if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {        runningAsyncCalls.add(call);        executorService().execute(call);    } else {        readyAsyncCalls.add(call);    }}</code></pre><p>当把该请求加入到了正在执行的队列之后，我们会立即使用一个线程池来执行该 AsyncCall。这样这个请求的责任链就会在一个线程池当中被异步地执行了。这里的线程池由 executorService() 方法返回：</p><pre><code>public synchronized ExecutorService executorService() {    if (executorService == null) {        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,        new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false));    }    return executorService;}</code></pre><p>显然，当线程池不存在的时候会去创建一个线程池。除了上面的这种方式，我们还可以在构建 OkHttpClient 的时候，自定义一个 Dispacher，并在其构造方法中为其指定一个线程池。</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ol><li><p>在配置 OkHttpClient时设置的interceptors；[eg. 最常用的:日志拦截器]</p></li><li><p>负责失败重试以及重定向的 RetryAndFollowUpInterceptor；会根据服务器返回的信息判断这个请求是否可以重定向，或者是否有必要进行重试</p></li><li><p>桥拦截器 BridgeInterceptor 用于从用户的请求中构建网络请求，然后使用该请求访问网络，最后从网络响应当中构建用户响应。[简单的说: 只是用来对请求进行包装，并将服务器响应转换成用户友好的响应]</p></li><li><p>负责读取缓存直接返回、更新缓存的 CacheInterceptor</p></li><li><p>负责和服务器建立连接的ConnectInterceptor；这里并没有真正地从网络中获取数据，而仅仅是打开一个连接。在获取连接对象的时候，使用了连接池 ConnectionPool 来复用连接。</p><pre><code>public final class ConnectInterceptor implements Interceptor {    @Override public Response intercept(Chain chain) throws IOException {        RealInterceptorChain realChain = (RealInterceptorChain) chain;        Request request = realChain.request();        StreamAllocation streamAllocation = realChain.streamAllocation();        boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);        HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);        RealConnection connection = streamAllocation.connection();        return realChain.proceed(request, streamAllocation, httpCodec, connection);    }}</code></pre><p> 这里的<strong>HttpCodec 用来编码请求并解码响应，RealConnection 用来向服务器发起连接</strong>。它们会在下一个拦截器中被用来从服务器中获取响应信息。</p><p> <strong>StreamAllocation相当于一个管理类，维护了服务器连接、并发流和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象</strong>。当我们调用 streamAllocation 的 newStream() 方法的时候，最终会经过一系列的判断到达 StreamAllocation 中的 findConnection() 方法。该方法会被放置在一个循环当中被不停地调用以得到一个可用的连接。它优先使用当前已经存在的连接，不然就使用连接池中存在的连接，再不行的话，就创建一个新的连接。我们使用<strong>连接复用</strong>的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。</p></li><li><p>配置 OkHttpClient 时设置的 networkInterceptors；[for web socket,自行了解]</p></li><li><p>服务器请求拦截器 CallServerInterceptor 用来向服务器发起请求并获取数据。<br> <strong>位置决定了功能，最后一个 Interceptor 一定是负责和服务器实际通讯的，重定向、缓存等一定是在实际通讯之前的</strong></p></li></ol><p>源码如下：</p><pre><code>Response getResponseWithInterceptorChain() throws IOException {    // Build a full stack of interceptors.    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();    interceptors.addAll(client.interceptors());    interceptors.add(retryAndFollowUpInterceptor);    interceptors.add(new BridgeInterceptor(client.cookieJar()));    interceptors.add(new CacheInterceptor(client.internalCache()));    interceptors.add(new ConnectInterceptor(client));    if (!forWebSocket) {        interceptors.addAll(client.networkInterceptors());    }    interceptors.add(new CallServerInterceptor(forWebSocket));    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,            originalRequest, this, eventListener, client.connectTimeoutMillis(),            client.readTimeoutMillis(), client.writeTimeoutMillis());    return chain.proceed(originalRequest);}</code></pre><p>这里，我们创建了一个列表对象之后把 client 中的拦截器、重连拦截器、桥拦截器、缓存拦截器、网络连接拦截器和服务器请求拦截器等依次加入到列表中。然后，我们用这个列表创建了一个拦截器链。这里使用了责任链设计模式，每当一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。当我们自定义一个拦截器的时候，也会被加入到这个拦截器链条里。</p><h3 id="连接管理：ConnectionPool"><a href="#连接管理：ConnectionPool" class="headerlink" title="连接管理：ConnectionPool"></a>连接管理：ConnectionPool</h3><p>与请求的缓存类似，OkHttp 的连接池也使用一个双端队列来缓存已经创建的连接：</p><pre><code>private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;();</code></pre><p>OkHttp 的缓存管理分成两个步骤，<strong>一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理</strong>。在 ConnectionPool 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 add() 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。</p><p>在 ConnectionPool 中存在一个静态的线程池：</p><pre><code>private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */,    Integer.MAX_VALUE /* maximumPoolSize */,     60L /* keepAliveTime */,    TimeUnit.SECONDS,    new SynchronousQueue&lt;Runnable&gt;(),     Util.threadFactory(&quot;OkHttp ConnectionPool&quot;, true));</code></pre><p>每当我们向连接池中插入一个连接的时候就会调用下面的方法，将连接插入到双端队列的同时，会调用上面的线程池来执行清理缓存的任务：</p><pre><code>void put(RealConnection connection) {    assert (Thread.holdsLock(this));    if (!cleanupRunning) {        cleanupRunning = true;        // 使用线程池执行清理任务        executor.execute(cleanupRunnable);    }    // 将新建的连接插入到双端队列中    connections.add(connection);}</code></pre><p>这里的清理任务是 cleanupRunnable，是一个 Runnable 类型的实例。它会在方法内部调用 cleanup() 方法来清理无效的连接。</p><p>在从缓存的连接中取出连接来判断是否应该将其释放的时候使用到了两个变量 maxIdleConnections 和 keepAliveDurationNs，分别表示最大允许的闲置的连接的数量和连接允许存活的最长的时间。默认空闲连接最大数目为5个，keepalive 时间最长为5分钟。该方法会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。</p><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>bytes()大小有限制，建议用byteStream()。源码如下：</p><pre><code>public final byte[] bytes() throws IOException {    long contentLength = contentLength();    if (contentLength &gt; Integer.MAX_VALUE) {      throw new IOException(&quot;Cannot buffer entire body for content length: &quot; + contentLength);    }    ...}public final InputStream byteStream() {    return source().inputStream();}</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>使用okhttp的cache，首先需指定缓存路径和大小</p><pre><code>private OkHttpClient initClient() {        File cacheFile = new File(config.getCacheFilePath());        if (!cacheFile.exists()) {            cacheFile.mkdir();        }        //缓存大小为30M        int cacheSize = 30 * 1024 * 1024;        //创建缓存对象        Cache cache = new Cache(getContext(), cacheFile, cacheSize);        OkHttpClient.Builder builder = new OkHttpClient.Builder();        builder.addInterceptor(new SercurityKeyInteraptor())                .addInterceptor(new HttpLoggingInterceptor())                .connectTimeout(config.getConnectTimeout(), TimeUnit.SECONDS)                .writeTimeout(config.getWriteTimeout(), TimeUnit.SECONDS)                .readTimeout(config.getReadTimeout(), TimeUnit.SECONDS)                .cache(cache)                .cookieJar(new FundCookie());        return mOkHttpClient = builder.build();    }</code></pre><p>其次在构造Request时配置缓存策略</p><pre><code>CacheControl cc = new CacheControl.Builder()              //不使用缓存，但是会保存缓存数据              //.noCache()              //不使用缓存，同时也不保存缓存数据             // .noStore()              //只使用缓存，（如果我们要加载的数据本身就是本地数据时，可以使用这个，不过目前尚未发现使用场景）              //.onlyIfCached()              //手机可以接收响应时间小于当前时间加上10s的响应              //  .minFresh(10,TimeUnit.SECONDS)              //手机可以接收有效期不大于10s的响应              //  .maxAge(10,TimeUnit.SECONDS)              //手机可以接收超出5s的响应              .maxStale(5,TimeUnit.SECONDS)              .build();      Request request = new Request.Builder()              .cacheControl(cc)              .url(&quot;http://192.168.152.2:8080/cache&quot;).build();  </code></pre><p>如果直接使用CacheControl中的常量，则不用调用上面那么多的方法，使用方式如下：</p><pre><code>Request request = new Request.Builder()              //强制使用网络              // .cacheControl(CacheControl.FORCE_NETWORK)              //强制使用缓存              .cacheControl(CacheControl.FORCE_CACHE)              .url(&quot;http://192.168.152.2:8080/cache&quot;).build();  </code></pre><p>OkHttp的Cache是根据URL以及请求参数来生成的，并且不支持POST请求。</p><p>CacheInterceptor拦截器实现读写操作,读写操作都是通过okio实现,快速,高效流</p><p>读: 根据缓存策略实现读取缓存,返回Response,Okhttp中实现的是轻量级 LruCache缓存模式[最近最少使用原则]。然后关于DiskLruCache是如何管理缓存文件的，这个其实也很好理解，首先的原则就是按照LRU这种最近最少使用删除的原则，当总的大小超过限定大小后，删除最近最少使用的缓存文件，它的LRU算法是使用LinkedHashMap进行维护的，这样来保证，保留的缓存文件都是更常使用的。</p><p>写: 根据缓存策略,将服务端返回的数据写入磁盘</p><p>Okhttp缓存相关的类有如下：</p><pre><code>CacheControl（HTTP中的Cache-Control和Pragma缓存控制）CacheControl是用于描述HTTP的Cache-Control和Pragma字段的类，用于指定缓存的规则。CacheStrategy（缓存策略类）CacheStrategy是用于判定使用缓存数据还是网络请求的决策类。Cache（缓存类）对外开放的缓存类，提供了缓存的增删改查接口。InternalCache（内部缓存类）对内使用的缓存类接口，没有具体实现，只是封装了Cache的使用。DiskLruCache（文件化的LRU缓存类）这是真正实现缓存功能的类，将数据存储在文件中，并使用LRU规则（由LinkedHashMap实现），控制对缓存文件的增删改查。</code></pre><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>3.0之后OKHttp是加了CookieJar和Cookie两个类的，通过实现CookieJar即可管理cookie。<br>加载Cookie时,IP地址与域名是有区别的。如果访问的是IP地址,Cookie是不会从publicsuffixes.gz文件中读取Cookie数据。<br>publicsuffixes.gz 就是一个类似apk一样的压缩文件,可以解压通过Txt查看里面的内容。<br>官文提供的原始文件内容:   <a href="https://publicsuffix.org" target="_blank" rel="noopener">https://publicsuffix.org</a></p><pre><code>private class FundCookie implements CookieJar {    private final ConcurrentHashMap&lt;String, List&lt;Cookie&gt;&gt; cookieStore = new ConcurrentHashMap&lt;&gt;();    @Override    public void saveFromResponse(HttpUrl url, List&lt;Cookie&gt; cookies) {        /*         * Cookie name 不能重复:需要人为管控         */        cookieStore.put(url.host(), cookies);    }    @Override    public List&lt;Cookie&gt; loadForRequest(HttpUrl url) {        /*         * 不能用url.host来获取Cookie值,因为在请求过程中可能存在 301 重定向问题,导致重定向的url无法获取Cookie值,         * 但它与其它接口属于同一个 domain         * 解决办法:将本地所有的Cookie都上传给接口,后台解析会去匹配 KEY-VALUE[SESSION name- Cookie value]         * 所以必要保证 不同的domain对应的SESSION name 不能重复         */        List&lt;Cookie&gt; curCookies = new ArrayList&lt;&gt;();        for (List&lt;Cookie&gt; entry : cookieStore.values()) {            curCookies.addAll(entry);        }        return curCookies;    }}</code></pre><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>Okhttp默认是支持https网络请求的，但是支持的Https网站必须是CA机构认证了的，对于自签名的网址，还是不能访问的，访问直接抛出如下异常信息：</p><pre><code>onFailure: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.</code></pre><p>针对https的处理，目前主要有两种方式：</p><blockquote><p>客户端默认信任全部证书<br>对自签名网址进行证书的单独处理</p></blockquote><p>具体可以参看我的这篇文章：<a href="https://zhaoshuming.github.io/2019/03/18/android-https/" target="_blank" rel="noopener">android中使用https</a></p><h3 id="Gzip"><a href="#Gzip" class="headerlink" title="Gzip"></a>Gzip</h3><blockquote><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4></blockquote><p>request header中声明<strong>Accept-Encoding: gzip</strong>，告知服务器客户端接受gzip的数据。</p><p>服务器支持的情况下，返回gzip后的response body，同时加入以下header：</p><pre><code>Content-Encoding: gzip：表明body是gzip过的数据Content-Length:117：表示body gzip压缩后的数据大小，便于客户端使用。或 Transfer-Encoding: chunked：分块传输编码</code></pre><p><img src="/2019/02/27/OKHttp深入理解/gzip.png" alt></p><blockquote><h4 id="Okhttp"><a href="#Okhttp" class="headerlink" title="Okhttp"></a>Okhttp</h4></blockquote><p>如果header中没有Accept-Encoding，默认自动添加 ，且标记变量transparentGzip为true。</p><p>针对返回结果，如果同时满足以下三个条件：</p><pre><code>transparentGzip为true，即之前自动添加了Accept-Encodingheader中标明了Content-Encoding为gzip有body</code></pre><p>移除 Content-Encoding、Content-Length，并对结果进行解压缩。</p><pre><code>开发者没有添加Accept-Encoding时，自动添加Accept-Encoding: gzip自动添加的request，response支持自动解压手动添加不负责解压缩自动解压时移除Content-Length，所以上层Java代码想要contentLength时为-1自动解压时移除 Content-Encoding自动解压时，如果是分块传输编码，Transfer-Encoding: chunked不受影响。</code></pre><blockquote><h4 id="HttpUrlConnection"><a href="#HttpUrlConnection" class="headerlink" title="HttpUrlConnection:"></a>HttpUrlConnection:</h4></blockquote><p>4.4版本之后与okhttp相仿</p><h3 id="其它：网络框架实现步骤"><a href="#其它：网络框架实现步骤" class="headerlink" title="其它：网络框架实现步骤"></a>其它：网络框架实现步骤</h3><p>1.封装请求参数<br>2.封装响应数据<br>3.根据前两步，封装请求任务<br>4.创建线程池管理类(队列,线程池)<br>5.封装”使用工具”、添加重试机制等</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5bc89fbc5188255c713cb8a5" target="_blank" rel="noopener">https://juejin.im/post/5bc89fbc5188255c713cb8a5</a><br><a href="https://www.jianshu.com/p/d5824d2150b9" target="_blank" rel="noopener">让 okhttp 支持 post缓存</a><br><a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="noopener">https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/</a><br><a href="https://www.jianshu.com/p/e41bc4f335f2" target="_blank" rel="noopener">手撸一个简单的网络框架</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OKHttp </tag>
            
            <tag> Gzip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android异步处理</title>
      <link href="/2019/02/27/android%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/02/27/android%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>异步处理实现方式主要有：</p><ul><li>实现Thread的run()方法或者实现Runable接口</li><li>HandlerThread</li><li>AsyncTask(已废弃)</li><li>LoaderManager</li><li>WorkManager</li></ul><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>直接使用Thread实现方式，这种方式简单，但不是很优雅。适合数量很少（偶尔一两次）的异步任务，但要处理的异步任务很多的话，使用该方式<strong>会导致创建大量的线程</strong>，这会影响用户交互。</p><ol><li><p>关键字join、sleep、yield</p><p> join() method suspends the execution of the calling thread until the object called finishes its execution.<br> 也就是说，t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。</p><p> join()方法是让出执行资源（如：CPU时间片），使得其它线程可以获得执行的资源。所以调用join()方法会使进入阻塞状态，该线程被唤醒后会进入runable状态，等待下一个时间片的到来才能再次执行。 </p><p> sleep()不会让出资源，只是处于睡眠状态（类似只执行空操作）。调用sleep()方法会使进入等待状态，当等待时间到后，如果还在时间片内，则直接进入运行状态，否则进入runable状态，等待下个时间片。</p><p> Yield()方法是停止当前线程，让同等优先权的线程运行。如果没有同等优先权的线程，那么Yield()方法将不会起作用。 </p><p> suspend()可能导致死锁，因此弃用</p></li></ol><h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p>HandlerThread，这种方式<strong>适合子线程有序的执行异步操作，异步任务的执行一个接着一个</strong>。</p><p>HandlerThread的内部实现机制很简单，在创建新的线程后，使该线程成为一个Looper线程，让该线程不断的从MessageQueue取出消息并处理。</p><p>就应用程序而言，Android系统中JAVA的应用程序和其他系统上相同，都是靠消息驱动来工作的，他们大致的工作原理如下：</p><p>1、有一个消息队列，可以往这个消息队列中投递消息。</p><p>2、有一个消息循环，不断从消息队列中取出消息，然后处理。</p><p>在Android中，一个线程对应一个Looper对象，而一个Looper对象又对应一个MessageQueue（用于存放message）。</p><p>循环者Looper类，消息处理类Handler，消息类Message。</p><p>Looper对象用来为一个线程开启一个消息循环，用来操作MessgeQueue。默认情况下，Android中新创建的线程是没有开启消息循环的。（主线程除外）</p><p>消息处理类（Handler）允许发送和处理Message和Rannable对象到其所在线程的MessageQueue中。（它主要有两个作用：1、将Message或Runnable应用post()方法或sendMessage()方法发送到MessageQueue中，在发送时可以指定延时时间、发送时间或者要携带的bundle数据。当MessageQueue循环到该Message时，调用相应的Handler对象的handlerMessage()方法对其进行处理。2、在子线程中与主线程进行通信，也就是在工作线程中与UI线程进行通信。）</p><p>另外，在一个线程中只能有一个Looper和MessageQueue，但是可以有多个Handler,而且这些Handler可以共享一个Looper和MessageQueue。</p><p>消息类(Message)被存放在MessageQueue中，一个MessageQueue中可以包含多个Message对象。每个Message对象可以通过Messhe.obtain()方法或者Handler.obtainMessage()方法获得。Message是一个final类，所以不可被继承。</p><h3 id="AsyncTask-已废弃"><a href="#AsyncTask-已废弃" class="headerlink" title="AsyncTask(已废弃)"></a>AsyncTask(已废弃)</h3><p>AsyncTask的内部使用了两个线程池，使用AsyncTask执行异步操作时，会先在SerialExecutor进行一个顺序排队， 后再用ThreadPoolExcutor线程池为你分配一个线程并执行。而整个应用的AsyncTask任务都在排同一条队，有可能等待排队的任务很多，所以一般不会使用AsyncTask执行一些优先级比较高的异步任务。 </p><p>当然我们是可以跳过不需要进行排队，直接就通过线程池分配一个线程并执行异步任务，但需要注意同时执行太多的异步任务，会影响用户体验，我想Google就是为了限制同时创建太多的线程才会采用一个排队机制的</p><pre><code>/** @hide */public static void setDefaultExecutor(Executor exec) {    sDefaultExecutor = exec;}</code></pre><p>该方法是隐藏，但可使用反射，设置一个线程池。</p><p>AsyncTask， <strong>通常用于耗时的异步处理，且时效性要求不是非常高的那种异步操作</strong>。如果时效性要求非常高的操作，不建议使用这个方式，因为AsyncTask的默认实现是有内部排队机制，且是整个应用的AsyncTask的任务进行排队，所以不能保证异步任务能很快的被执行。</p><p>问题如下：</p><ol><li>并行串行问题：AsyncTasks should ideally be used for short operations (a few seconds at the most)</li><li>错误处理问题：AsyncTask没有对发生的一些异常进行处理，你只能在onBackground里进行一些判断，但之外的一些异常情况发生你都无法了解，比如线程异常退出等。</li><li>多个任务的管理问题：如果需要多个后台任务，需要新建多个AsyncTask来执行任务，在需要退出的时候你需要对每一个都进行一定的处理来避免内存泄露以及UI问题，这是一个很麻烦的事情。</li></ol><h3 id="LoaderManager"><a href="#LoaderManager" class="headerlink" title="LoaderManager"></a>LoaderManager</h3><p>LoaderManager，当<strong>请求处理时机需要根据Activity的生命周期进行调整</strong>，或需要<strong>时刻监测数据的变化</strong>，那LoaderManager是很不错的解决方案。</p><p>LoaderManager可以解决的问题包括：</p><p>1.加载的数据有变化时，会自动通知我们，而不自己监控数据的变化情况，如：用CursorLoader来加载数据库数据，当数据库数据有变化时，可是个展示变化的数据</p><p>2.数据的请求处理时机会结合Activity和Fragment的生命周期进行调整，如：若Acivity销毁了，那就不会再去请求新的数据</p><h4 id="1-LoaderManager"><a href="#1-LoaderManager" class="headerlink" title="1.LoaderManager"></a>1.LoaderManager</h4><p> LoaderManager用来负责管理与Activity或者Fragment联系起来的一个或多个Loaders对象.</p><p> 每个Activity或者Fragment都有唯一的一个LoaderManager实例(通过getLoaderManager()方法获得),用来启动,停止,保持,重启,关闭它的Loaders,这些功能可通过调用initLoader()/restartLoader()/destroyLoader()方法来实现.</p><p> LoaderManager并不知道数据如何装载以及何时需要装载.相反,它只需要控制它的Loaders们开始,停止,重置他们的Load行为,在配置变换或数据变化时保持loaders们的状态,并使用接口来返回load的结果.</p><h4 id="2-Loader"><a href="#2-Loader" class="headerlink" title="2.Loader"></a>2.Loader</h4><p> Loades负责在一个单独线程中执行查询,监控数据源改变,当探测到改变时将查询到的结果集发送到注册的监听器上.Loader是一个强大的工具,具有如下特点</p><p> (1)它封装了实际的数据载入.</p><p> Activity或Fragment不再需要知道如何载入数据.它们将该任务委托给了Loader,Loader在后台执行查询要求并且将结果返回给Activity或Fragment.</p><p> (2)客户端不需要知道查询如何执行.Activity或Fragment不需要担心查询如何在独立的线程中执行,Loder会自动执行这些查询操作.</p><p> (3)它是一种安全的事件驱动方式.</p><p> Loader检测底层数据,当检测到改变时,自动执行并载入最新数据.</p><p> 这使得使用Loader变得容易,客户端可以相信Loader将会自己自动更新它的数据.</p><p> Activity或Fragment所需要做的就是初始化Loader,并且对任何反馈回来的数据进行响应.除此之外,所有其他的事情都由Loader来解决.</p><p>Loader：该类用于数据的加载 ，类型参数D用于指定Loader加载的数据类型</p><pre><code>public class Loader&lt;D&gt; {}</code></pre><p>一般我们不直接继承Loader，而是继承AsyncTaskLoader，因为Loader的加载工作并不是在异步线程中。而AsyncTaskLoader实现了异步线程，加载流程在子线程中执行。注意：对该类的调用应该在主线程中完成。</p><p><strong>Loader负责数据加载逻辑，LoaderManager负责Loader的调度</strong>，开发者只需要自定义自己的Loader，实现数据的加载逻辑，而不再关注数据加载时由于Activity销毁引发的问题。</p><p>注意：其实AsyncTaskLoader内部实现异步的方式是使用AsyncTask完成的，上面我们说过AsyncTask的内部是有一个排队机制，但<strong>AsyncTaskLoader内部使用AsyncTask进行数据异步加载时，异步任务并不进行排队</strong>。而直接由线程池分配新线程来执行。</p><h3 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h3><p>WorkManager<strong>最适用于可以延迟的任务，即使应用程序或设备重新启动（例如，使用后端服务定期同步数据并上载日志或分析数据），仍然可以运行</strong>。</p><p><strong>特点：</strong></p><ul><li>允许在任务运行时设置约束，例如网络状态或充电状态；</li><li>支持异步一次性和周期性任务；</li><li>支持带输入和输出的链式任务；</li><li>即使应用程序或设备重新启动，也可确保任务执行</li></ul><p>使用WorkManager，可以轻松添加网络可用性或计费状态等约束。任务将在满足约束时运行，并在运行时失败时自动重试。例如，如果任务需要网络可用，则当网络不再可用时将停止该任务，并在以后重试。<br>不仅如此，它还可以使用LiveData监视工作状态并检索工作结果，这样可以在任务完成时通知您的UI。如果任务执行失败，可以通过配置退避的处理方式来控制工作的重试方式。如果发生应用程序或设备重新启动，WorkManager还可以使用本地数据库中的工作记录重新安排工作。<br>利用OneTimeWorkRequest进行一次性调度或使用PeriodicWorkRequest进行重复调度。并且，我们还可以将一次性工作请求链接到按顺序或并行运行，如果链中的任何工作失败，WorkManager将确保不会运行剩余的工作链。</p><p>WorkManager API <strong>可以很容易的指定可延迟的异步任务。允许你创建任务，并把它交给WorkManager来立即运行或在适当的时间运行。</strong>WorkManager根据设备API的级别和应用程序状态等因素来选择适当的方式运行任务。如果WorkManager在应用程序运行时执行你的任务，它会在应用程序进程的新线程中执行。如果应用程序没有运行，WorkManager会根据设备API级别和包含的依赖项选择适当的方式安排后台任务，可能会使用JobScheduler、Firebase JobDispatcher或AlarmManager。你不需要编写设备逻辑来确定设备有哪些功能和选择适当的API；相反，你只要把它交给WorkManager让它选择最佳的方式。</p><p><img src="/2019/02/27/android多线程/workmanager.jpg" alt></p><p>基础功能:</p><ul><li>使用WorkManager创建运行在你选择的环境下的单个任务或指定间隔的重复任务</li><li>WorkManager API使用几个不同的类，有时，你需要继承一些类。</li><li>Worker 指定需要执行的任务。有一个抽象类Worker，你需要继承并在此处工作。在后台线程同步工作的类。WorkManager在运行时实例化Worker类，并在预先指定的线程调用doWork方法(见Configuration.getExecutor())。此方法同步处理你的工作，意味着一旦方法返回，Worker被视为已经完成并被销毁。如果你需要异步执行或调用异步API，应使用ListenableWorker。如果因为某种原因工作没抢占，相同的Worker实例不会被重用。即每个Worker实例只会调用一次doWork()方法，如果需要重新运行工作单元，需要创建新的Worker。Worker最大10分钟完成执行并ListenableWorker.Result。如果过期，则会被发出信号停止。(Worker的doWork()方法是同步的，方法执行完则结束，不会重复执行，且默认超时时间是10分钟，超过则被停止。)</li><li>WorkRequest 代表一个独立的任务。一个WorkRequest对象至少指定哪个Worker类应该执行该任务。但是，你还可以给WorkRequest添加详细信息，比如任务运行时的环境。每个WorkRequest有一个自动生成的唯一ID，你可以使用ID来取消排队的任务或获取任务的状态。WorkRequest是一个抽象类，你需要使用它一个子类，OneTimeWorkRequest或PeriodicWorkRequest。<br>1)WorkRequest.Builder 创建WorkRequest对象的帮助类，你需要使用子类OneTimeWorkRequest.Builder或PeriodicWorkRequest.Builder。<br>2)Constraints(约束) 指定任务执行时的限制(如只有网络连接时)。使用Constraints.Builder创建Constraints对象，并在创建WorkRequest对象前传递给WorkRequest.Builder。</li><li>WorkManager 排队和管理WorkRequest。将WorkRequest对象传递给WorkManager来将任务添加到队列。WorkManager 使用分散加载系统资源的方式安排任务，同时遵守你指定的约束。<br>1)WorkManager使用一种底层作业调度服务基于下面的标注<br>2)使用JobScheduler API23+<br>3)使用AlarmManager + BroadcastReceiver API14-22</li><li>WorkInfo 包含有关特定任务的信息。WorkManager为每个WorkRequest对象提供一个LiveData。LiveData持有WorkInfo对象，通过观察LiveData，你可以确定任务的当前状态，并在任务完成后获取任何返回的值。</li></ul><p><img src="/2019/02/27/android多线程/workmanager-create.jpg" alt></p><p>注意：</p><ol><li>WorkManager组件库里面提供了一个专门做周期性任务的类PeriodicWorkRequest。但是PeriodicWorkRequest类有一个限制条件最小的周期时间是15分钟。</li><li>链式任务的任务链里面的任何一个任务返回WorkerResult.FAILURE，则整个任务链终止；WorkManager会把上一个任务的输出自动作为下一个任务的输入。链式任务的关键在WorkContinuation，通过WorkContinuation来整理好队列(是顺序执行，还是组合执行)然后入队执行。</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/baidu_36385172/article/details/79705915" target="_blank" rel="noopener">https://blog.csdn.net/baidu_36385172/article/details/79705915</a><br><a href="https://www.cnblogs.com/diysoul/p/5124886.html" target="_blank" rel="noopener">https://www.cnblogs.com/diysoul/p/5124886.html</a><br><a href="https://juejin.im/post/5c6134f2e51d4563567cbd89" target="_blank" rel="noopener">WorkManager浅析</a><br><a href="https://blog.csdn.net/wuyuxing24/article/details/80955646" target="_blank" rel="noopener">Android架构组件WorkManager详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Android知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github博客搭建</title>
      <link href="/2019/02/20/github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/02/20/github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><pre><code>hexo clean #/清除静态页面缓存（清除 public 文件夹)hexo g #生成或 hexo generatehexo s #启动本地服务器 或者hexo server,这一步之后就可以通过localhost:4000查看了hexo d #部署到githubhexo clean &amp; hexo g &amp; hexo s #一键启动</code></pre><h3 id="hexo-new-page-xxx-创建页面"><a href="#hexo-new-page-xxx-创建页面" class="headerlink" title="hexo new page xxx #创建页面"></a>hexo new page xxx #创建页面</h3><pre><code>命令       文件目录            post    source/_post       新建一个文章draft   source/_drafts     新建一个草稿文件page    source             新建一个页面文件</code></pre><h3 id="hexo添加分类和标签"><a href="#hexo添加分类和标签" class="headerlink" title="hexo添加分类和标签:"></a>hexo添加分类和标签:</h3><pre><code>---title: title #文章標題date: 2016-06-01 23:47:44 #文章生成時間categories: &quot;Hexo教程&quot; #文章分類目錄 可以省略tags: #文章標籤 可以省略     - 标签1     - 标签2 description: #你對本頁的描述 可以省略---</code></pre><h3 id="hexo目录结构"><a href="#hexo目录结构" class="headerlink" title="hexo目录结构"></a>hexo目录结构</h3><p><img src="/2019/02/20/github博客搭建/5346170-61efae0da32ec550.png" alt></p><h3 id="markdown编辑器"><a href="#markdown编辑器" class="headerlink" title="markdown编辑器"></a>markdown编辑器</h3><p>说明：在Hexo中插入图片时，请按照以下步骤进行设置 </p><p>（1）将站点配置文件中的 post_asset_folde 选项设置成 true </p><p>（2）在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件</p><p>（3）此时使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将待添加的图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加了图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片]（title/example.PNG “示例图片”） 添加图片</p><h3 id="使用-Hexo-Admin-插件（难用）"><a href="#使用-Hexo-Admin-插件（难用）" class="headerlink" title="使用 Hexo Admin 插件（难用）"></a>使用 Hexo Admin 插件（难用）</h3><p>Hexo Admin 是一个本地在线式文章管理器，可以用直观可视化的方式新建、编辑博客文章、page页面，添加标签、分类等，并且支持剪贴板粘贴图片（自动在source_images_目录中创建文件）</p><p>在Hexo网站目录下，安装 Hexo Admin 插件</p><p>npm install –save hexo-admin</p><p>启动本地服务器并打开管理界面，即可使用</p><p>hexo server -d</p><p>open localhost:4000/admin/</p><h3 id="markdown表格调整宽度"><a href="#markdown表格调整宽度" class="headerlink" title="markdown表格调整宽度"></a>markdown表格调整宽度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">table th:first-of-type &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下方是表格的 Markdown 语法 --!&gt;</span><br><span class="line">名称|值|备注</span><br><span class="line">---|---|---</span><br></pre></td></tr></table></figure><p>这里需要一点 CSS 知识，选择器的问题，首先 &lt;th> 存在于 &lt;table> 中；其次 th:first-of-type 的意思是每个 &lt;th> 为其父级的第一个元素，这里指的就是围绕着【名称】的 &lt;th>。同理第二、三个使用 th:nth-of-type(2)、th:nth-of-type(3) 就可以了，以此类推。上述的 th:first-of-type 等于 th:nth-of-type(1)。</p><h3 id="Markdown编辑表格时如何输入竖线"><a href="#Markdown编辑表格时如何输入竖线" class="headerlink" title="Markdown编辑表格时如何输入竖线"></a>Markdown编辑表格时如何输入竖线</h3><p>主要思路： 竖线用 &amp;#124 或者 &amp;#x7C 来代替,后加分号</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackyroc/p/7681938.html</a></p><p><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a></p><p><a href="https://blog.csdn.net/wsmrzx/article/details/81478945" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81478945</a></p><p><a href="https://www.jianshu.com/p/df46bca5889d" target="_blank" rel="noopener">https://www.jianshu.com/p/df46bca5889d</a></p>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
