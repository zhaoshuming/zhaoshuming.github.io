<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter集成Android项目]]></title>
    <url>%2F2019%2F06%2F28%2Fflutter-integration%2F</url>
    <content type="text"><![CDATA[在现有项目上集成Flutter1.在andorid工程目录上级目录下执行命令: flutter create -t module xxxx(想要创建的flutter项目名) 执行完后，一个和Android项目平级的flutter项目就已经创建好了。 2.添加flutter到当前Android项目：在Android项目根目录下的settings.gradle文件中，添加如下代码： setBinding(new Binding([gradle: this])) evaluate(new File( settingsDir.parentFile, &quot;flutter_hybrid/.android/include_flutter.groovy&quot; )) 然后，在项目的app目录下，build.gradle文件中，添加如下dependency: implementation project(&apos;:flutter&apos;) 如上，添加完之后，准备工作就完成了。 集成Flutter页面跳转通过继承FlutterActivity跳到默认页面1.Application：初始化Flutter public class App extends Application { @Override public void onCreate() { super.onCreate(); FlutterMain.startInitialization(this); } } 2.Activity：继承FlutterActivity /** * debug模式原生跳转到flutter界面会出现白屏，release包就不会出现白屏了 */ public class MainFlutterActivity extends FlutterActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); GeneratedPluginRegistrant.registerWith(this); } 这样以后，我们就可以跳转这个MainFlutterActivity，实现在Android工程里面进入Flutter工程的默认页面了。 通过FlutterView跳到指定页面首先通过Flutter.createFlutterView方法来创建一个FlutterView类型的View。它有三个构造参数： public static FlutterView createView(Activity activity, Lifecycle lifecycle, String initialRoute) 三个参数分别是：1.Activity，即当前附着的Activity 2.LifeCycle，且是不能为空(NonNull)的，这也就要求我们必须用AppCompatActivity来承载FlutterView了，如果我们的Activity继承自android.app.Activity是没有getLifeCycle()这个方法的。 public class FlutterViewActivity extends AppCompatActivity 复制代码 3.initialRoute这是一个String类型的变量，根据不同的标识跳转不同的Flutter页面： Widget _widgetForRoute(String route) { switch (route) { case &apos;route1&apos;: return MyHomePage(title: &apos;Flutter Demo Home Page1&apos;); case &apos;route2&apos;: return MyHomePage(title: &apos;Flutter Demo Home Page2&apos;); default: return MyHomePage(title: &apos;Flutter Demo Home Page2&apos;); } } 然后在当前Activity的OnCreate方法中，执行： FlutterView flutterView = Flutter.createView(this, getLifecycle(), &quot;route1&quot;); setContentView(flutterView); //或者： setContentView(R.layout.activity_flutter); rlContainer = findViewById(R.id.rl_container); rlContainer.addView(flutterView) 参考资料https://github.com/chinaltz/FlutterDemohttps://juejin.im/post/5c74dbeee51d45708f2a20c6]]></content>
      <categories>
        <category>HyBrid</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dart语言基础]]></title>
    <url>%2F2019%2F06%2F25%2Fdart-knowledge%2F</url>
    <content type="text"><![CDATA[在Dart中，一切都是对象，一切对象都是class的实例，哪怕是数字类型、方法甚至null都是对象，所有的对象都是继承自Object 虽然Dart是强类型语言，但变量类型是可选的，因为Dart可以自动推断变量类型 Dart支持范型，List&lt;int&gt;表示一个整型的数据列表，List&lt;dynamic&gt;则是一个对象的列表，其中可以装任意对象 Dart支持顶层方法（如main方法），也支持类方法或对象方法，同时你也可以在方法内部创建方法 Dart支持顶层变量，也支持类变量或对象变量 跟Java不同的是，Dart没有public protected private等关键字，如果某个变量以下划线（_）开头，代表这个变量在库中是私有的 Dart中变量可以以字母或下划线开头，后面跟着任意组合的字符或数字 变量以下代码是Dart中定义变量的方法： main() { var a = 1; int b = 10; String s = &quot;hello&quot;; dynamic c = 0.5; var count = 10; final Num = count; // final 只能赋值一次 const Num1 = 10; // const赋值必须是编译时常量 } 你可以明确指定某个变量的类型，如int bool String，也可以用var或 dynamic来声明一个变量，Dart会自动推断其数据类型。 使用final或const，不要使用var或其他类型，一个被final修饰的变量只能被赋值一次，一个被const修饰的变量是一个编译时常量（const常量毫无疑问也是final常量）。final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量；而 const 要求在声明时初始化，并且赋值必需为编译时常量。 注意：没有赋初值的变量都会有默认值null注意：实例变量可以是final的但不能是const的 内建数据类型Dart有如下几种内建的数据类型： numbers strings booleans lists(或者是arrays) maps runes（UTF-32字符集的字符） symbols下面用一段代码来演示以上各类数据类型： main() { // numbers var a = 0; int b = 1; double c = 0.1; // strings var s1 = &apos;hello&apos;; String s2 = &quot;world&quot;; // booleans var real = true; bool isReal = false; // lists var arr = [1, 2, 3, 4, 5]; List&lt;String&gt; arr2 = [&apos;hello&apos;, &apos;world&apos;, &quot;123&quot;, &quot;456&quot;]; List&lt;dynamic&gt; arr3 = [1, true, &apos;haha&apos;, 1.0]; // maps var map = new Map(); map[&apos;name&apos;] = &apos;zhangsan&apos;; map[&apos;age&apos;] = 10; Map m = new Map(); m[&apos;a&apos;] = &apos;a&apos;; //runes，Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符 var clapping = &apos;\u{1f44f}&apos;; print(clapping); // 打印的是拍手emoji的表情 // symbols print(#s == new Symbol(&quot;s&quot;)); // true } 函数Dart是一个面向对象的编程语言，所以即使是函数也是一个对象，也有一种类型Function，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。虽然Dart推荐你给函数加上返回值，但是不加返回值的函数同样可以正常工作，另外你还可以用=&gt;代替return语句，比如下面的代码： // 声明返回值 int add(int a, int b) { return a + b; } // 不声明返回值 add2(int a, int b) { return a + b; } // =&gt;是return语句的简写 add3(a, b) =&gt; a + b; main() { print(add(1, 2)); // 3 print(add2(2, 3)); // 5 print(add3(1, 2)); // 3 } 命名参数sayHello({String name}) { print(&quot;hello, my name is $name&quot;); } sayHello2({name: String}) { print(&quot;hello, my name is $name&quot;); } main() { // 打印 hello, my name is zhangsan sayHello(name: &apos;zhangsan&apos;); // 打印 hello, my name is wangwu sayHello2(name: &apos;wangwu&apos;); } 可以看到，定义命名参数时，你可以以 {type paramName} 或者 {paramName: type} 两种方式声明参数，而调用命名参数时，需要以 funcName(paramName: paramValue) 的形式调用。 命名参数的参数并不是必须的，所以上面的代码中，如果调用sayHello()不带任何参数，也是可以的，只不过最后打印出来的结果是：hello, my name is null，在Flutter开发中，你可以使用@required注解来标识一个命名参数，这代表该参数是必须的，你不传则会报错，比如下面的代码： const Scrollbar({Key key, @required Widget child}) 位置参数使用中括号[]括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面，如下代码所示： sayHello(String name, int age, [String hobby]) { // 位置参数可以有多个，比如[String a, int b] StringBuffer sb = new StringBuffer(); sb.write(&quot;hello, this is $name and I am $age years old&quot;); if (hobby != null) { sb.write(&quot;, my hobby is $hobby&quot;); } print(sb.toString()); } main() { // hello, this is zhangsan and I am 20 years old sayHello(&quot;zhangsan&quot;, 20); // hello, this is zhangsan and I am 20 years old, my hobby is play football sayHello(&quot;zhangsan&quot;, 20, &quot;play football&quot;); } 参数默认值你可以为命名参数或者位置参数设置默认值，如下代码所示： // 命名参数的默认值 int add({int a, int b = 3}) { // 不能写成：int add({a: int, b: int = 3}) return a + b; } // 位置参数的默认值 int sum(int a, int b, [int c = 3]) { return a + b + c; } main()函数不论在Dart还是Flutter中，必须都需要一个顶层的main()函数，它是整个应用的入口函数，main()函数的返回值是void，还有一个可选的参数，参数类型是List&lt;String&gt;。 函数作为一类对象你可以将一个函数作为参数传给另一个函数，比如下面的代码： printNum(int a) { print(&quot;$a&quot;); } main() { // 依次打印： // 1 // 2 // 3 var arr = [1, 2, 3]; arr.forEach(printNum); } 你也可以将一个函数赋值给某个变量，比如下面的代码： printNum(int a) { print(&quot;$a&quot;); } main() { var f1 = printNum; Function f2 = printNum; var f3 = (int a) =&gt; print(&quot;a = $a&quot;); f1(1); f2(2); f3(6); } 匿名函数大多数函数都是有名称的，比如main() printName()等，但是你也可以写匿名函数，如果你对Java比较熟悉，那下面的Dart代码你肯定也不会陌生： test(Function callback) { callback(&quot;hello&quot;); } main() { test((param) { // 打印hello print(param); }); } 匿名函数类似于Java中的接口，往往在某个函数的参数为函数时使用到。 函数返回值所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null 运算符Dart中的运算符与Java中的类似，比如++a a == b b ? a : b，但是也有一些与Java不太一样的运算符，下面用代码说明： main() { // 与Java相同的运算符操作 int a = 1; ++a; a++; var b = 1; print(a == b); // false print(a * b); // 3 bool real = false; real ? print(&apos;real&apos;) : print(&apos;not real&apos;); // not real print(real &amp;&amp; a == b); // false print(real || a == 3); // true print(a != 2); // true print(a &lt;= b); // false var c = 9; c += 10; print(&quot;c = $c&quot;); // c = 19 print(1&lt;&lt;2); // 4 // 与Java不太一样的运算符操作 // is运算符用于判断一个变量是不是某个类型的数据 // is!则是判断变量不是某个类型的数据 var s = &quot;hello&quot;; print(s is String); // true var num = 6; print(num is! String); // true // ~/才是取整运算符，如果使用/则是除法运算，不取整 int k = 1; int j = 2; print(k / j); // 0.5 print(k ~/ j); // 0 // as运算符类似于Java中的cast操作，将一个对象强制类型转换 (emp as Person).teach(); // ??=运算符 如果 ??= 运算符前面的变量为null，则赋值，否则不赋值 var param1 = &quot;hello&quot;, param2 = null; param1 ??= &quot;world&quot;; param2 ??= &quot;world&quot;; print(&quot;param1 = $param1&quot;); // param1 = hello print(&quot;param2 = $param2&quot;); // param2 = world // ?.运算符 var str1 = &quot;hello world&quot;; var str2 = null; print(str1?.length); // 11 print(str2?.length); // null print(str2.length); // 报错 } ..运算符（级联操作）如果你对Java中的建造者模式比较熟悉的话，Dart中的..运算符也很好理解，先看下面的代码： class Person { eat() { print(&quot;I am eating...&quot;); } sleep() { print(&quot;I am sleeping...&quot;); } study() { print(&quot;I am studying...&quot;); } } main() { // 依次打印 // I am eating... // I am sleeping... // I am studying... new Person()..eat() ..sleep() ..study(); } 可以看到，使用..调用某个对象的方法（或者成员变量）时，返回值是这个对象本身，所以你可以接着使用..调用这个对象的其他方法，这不就类似于Java中的建造者模式，每次build某个属性时，都返回一个this对象吗。 控制流程if / else switch for /while try / catch语句跟Java中都类似，try / catch语句可能稍有不同，下面用一段代码说明： main() { // if else语句 int score = 80; if (score &lt; 60) { print(&quot;so bad!&quot;); } else if (score &gt;= 60 &amp;&amp; score &lt; 80) { print(&quot;just so so!&quot;); } else if (score &gt;= 80) { print(&quot;good job!&quot;); } // switch语句 String a = &quot;hello&quot;; // case语句中的数据类型必须是跟switch中的类型一致 switch (a) { case &quot;hello&quot;: print(&quot;haha&quot;); break; case &quot;world&quot;: print(&quot;heihei&quot;); break; default: print(&quot;WTF&quot;); } // for语句 List&lt;String&gt; list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; for (int i = 0; i &lt; list.length; i++) { print(list[i]); } for (var i in list) { print(i); } // 这里的箭头函数参数必须用圆括号扩起来 list.forEach((item) =&gt; print(item)); // while语句 int start = 1; int sum = 0; while (start &lt;= 100) { sum += start; start++; } print(sum); // try catch语句 try { print(1 ~/ 0); } catch (e) { // IntegerDivisionByZeroException print(e); } try { 1 ~/ 0; } on IntegerDivisionByZeroException { // 捕获指定类型的异常 print(&quot;error&quot;); // 打印出error } finally { print(&quot;over&quot;); // 打印出over } } rethrowrethrow语句用来处理一个异常，同时希望这个异常能够被其它调用的部分使用: final foo = &apos;&apos;; void misbehave() { try { foo = &quot;1&quot;; } catch (e) { print(&apos;2&apos;); rethrow;// 如果不重新抛出异常，main函数中的catch语句执行不到 } } void main() { try { misbehave(); } catch (e) { print(&apos;3&apos;); } } 类（Class）类的定义与构造方法Dart中的类没有访问控制，所以你不需要用private, protected, public等修饰成员变量或成员函数，一个简单的类如下代码所示： class Person { String name; int age; String gender; Person(this.name, this.age, this.gender); sayHello() { print(&quot;hello, this is $name, I am $age years old, I am a $gender&quot;); } } 上面的Person类中有3个成员变量，一个构造方法和一个成员方法，看起来比较奇怪的是Person的构造方法，里面传入的3个参数都是this.xxx，而且没有大括号{}包裹的方法体，这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码： Person(String name, int age, String gender) { this.name = name; this.age = age; this.gender = gender; } 要调用Person类的成员变量或成员方法，可以用下面的代码： var p = new Person(&quot;zhangsan&quot;, 20, &quot;male&quot;); p.sayHello(); // hello, this is zhangsan, I am 20 years old, I am a male p.age = 50; p.gender = &quot;female&quot;; p.sayHello(); // hello, this is zhangsan, I am 50 years old, I am a female 类除了有跟类名相同的构造方法外，还可以添加命名的构造方法，如下代码所示： class Point { num x, y; Point(this.x, this.y); // 类的命名构造方法 Point.origin() { x = 0; y = 0; } } main() { // 调用Point类的命名构造方法origin() var p = new Point.origin(); var p2 = new Point(1, 2); } Dart中使用extends关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码： class Human { String name; Human.fromJson(Map data) { print(&quot;Human&apos;s fromJson constructor&quot;); } } class Man extends Human { Man.fromJson(Map data) : super.fromJson(data) { print(&quot;Man&apos;s fromJson constructor&quot;); } } 由于Human类没有默认构造方法，只有一个命名构造方法fromJson，所以在Man类继承Human类时，需要调用父类的fromJson方法做初始化，而且必须使用Man.fromJson(Map data) : super.fromJson(data)这种写法，而不是像Java那样将super写到花括号中。Dart语言中，子类不会继承父类的命名构造函数。如果不显式提供子类的构造函数，系统就提供默认的构造函数。 有时候你仅仅只是在某个类的构造方法中，调用这个类的另一个构造方法，你可以这么写： class Point { num x, y; Point(this.x, this.y); // 命名构造方法调用了默认的构造方法 Point.alongXAxis(num x) : this(x, 0); } 初始化列表除了调用父类的构造函数，也可以通过初始化列表在子类的构造函数体前（大括号前）来初始化实例的变量值，使用逗号,分隔。如下所示： class Point { num x; num y; Point(this.x, this.y); // 初始化列表在构造函数运行前设置实例变量。 Point.fromJson(Map jsonMap) : x = jsonMap[&apos;x&apos;], y = jsonMap[&apos;y&apos;] { print(&apos;In Point.fromJson(): ($x, $y)&apos;); } } 注意：上述代码，初始化程序无法访问 this 关键字。 类的成员方法一个类的成员方法是一个函数，为这个类提供某些行为。上面的代码中已经有了一些类的成员方法的定义，这些定义方式跟Java很类似，你可以为某个类的成员变量提供getter/setter方法，如下代码： class Rectangle { num left, top, width, height; // 构造方法传入left, top, width, height几个参数 Rectangle(this.left, this.top, this.width, this.height); // right, bottom两个成员变量提供getter/setter方法 num get right =&gt; left + width; set right(num value) =&gt; left = value - width; num get bottom =&gt; top + height; set bottom(num value) =&gt; top = value - height; } 抽象类和抽象方法使用abstract修饰一个类，则这个类是抽象类，抽象类中可以有抽象方法和非抽象方法，抽象方法没有方法体，需要子类去实现，如下代码： abstract class Doer { // 抽象方法，没有方法体，需要子类去实现 void doSomething(); // 普通的方法 void greet() { print(&quot;hello world!&quot;); } } class EffectiveDoer extends Doer { // 实现了父类的抽象方法 void doSomething() { print(&quot;I&apos;m doing something...&quot;); } } 运算符重载Dart中有类似于C++中的运算符重载语法，比如下面的代码定义了一个向量类，重载了向量的+ -运算： class Vector { num x, y; Vector(this.x, this.y); Vector operator +(Vector v) =&gt; new Vector(x + v.x, y + v.y); Vector operator -(Vector v) =&gt; new Vector(x - v.x, y - v.y); printVec() { print(&quot;x: $x, y: $y&quot;); } } main() { Vector v1 = new Vector(1, 2); Vector v2 = new Vector(3, 4); (v1 - v2).printVec(); // -2, -2 (v1 + v2).printVec(); // 4, 6 } 枚举类使用enum关键字定义一个枚举类，这个语法跟Java类似，如下代码： enum Color { red, green, blue } Mixinsmixins是一个重复使用类中代码的方式，比如下面的代码： class A { a() { print(&quot;A&apos;s a()&quot;); } } class B { b() { print(&quot;B&apos;s b()&quot;); } } // 使用with关键字，表示类C是由类A和类B混合而构成 class C = A with B; main() { C c = new C(); c.a(); // A&apos;s a() c.b(); // B&apos;s b() } Dart和Java一样只支持单继承。而且Dart中没有和Java一样提供Interface字段去声明一个接口。如果想使用和Java接口一样的功能可以使用Mixins和implements两种方式，分别解释下两种方式： Mixins : 指能够将另一个或多个类的功能添加到您自己的类中，而无需继承这些类 implements : 将一个类作为接口使用 class A { void a() { print(&apos;a&apos;); } } class B implements A { @override void a() { print(&apos;override a&apos;); } } class C { void c() { print(&apos;c&apos;); } } class E { String e = &apos;eeee&apos;; } class D extends A with C, E { void c() { print(&apos;c is D&apos;); } void d() { c(); } } 首先看B implements A，所以此时A相对于B来说就是一个接口，所以他要实现B中的方法。换句话说，Dart每个类都是接口 静态成员变量和静态成员方法// 类的静态成员变量和静态成员方法 class Cons { static const name = &quot;zhangsan&quot;; static sayHello() { print(&quot;hello, this is ${Cons.name}&quot;); } } main() { Cons.sayHello(); // hello, this is zhangsan print(Cons.name); // zhangsan } 泛型（Generics）Java和C++语言都有泛型，Dart语言也不例外，使用泛型有很多好处，比如：正确指定泛型类型会产生更好的生成代码。泛型可以减小代码的复杂度Dart内置的数据类型List就是一个泛型数据类型，你可以往List中塞任何你想的数据类型比如整型、字符串、布尔值等 Dart库（Libraries）Dart目前已经有很多的库提供给开发者，许多功能不需要开发者自己去实现，只需要导入对应的包即可，使用import语句来导入某个包，比如下面的代码： import &apos;dart:html&apos;; 如果你想导入自己写的某个代码文件，使用相对路径即可，例如当前有一个demo.dart文件，跟该文件同级目录下有个util.dart文件，文件代码如下： // util.dart文件内容 int add(int a, int b) { return a + b; } 在demo.dart文件中如果要引用util.dart文件，使用下面的方式导入： import &apos;./util.dart&apos;; main() { print(add(1, 2)); } 你可以使用as关键字为导入的某个包设置一个前缀，或者说别名，比如下面的代码： import &apos;package:lib1/lib1.dart&apos;; import &apos;package:lib2/lib2.dart&apos; as lib2; // Uses Element from lib1. Element element1 = Element(); // Uses Element from lib2. lib2.Element element2 = lib2.Element(); 你也可以在导入包时使用show hide关键字来导入某个包中的部分功能，比如下面的代码： // 只导入foo import &apos;package:lib1/lib1.dart&apos; show foo; // 导入除了foo的所有其他部分 import &apos;package:lib2/lib2.dart&apos; hide foo; 导入包时使用deferred as可以让这个包懒加载，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如下面的代码： import &apos;package:greetings/hello.dart&apos; deferred as hello; 利用library identifier（库标识符）声明库： // 声明库，名ballgame library ballgame; // 导入html库 import &apos;dart:html&apos;; // ...代码从这里开始... 关联文件与库添加实现文件，把part fileUri放在有库的文件，其中fileURI是实现文件的路径。然后在实现文件中，添加部分标识符（part of identifier），其中标识符是库的名称。下面的示例使用的一部分，在三个文件来实现部分库。 第一个文件，ballgame.dart，声明球赛库，导入其他需要的库，并指定ball.dart和util.dart是此库的部分： library ballgame; import &apos;dart:html&apos;; // ...其他导入在这里... part &apos;ball.dart&apos;; part &apos;util.dart&apos;; // ...代码从这里开始... 第二、三个文件ball.dart、util.dart，实现了球赛库的一部分： part of ballgame; // ...代码从这里开始... 重新导出库(Re-exporting libraries)可以通过重新导出部分库或者全部库来组合或重新打包库。例如，你可能有实现为一组较小的库集成为一个较大库。或者你可以创建一个库，提供了从另一个库方法的子集: // In french.dart: library french; hello() =&gt; print(&apos;Bonjour!&apos;); goodbye() =&gt; print(&apos;Au Revoir!&apos;); // In togo.dart: library togo; import &apos;french.dart&apos;; export &apos;french.dart&apos; show hello; // In another .dart file: import &apos;togo.dart&apos;; void main() { hello(); //print bonjour goodbye(); //FAIL } 异步Dart是单线程模型，也就没有了所谓的主线程/子线程之分。 Dart提供了类似ES7中的async await等异步操作，Dart库大多方法返回 Future 和 Stream 对象。这些方法是异步的：它们在设置一个可能的耗时操作（比如 I/O 操作）之后返回，而无需等待操作完成。 async和await往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成async，并给其中的耗时操作加上await关键字，如果这个方法有返回值，你需要将返回值塞到Future中并返回，如下代码所示： Future checkVersion() async { var version = await lookUpVersion(); // Do something with version } 下面的代码使用Dart从网络获取数据并打印出来： import &apos;dart:async&apos;; import &apos;package:http/http.dart&apos; as http; Future&lt;String&gt; getNetData() async{ http.Response res = await http.get(&quot;https://www.baidu.com&quot;); return res.body; } main() { getNetData().then((str) { print(str); }); } Even-LooperDart是单线程模型，也就没有了所谓的主线程/子线程之分。Dart也是Event-Looper以及Event-Queue的模型，所有的事件都是通过EventLooper的依次执行。而Dart的Event Loop就是： 从EventQueue中获取Event 处理Event 直到EventQueue为空 而这些Event包括了用户输入，点击，Timer，文件IO等 单线程模型一旦某个Dart的函数开始执行，它将执行到这个函数结束，也就是Dart的函数不会被其他Dart代码打断。 Dart中没有线程的概念，只有isolate，每个isolate都是隔离的，并不会共享内存。而一个Dart程序是在Main isolate的main函数开始，而在Main函数结束后，Main isolate线程开始一个一个（one by one）的开始处理Event Queue中的每一个Event。 Event Queue以及Microtask QueueDart中的Main Isolate只有一个Event Looper，但是存在两个Event Queue:Event Queue以及Microtask Queue。 Microtask Queue存在的意义是：希望通过这个Queue来处理稍晚一些的事情，但是在下一个消息到来之前需要处理完的事情。 当Event Looper正在处理Microtask Queue中的Event时候，Event Queue中的Event就停止了处理了，此时App不能绘制任何图形，不能处理任何鼠标点击，不能处理文件IO等等 Event-Looper挑选Task的执行顺序为：1.优先全部执行完Microtask Queue中的Event；2.直到Microtask Queue为空时，才会执行Event Queue中的Event： Dart中只能知道Event处理的先后顺序，但是并不知道某个Event执行的具体时间点，因为它的处理模型是一个单线程循环，而不是基于时钟调度（即它的执行只是按照Event处理完，就开始循环下一个Event，而与Java中的Thread调度不一样，没有时间调度的概念），也就是我们既是指定另一个Delay Time的Task，希望它在预期的时间后开始执行，它有可能不会在那个时间执行，需要看是否前面的Event是否已经Dequeue。 异步任务调度当有代码可以在后续任务执行的时候，有两种方式，通过dart:async这个Lib中的API即可： 使用Future类，可以将任务加入到Event Queue的队尾 使用scheduleMicrotask函数，将任务加入到Microtask Queue队尾 当使用EventQueue时，需要考虑清楚，尽量避免microtask queue过于庞大，否则会阻塞其他事件的处理： 使用Future一般常用的Future构造函数： new Future((){ // doing something }); 而一般常用的还有当有分治任务时，需要将一个大任务拆成很多小任务一步步执行时，就需要使用到Future.then函数来拆解任务 void main(){ new Future(() =&gt; futureTask) // 异步任务的函数 .then((m) =&gt; &quot;futueTask execute result:$m&quot;) // 任务执行完后的子任务 .then((m) =&gt; m.length) // 其中m为上个任务执行完后的返回的结果 .then((m) =&gt; printLength(m)) .whenComplete(() =&gt; whenTaskCompelete); // 当所有任务完成后的回调函数 } int futureTask() { return 21; } void printLength(int length) { print(&quot;Text Length:$length&quot;); } void whenTaskCompelete() { print(&quot;Task Complete&quot;); } 当任务需要延迟执行时，可以使用new Future.delay来将任务延迟执行，而如上所述，只有当Main isolate的Event Queue处于Idle的状态时，才会延迟1s执行，否则等待的时间会比1s长很多 new Future.delayed(const Duration(seconds: 1), () =&gt; futureTask); 当需要做动画的时候，不要使用Future，而需要使用animateFrame PS: Future中的then并没有创建新的Event丢到Event Queue中，而只是一个普通的Function Call，在FutureTask执行完后，立即开始执行 当Future在then函数之前已经执行完成了，则会创建一个task，将该task的添加到microtask queue中，并且该任务将会执行通过then传入的函数 Future只是创建了一个Event，将Event插入到了Event Queue的队尾 使用Future.value构造函数的时候，就会和第二条一样，创建Task丢到microtask Queue中执行then传入的函数 Future.sync构造函数执行了它传入的函数之后，也会立即创建Task丢到microtask Queue中执行 使用scheduleMicrotask在最顶层的调用关系中，使用该函数即可： async.scheduleMicrotask(() =&gt; microtask()); void microtask(){ // doing something } 使用isolate以及Worker当有计算很繁重的任务时，则需要使用isolate或者Worker来执行，以保持App对用户操作的及时响应。Isolate的实现可能是一个单独的线程，或者一个单独的进程，需要看Dart VM是如何实现的。 参考资料https://www.jianshu.com/p/06aebcad0543https://www.jianshu.com/p/9e5f4c81cc7dFlutter–Dart中的异步https://dart.dev/articles/archive/event-loop]]></content>
      <categories>
        <category>HyBrid</category>
      </categories>
      <tags>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter知识点]]></title>
    <url>%2F2019%2F06%2F25%2Fflutter-knowledge%2F</url>
    <content type="text"><![CDATA[Views在Flutter中，View相当于是Widget。Widget仅支持一帧，并且在每一帧上，Flutter的框架都会创建一个Widget实例树(相当于一次性绘制整个界面)。在Flutter中的widget是不可变的，这允许widget变得超级轻量。 Widget状态在Flutter中Widget是不可变的，不会直接更新，而必须使用Widget的状态。这是Stateful和Stateless widget的概念的来源。一个Stateless Widget就像它的名字，是一个没有状态信息的widget。 这里要注意的重要一点是无状态和有状态widget的核心特性是相同的。每一帧它们都会重新构建，不同之处在于StatefulWidget有一个State对象，它可以跨帧存储状态数据并恢复它。 如果你有疑问，那么要记住这个规则：如果一个widget发生了变化（例如用户与它交互），它就是有状态的。但是，如果一个子widget对变化做出反应，而其父widget对变化没有反应，那么包含的父widget仍然可以是无状态的widget。 Widget编写在Android中，您通过XML编写布局，但在Flutter中，使用widget树来编写布局。可以查看Flutter所提供的所有布局: Flutter widget layout 在Android中，您可以从父级控件调用addChild或removeChild以动态添加或删除View。 在Flutter中，因为widget是不可变的，所以没有addChild。相反，您可以传入一个函数，该函数返回一个widget给父项，并通过布尔值控制该widget的创建。 在Flutter中，可以通过动画库给widget添加动画，将widget包装到Animation中。与Android相似，在Flutter中，您有一个AnimationController和一个Interpolator， 它是Animation类的扩展，例如CurvedAnimation。您将控制器和动画传递到AnimationWidget中，并告诉控制器启动动画。See https://flutter.io/widgets/animation/ and https://flutter.io/tutorials/animation for more specific details. Flutter有两个类可以帮助您绘制画布，CustomPaint和CustomPainter，它们实现您的算法以绘制到画布。在这个人气较高的的StackOverFlow答案中，您可以看到签名painter是如何实现的：请参阅https://stackoverflow.com/questions/46241071/create-signature-area-for-mobile-app-in-dart-flutter 如何构建自定义 Widgets在Flutter中，一个自定义widget通常是通过组合其它widget来实现的，而不是继承。 我们来看看如何构建持有一个label的CustomButton。这是通过将Text与RaisedButton组合来实现的，而不是扩展RaisedButton并重写其绘制方法实现： class CustomButton extends StatelessWidget { final String label; CustomButton(this.label); @override Widget build(BuildContext context) { return new RaisedButton(onPressed: () {}, child: new Text(label)); } } IntentsFlutter不具有Intents的概念，但如果需要的话，Flutter可以通过Native整合来触发Intents。 要在Flutter中切换屏幕，您可以访问路由以绘制新的Widget。 管理多个屏幕有两个核心概念和类：Route 和 Navigator。Route是应用程序的“屏幕”或“页面”的抽象（可以认为是Activity）， Navigator是管理Route的Widget。Navigator可以通过push和pop route以实现页面切换。 在Flutter中，可以将具有指定Route的Map传递到顶层MaterialApp实例 void main() { runApp(new MaterialApp( home: new MyAppHome(), // becomes the route named &apos;/&apos; routes: &lt;String, WidgetBuilder&gt; { &apos;/a&apos;: (BuildContext context) =&gt; new MyPage(title: &apos;page A&apos;), &apos;/b&apos;: (BuildContext context) =&gt; new MyPage(title: &apos;page B&apos;), &apos;/c&apos;: (BuildContext context) =&gt; new MyPage(title: &apos;page C&apos;), }, )); } 然后，您可以通过Navigator来切换到命名路由的页面。 Navigator.of(context).pushNamed(&apos;/b&apos;); Intents的另一个主要的用途是调用外部组件，如Camera或File picker。为此，您需要和native集成（或使用现有的库） 处理外部传入的IntentsFlutter可以通过直接与Android层通信并请求共享的数据来处理来自Android的Intents 在这个例子中，我们注册文本共享intent，所以其他应用程序可以共享文本到我们的Flutter应用程序 这个应用程序的基本流程是我们首先处理Android端的共享文本数据，然后等待Flutter请求数据，然后通过MethodChannel发送。 首先在在AndroidManifest.xml中注册我们想要处理的intent: &lt;activity android:name=&quot;.MainActivity&quot; android:launchMode=&quot;singleTop&quot; android:theme=&quot;@style/LaunchTheme&quot; android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection&quot; android:hardwareAccelerated=&quot;true&quot; android:windowSoftInputMode=&quot;adjustResize&quot;&gt; &lt;!-- This keeps the window background of the activity showing until Flutter renders its first frame. It can be removed if there is no splash screen (such as the default splash screen defined in @style/LaunchTheme). --&gt; &lt;meta-data android:name=&quot;io.flutter.app.android.SplashScreenUntilFirstFrame&quot; android:value=&quot;true&quot; /&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:mimeType=&quot;text/plain&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 然后，在MainActivity中处理intent，一旦我们从intent中获得共享文本数据，我们就会持有它，直到Flutter在完成准备就绪时请求它。 public class MainActivity extends FlutterActivity { String sharedText; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); GeneratedPluginRegistrant.registerWith(this); Intent intent = getIntent(); String action = intent.getAction(); String type = intent.getType(); if (Intent.ACTION_SEND.equals(action) &amp;&amp; type != null) { if (&quot;text/plain&quot;.equals(type)) { handleSendText(intent); // Handle text being sent } } new MethodChannel(getFlutterView(), &quot;app.channel.shared.data&quot;).setMethodCallHandler(new MethodChannel.MethodCallHandler() { @Override public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) { if (methodCall.method.contentEquals(&quot;getSharedText&quot;)) { result.success(sharedText); sharedText = null; } } }); } void handleSendText(Intent intent) { sharedText = intent.getStringExtra(Intent.EXTRA_TEXT); } } 最后，在Flutter中，在渲染Flutter视图时请求数据： class _SampleAppPageState extends State&lt;SampleAppPage&gt; { static const platform = const MethodChannel(&apos;app.channel.shared.data&apos;); String dataShared = &quot;No data&quot;; @override void initState() { super.initState(); getSharedText(); } @override Widget build(BuildContext context) { return new Scaffold(body: new Center(child: new Text(dataShared))); } getSharedText() async { var sharedData = await platform.invokeMethod(&quot;getSharedText&quot;); if (sharedData != null) { setState(() { dataShared = sharedData; }); } } } startActivityForResult 在Flutter中等价于什么处理Flutter中所有路由的Navigator类可用于从已经push到栈的路由中获取结果。 这可以通过等待push返回的Future来完成。例如，如果您要启动让用户选择其位置的位置的路由，则可以执行以下操作： Map coordinates = await Navigator.of(context).pushNamed(&apos;/location&apos;); 然后在你的位置路由中，一旦用户选择了他们的位置，你可以将结果”pop”出栈： Navigator.of(context).pop({&quot;lat&quot;:43.821757,&quot;long&quot;:-79.226392}); 异步UIrunOnUiThread 在Flutter中等价于什么Dart是单线程执行模型，支持Isolates（在另一个线程上运行Dart代码的方式）、事件循环和异步编程。 除非您启动一个Isolate，否则您的Dart代码将在主UI线程中运行，并由事件循环驱动（译者语：和JavaScript一样）。 AsyncTask和IntentService在Flutter中等价于什么由于Flutter是单线程的，运行一个事件循环（如Node.js），所以您不必担心线程管理或者使用AsyncTasks、IntentServices。 要异步运行代码，可以将函数声明为异步函数，并在该函数中等待这个耗时任务 loadData() async { String dataURL = &quot;https://jsonplaceholder.typicode.com/posts&quot;; http.Response response = await http.get(dataURL); setState(() { widgets = JSON.decode(response.body); }); } 这就是典型的进行网络或数据库调用的方式 在Android上，当您继承AsyncTask时，通常会覆盖3个方法，OnPreExecute、doInBackground和onPostExecute。 在Flutter中没有这种模式的等价物，因为您只需等待一个长时间运行的函数，而Dart的事件循环将负责其余的事情。但是，有时您可能需要处理大量数据，导致UI可能会挂起。在这种情况下，与AsyncTask一样，在Flutter中，可以利用多个CPU内核来执行耗时或计算密集型任务。这是通过使用Isolates来完成的。 Isolate是一个独立的执行线程，它运行时不会与主线程共享任何内存。这意味着你不能从该线程访问变量或通过调用setState来更新你的UI。 OkHttp在Flutter中等价于什么当使用受欢迎的“http”package时，Flutter进行网络信非常简单。 虽然“http” package 没有实现OkHttp的所有功能，但“http” package 抽象出了许多常用的API，可以简单有效的发起网络请求。 您可以通过在pubspec.yaml中添加依赖项来使用它 dependencies: ... http: &apos;&gt;=0.11.3+12&apos; 在Android中，当您执行耗时任务时，通常会显示进度指示器。在Flutter中，这可以通过渲染Progress Indicator widget来实现。您可以通过编程方式显示Progress Indicator ， 通过布尔值通知Flutter在耗时任务发起之前更新其状态。 项目结构和资源在哪里存储分辨率相关的图片文件? HDPI/XXHDPIFlutter遵循像iOS这样简单的3种分辨率格式: 1x, 2x, and 3x. 创建一个名为images的文件夹，并为每个图像文件生成一个@2x和@3x文件，并将它们放置在如下这样的文件夹中: …/my_icon.png …/2.0x/my_icon.png …/3.0x/my_icon.png 然后，您需要在pubspec.yaml文件中声明这些图片: assets: - images/a_dot_burr.jpeg - images/a_dot_ham.jpeg 然后您可以使用AssetImage访问您的图像 return new AssetImage(&quot;images/a_dot_burr.jpeg&quot;); 在哪里存储字符串? 如何存储不同的语言目前，最好的做法是创建一个名为Strings的类 class Strings{ static String welcomeMessage = &quot;Welcome To Flutter&quot;; } 然后在你的代码中，你可以像访问你的字符串一样： new Text(Strings.welcomeMessage) Flutter对Android的可访问性提供了基本的支持，虽然这个功能正在进行中。 鼓励Flutter开发者使用intl package进行国际化和本地化 Android Gradle vs Flutter pubspec.yaml在Android中，您可以在Gradle文件来添加依赖项。 在Flutter中，虽然在Flutter项目中的Android文件夹下有Gradle文件，但只有在添加平台相关所需的依赖关系时才使用这些文件。 否则，应该使用pubspec.yaml声明用于Flutter的外部依赖项。 发现好的flutter packages的一个好地方 Pub Activities 和 Fragments在Flutter中，这两个概念都等同于Widget。 如何监听Android Activity生命周期事件在Android中，您可以覆盖Activity的方法来捕获Activity的生命周期回调。 在Flutter中您可以通过挂接到WidgetsBinding观察并监听didChangeAppLifecycleState更改事件来监听生命周期事件 您可以监听到的生命周期事件是 resumed - 应用程序可见并响应用户输入。这是来自Android的onResume inactive - 应用程序处于非活动状态，并且未接收用户输入。此事件在Android上未使用，仅适用于iOS paused - 应用程序当前对用户不可见，不响应用户输入，并在后台运行。这是来自Android的暂停 suspending - 该应用程序将暂时中止。这在iOS上未使用 class _LifecycleWatcherState extends State with WidgetsBindingObserver { AppLifecycleState _lastLifecyleState; @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); } @override void dispose() { WidgetsBinding.instance.removeObserver(this); super.dispose(); } @override void didChangeAppLifecycleState(AppLifecycleState state) { setState(() { _lastLifecyleState = state; }); } @override Widget build(BuildContext context) { if (_lastLifecyleState == null) return new Text(&apos;This widget has not observed any lifecycle changes.&apos;, textDirection: TextDirection.ltr); return new Text(&apos;The most recent lifecycle state this widget observed was: $_lastLifecyleState.&apos;, textDirection: TextDirection.ltr); } } LayoutsLinearLayout在Flutter中相当于什么在Android中，使用LinearLayout来使您的控件呈水平或垂直排列。在Flutter中，您可以使用Row或Co​​lumn来实现相同的结果: @override Widget build(BuildContext context) { return new Row( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ new Text(&apos;Row One&apos;), new Text(&apos;Row Two&apos;), new Text(&apos;Row Three&apos;), new Text(&apos;Row Four&apos;), ], ); } RelativeLayout在Flutter中等价于什么RelativeLayout用于使widget相对于彼此位置排列。在Flutter中，有几种方法可以实现相同的结果 您可以通过使用Column、Row和Stack的组合来实现RelativeLayout的效果。您可以为widget构造函数指定相对于父组件的布局规则。 一个在Flutter中构建RelativeLayout的好例子，请参考在StackOverflow上: https://stackoverflow.com/questions/44396075/equivalent-of-relativelayout-in -flutter ScrollView在Flutter中等价于什么在Android中，ScrollView允许您包含一个子控件，以便在用户设备的屏幕比控件内容小的情况下，使它们可以滚动。 在Flutter中，最简单的方法是使用ListView。但在Flutter中，一个ListView既是一个ScrollView，也是一个Android ListView。 手势检测和触摸事件处理如何将一个onClick监听器添加到Flutter中的widget在Flutter中，添加触摸监听器有两种方法: 如果Widget支持事件监听，则可以将一个函数传递给它并进行处理。例如，RaisedButton有一个onPressed参数: @override Widget build(BuildContext context) { return new RaisedButton( onPressed: () { print(&quot;click&quot;); }, child: new Text(&quot;Button&quot;)); } 如果Widget不支持事件监听，则可以将该Widget包装到GestureDetector中，并将处理函数传递给onTap参数: class SampleApp extends StatelessWidget { @override Widget build(BuildContext context) { return new Scaffold( body: new Center( child: new GestureDetector( child: new FlutterLogo( size: 200.0, ), onTap: () { print(&quot;tap&quot;); }, ), )); } } 如何处理widget上的其他手势使用GestureDetector，可以监听多种手势，例如: Tap onTapDownonTapUponTaponTapCancel Double tap onDoubleTap 用户快速连续两次在同一位置轻敲屏幕. 长按 onLongPress 垂直拖动 onVerticalDragStartonVerticalDragUpdateonVerticalDragEnd 水平拖拽 onHorizontalDragStartonHorizontalDragUpdateonHorizontalDragEnd Listview &amp; AdapterListView在Flutter中相当于什么在Flutter中，ListView就是一个ListView！ 在Android ListView中，您可以创建一个适配器，然后您可以将它传递给ListView，该适配器将使用适配器返回的内容来展示每一行。 然而，你必须确保在合适的时机回收行，否则，你会得到各种疯狂的视觉和内存问题。 在Flutter中，由于Flutter的不可变的widget模型，将一个Widgets列表传递给的ListView，而Flutter将负责确保它们快速平滑地滚动。 怎么知道哪个列表项被点击在Android中，ListView有一个方法’onItemClickListener’来确定哪个列表项被点击。 Flutter中可以更轻松地通过您传入的处理回调来进行操作： _getListData() { List&lt;Widget&gt; widgets = []; for (int i = 0; i &lt; 100; i++) { widgets.add(new GestureDetector( child: new Padding( padding: new EdgeInsets.all(10.0), child: new Text(&quot;Row $i&quot;)), onTap: () { print(&apos;row tapped&apos;); }, )); } return widgets; } 如何动态更新ListView需要更新适配器并调用notifyDataSetChanged。在Flutter中，如果setState（）中更新widget列表，您会发现没有变化， 这是因为当setState被调用时，Flutter渲染引擎会遍历所有的widget以查看它们是否已经改变。 当遍历到你的ListView时，它会做一个==运算，以查看两个ListView是否相同，因为没有任何改变，因此没有更新数据。 要更新您的ListView，然后在setState中创建一个新的List（）并将所有旧数据复制到新列表中。这是实现更新的简单方法（译者语：此时状态改变，ListView被重新构建） 然而，推荐的方法是使用ListView.Builder。当您拥有动态列表或包含大量数据的列表时，此方法非常有用。 这实际上相当于在Android上使用RecyclerView，它会自动为您回收列表元素： @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(&quot;Sample App&quot;), ), body: new ListView.builder( itemCount: widgets.length, itemBuilder: (BuildContext context, int position) { return getRow(position); })); } Widget getRow(int i) { return new GestureDetector( child: new Padding( padding: new EdgeInsets.all(10.0), child: new Text(&quot;Row $i&quot;)), onTap: () { setState(() { widgets.add(getRow(widgets.length + 1)); print(&apos;row $i&apos;); }); }, ); } 我们不是创建一个“新的ListView”，而是创建一个新的ListView.builder，它接受两个参数，即列表的初始长度和一个ItemBuilder函数。ItemBuilder函数非常类似于Android适配器中的getView函数，它需要一个位置并返回要为该位置渲染的行。 最后，但最重要的是，如果您注意到onTap函数，在里面，我们不会再重新创建列表，而只是添加新元素到列表。 使用 Text如何在 Text widget上设置自定义字体在Android SDK（从Android O开始）中，创建一个Font资源文件并将其传递到TextView的FontFamily参数中。 在Flutter中，首先你需要把你的字体文件放在项目文件夹中（最好的做法是创建一个名为assets的文件夹） 接下来在pubspec.yaml文件中，声明字体： fonts: - family: MyCustomFont fonts: - asset: fonts/MyCustomFont.ttf - style: italic 最后，将字体应用到Text widget: @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(&quot;Sample App&quot;), ), body: new Center( child: new Text( &apos;This is a custom font text&apos;, style: new TextStyle(fontFamily: &apos;MyCustomFont&apos;), ), ), ); } 如何在Text上定义样式Text的样式参数需要一个TextStyle对象，您可以在其中自定义许多参数。 表单输入Input的”hint”在flutter中相当于什么在Flutter中，您可以通过向Text Widget的装饰构造函数参数添加InputDecoration对象，轻松地为输入框显示占位符文本 body: new Center( child: new TextField( decoration: new InputDecoration(hintText: &quot;This is a hint&quot;), ) ) 如何显示验证错误就像您如何使用“hint”一样，您可以将InputDecoration对象传递给Text的装饰构造函数。 但是，您不希望首先显示错误，并且通常会在用户输入一些无效数据时显示该错误。这可以通过更新状态并传递一个新的InputDecoration对象来完成： class _SampleAppPageState extends State&lt;SampleAppPage&gt; { String _errorText; @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text(&quot;Sample App&quot;), ), body: new Center( child: new TextField( onSubmitted: (String text) { setState(() { if (!isEmail(text)) { _errorText = &apos;Error: This is not an email&apos;; } else { _errorText = null; } }); }, decoration: new InputDecoration(hintText: &quot;This is a hint&quot;, errorText: _getErrorText()), ), ), ); } _getErrorText() { return _errorText; } bool isEmail(String em) { String emailRegexp = r&apos;^(([^&lt;&gt;()[\]\\.,;:\s@\&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@\&quot;]+)*)|(\&quot;.+\&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$&apos;; RegExp regExp = new RegExp(p); return regExp.hasMatch(em); } } Flutter 插件如何使用 GPS sensor要访问GPS传感器，您可以使用社区插件 https://pub.dartlang.org/packages/location 如何访问相机访问相机的流行社区插件是 https://pub.dartlang.org/packages/image_picker 如何使用Facebook登陆要访问Facebook Connect功能，您可以使用 https://pub.dartlang.org/packages/flutter_facebook_connect . 如何构建自定义集成Native功能如果有Flutter或其社区插件缺失的平台特定功能，那么您可以自己按照以下教程构建https://flutterchina.club/developing-packages/简而言之，Flutter的插件架构就像在Android中使用Event bus一样：您可以发出消息并让接收者进行处理并将结果返回给您，在这种情况下，接收者将是iOS或Android。 如何在我的Flutter应用程序中使用NDK自定义插件首先会与Android应用程序通信，您可以在其中调用native标记的函数。一旦Native完成了相应操作，就可以将响应消息发回给Flutter并呈现结果。 主题Flutter很好的实现了一个美丽的Material Design，它会满足很多样式和主题的需求。 与Android中使用XML声明主题不同，在Flutter中，您可以通过顶层widget声明主题。 MaterialApp是一个方便的widget，它包装了许多Material Design应用通常需要的widget，它通过添加Material特定功能构建在WidgetsApp上。 如果你不想使用Material Components，那么你可以声明一个顶级widget-WidgetsApp，它是一个便利的类，它包装了许多应用程序通常需要的widget。 要自定义Material Components的颜色和样式，您可以将ThemeData对象传递到MaterialApp widget中，例如在下面的代码中，您可以看到主色板设置为蓝色，并且所有选择区域的文本颜色都应为红色。 class SampleApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: &apos;Sample App&apos;, theme: new ThemeData( primarySwatch: Colors.blue, textSelectionColor: Colors.red ), home: new SampleAppPage(), ); } } Scaffold 是 Material library 中提供的一个widget, 它提供了默认的导航栏、标题和包含主屏幕widget树的body属性。widget树可以很复杂。 数据库和本地存储如何在Flutter中访问Shared Preferences ?在Flutter中，您可以通过使用插件Shared_Preferences来访问此功能 这个插件包装了Shared Preferences和NSUserDefaults（与iOS相同）的功能 import &apos;package:flutter/material.dart&apos;; import &apos;package:shared_preferences/shared_preferences.dart&apos;; void main() { runApp( new MaterialApp( home: new Scaffold( body: new Center( child: new RaisedButton( onPressed: _incrementCounter, child: new Text(&apos;Increment Counter&apos;), ), ), ), ), ); } _incrementCounter() async { SharedPreferences prefs = await SharedPreferences.getInstance(); int counter = (prefs.getInt(&apos;counter&apos;) ?? 0) + 1; print(&apos;Pressed $counter times.&apos;); prefs.setInt(&apos;counter&apos;, counter); } 如何在Flutter中访问SQLite在Android中，您可以使用SQLite存储，通过SQL查询的结构化数据。 在Flutter中，您可以使用SQFlite插件来访问SQFlite此功能 通知在Android中，您可以使用Firebase云消息传递为您的应用设置推送通知。 在Flutter中，您可以使用Firebase_Messaging插件访问此功能 注意：在中国无法使用Firebase服务。 参考资料Flutter for Android 开发者]]></content>
      <categories>
        <category>HyBrid</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux概念]]></title>
    <url>%2F2019%2F06%2F25%2Fhybird-redux%2F</url>
    <content type="text"><![CDATA[Redux是一个状态管理器。 Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers）。 Redux核心概念 actions store reducers Actions简单地，Actions就是事件。Actions传递来自这个应用（用户接口，内部事件比如API调用和表单提交）的数据给store。store只获取来自Actions的信息。内部Actions就是简单的具有一个type属性（通常是常量）的JavaScript对象，这个对象描述了action的类型以及传递给store的负载信息: { type: LOGIN_FORM_SUBMIT, payload: {username: &apos;alex&apos;, password: &apos;123456&apos;} } Reducers在函数式JavaScript中reducer基于数组reduce方法，接收一个回调（reducer）让你从多个值中获得单个值，整数和，或者一个一系列值的累积。在Redux中，reducer就是获得这个应用的当前状态和事件然后返回一个新状态的函数。理解reducer是怎样工作的至关重要，因为它们完成大部分工作。这是一个非常简单的reducer，通过获取当前state和一个action作为参数，再返回下一个state： function handleAuth(state, action) { return _.assign({}, state, { auth: action.payload }); } 对于更多复杂的项目，使用Redux提供的combineReducers()实例是必要的（推荐）。它把在这个应用中所有的reducer结合在一起成为单个索引reducer。每一个reducer负责它自己那部分应用的状态，这个状态参数和其他reducer的不一样。combineReducers()实例使文件结构更容易维护。如果一个对象（state）只改变一些值，Redux就创建一个新的对象，那些没有改变的值将会指向旧的对象而且新的值将会被创建。这对性能是极好的。为了让它更有效率你可以添加 Immutable.js const rootReducer = combineReducers({ handleAuth: handleAuth, editProfile: editProfile, changePassword: changePassword }); StoreStore对象保存应用的状态并提供一些帮助方法来存取状态，分发状态以及注册监听。全部state由一个store来表示。任何action通过reducer返回一个新的状态对象。这就使得Redux非常简单以及可预测。 参考资料完全理解 redux（从零实现一个 redux）]]></content>
      <categories>
        <category>HyBrid</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android IBinder机制]]></title>
    <url>%2F2019%2F05%2F30%2Fandroid-binder%2F</url>
    <content type="text"><![CDATA[Android系统Binder机制中的四个组件Client、Server、Service Manager和Binder驱动程序的关系如下图所示： Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中 Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信 Client和Server之间的进程间通信通过Binder驱动程序间接实现 Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力 Android 整体架构我们先来大概看下 Android 这座大山的整体轮廓。我们先从 Android 的整体架构来看看 Binder 是处于什么地位，这张图引自 Android 项目开源网站：https://source.android.com： 从下往上依次为 内核层：Linux 内核和各类硬件设备的驱动，这里需要注意的是，Binder IPC 驱动也是在这一层实现，比较特殊 硬件抽象层：封装「内核层」硬件驱动，提供可供「系统服务层」调用的统一硬件接口 系统服务层：提供核心服务，并且提供可供「应用程序框架层」调用的接口 Binder IPC 层：作为「系统服务层」与「应用程序框架层」的 IPC 桥梁，互相传递接口调用的数据，实现跨进层的通讯 应用程序框架层：这一层可以理解为 Android SDK，提供四大组件，View 绘制体系等平时开发中用到的基础部件 在一个大的项目里面，分层是非常重要的，处于最底层的接口最具有「通用性」，接口粒度最细，越往上层通用性降低。理论上来说上面的每一层都可以「开放」给开发者调用，例如开发者可以直接调用硬件抽象层的接口去操作硬件，或者直接调用系统服务层中的接口去直接操作系统服务，甚至是像 Windows 开发一样，开发者可以在内核层写程序，运行在内核中。不过开放带来的问题就是开发者权利太大，对于系统的稳定性是没有任何好处的，一个病毒制作者写了一个内核层的病毒，系统也许永远也起不来了。所以谷歌的做法是将开发者的权利收拢到了「应用程序框架层」，开发者只能调用这一层提供的接口。 上面的层次中，内核层与硬件抽象层均用 C/C++ 实现，系统服务层是以 Java 实现，硬件抽象层编译为 so 文件，以 JNI 的形式供系统服务层使用。系统服务层中的服务随系统的启动而启动，只要不关机，就会一直运行。这些服务干什么事情呢？其实很简单，就是完成一个手机该有的核心功能如短信的收发管理、电话的接听、挂断以及应用程序的包管理、Activity 的管理等等。每一个服务均运行在一个独立进程中，因为是以 Java 实现，所以本质上来说就是运行在一个独立进程的 Dalvik 虚拟机中。问题就来了，开发者的 APP 运行在一个新的进程空间，如何调用到系统服务层中的接口呢？答案是 IPC（Inter-Process Communication），进程间通讯，缩写与 RPC（Remote Procedure Call）是不一样的，实现原理也是不一样的。每一个系统服务在应用层序框架层都有一个 Manager 与之对应，方便开发者调用其相关的功能，具体关系大致如下 IPC 的方式有很多种，例如 socket、共享内存、管道、消息队列等等，我们就不去深究为何要使用 Binder 而不使用其他方式去做，到目前为止，这座大山的面目算是有个大概的轮廓了。 小结 Android 从下而上分了内核层、硬件抽象层、系统服务层、Binder IPC 层、应用程序框架层 Android 中「应用程序框架层」以 SDK 的形式开放给开发者使用，「系统服务层」中的核心服务随系统启动而运行，通过应用层序框架层提供的 Manager 实时为应用程序提供服务调用。系统服务层中每一个服务运行在自己独立的进程空间中，应用程序框架层中的 Manager 通过 Binder IPC 的方式调用系统服务层中的服务。 Binder IPC 的架构下面我们就来看看 Binder IPC 的架构是怎样的 Binder IPC 属于 C/S 结构，Client 部分是用户代码，用户代码最终会调用 Binder Driver 的 transact 接口，Binder Driver 会调用 Server，这里的 Server 与 service 不同，可以理解为 Service 中 onBind 返回的 Binder 对象，请注意区分下: Client：用户需要实现的代码，如 AIDL 自动生成的接口类 Binder Driver：在内核层实现的 Driver Server：这个 Server 就是 Service 中 onBind 返回的 IBinder 对象 需要注意的是，上面绿色的色块部分都是属于用户需要实现的部分，而蓝色部分是系统去实现了。也就是说 Binder Driver 这块并不需要知道，Server 中会开启一个线程池去处理客户端调用。为什么要用线程池而不是一个单线程队列呢？试想一下，如果用单线程队列，则会有任务积压，多个客户端同时调用一个服务的时候就会有来不及响应的情况发生，这是绝对不允许的。 对于调用 Binder Driver 中的 transact 接口，客户端可以手动调用，也可以通过 AIDL 的方式生成的代理类来调用，服务端可以继承 Binder 对象，也可以继承 AIDL 生成的接口类的 Stub 对象。 切记，这里 Server 的实现是线程池的方式，而不是单线程队列的方式，区别在于，单线程队列的话，Server 的代码是线程安全的，线程池的话，Server 的代码则不是线程安全的，需要开发者自己做好多线程同步。 小结 Binder IPC 属于 C/S 架构，包括 Client、Driver、Server 三个部分 Client 可以手动调用 Driver 的 transact 接口，也可以通过 AIDL 生成的 Proxy 调用 Server 中会启动一个「线程池」来处理 Client 的调用请求，处理完成后将结果返回给 Driver，Driver 再返回给 Client 这里就回答了两个问题：Service 中通过 AIDL 提供的接口并不是线程安全的，同理 ContentProvider 底层也是使用 Binder，同样不是线程安全的，至于是否需要做多线程保护，看业务而定，最好是做好多线程同步，以防万一。 使用 AIDL 实现 Binder IPCAndroid 给了我们更好用的方式那就是 AIDL，假如我们要做一个上报数据的功能，运行在 Service 中，在后台上报数据，接口定义如下 IReporter.aidlpackage com.android.binder; interface IReporter { int report(String values, int type); } ServerAidlService.java public class AidlService extends Service { public static final class Reporter extends IReporter.Stub { @Override public int report(String values, int type) throws RemoteException { return type; } } private Reporter mReporter; public AidlService() { mReporter = new Reporter(); } @Override public IBinder onBind(Intent intent) { return mReporter; } } 继承了 AIDL 自动生成的 Stub 对象，它是什么呢？我们可以看下它的定义 IReporter.javapublic interface IReporter extends android.os.IInterface { public static abstract class Stub extends android.os.Binder implements com.android.binder.IReporter { ... @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException { switch (code) { case INTERFACE_TRANSACTION: { reply.writeString(DESCRIPTOR); return true; } case TRANSACTION_report: { data.enforceInterface(DESCRIPTOR); java.lang.String _arg0; _arg0 = data.readString(); int _arg1; _arg1 = data.readInt(); int _result = this.report(_arg0, _arg1); reply.writeNoException(); reply.writeInt(_result); return true; } } return super.onTransact(code, data, reply, flags); } } ... } 自动生成的 IReporter 类自动给我们处理了一些参数的组包和解包而已，在 case 语句中调用了 this.report 即可调用到自己的业务逻辑部分了。 Driver该部分已经被 Binder 类给封装了，暴露给开发者的已经是很简单的使用方式了，即继承 Binder，实现 onTransact 即可。 ClientMainActivity.java private IReporter mReporterAidl; private class AidlConnection implements ServiceConnection { @Override public void onServiceConnected(ComponentName name, IBinder service) { mReporterAidl = IReporter.Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { mReporterAidl = null; } } ... @Override protected void onCreate(Bundle savedInstanceState) { ... Intent intent = new Intent(this, AidlService.class); bindService(intent, new AidlConnection(), BIND_AUTO_CREATE); } 这里调用了 Stub 对象的 asInterface，具体做了什么呢？ public static com.android.binder.IReporter asInterface(android.os.IBinder obj) { if ((obj==null)) { return null; } android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)&amp;&amp;(iin instanceof com.android.binder.IReporter))) { return ((com.android.binder.IReporter)iin); } return new com.android.binder.IReporter.Stub.Proxy(obj); } 先查找本地接口是否存在，判断是否是本地调用，如果是则直接返回 IReporter 的对象，否则返回 Stub.Proxy 对象，这个 Proxy 对象是做什么的呢？ private static class Proxy implements com.android.binder.IReporter { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } @Override public android.os.IBinder asBinder() { return mRemote; } public java.lang.String getInterfaceDescriptor() { return DESCRIPTOR; } @Override public int report(java.lang.String values, int type) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try { _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(values); _data.writeInt(type); mRemote.transact(Stub.TRANSACTION_report, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); } finally { _reply.recycle(); _data.recycle(); } return _result; } } 基本上已经很明了了，就是一个代理对象，对调用接口参数做组包而已，然后调用了 mRemote.transact 接口。 小结 AIDL 自动生成了 Stub 类 在 Service 端继承 Stub 类，Stub 类中实现了 onTransact 方法实现了「解包」的功能 在 Client 端使用 Stub 类的 Proxy 对象，该对象实现了「组包」并且调用 transact 的功能 有了 AIDL 之后，IReporter 接口就变得有意义了，Client 调用接口，Server 端实现接口，一切「组包」、「解包」的逻辑封装在了 Stub 类中，一切就是那么完美。 参考资料https://www.jianshu.com/p/bdef9e3178c9https://blog.csdn.net/luoshengyang/article/details/6618363Android IBinder机制简单介绍]]></content>
      <categories>
        <category>android知识点</category>
      </categories>
      <tags>
        <tag>iBinder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常量池]]></title>
    <url>%2F2019%2F05%2F29%2Fjava-constant-pool%2F</url>
    <content type="text"><![CDATA[常量池是为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享。 Jvm虚拟内存分布 程序计数器是jvm执行程序的流水线，存放一些跳转指令。 本地方法栈是jvm调用操作系统方法所使用的栈。 虚拟机栈是jvm执行java代码所使用的栈。 方法区存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。 虚拟机堆是jvm执行java代码所使用的堆。 Java常量池分类Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。这种常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量： 类和接口的全限定名字段名称和描述符方法名称和描述符 而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。 常量池的好处常量池是为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。 享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，减少对象数量从而改善应用所需的对象结构的方式。实现方式一般是通过HashMap完成。java常量池的设计初中也是为了减少内存占用，同时保证访问安全。继承Number的包装类常量池存储使用数组，String使用继承自HashTable的StringTable 实例接下来我们引用一些网络上流行的常量池例子，然后借以讲解。 1 String s1 = &quot;Hello&quot;; 2 String s2 = &quot;Hello&quot;; 3 String s3 = &quot;Hel&quot; + &quot;lo&quot;; 4 String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;); 5 String s5 = new String(&quot;Hello&quot;); 6 String s6 = s5.intern(); 7 String s7 = &quot;H&quot;; 8 String s8 = &quot;ello&quot;; 9 String s9 = s7 + s8; 10 11 System.out.println(s1 == s2); // true 12 System.out.println(s1 == s3); // true 13 System.out.println(s1 == s4); // false 14 System.out.println(s1 == s9); // false 15 System.out.println(s4 == s5); // false 16 System.out.println(s1 == s6); // true 首先说明一点，在java 中，直接使用==操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用String.equals()。 s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。 s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = “Hel” + “lo”;在class文件中被优化成String s3 = “Hello”，所以s1 == s3成立。只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。 s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。 配上一张简图理清思路： s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，不能在编译期被确定，所以不做优化，只能等到运行时，在堆中创建s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同。 s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。 s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。 特例1 public static final String A = &quot;ab&quot;; // 常量A public static final String B = &quot;cd&quot;; // 常量B public static void main(String[] args) { String s = A + B; // 将两个常量用+连接对s进行初始化 String t = &quot;abcd&quot;; if (s == t) { System.out.println(&quot;s等于t，它们是同一个对象&quot;); } else { System.out.println(&quot;s不等于t，它们不是同一个对象&quot;); } } s等于t，它们是同一个对象 A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：String s=A+B; 等同于：String s=”ab”+”cd”; 特例2 public static final String A; // 常量A public static final String B; // 常量B static { A = &quot;ab&quot;; B = &quot;cd&quot;; } public static void main(String[] args) { // 将两个常量用+连接对s进行初始化 String s = A + B; String t = &quot;abcd&quot;; if (s == t) { System.out.println(&quot;s等于t，它们是同一个对象&quot;); } else { System.out.println(&quot;s不等于t，它们不是同一个对象&quot;); } } s不等于t，它们不是同一个对象 A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。 至此，我们可以得出三个非常重要的结论： 必须要关注编译期的行为，才能更好的理解常量池。运行时常量池中的常量，基本来源于各个class文件中的常量池。程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。 以上所讲仅涉及字符串常量池，实际上还有整型常量池、浮点型常量池(java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；两种浮点数类型的包装类Float,Double并没有实现常量池技术) 等等，但都大同小异，只不过数值类型的常量池不可以手动添加常量，程序启动时常量池中的常量就已经确定了，比如整型常量池中的常量范围：-128~127，（Byte,Short,Integer,Long,Character,Boolean）这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 例如在自动装箱时，把int变成Integer的时候，是有规则的，当你的int的值在-128-IntegerCache.high(127) 时，返回的不是一个新new出来的Integer对象，而是一个已经缓存在堆 中的Integer对象，（我们可以这样理解，系统已经把-128到127之 间的Integer缓存到一个Integer数组中去了，如果你要把一个int变成一个Integer对象，首先去缓存中找，找到的话直接返回引用给你就 行了，不必再新new一个），如果不在-128-IntegerCache.high(127) 时会返回一个新new出来的Integer对象。 实践说了这么多理论，接下来让我们触摸一下真正的常量池。 前文提到过，class文件中存在一个静态常量池，这个常量池是由编译器生成的，用来存储java源文件中的字面量(本文仅仅关注字面量)，假设我们有如下java代码： 1 String s = &quot;hi&quot;; 为了方便起见，就这么简单，没错！将代码编译成class文件后，用winhex打开二进制格式的class文件。如图：简单讲解一下class文件的结构，开头的4个字节是class文件魔数，用来标识这是一个class文件，说白话点就是文件头，既：CA FE BA BE。 紧接着4个字节是java的版本号，这里的版本号是34，因为笔者是用jdk8编译的，版本号的高低和jdk版本的高低相对应，高版本可以兼容低版本，但低版本无法执行高版本。所以，如果哪天读者想知道别人的class文件是用什么jdk版本编译的，就可以看这4个字节。 接下来就是常量池入口，入口处用2个字节标识常量池常量数量，本例中数值为00 1A，翻译成十进制是26，也就是有25个常量，其中第0个常量是特殊值，所以只有25个常量。 常量池中存放了各种类型的常量，他们都有自己的类型，并且都有自己的存储规范，本文只关注字符串常量，字符串常量以01开头(1个字节)，接着用2个字节记录字符串长度，然后就是字符串实际内容。本例中为：01 00 02 68 69。 接下来再说说运行时常量池，由于运行时常量池在方法区中，我们可以通过jvm参数：-XX:PermSize、-XX:MaxPermSize来设置方法区大小，从而间接限制常量池大小。 假设jvm启动参数为：-XX:PermSize＝2M -XX:MaxPermSize＝2M，然后运行如下代码： 1 //保持引用，防止自动垃圾回收 2 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 3 4 int i = 0; 5 6 while(true){ 7 //通过intern方法向常量池中手动添加常量 8 list.add(String.valueOf(i++).intern()); 9 } 程序立刻会抛出：Exception in thread “main” java.lang.outOfMemoryError: PermGen space异常。PermGen space正是方法区，足以说明常量池在方法区中。 在jdk8中，移除了方法区，转而用Metaspace区域替代，所以我们需要使用新的jvm参数：-XX:MaxMetaspaceSize=2M，依然运行如上代码，抛出：java.lang.OutOfMemoryError: Metaspace异常。同理说明运行时常量池是划分在Metaspace区域中。 参考资料https://www.cnblogs.com/syp172654682/p/8082625.htmlhttps://www.jianshu.com/p/aaa80665542d]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解（Annotation）]]></title>
    <url>%2F2019%2F05%2F28%2Fjava-annotation%2F</url>
    <content type="text"><![CDATA[Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。 注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。 元注解java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）： @Documented – 注解是否将包含在JavaDoc中 @Retention – 什么时候使用该注解 @Target – 注解用于什么地方 @Inherited – 是否允许子类继承该注解 1.）@Retention – 定义该注解的生命周期 ● RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 ● RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式 ● RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 2.）Target – 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括 ● ElementType.CONSTRUCTOR: 用于描述构造器 ● ElementType.FIELD: 成员变量、对象、属性（包括enum实例） ● ElementType.LOCAL_VARIABLE: 用于描述局部变量 ● ElementType.METHOD: 用于描述方法 ● ElementType.PACKAGE: 用于描述包 ● ElementType.PARAMETER: 用于描述参数 ● ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明 3.)@Documented – 一个简单的Annotations 标记注解，没有成员，表示是否将注解信息添加在java 文档中。 4.)@Inherited – 定义该注释和子类的关系 @Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。 注意：Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。 当Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 自定义注解自定义注解类编写的一些规则: Annotation 型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口. 参数成员只能用public 或默认(default) 这两个访问权修饰 参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组. 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法 注解也可以没有定义成员,，不过这样注解就没啥用了PS:自定义注解需要使用到元注解 注解实现创建注解处理器，利用反射对注解加以处理。AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口。所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息： 方法1： T getAnnotation(Class annotationClass):返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。 方法3：boolean is AnnotationPresent(Class annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false. 方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 参考资料Java注解（Annotation）原理详解https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html]]></content>
      <categories>
        <category>Java知识点</category>
      </categories>
      <tags>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载器ClassLoader及Dex/Class]]></title>
    <url>%2F2019%2F05%2F10%2Fandroid-dex%2F</url>
    <content type="text"><![CDATA[ClassLoader顾名思义，类加载器用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例，每个这样的实例用来表示一个 Java 类，通过此实例的 newInstance()方法就可以创建出该类的一个对象。 类加载器是 Java 语言的一个创新。它使得动态安装和更新软件组件成为可能。 Java 虚拟机是如何判定两个Java类是相同的：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。 类加载器的代理模式类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。 代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。 不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。 ClassLoader特点：遵循双亲委派模型 ClassLoader在加载一个class文件时：会询问当前ClassLoader是否已经加载过此类，如果已经加载过则直接返回，不再重复加载。如果没有加载过，会去查询当前ClassLoader的parent是否已经加载过。 因为遵循双亲委派模型，Android中的classLoader具有两个特点： 类加载共享当一个class文件被任何一个ClassLoader加载过，就不会再被其他ClassLoader加载。 类加载隔离不同ClassLoader加载的class文件肯定不是一个。举个栗子，一些系统层级的class文件在系统初始化的时候被加载，比如java.net.String，这个是在应用启动前就被系统加载好的。如果在一个应用里能简单地用一个自定义的String类把这个String类替换掉的话，将有严重的安全问题。 线程上下文类加载器线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 类加载器与 OSGiOSGi™是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse 就是基于 OSGi 技术来构建的。 OSGi 中的每个模块（bundle）都包含 Java 包和类。模块可以声明它所依赖的需要导入（import）的其它模块的 Java 包和类（通过 Import-Package），也可以声明导出（export）自己的包和类，供其它模块使用（通过 Export-Package）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性 org.osgi.framework.bootdelegation的值即可。 OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。下面提供几条比较好的建议： 如果一个类库只有一个模块使用，把该类库的 jar 包放在模块中，在 Bundle-ClassPath中指明即可。 如果一个类库被多个模块共用，可以为这个类库单独的创建一个模块，把其它模块需要用到的 Java 包声明为导出的。其它模块声明导入这些类。 如果类库提供了 SPI 接口，并且利用线程上下文类加载器来加载 SPI 实现的 Java 类，有可能会找不到 Java 类。如果出现了 NoClassDefFoundError异常，首先检查当前线程的上下文类加载器是否正确。通过 Thread.currentThread().getContextClassLoader()就可以得到该类加载器。该类加载器应该是该模块对应的类加载器。如果不是的话，可以首先通过 class.getClassLoader()来得到模块对应的类加载器，再通过 Thread.currentThread().setContextClassLoader()来设置当前线程的上下文类加载器。 ClassLoader种类 BootClassLoader（Java的BootStrap ClassLoader）用于加载Android Framework层class文件。 PathClassLoader（Java的App ClassLoader）用于加载已经安装到系统中的apk中的class文件（要传入系统中apk的存放Path，所以只能加载已经安装的apk文件）。 DexClassLoader（Java的Custom ClassLoader）用于加载指定目录中的class文件(可以加载jar/apk/dex，可以从SD卡中加载未安装的apk)。 BaseDexClassLoader是PathClassLoader和DexClassLoader的父类。 PathClassLoader加载已安装的apk插件使用PathClassLoader加载已安装的apk插件。sharedUserId要一致，简单的说，应用从一开始安装在Android系统上时，系统都会给它分配一个linux user id，之后该应用在今后都将运行在独立的一个进程中，其它应用程序不能访问它的资源，那么如果两个应用的sharedUserId相同，那么它们将共同运行在相同的linux进程中，从而便可以数据共享、资源访问了。所以我们在宿主app和插件app的manifest上都定义一个相同的sharedUserId。 下面看一个样例：加载包名为packageName的插件，然后获得插件内名为one.png的图片的资源id，进而供宿主app使用该图片 /** * 加载已安装的apk * @param packageName 应用的包名 * @param pluginContext 插件app的上下文 * @return 对应资源的id */ private int dynamicLoadApk(String packageName, Context pluginContext) throws Exception { //第一个参数为包含dex的apk或者jar的路径，第二个参数为父加载器 PathClassLoader pathClassLoader = new PathClassLoader(pluginContext.getPackageResourcePath(),ClassLoader.getSystemClassLoader()); //Class&lt;?&gt; clazz = pathClassLoader.loadClass(packageName + &quot;.R$mipmap&quot;);//通过使用自身的加载器反射出mipmap类进而使用该类的功能 //参数：1、类的全名，2、是否初始化类，3、加载时使用的类加载器 Class&lt;?&gt; clazz = Class.forName(packageName + &quot;.R$mipmap&quot;, true, pathClassLoader); //使用上述两种方式都可以，这里我们得到R类中的内部类mipmap，通过它得到对应的图片id，进而给我们使用 Field field = clazz.getDeclaredField(&quot;one&quot;); int resourceId = field.getInt(R.mipmap.class); return resourceId; } 首先就是new出一个PathClassLoader对象，它的构造方法为：public PathClassLoader(String dexPath, ClassLoader parent)。其中第一个参数是通过插件的上下文来获取插件apk的路径，其实获取到的就是/data/app/apkthemeplugin.apk，那么插件的上下文怎么获取呢？在宿主app中我们只有本app的上下文啊，答案就是为插件app创建一个上下文：Context plugnContext = this.createPackageContext(packageName, CONTEXT_IGNORE_SECURITY | CONTEXT_INCLUDE_CODE。 通过插件的包名来创建上下文，不过这种方法只适合获取已安装的app上下文。或者不需要通过反射直接通过插件上下文getResource().getxxx(R..);也行，而这里用的是反射方法。第二个参数是父加载器，都是ClassLoader.getSystemClassLoader()。 DexClassLoader加载已安装的apk插件关于动态加载未安装的apk，先描述下思路：首先我们得到事先知道我们的插件apk存放在哪个目录下，然后分别得到插件apk的信息（名称、包名等），然后显示可用的插件，最后动态加载apk获得资源。 按照上面这个思路，我们需要解决几个问题：1、怎么得到未安装的apk的信息2、怎么得到插件的context或者Resource，因为它是未安装的不可能通过createPackageContext(…);方法来构建出一个context，所以这时只有在Resource上下功夫。 现在我们就一一来解答这些问题吧：1、得到未安装的apk信息可以通过mPackageManager.getPackageArchiveInfo()方法获得 /** * 获取未安装apk的信息 * @param context * @param archiveFilePath apk文件的path * @return */ private String[] getUninstallApkInfo(Context context, String archiveFilePath) { String[] info = new String[2]; PackageManager pm = context.getPackageManager(); PackageInfo pkgInfo = pm.getPackageArchiveInfo(archiveFilePath, PackageManager.GET_ACTIVITIES); if (pkgInfo != null) { ApplicationInfo appInfo = pkgInfo.applicationInfo; String versionName = pkgInfo.versionName;//版本号 Drawable icon = pm.getApplicationIcon(appInfo);//图标 String appName = pm.getApplicationLabel(appInfo).toString();//app名称 String pkgName = appInfo.packageName;//包名 info[0] = appName; info[1] = pkgName; } return info; } 2、得到对应未安装apk的Resource对象，我们需要通过反射来获得： /** * @param apkName * @return 得到对应插件的Resource对象 */ private Resources getPluginResources(String apkName) { try { AssetManager assetManager = AssetManager.class.newInstance(); Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);//反射调用方法addAssetPath(String path) //第二个参数是apk的路径：Environment.getExternalStorageDirectory().getPath()+File.separator+&quot;plugin&quot;+File.separator+&quot;apkplugin.apk&quot; addAssetPath.invoke(assetManager, apkDir+File.separator+apkName);//将未安装的Apk文件的添加进AssetManager中，第二个参数为apk文件的路径带apk名 Resources superRes = this.getResources(); Resources mResources = new Resources(assetManager, superRes.getDisplayMetrics(), superRes.getConfiguration()); return mResources; } catch (Exception e) { e.printStackTrace(); } return null; } 通过得到AssetManager中的内部的方法addAssetPath，将未安装的apk路径传入从而添加进assetManager中，然后通过new Resource把assetManager传入构造方法中，进而得到未安装apk对应的Resource对象。 3、接下来就是加载未安装的apk获得它的内部资源 /** * 加载apk获得内部资源 * @param apkDir apk目录 * @param apkName apk名字,带.apk * @throws Exception */ private void dynamicLoadApk(String apkDir, String apkName, String apkPackageName) throws Exception { File optimizedDirectoryFile = getDir(&quot;dex&quot;, Context.MODE_PRIVATE);//在应用安装目录下创建一个名为app_dex文件夹目录,如果已经存在则不创建 Log.v(&quot;zxy&quot;, optimizedDirectoryFile.getPath().toString());// /data/data/com.example.dynamicloadapk/app_dex //参数：1、包含dex的apk文件或jar文件的路径，2、apk、jar解压缩生成dex存储的目录，3、本地library库目录，一般为null，4、父ClassLoader DexClassLoader dexClassLoader = new DexClassLoader(apkDir+File.separator+apkName, optimizedDirectoryFile.getPath(), null, ClassLoader.getSystemClassLoader()); Class&lt;?&gt; clazz = dexClassLoader.loadClass(apkPackageName + &quot;.R$mipmap&quot;);//通过使用apk自己的类加载器，反射出R类中相应的内部类进而获取我们需要的资源id Field field = clazz.getDeclaredField(&quot;one&quot;);//得到名为one的这张图片字段 int resId = field.getInt(R.id.class);//得到图片id Resources mResources = getPluginResources(apkName);//得到插件apk中的Resource if (mResources != null) { //通过插件apk中的Resource得到resId对应的资源 findViewById(R.id.background).setBackgroundDrawable(mResources.getDrawable(resId)); } } 其中通过new DexClassLoader()来创建未安装apk的类加载器，我们来看看它的参数： public class DexClassLoader extends BaseDexClassLoader { public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) { super(dexPath, new File(optimizedDirectory), libraryPath, parent); } } 可以看到DexClassLoader的源码非常简单，只有一个构造方法。我们来看下其四个参数都是什么含义： dexPath：要加载的dex文件路径。 optimizedDirectory：dex文件要被copy到的目录路径。此位置一定要是可读写且仅该应用可读写（安全性考虑），所以只能放在data/data下。看官方文档：This class loader requires an application-private, writable directory to cache optimized classes. Use Context.getDir(String, int) to create such a directory: File dexOutputDir = context.getDir(“dex”, 0); libraryPath：apk文件中类要使用的c/c++代码，指向包含本地库(so)的文件夹路径，可以设为null。 parent：父装载器，也就是真正loadclass的装载器，一般可以通过Context.getClassLoader获取到，也可以通过ClassLoader.getSystemClassLoader()取到。在Android中加载class，其实最终是通过DexPathList的findClass来加载的。 Dex文件定义：能够被DVM或者Art虚拟机执行并且加载的文件格式。 作用：dex文件的作用是记录整个工程（通常是一个Android工程）的所有类文件的信息。 Android支持动态加载的两种方式是：DexClassLoader和PathClassLoader。DexClassLoader可加载jar/apk/dex，且支持从SD卡加载；PathClassLoader据说只能加载已经安装在Android系统内APK文件,以下这一段是摘录：PathClassLoader 的限制要更多一些，它只能加载已经安装到 Android 系统中的 apk 文件，也就是 /data/app 目录下的 apk 文件。其它位置的文件加载的时候都会出现 ClassNotFoundException。 dex文件的生成： 先生成class文件（注意执行低版本的JDK版本，否则手机无法运行），然后执行： dx --dex --output Test.dex Test.class 然后把生成的dex文件拷贝到手机： adb push C:\Users\Administrator\Desktop\Test.dex /storage/emulated/0 adb shell dalvikvm -cp /sdcard/Test.dex Test dex文件的结构： 8位字节的二进制流文件 各个数据紧密排列，无间隙，减少了文件体积，加快加载速度 整个工程的类信息都存放在一个dex文件中（不考虑dex分包的情况下） 注意：文件头包含了dex文件的信息，所有数据的大致分布情况链接数据区：主要是指so库 Dex文件头格式上图和上表就是dex的文件头的结构和各个位置的意思。其中最开始的64 65 78 0A 30 33 3500（dex.035.）表示这是按照dex解析的。 Class文件定义：能够被JVM识别，加载并执行的文件格式。 作用：记录一个类文件的所有信息，记住所有。例如记住了当前类的引用this、父类super等等。class文件记录的信息往往比java文件多。 class文件的结构: 8位字节的二进制流文件 各个数据紧密排列，无间隙，减少了文件体积，加快加载速度 每个类或者接口单独占据一个class文件，每个类单独管理，没有交叉 class文件中的字段如下所示： magic 加密字段，虚拟机判断当前的class文件是否被篡改过 minor_version 支持最低版本的jdk major_version 编译使用的jdk版本 constant_pool_count 常量池的数量，一般为一个 cp_info constant_pool 常量池的结构体，数量不定（类型是cp_info结构体） access_flags 访问级别，例如public等 this_class 当前类 super_class 父类 interfaces_count 类实现接口的数量 fields_count 类成员变量的数量 methods_count 类方法的数量 method_info methods 类方法的结构体 attributes_count 类属性的数量 attribute_info attributes 类属性的结构体 constant_pool包括： CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_String_info等等 CONSTANT_Class_info：类的相关信息，包括当前类、引用到的类的信息 CONSTANT_Fieldref_info：类的域信息 CONSTANT_Methodref_info：类的方法信息 class文件的弊端： 内存占用大，不适合移动端 堆栈的加栈模式，加载速度慢。 文件IO操作多，类加载慢。 Class文件与Dex文件的比较本质上都是一样的，都是二进制流文件格式，dex文件是从class文件演变而来的。class文件存在冗余信息，dex文件则去掉了冗余，并且整合了整个工程的类信息。 参考资料深入探讨 Java 类加载器插件化开发—动态加载技术加载已安装和未安装的apkAndroid_dex详解ClassLoader详解class文件和dex文件]]></content>
      <categories>
        <category>android知识点</category>
      </categories>
      <tags>
        <tag>Dex</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可扩展架构]]></title>
    <url>%2F2019%2F05%2F05%2Farchitecture-extensible%2F</url>
    <content type="text"><![CDATA[可扩展架构的基本思想是：拆 不同的拆分方式，本质上决定了系统的可扩展性。常见的拆分思路有三种： 1）面向流程拆分：分层架构分层架构的本质：固定的内核，移动的数据。扩展时大部分情况只需要修改其一层，少部分情况可能修改关联的两层，不会出现所有层都同时要修改。以简单的学生信息管理系统为例：展示层–&gt;业务层–&gt;数据层–&gt;存储层 2）面向服务拆分：SOA、微服务服务是一组相似功能的集合。对于某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可。以简单的学生信息管理系统为例：将系统拆分为注册、登录、信息管理、安全设置等服务 3）面向功能拆分:微内核架构以简单的学生信息管理系统为例：每个服务都可以拆分为更多细粒度的功能 当然，这几个系统架构并不是非彼既此的，而是可以组合使用。 分层架构分层架构也叫N层架构，通常情况下，N至少是两层。 分层架构的本质在于隔离关注点（separation of concerns），即每个层中的组件只会处理本层的逻辑，核心就是需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构。 根据不同的划分维度和对象，可以得到多种不同的分层架构：1）C/S、B/S架构2）MVC、MVP架构3）逻辑分层架构逻辑分层架构中的层是自顶向下依赖的，如andoid操作系统的架构 SOA架构SOA(Service Oriented Architecture)提出来三个关键概念： 1）服务所有业务功能都是一项服务，服务意味着要对外提供开发的能力，当其他系统需要使用这项功能时，无须定制化开发。 2）ESB(Enterprise Service Bus)ESB是将企业中各个不同的服务连接到一起。SOA使用ESB来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。 3）松耦合目的是减少各个服务间的依赖和相互影响。 SOA架构是集成的思想，是解决服务孤岛打通链条，是无奈之举。ESB集中化的管理带来了性能不佳、厚重等问题，也无法快速扩展。所以不适合互联网的业务特点。 微服务架构微服务是一种和SOA相似但本质上不同的架构理念。两者都关注于“服务”，都是通过服务的拆分来解决可扩展性问题。本质上不同在于几个核心理念的差异：是否有ESB、服务的粒度、架构设计的目标（small、lightweight、automated）等。 微服务架构其实相当复杂，可以分成几个阶段理解：1）第一阶段，微服务架构就是去掉了ESB的SOA架构，只不过是通信的方式和结构变了。对于初级的使用者而言，这样理解没有太大问题。2）第二阶段，没有了ESB，原本很多由ESB组件做的事儿，转到服务的提供者和调用者这里了。他们需要考虑服务的拆分粒。大体仍然算是SOA架构。3）第三阶段，随着服务的数量大幅增加，服务的管理越来越困难，此时DevOps出现了。这个阶段的微服务架构，已经是跟SOA架构完全不同的东西了。要逐步演进和迭代，不要过于激进，更不要拆分过细，拆分的粒度，要与团队的架构相互匹配。（康威定律） SOA和微服务的区别：1）服务粒度2）服务通讯微服务推荐使用统一的协议和格式。3）服务交付SOA更多的是考虑兼容已有的系统；微服务的架构理念要求“快速交付”，相应的要求自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践。4）应用场景SOA更适合庞大、复杂、异构的企业级系统，这也是SOA诞生的背景。微服务更适合快速、轻量级、基于Web的物联网系统。 微服务的陷阱及问题1）服务划分过细，服务间关系复杂2）服务数量太多，团队效率急剧下降3）调用链太长，性能下降4）调用链太长，问题定位困难5）没有自动化支撑，无法快速交付6）没有服务治理，数量多了之后管理混乱 微服务架构实践1.服务粒度三个火枪手原则。亚马逊CEO Jeff Bezos有个一个经验法则：如果两个披萨对于一个团队来说不够，那么这个团队就太大了。 2.拆分方法1）基于业务逻辑拆分 2）基于可扩展拆分：区分稳定服务、可变服务 3）基于可靠性拆分好处：避免非核心业务故障影响核心业务；核心服务高可用方案可以更简单；能够降低高可用成本 4）基于性能拆分将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务。 以上方案可自由排列组合。 3.基础设施1）服务发现、服务路由、服务容错：这是最基本的微服务基础设施 2）接口框架、API网关：主要是为了提升开发效率 3）自动化部署、自动化测试、配置中心：主要为了提升测试和运维效率 4）服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率 以上3、4会随着微服务节点数量增加而越来越重要，当节点较少时，可以通过人工支撑，虽然效率不高，但也基本能够顶得住。 微内核架构微内核架构也被称为插件化架构，是一种面向功能进行拆分的可扩展性架构。 微内核架构包含两类组件：核心系统和插件模块。核心模块负责和具体业务功能无关的通用功能，如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑。 微内核的核心系统设计的关键技术有：插件管理、插件链接和插件通信。 常见架构有：OSGI、规则引擎架构、Atlas容器化框架等。 android架构模式参考：1.Atlas：手淘Native容器化框架和思考2.微信 Android 客户端架构演进之路 康威定律微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是康威定律（Conway’s Law）。 在康威的这篇文章中，最有名的一句话就是： Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - Melvin Conway(1967) 中文直译大概的意思就是：设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。 Mike从他的角度归纳这篇论文中的其他一些核心观点，如下： 第一定律：企业沟通方式会通过系统设计表达出来——Communication dictates design 第二定律：再多的时间也没办法让任务完美至极，但总有时间能将它完成——There is never enough time to do something right, but there is always enough time to do it over 第三定律：线型系统和线型组织架构间有潜在的异质同态特性——There is a homomorphism from the linear graph of a system to the linear graph of its design organization 第四定律：大系统比小系统更适用于任务分解——The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems 康威第一定律“人类是复杂的社会动物。” 《The Mythical Man-Month》 这本书里有一句令人难忘的话：在应用项目后期加大人员的投资，会更加拖慢它的速度。——Fred Brooks（1975） 沟通的问题会影响系统设计，进而影响整个系统的开发效率以及最终结果。 康威第二定律罗马不是一天建成的，学会先解决首要问题。 敏捷开发巨头之一Erik Hollnagel 在他的书中阐述了类似的观点： 问题太复杂？那么不妨忽略不必要的细节。没有足够的资源？放弃无用的功能。——Erik Hollnagel（2009） 系统的复杂性、功能数量、市场竞争以及投资人的期望值都在增加，而人的智力是有上限的，没有企业能说一定能找到合适的人，对于一个极其复杂的系统，总会有考虑不周全的地方，Erik认为这个问题最好的解决办法就是：不去管它。 最佳解决方案不是消除所有问题，而是允许它们存在，在发生故障时实现自动恢复。在由微服务组成的系统中，每个微服务都可能停止响应，这是完全正常的，只需要确保足够的冗余和备份，这就是弹性或高可用性设计。 康威第三定律创建独立的子系统，减少沟通成本。 团队中微服务的理念应是Inter-Operate，而不是Integrate ，Inter-Operate是指定义系统边界和接口，并为整个团队提供完整的堆栈，实现完全的自制。如此就能降低系统间的依赖性，减少通信成本。 康威第四定律前面提到，人类是复杂的社会动物，人与人之间的交流是非常复杂的，当涉及到一个系统时，人们经常选择增加人力去减少复杂性，对于企业来说，该如何处理这样的沟通问题？答案是：分而治之。 康威定律与微服务再来看一下康威定律是如何在半个世纪前就奠定了微服务理论基础的。 人与人之间的交流很复杂，每个人的精力是有限的，因此当问题很复杂，需要协调地去解决时，需要将组织划分进而提高沟通效率。 团队成员工作的系统设计依赖于成员之间的沟通，管理人员可以调整划分模式，实现团队之间的不同沟通方式，这也会影响系统的设计。 如果子系统有清晰的外部通信便捷，那么就可以有效地降低通信成本，响应地设计将更加适合和有效。 需要不断优化一个复杂的系统，并容错性和故障恢复率的帮助下进行优化，不要期望大而全面的设计或架构，因为它们的开发以迭代的方式发生。 以下是一些具体的实践建议： 利用一切手段提高通信效率，如Slack、Github和Wiki，且只与相关人员进行沟通，每个人和每个系统必须有明确的职责，在遇到问题时，知道该找谁去解决。 在MVP模式下设计一套系统，以迭代的方式优化及验证，并确保系统的弹性。 采用与系统设计相一致的团队，以扁平化和以业务为基准的方式去简化团队，每个小团队之间必须有对应负责的模块，避免模糊的界限，以免在发生问题时互相推卸责任。 要做小而美的团队，人员数量的增加会降低效率以及加大成本，亚马逊CEO Jeff Bezos有个一个经验法则：如果两个披萨对于一个团队来说不够，那么这个团队就太大了。一般来说，一家互联网公司的产品团队由7到8个人组成（包括前端和后端测试、交互和用户体验师，一些人可能身兼数职）。 在查看以下微服务标准时，我们可以很容易地看到微服务与康威定律之间的密切关系： 由分布式服务组成的系统 企业部门的业务线 开发优秀的产品 Smart endpoints and dumb pipes DevOps 容错 快速发展 参考资料康威定律]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据库高性能]]></title>
    <url>%2F2019%2F04%2F29%2Farchitecture-high-performance%2F</url>
    <content type="text"><![CDATA[读写分离读写分离的基本原理是将数据库读写操作分散到不同的节点上。 读写分离适用单机并发无法支撑并且读的请求更多的情形。在单机数据库情况下，表上加索引一般对查询有优化作用却影响写入速度，读写分离后可以单独对读库进行优化，写库上减少索引，对读写的能力都有提升，且读的提升更多一些。不适用的情况:1）如果并发写入特别高，单机写入无法支撑，就不适合这种模式。2）通过缓存技术或者程序优化能够满足要求 读写分离的基本实现是：1）数据库服务器搭建主从集群，一主一从，一主多从都可以2）数据库主机负责写操作，从机负责读操作3）数据库主机通过复制将数据同步到数据库从机，每台数据库服务器都存储了所有的业务数据4）业务服务器将写操作发给数据库主机，将读操作发给数据库从机 但有两个细节点引入了复杂度：主从复制延时和分配机制，以下为解决方案 复制延时：1）写操作后的读操作指定发给数据库主机2）读从机失败后再度一次主机3）关键业务读写操作全部指向主机，非关键业务采用读写分离 分配机制：将读写操作区分开来，然后访问不同的数据库，一般有两种方式：程序代码封装和中间件封装 分库分表分库分表会带来很多复杂度。在引入分库分表之前，应该是这些操作依次尝试：1.做硬件优化，例如从机械硬盘改成使用固态硬盘，当然固态硬盘不适合服务器使用，只是举个例子2.先做数据库服务器的调优操作，例如增加索引，oracle有很多的参数调整;3.引入缓存技术，例如Redis，减少数据库压力4.程序与数据库表优化，重构，例如根据业务逻辑对程序逻辑做优化，减少不必要的查询;5.在这些操作都不能大幅度优化性能的情况下，不能满足将来的发展，再考虑分库分表，也要有预估性 分库业务分库是指按照业务模块将数据分散到不同的数据库服务器。 存在问题：1）join问题2）事务问题3）成本问题 分表分两种方式：垂直分表、水平分表 水平分表：水平分表后，某条数据具体属于哪个子表，需要增加路由算法进行计算，这个算法会引入一定的复杂性。常见的路由算法有：1）范围路由2）hash路由3）配置路由 其他常见的复杂性问题：join，count，order by等]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[架构设计流程]]></title>
    <url>%2F2019%2F04%2F28%2Farchitecture-design-flow%2F</url>
    <content type="text"><![CDATA[如何识别复杂度架构设计由需求所驱动，本质目的是为了解决软件系统的复杂性；为此，我们在进行架构设计时，需要以理解需求为前提，首要进行系统复杂性的分析。具体做法是： （1）构建复杂度的来源清单——高性能、可用性、扩展性、安全、低成本、规模等。 （2）结合需求、技术、团队、资源等对上述复杂度逐一分析是否需要？是否关键？ “高性能”主要从软件系统未来的TPS、响应时间、服务器资源利用率等客观指标，也可以从用户的主观感受方面去考虑。 “可用性”主要从服务不中断等质量属性，符合行业政策、国家法规等方面去考虑。 “扩展性”则主要从功能需求的未来变更幅度等方面去考虑。 （3）按照上述的分析结论，得到复杂度按照优先级的排序清单，越是排在前面的复杂度，就越关键，就越优先解决。 需要特别注意的是：随着所处的业务阶段不同、外部的技术条件和环境的不同，得到的复杂度问题的优先级排序就会有所不同。一切皆变化。 备选方案设计经过架构设计流程第 1 步——识别复杂度，确定了系统面临的主要复杂度问题，进而明确了设计方案的目标，就可以开展架构设计流程第 2 步——设计备选方案。架构设计备选方案的工作更多的是从需求、团队、技术、资源等综合情况出发，对主流、成熟的架构模式进行选择、组合、调整、创新。 1.几种常见的架构设计误区 （1）设计最优秀的方案。不要面向“简历”进行架构设计，而是要根据“合适”、“简单”、“演进”的架构设计原则，决策出与需求、团队、技术能力相匹配的合适方案。 （2）只做一个方案。一个方案容易陷入思考问题片面、自我坚持的认知陷阱。 2.备选方案设计的注意事项 （1）备选方案不要过于详细。备选阶段解决的是技术选型问题，而不是技术细节。 （2）备选方案的数量以 3~5个为最佳。 （3）备选方案的技术差异要明显。 （4）备选方案不要只局限于已经熟悉的技术。 3.问题思考 可以从开源、自研的角度提出架构设计方案 如果是创业公司的业务早、中期阶段，可直接考虑采用阿里云/腾讯云，性能、HA、伸缩性都有保证。 最大的感悟是：做事情永远都要有B方案。 评估和选择备选方案1 评估和选择备选方案的方法列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。常见的质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性。按优先级选择，即架构师综合当前的业务发展情况、团队人员规模和技能、业务发展预测等因素，将质量属性按照优先级排序，首先挑选满足第一优先级的，如果方案都满足，那就再看第二优先级……以此类推。 2 RocketMQ 和 Kafka 有什么区别？ （1） 适用场景Kafka适合日志处理；RocketMQ适合业务处理。 （2） 性能Kafka单机写入TPS号称在百万条/秒；RocketMQ大约在10万条/秒。Kafka单机性能更高。 （3） 可靠性RocketMQ支持异步/同步刷盘;异步/同步Replication；Kafka使用异步刷盘方式，异步Replication。RocketMQ所支持的同步方式提升了数据的可靠性。 （4） 实时性均支持pull长轮询，RocketMQ消息实时性更好 （5） 支持的队列数Kafka单机超过64个队列/分区，消息发送性能降低严重；RocketMQ单机支持最高5万个队列，性能稳定（这也是适合业务处理的原因之一） 3 为什么阿里会自研RocketMQ？ （1） Kafka的业务应用场景主要定位于日志传输；对于复杂业务支持不够（2） 阿里很多业务场景对数据可靠性、数据实时性、消息队列的个数等方面的要求很高（3）当业务成长到一定规模，采用开源方案的技术成本会变高（开源方案无法满足业务的需要；旧版本、自开发代码与新版本的兼容等）（4） 阿里在团队、成本、资源投入等方面约束性条件几乎没有 详细设计方案完成备选方案的设计和选择后，接下来需要将确定的备选方案细化，使得备选方案变成一个可以落地的设计方案。 1）架构师不但要进行备选方案的设计和选型，还需要对备选方案的关键细节有较深入的理解。2）通过分步骤、分阶段、分系统等方式，尽量减低方案复杂度，方案本身的复杂度越高，某个细节推翻整个方案的可能性就越大，适当降低复杂度，可以降低这种风险。3）如果方案本身就很复杂，那就采取设计团队的方式来进行设计，博采众长，防止可能出现的盲点或经验误区。]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flutter APP体积为何比较大]]></title>
    <url>%2F2019%2F04%2F26%2Fflutter-package-size%2F</url>
    <content type="text"><![CDATA[flutter构建的App体积比native的大一些，是什么原因造成App体积大呢？ 其实flutter 在release时App体积和native的大小差不多，而debug时体积通常会大。debug版本体积较大是为了Hot reload和快速编译。如果有flutter开发经验的朋友都体验过，如果您修改一下App的背景颜色，只需save一下就可以立刻看到修改后效果。我称之为“像艺术家一样在创造App”，因此为了实现这些目标，提高开发的效率，debug将占用全部资源。而当我们构建release版时，flutter又会采用AOT策略，提高App运行效率，release版只打包必需的资源，因而体积又会减少。 另外，flutter团队也一直在寻找减小程序大小的方法。 现在开发 App 的方式非常多，原生、ReactNative、Flutter 都是不错的选择。那你有没有关注过，使用不同的方式，编译生成的 Apk ，大小是否会有什么影响呢？本文就以一个最简单的 Hello World App，来看看不同的框架，编译出来的 Apk 大小，有什么区别。 Java（539 KB）首先使用 Java 来开始这次实验，使用 Java 开发 Android 算是最常规也是最简单的一种方式。正如前面描述的那样，由于我们仅仅使用了 Java 和 Android 框架来创建这个应用程序，所以它将是最小的，唯一的依赖是 Android 支持库，它占用了整个 Apk 内相当多的空间。 Flutter（7.5MB）由 Flutter 的 cli 生成的 Release 版本的应用程序中，包含 C / C ++ 引擎和 Dart VM，它们构成了 Apk 的几乎所有部分。该应用程序直接使用本机指令集运行，不涉及任何解释器。本文里介绍的几种编写 App 的方法，都存在优缺点，在实际工作中，应该根据需求选择适合的方式。你还可以混合搭配这些框架，仅仅用它们的优点来开发 App 的部分功能。 React Native（7MB）如果你有前端（Web）的开发经验，并希望使用 JavaScript 来开发 App，那么 React Native 是一个不错的选择。 如果你希望在已发布的 App 上，进行更快的功能迭代，使用 React Native 也可以让你不必为每个小改动都发布应用市场。 由 React Native 生成的 Release apk 在 classes.dex 文件中有几个类，这些类有 12193 个针对此应用程序的引用方法。它还在 x86 和 armeabi-v7a 的 lib 目录中添加了一些 so 库。总共添加了大约 6.4 MB 的空间。 ReactNative 和 Flutter 因为其内部还需要包含一些解析器和引擎，本身就会有一些基础库在其内，所以变大也是符合预期的。 参考资料https://www.jianshu.com/p/0e223b472f41https://www.cnblogs.com/plokmju/p/release_apk.html]]></content>
      <categories>
        <category>HyBrid</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构的概念]]></title>
    <url>%2F2019%2F04%2F25%2Farchitecture-basics%2F</url>
    <content type="text"><![CDATA[架构设计的主要目的是为了解决软件系统复杂度带来的问题。个人感悟是：架构及（重要）决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体（人、财、时间等）。架构无优劣，但是存在恰当的架构用在合适的系统中，而这些就是决策的结果。不要过分设计。 架构概念软件架构指软件系统的顶层结构；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。 软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。 软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。 软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。 高性能性能是软件的一个重要质量属性。衡量软件性能包括了响应时间、TPS、服务器资源利用率等客观指标，也可以是用户的主观感受（从程序员、业务用户、终端用户/客户不同的视角，可能会得出不同的结论）。 在说性能的时候，有一个概念与之紧密相关—伸缩性，这是两个有区别的概念。性能更多的是衡量软件系统处理一个请求或执行一个任务需要耗费的时间长短；而伸缩性则更加关注软件系统在不影响用户体验的前提下，能够随着请求数量或执行任务数量的增加（减少）而相应地拥有相适应的处理能力。 但是，什么是“高”性能？这可能是一个动态概念，与当前的技术发展状况与业务所处的阶段紧密相关。比如，现在在行业/企业内部认为的高性能，站在5年后来看，未必是高性能。因此，站在架构师、设计师的角度，高性能需要和业务所处的阶段来衡量。高到什么程度才能与当前或可预见的未来业务增长相匹配。一味去追求绝对意义上的高，没有太大的实际意义。因为，伴随性能越来越高，相应的方法和系统复杂度也是越来越高，而这可能会与当前团队的人力、技术、资源等不相匹配。但是什么才合适的高性能了？这可能需要从国、内外的同行业规模相当、比自己强的竞争者、终端用户使用反馈中获取答案并不断迭代发展。 软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。 2 WHY 为什么需要高性能？追求良好的用户体验；满足业务增长的需要。 3 HOW 如何做好高性能？可以从垂直与水平两个维度来考虑。垂直维度主要是针对单台计算机，通过升级软、硬件能力实现性能提升；水平维度则主要针对集群系统，利用合理的任务分配与任务分解实现性能的提升。 垂直维度可包括以下措施：增大内存减少I/O操作更换为固态硬盘（SSD）提升I/O访问速度使用RAID增加I/O吞吐能力置换服务器获得更多的处理器或分配更多的虚拟核升级网络接口或增加网络接口 水平维度可包括以下措施：功能分解：基于功能将系统分解为更小的子系统多实例副本：同一组件重复部署到多台不同的服务器数据分割：在每台机器上都只部署一部分数据 垂直维度方案比较适合业务阶段早期和成本可接受的阶段，该方案是提升性能最简单直接的方式，但是受成本与硬件能力天花板的限制。 水平维度方案所带来的好处要在业务发展的后期才能体现出来。起初，该方案会花费更多的硬件成本，另外一方面对技术团队也提出了更高的要求；但是，没有垂直方案的天花板问题。一旦达到一定的业务阶段，水平维度是技术发展的必由之路。因此，作为技术部门，需要提前布局 ，未雨绸缪，不要被业务抛的太远。 高可用高可用基础是“状态决策”。本质上是通过“冗余”来实现高可用。 高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。保证系统高可用，架构设计的核心准则是：冗余。有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。 可扩展性核心是：封装变化，隔离可变性。 应对变化方案：1）将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”2）提炼出一个“抽象层”和一个“实现层”。抽象层是稳定的，而实现层是根据业务进行定制的，当加入新功能时，只需要更改实现层，无须修改抽象层。 可伸缩性当前大型互联网网站需要面对大量用户高并发访问、存储更多数据、处理更高频次的用户交互。网站系统一般通过多种分布式技术将多台服务器组成集群对外提供服务。伸缩性一般是系统可以根据需求和成本调整自身处理能力的一种能力。伸缩性常意味着系统可以通过低成本并能够快速改变自身的处理能力以满足更多用户访问、处理更多数据而不会对用户体验造成任何影响。 伸缩性度量指标包括（1）处理更高并发；（2）处理更多数据；（3）处理更高频次的用户交互。 其复杂度体现在（1）伸——增强系统在上述三个方面的处理能力；（2）缩——缩减系统处理能力；（3）上述伸缩过程还必须相对低成本和快速。 成本、安全、规模低成本是架构设计中需要考虑一个约束条件，但不会是首要目标。低成本本质上是与高性能和高可用冲突的，当无法设计出满足成本要求的方案，就只能协调并调整成本目标。往往只有“创新”才能达到低成本目标。1）引入新技术。主要复杂度在于需要去熟悉新技术，并且将新技术与已有技术结合；一般中小型公司基本采用该方式达到目标。2）开创一个全新技术领域。主要复杂度在于需要去创造全新的理念和技术，并且与旧技术相比，需要有质的飞跃，复杂度更高；一般大公司拥有更多的资源、技术实力会采用该方式来达到低成本的目标。 安全在技术角度上将包括功能安全和架构安全。1）功能安全-“防小偷”，减少系统潜在的缺陷（是一个逐步完善的过程，而且往往都是在问题出现后才能有针对性的提出解决方案，与编码实现有关），阻止黑客的破坏行为。2）架构安全-“防强盗”，保护系统不受恶意访问与攻击，保护系统的重要数据不被窃取（传统企业主要通过防火墙实现不同区域的访问控制，功能强大、性能一般，但是成本更高；互联网企业更多的是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现）。 规模带来复杂度的主要原因是“量变引起质变”。1）功能越来越多，调用逻辑越来越复杂，会导致系统复杂度指数级上升。2）数据容量、类型、关联关系越来越多。规模问题需要与高性能、高可用、高扩展、高伸缩性统一考虑。常采用“分而治之，各个击破”的方法策略。 架构设计三原则不断演化是架构发展的主旋律，而满足适合、追求简单是架构决策的重要依据。需求驱动技术的创新演化；技术反哺业务的发展升级。1）合适原则合适原则宣言：合适优于业界领先失败原因：没有那么多人，却想干那么多活；没有那么多积累，却想一步登天；没有卓越的业务场景，却幻想灵光一闪成为天才。设计的目的不是为了证明自己，而是更快更好的满足业务需求。 2）简单原则简单原则宣言：简单优于复杂定位一个复杂系统中的问题总是比简单系统更为复杂 3）演化原则演化原则宣言：演化优于一步到位对于软件来说，变化才是主题。罗马不是一天建成的，架构也不是一开始就设计成完美的样子，然后可以一劳永逸的用下去。 各个公司的架构都是逐渐演进成当前的样子，在达到同样目的的过程中实现手段确并不完全相同，蚂蚁和阿里都进行了多地多中心部署的架构改造，但二者在诸如配置中心、跨ldc访问管控等方面都不尽相同，即使在蚂蚁内部也出现了后续实现推翻原始规划的情况。在多地多中心部署架构改造完成后，为进一步降低成本，避免大促活动中机器的浪费，又开始了弹性部署的改造，希望能够在大促高峰来临的前几个小时再临时增加服务器，等活动结束服务器就立即回收。等这个搞定，又开始在线离线混布的改造，进一步降低整体成本。这些改造之所以一个接一个的能够实现，也在于使用的主要中间件和框架都是自研的，知根知底，可以快速迭代修改，如果是使用第三方的或者购买的，一方面可能非常贵，另一方面可能根本不支持，要重新设计改造部署所需的时间要远远大于自研的成本。 软件活动中没有“银弹”在古代的狼人传说中，只有用银质子弹（银弹）才能制服这些异常凶残的怪兽。在软件开发活动中，“银弹”特指人们渴望找到用于制服软件项目这头难缠的“怪兽”的“万能钥匙”。 软件开发过程包括了分析、设计、实现、测试、验证、部署、运维等多个环节。从IT技术的发展历程来看，先辈们在上述不同的环节中提出过很多在当时看来很先进的方法与理念。但是，这些方法、理念在摩尔定律、业务创新、技术发展面前都被一一验证了以下观点：我们可以通过诸多方式去接近“银弹”，但很遗憾，软件活动中没有“银弹”。 布鲁克斯发表《人月神话》三十年后，又写了《设计原本》。他认为一个成功的软件项目的最重要因素就是设计，架构师、设计师需要在业务需求和IT技术中寻找到一个平衡点。个人觉得，对这个平衡点的把握，就是架构设计中的取舍问题。而这种决策大部分是靠技术，但是一定程度上也依赖于架构师的“艺术”，技术可以依靠新工具、方法论、管理模式去提升，但是“艺术”无法量化 ，是一种权衡。 软件设计过程中，模块、对象、组件本质上是对一定规模软件在不同粒度和层次上的“拆分”方法论，软件架构是一种对软件的“组织”方法论。一分一合，其目的是为了软件研发过程中的成本、进度、质量得到有效控制。但是，一个成功的软件设计是要适应并满足业务需求，同时不断“演化”的。设计需要根据业务的变化、技术的发展不断进行“演进”，这就决定了这是一个动态活动，出现新问题，解决新问题，没有所谓的“一招鲜”。 以上只是针对设计领域的银弹讨论，放眼到软件全生命周期，银弹问题会更加突出。 小到一个软件开发团队，大到一个行业，没有银弹，但是“行业最佳实践”可以作为指路明灯，这个可以有。]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Retrofit 2使用]]></title>
    <url>%2F2019%2F04%2F11%2Fandroid-retrofit%2F</url>
    <content type="text"><![CDATA[基础使用以下就是实现一个登录Login接口的小功能 ，先了解一下Retrofit的基本用法: private void getLogin() { Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;//localhost:8080/&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); ApiManager apiService = retrofit.create(ApiManager.class); Call&lt;LoginResult&gt; call = apiService.getData(&quot;lyk&quot;, &quot;1234&quot;); call.enqueue(new Callback&lt;LoginResult&gt;() { @Override public void onResponse(Call&lt;LoginResult&gt; call, Response&lt;LoginResult&gt; response) { if (response.isSuccess()) { // 请求成功 } else { //直接操作UI 或弹框提示请求失败 } } @Override public void onFailure(Call&lt;LoginResult&gt; call, Throwable t) { //错误处理代码 } }); } ApiManager接口: public interface ApiManager { @GET(&quot;login/&quot;) Call&lt;LoginResult&gt; getData(@Query(&quot;name&quot;) String name, @Query(&quot;password&quot;) String pw); } Retrofit支持异步和同步call.enqueue(new Callback）采用异步请求；call.execute() 采用同步方式。 call.cancel() 取消请求 ConverterFactoryaddConverterFactory 制定数据解析器，上面添加依赖的gson就是用在这里做默认数据返回的， 之后通过build()创建出来。 Retrofit内部自带如下格式： Gson: com.squareup.retrofit2:converter-gsonJackson: com.squareup.retrofit2:converter-jacksonMoshi: com.squareup.retrofit2:converter-moshiProtobuf: com.squareup.retrofit2:converter-protobufWire: com.squareup.retrofit2:converter-wireSimple XML: com.squareup.retrofit2:converter-simplexmlScalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars 网络请求参数@Path:所有在网址中的参数(URL的问号前面),如://192.168.1.1/api/Accounts/{accountId} @Query:URL问号后面的参数,如://192.168.1.1/api/Comments?access_token={access_token} @QueryMap:相当于多个@Query @Field:用于POST请求,提交单个数据 @FieldMap:以map形式提交多个Field(Retrofit2.0之后添加) @Body:相当于多个@Field,以对象的形式提交 注意： 使用@Field时记得添加@FormUrlEncoded 若需要重新定义接口地址,可以使用@Url,将地址以参数的形式传入即可。 @Path 和@Query的区别相同点:都是请求头中的带有的数据不同点:前者是请求头中问号之前用于替换URL中变量的字段,后者是请求头问号之后用于查询数据的字段,作用和应用场景都不同 进阶功能开启Log用拦截器实现， retrofit已经提供了 HttpLoggingInterceptor 里面有四种级别，输出的格式，可以看下面介绍： public enum Level { /** No logs. */ NONE, /** * Logs request and response lines. * * &lt;p&gt;Example: * &lt;pre&gt;{@code * --&gt; POST /greeting * * * /1.1 (3-byte body) * * &lt;-- 200 OK (22ms, 6-byte body) * }&lt;/pre&gt; */ BASIC, /** * Logs request and response lines and their respective headers. * * &lt;p&gt;Example: * &lt;pre&gt;{@code * --&gt; POST /greeting http/1.1 * Host: example.com * Content-Type: plain/text * Content-Length: 3 * --&gt; END POST * * &lt;-- 200 OK (22ms) * Content-Type: plain/text * Content-Length: 6 * &lt;-- END HTTP * }&lt;/pre&gt; */ HEADERS, /** * Logs request and response lines and their respective headers and bodies (if present). * * &lt;p&gt;Example: * &lt;pre&gt;{@code * --&gt; POST /greeting http/1.1 * Host: example.com * Content-Type: plain/text * Content-Length: 3 * * Hi? * --&gt; END GET * * &lt;-- 200 OK (22ms) * Content-Type: plain/text * Content-Length: 6 * * Hello! * &lt;-- END HTTP * }&lt;/pre&gt; */ BODY } 例如，开启请求头添加拦截器: Retrofit retrofit = new Retrofit.Builder().client(new OkHttpClient.Builder() .addNetworkInterceptor(new HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.HEADERS)) .build()) 增加头部信息new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .client(new OkHttpClient.Builder() .addInterceptor(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Request request = chain.request() .newBuilder() .addHeader(&quot;mac&quot;, &quot;f8:00:ea:10:45&quot;) .addHeader(&quot;uuid&quot;, &quot;gdeflatfgfg5454545e&quot;) .addHeader(&quot;userId&quot;, &quot;Fea2405144&quot;) .addHeader(&quot;netWork&quot;, &quot;wifi&quot;) .build(); return chain.proceed(request); } }) .build() 特殊API接口单独加入,方法上注释@Headers: @Headers({ &quot;Accept: application/vnd.github.v3.full+json&quot;, &quot;User-Agent: Retrofit-your-App&quot;}) @get(&quot;users/{username}&quot;) Call&lt;User&gt; getUser(@Path(&quot;username&quot;) String username); 添加证书Pinning证书可以在自定义的OkHttpClient加入certificatePinner 实现： OkHttpClient client = new OkHttpClient.Builder() .certificatePinner(new CertificatePinner.Builder() .add(&quot;YOU API.com&quot;, &quot;sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=&quot;) .add(&quot;YOU API..com&quot;, &quot;sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=&quot;) .add(&quot;YOU API..com&quot;, &quot;sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=&quot;) .add(&quot;YOU API..com&quot;, &quot;sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=&quot;) .build()) 支持https加密和普通http客户端请求支持https一样，证书同样可以设置到okhttpclient中.详细可以参考我之前的文章：android中使用https 常见问题url被转义https://api.myapi.com/http%3A%2F%2Fapi.mysite.com%2Fuser%2Flist 请将@path改成@url public interface APIService { @GET Call&lt;Users&gt; getUsers(@Url String url);} 或者： public interface APIService { @GET(&quot;{fullUrl}&quot;) Call&lt;Users&gt; getUsers(@Path(value = &quot;fullUrl&quot;, encoded = true) String fullUrl); } Method方法找不到java.lang.IllegalArgumentException: Method must not be null 请指定具体请求类型@get @post等 public interface APIService { @GET Call&lt;Users&gt; getUsers(@Url String url); } Url编码不对，@fieldMap parameters must be use FormUrlEncoded如果用fieldMap加上FormUrlEncoded编码 @POST() @FormUrlEncoded Observable&lt;ResponseBody&gt; executePost(@FieldMap Map&lt;String, Object&gt; maps); 上层需要转换将自己的map转换为FieldMap @FieldMap(encoded = true) Map&lt;String, Object&gt; parameters, path和url一起使用Using @Path and @Url paramers together with retrofit2 java.lang.IllegalArgumentException: @Path parameters may not be used with @Url. (parameter #4 如果你是这样的： @GET Call&lt;DataResponse&gt; getOrder(@Url String url, @Path(&quot;id&quot;) int id); 请在你的url指定占位符.url: www.myAPi.com/{Id} 参考资料Android Retrofit 2.0]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA中的CAS]]></title>
    <url>%2F2019%2F03%2F29%2Fjava-cas%2F</url>
    <content type="text"><![CDATA[无锁的概念加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程序来说，它们总是认为每次访问共享资源时总会发生冲突，因此必须对每一次数据操作实施加锁策略。而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，无锁策略则采用一种称为CAS的技术来保证线程执行的安全性，这项CAS技术就是无锁策略实现的关键。 CASCAS的全称是Compare And Swap 即比较交换，其算法核心思想如下: 执行函数：CAS(V,E,N) 其包含3个参数:V表示要更新的变量E表示预期值N表示新值如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作，原理图如下:示例如下： //加一并返回值 public final int incrementAndGet() { for (;;) { int current = get(); int next = current + 1; if (compareAndSet(current, next)) return next; } } //返回CAS操作成功与否 public final boolean compareAndSet(int expect, int update) { //根据变量在内存中的偏移地址valueOffset获取原值，然后和预期值except进行比，如果符合，用update值进行更新，这个过程是原子操作 return unsafe.compareAndSwapInt(this, valueOffset, expect, update); } 如果此时有两个线程，线程A得到current值为1，线程B得到current值也为2，此时线程A执行CAS操作，成功将值改为2，而此时线程B执行CAS操作，发现此时内存中的值并不是读到current值1，所以返回false，此时线程B继续进行循环，最后成功加1 CAS的原子性或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。 Unsafe类Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作CAS基于以下3个方法实现： //第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值， //expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。 public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x); public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x); public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x); 参考资料JAVA中的CAS]]></content>
      <categories>
        <category>同步</category>
      </categories>
      <tags>
        <tag>cas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中使用RSA/AES加解密]]></title>
    <url>%2F2019%2F03%2F29%2Fjava-rsa%2F</url>
    <content type="text"><![CDATA[RSA加密明文最大长度245字节，解密要求密文最大长度为256字节，所以在加密和解密的过程中需要分块进行。(RSA密钥长度随着保密级别提高，增加很快)RSA加密对明文的长度是有限制的，如果加密数据过大会抛出如下异常： Exception in thread &quot;main&quot; javax.crypto.IllegalBlockSizeException: Data must not be longer than 117 bytes at com.sun.crypto.provider.RSACipher.a(DashoA13*..) at com.sun.crypto.provider.RSACipher.engineDoFinal(DashoA13*..) at javax.crypto.Cipher.doFinal(DashoA13*..) 1.密钥长度rsa算法初始化的时候一般要填入密钥长度,在96-2048bits间(1)为啥下限是96bits(12bytes)?因为加密1byte的明文,需要至少1+11=12bytes的密钥(不懂?看下面的明文长度),低于下限96bits时,一个byte都加密不了,当然没意义啦(2)为啥上限是2048(256bytes)?这是算法本身决定的。另RSA密钥长度随着保密级别提高，增加很快 2.明文长度明文长度(bytes) &lt;= 密钥长度(bytes)-11.这样的话,对于上限密钥长度1024bits能加密的明文上限就是117bytes了.所以就出现了分片加密,网上很流行这个版本.很简单,如果明文长度大于那个最大明文长度了,我就分片吧,保证每片都别超过那个值就是了.片数=(明文长度(bytes)/(密钥长度(bytes)-11))的整数部分+1,就是不满一片的按一片算 3.密文长度密文长度等于密钥长度.当然这是不分片情况下的.分片后,密文长度=密钥长度*片数 例如96bits的密钥,明文4bytes每片明文长度=96/8-11=1byte,片数=4,密文长度=96/8*4=48bytes 又例如128bits的密钥,明文8bytes每片明文长度=128/8-11=5bytes,片数=8/5取整+1=2,密文长度=128/8*2=32 注意,对于指定长度的明文,其密文长度与密钥长度非正比关系.如4bytes的明文,在最短密钥96bites是,密文长度48bytes,128bits米密钥时,密文长度为16bytes,1024bits密钥时,密文长度128bytes.因为分片越多,密文长度显然会变大,所以有人说,那就一直用1024bits的密钥吧…拜托,现在的机器算1024bits的密钥还是要点时间滴,别以为你的cpu很牛逼…那么选个什么值比较合适呢?个人认为是600bits,因为我们对于一个字符串的加密,一般不是直接加密,而是将字符串hash 后,对hash值加密.现在的hash值一般都是4bytes,很少有8bytes,几十年内应该也不会超过64bytes.那就用64bytes算吧, 密钥长度就是(64+11)*8=600bits了. RSAUtils.java package security; import java.io.ByteArrayOutputStream; import java.security.Key; import java.security.KeyFactory; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.PrivateKey; import java.security.PublicKey; import java.security.Signature; import java.security.interfaces.RSAPrivateKey; import java.security.interfaces.RSAPublicKey; import java.security.spec.PKCS8EncodedKeySpec; import java.security.spec.X509EncodedKeySpec; import java.util.HashMap; import java.util.Map; import javax.crypto.Cipher; /** *//** * RSA公钥/私钥/签名工具包 * * 罗纳德·李维斯特（Ron [R]ivest）、阿迪·萨莫尔（Adi [S]hamir）和伦纳德·阿德曼（Leonard [A]dleman） * * 字符串格式的密钥在未在特殊说明情况下都为BASE64编码格式&lt;br/&gt; * 由于非对称加密速度极其缓慢，一般文件不使用它来加密而是使用对称加密，&lt;br/&gt; * 非对称加密算法可以用来对对称加密的密钥加密，这样保证密钥的安全也就保证了数据的安全 * * @author IceWee * @date 2012-4-26 * @version 1.0 */ public class RSAUtils { /** *//** * 加密算法RSA */ public static final String KEY_ALGORITHM = &quot;RSA&quot;; /** *//** * 签名算法 */ public static final String SIGNATURE_ALGORITHM = &quot;MD5withRSA&quot;; /** *//** * 获取公钥的key */ private static final String PUBLIC_KEY = &quot;RSAPublicKey&quot;; /** *//** * 获取私钥的key */ private static final String PRIVATE_KEY = &quot;RSAPrivateKey&quot;; /** *//** * RSA最大加密明文大小 */ private static final int MAX_ENCRYPT_BLOCK = 117; /** *//** * RSA最大解密密文大小 */ private static final int MAX_DECRYPT_BLOCK = 128; /** *//** * 生成密钥对(公钥和私钥) * * @return * @throws Exception */ public static Map&lt;String, Object&gt; genKeyPair() throws Exception { KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM); keyPairGen.initialize(1024); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, Object&gt; keyMap = new HashMap&lt;String, Object&gt;(2); keyMap.put(PUBLIC_KEY, publicKey); keyMap.put(PRIVATE_KEY, privateKey); return keyMap; } /** *//** * 用私钥对信息生成数字签名 * * @param data 已加密数据 * @param privateKey 私钥(BASE64编码) * * @return * @throws Exception */ public static String sign(byte[] data, String privateKey) throws Exception { byte[] keyBytes = Base64Utils.decode(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initSign(privateK); signature.update(data); return Base64Utils.encode(signature.sign()); } /** *//** * 校验数字签名 * * @param data 已加密数据 * @param publicKey 公钥(BASE64编码) * @param sign 数字签名 * * @return * @throws Exception * */ public static boolean verify(byte[] data, String publicKey, String sign) throws Exception { byte[] keyBytes = Base64Utils.decode(publicKey); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PublicKey publicK = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initVerify(publicK); signature.update(data); return signature.verify(Base64Utils.decode(sign)); } /** *//** * &lt;P&gt; * 私钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] encryptedData, String privateKey) throws Exception { byte[] keyBytes = Base64Utils.decode(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) { cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); } else { cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; } byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; } /** *//** * &lt;p&gt; * 公钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */ public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey) throws Exception { byte[] keyBytes = Base64Utils.decode(publicKey); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) { cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); } else { cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; } byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; } /** *//** * &lt;p&gt; * 公钥加密 * &lt;/p&gt; * * @param data 源数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPublicKey(byte[] data, String publicKey) throws Exception { byte[] keyBytes = Base64Utils.decode(publicKey); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, publicK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) { cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); } else { cache = cipher.doFinal(data, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; } byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; } /** *//** * &lt;p&gt; * 私钥加密 * &lt;/p&gt; * * @param data 源数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPrivateKey(byte[] data, String privateKey) throws Exception { byte[] keyBytes = Base64Utils.decode(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, privateK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) { if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) { cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); } else { cache = cipher.doFinal(data, offSet, inputLen - offSet); } out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; } byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; } /** *//** * &lt;p&gt; * 获取私钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return * @throws Exception */ public static String getPrivateKey(Map&lt;String, Object&gt; keyMap) throws Exception { Key key = (Key) keyMap.get(PRIVATE_KEY); return Base64Utils.encode(key.getEncoded()); } /** *//** * &lt;p&gt; * 获取公钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return * @throws Exception */ public static String getPublicKey(Map&lt;String, Object&gt; keyMap) throws Exception { Key key = (Key) keyMap.get(PUBLIC_KEY); return Base64Utils.encode(key.getEncoded()); } } Base64Utils.java package security; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream; import it.sauronsoftware.base64.Base64; /** *//** * &lt;p&gt; * BASE64编码解码工具包 * &lt;/p&gt; * &lt;p&gt; * 依赖javabase64-1.3.1.jar * &lt;/p&gt; * * @author IceWee * @date 2012-5-19 * @version 1.0 */ public class Base64Utils { /** *//** * 文件读取缓冲区大小 */ private static final int CACHE_SIZE = 1024; /** *//** * &lt;p&gt; * BASE64字符串解码为二进制数据 * &lt;/p&gt; * * @param base64 * @return * @throws Exception */ public static byte[] decode(String base64) throws Exception { return Base64.decode(base64.getBytes()); } /** *//** * &lt;p&gt; * 二进制数据编码为BASE64字符串 * &lt;/p&gt; * * @param bytes * @return * @throws Exception */ public static String encode(byte[] bytes) throws Exception { return new String(Base64.encode(bytes)); } /** *//** * &lt;p&gt; * 将文件编码为BASE64字符串 * &lt;/p&gt; * &lt;p&gt; * 大文件慎用，可能会导致内存溢出 * &lt;/p&gt; * * @param filePath 文件绝对路径 * @return * @throws Exception */ public static String encodeFile(String filePath) throws Exception { byte[] bytes = fileToByte(filePath); return encode(bytes); } /** *//** * &lt;p&gt; * BASE64字符串转回文件 * &lt;/p&gt; * * @param filePath 文件绝对路径 * @param base64 编码字符串 * @throws Exception */ public static void decodeToFile(String filePath, String base64) throws Exception { byte[] bytes = decode(base64); byteArrayToFile(bytes, filePath); } /** *//** * &lt;p&gt; * 文件转换为二进制数组 * &lt;/p&gt; * * @param filePath 文件路径 * @return * @throws Exception */ public static byte[] fileToByte(String filePath) throws Exception { byte[] data = new byte[0]; File file = new File(filePath); if (file.exists()) { FileInputStream in = new FileInputStream(file); ByteArrayOutputStream out = new ByteArrayOutputStream(2048); byte[] cache = new byte[CACHE_SIZE]; int nRead = 0; while ((nRead = in.read(cache)) != -1) { out.write(cache, 0, nRead); out.flush(); } out.close(); in.close(); data = out.toByteArray(); } return data; } /** *//** * &lt;p&gt; * 二进制数据写文件 * &lt;/p&gt; * * @param bytes 二进制数据 * @param filePath 文件生成目录 */ public static void byteArrayToFile(byte[] bytes, String filePath) throws Exception { InputStream in = new ByteArrayInputStream(bytes); File destFile = new File(filePath); if (!destFile.getParentFile().exists()) { destFile.getParentFile().mkdirs(); } destFile.createNewFile(); OutputStream out = new FileOutputStream(destFile); byte[] cache = new byte[CACHE_SIZE]; int nRead = 0; while ((nRead = in.read(cache)) != -1) { out.write(cache, 0, nRead); out.flush(); } out.close(); in.close(); } } RSATester.java package security; import java.util.Map; public class RSATester { static String publicKey; static String privateKey; static { try { Map&lt;String, Object&gt; keyMap = RSAUtils.genKeyPair(); publicKey = RSAUtils.getPublicKey(keyMap); privateKey = RSAUtils.getPrivateKey(keyMap); System.err.println(&quot;公钥: \n\r&quot; + publicKey); System.err.println(&quot;私钥： \n\r&quot; + privateKey); } catch (Exception e) { e.printStackTrace(); } } public static void main(String[] args) throws Exception { test(); testSign(); } static void test() throws Exception { System.err.println(&quot;公钥加密——私钥解密&quot;); String source = &quot;这是一行没有任何意义的文字，你看完了等于没看，不是吗？&quot;; System.out.println(&quot;\r加密前文字：\r\n&quot; + source); byte[] data = source.getBytes(); byte[] encodedData = RSAUtils.encryptByPublicKey(data, publicKey); System.out.println(&quot;加密后文字：\r\n&quot; + new String(encodedData)); byte[] decodedData = RSAUtils.decryptByPrivateKey(encodedData, privateKey); String target = new String(decodedData); System.out.println(&quot;解密后文字: \r\n&quot; + target); } static void testSign() throws Exception { System.err.println(&quot;私钥加密——公钥解密&quot;); String source = &quot;这是一行测试RSA数字签名的无意义文字&quot;; System.out.println(&quot;原文字：\r\n&quot; + source); byte[] data = source.getBytes(); byte[] encodedData = RSAUtils.encryptByPrivateKey(data, privateKey); System.out.println(&quot;加密后：\r\n&quot; + new String(encodedData)); byte[] decodedData = RSAUtils.decryptByPublicKey(encodedData, publicKey); String target = new String(decodedData); System.out.println(&quot;解密后: \r\n&quot; + target); System.err.println(&quot;私钥签名——公钥验证签名&quot;); String sign = RSAUtils.sign(encodedData, privateKey); System.err.println(&quot;签名:\r&quot; + sign); boolean status = RSAUtils.verify(encodedData, publicKey, sign); System.err.println(&quot;验证结果:\r&quot; + status); } } AES对称加密和解密package demo.security; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.InvalidKeyException; import java.security.NoSuchAlgorithmException; import java.security.SecureRandom; import java.util.Base64; import java.util.Scanner; import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.IllegalBlockSizeException; import javax.crypto.KeyGenerator; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; /* * AES对称加密和解密 */ public class SymmetricEncoder { /* * 加密 * 1.构造密钥生成器 * 2.根据ecnodeRules规则初始化密钥生成器 * 3.产生密钥 * 4.创建和初始化密码器 * 5.内容加密 * 6.返回字符串 */ public static String AESEncode(String encodeRules,String content){ try { //1.构造密钥生成器，指定为AES算法,不区分大小写 KeyGenerator keygen=KeyGenerator.getInstance(&quot;AES&quot;); //2.根据ecnodeRules规则初始化密钥生成器 //生成一个128位的随机源,根据传入的字节数组 keygen.init(128, new SecureRandom(encodeRules.getBytes())); //3.产生原始对称密钥 SecretKey original_key=keygen.generateKey(); //4.获得原始对称密钥的字节数组 byte [] raw=original_key.getEncoded(); //5.根据字节数组生成AES密钥 SecretKey key=new SecretKeySpec(raw, &quot;AES&quot;); //6.根据指定算法AES自成密码器 Cipher cipher=Cipher.getInstance(&quot;AES&quot;); //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密解密(Decrypt_mode)操作，第二个参数为使用的KEY cipher.init(Cipher.ENCRYPT_MODE, key); //8.获取加密内容的字节数组(这里要设置为utf-8)不然内容中如果有中文和英文混合中文就会解密为乱码 byte [] byte_encode=content.getBytes(&quot;utf-8&quot;); //9.根据密码器的初始化方式--加密：将数据加密 byte [] byte_AES=cipher.doFinal(byte_encode); //10.将加密后的数据转换为字符串 //这里用Base64Encoder中会找不到包 //解决办法： //在项目的Build path中先移除JRE System Library，再添加库JRE System Library，重新编译后就一切正常了。 String AES_encode=new String(new BASE64Encoder().encode(byte_AES)); //11.将字符串返回 return AES_encode; } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (NoSuchPaddingException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } //如果有错就返加nulll return null; } /* * 解密 * 解密过程： * 1.同加密1-4步 * 2.将加密后的字符串反纺成byte[]数组 * 3.将加密内容解密 */ public static String AESDncode(String encodeRules,String content){ try { //1.构造密钥生成器，指定为AES算法,不区分大小写 KeyGenerator keygen=KeyGenerator.getInstance(&quot;AES&quot;); //2.根据ecnodeRules规则初始化密钥生成器 //生成一个128位的随机源,根据传入的字节数组 keygen.init(128, new SecureRandom(encodeRules.getBytes())); //3.产生原始对称密钥 SecretKey original_key=keygen.generateKey(); //4.获得原始对称密钥的字节数组 byte [] raw=original_key.getEncoded(); //5.根据字节数组生成AES密钥 SecretKey key=new SecretKeySpec(raw, &quot;AES&quot;); //6.根据指定算法AES自成密码器 Cipher cipher=Cipher.getInstance(&quot;AES&quot;); //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密(Decrypt_mode)操作，第二个参数为使用的KEY cipher.init(Cipher.DECRYPT_MODE, key); //8.将加密并编码后的内容解码成字节数组 byte [] byte_content= new BASE64Decoder().decodeBuffer(content); /* * 解密 */ byte [] byte_decode=cipher.doFinal(byte_content); String AES_decode=new String(byte_decode,&quot;utf-8&quot;); return AES_decode; } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (NoSuchPaddingException e) { e.printStackTrace(); } catch (InvalidKeyException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (IllegalBlockSizeException e) { e.printStackTrace(); } catch (BadPaddingException e) { e.printStackTrace(); } //如果有错就返加nulll return null; } public static void main(String[] args) { SymmetricEncoder se=new SymmetricEncoder(); Scanner scanner=new Scanner(System.in); /* * 加密 */ System.out.println(&quot;使用AES对称加密，请输入加密的规则&quot;); String encodeRules=scanner.next(); System.out.println(&quot;请输入要加密的内容:&quot;); String content = scanner.next(); System.out.println(&quot;根据输入的规则&quot;+encodeRules+&quot;加密后的密文是:&quot;+se.AESEncode(encodeRules, content)); /* * 解密 */ System.out.println(&quot;使用AES对称解密，请输入加密的规则：(须与加密相同)&quot;); encodeRules=scanner.next(); System.out.println(&quot;请输入要解密的内容（密文）:&quot;); content = scanner.next(); System.out.println(&quot;根据输入的规则&quot;+encodeRules+&quot;解密后的明文是:&quot;+se.AESDncode(encodeRules, content)); } } 测试结果： 使用AES对称加密，请输入加密的规则 使用AES对称加密 请输入要加密的内容: 使用AES对称加密 根据输入的规则使用AES对称加密加密后的密文是:Z0NwrNPHghgXHN0CqjLS58YCjhMcBfeR33RWs7Lw+AY= 使用AES对称解密，请输入加密的规则：(须与加密相同) 使用AES对称加密 请输入要解密的内容（密文）: Z0NwrNPHghgXHN0CqjLS58YCjhMcBfeR33RWs7Lw+AY= 根据输入的规则使用AES对称加密解密后的明文是:使用AES对称加密 参考资料java RSA加密解密实现（含分段加密）AES对称加密和解密Android: AndroidKeyStore 非对称RSA加密解密https://www.cnblogs.com/zuge/p/5430362.html]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>AES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android dagger2使用心得]]></title>
    <url>%2F2019%2F03%2F22%2Fandroid-dagger2%2F</url>
    <content type="text"><![CDATA[ScopeScope 是用来确定注入的实例的生命周期的，如果没有使用 Scope 注解，Component 每次调用 Module 中的 provide 方法或 Inject 构造函数生成的工厂时都会创建一个新的实例，而使用 Scope 后可以复用之前的依赖实例。 在Dagger 2中1、@Singleton可以保持类的单例。2、@ApplicationScope注解的Component类与Applicaiton对象的生命周期一致。3、@ActivityScope注解的Component类与Activity的生命周期一致scope可以给我们带来“局部单例”，生命周期取决于scope自己。 在 Dagger 2 官方文档中我找到一句话，非常清楚地描述了@Scope的原理：When a binding uses a scope annotation, that means that the component object holds a reference to the bound object until the component object itself is garbage-collected.Scope 作用域的本质：Component 间接持有依赖实例的引用，把实例的作用域与 Component 绑定，它们不是同年同月同日生，但是同年同月死。 自定义@Scope对于Android，我们通常会定义一个针对整个Activity的注解,通过仿照@Singleton @Scope @Documented @Retention(RUNTIME) public @interface ActivityScope {} 你可能会发现，这个自定义的@Scope和@Singleton代码完全一样，具有实现单例模式的功能。那干嘛还自定义@Scope，好处如下： 更好的管理ApplicationComponent和Module之间的关系，Component和Component之间的依赖和继承关系。如果关系不匹配，在编译期间会报错，详细下面会介绍。代码可读性，让程序猿更好的了解Module中创建的类实例的使用范围。 使用@Scope的一些经验：1、@Component关联的@Module中的任何一个@Provides有@scope，则该整个@Component要加上这个scope。否则在暴露或者注入时（不暴露且不注入时，既不使用它构造对象时，不报错），会有如下错误: Error:(13, 1) 错误: cn.xuexuan.newui.di.component.ActivityComponent (unscoped) may not reference scoped bindings: @Singleton @Provides android.app.Activity cn.xuexuan.newui.di.module.ActivityModule.getActivity() 2、@Component的dependencies与@Component自身的scope不能相同，即dependencies组件之间的scope不能相同,否则出现下面错误3、@Singleton的组件不能依赖其他scope的组件，但是其他scope的组件可以依赖@Singleton组件。否则出现下面错误4、没有scope的不能依赖有scope的组件。否则出现下面错误: Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) cannot depend on scoped components: @com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.di.component.MyTestComponentX 5、一个component不能同时有多个scope(Subcomponent除外)，否则出现下面的错误 Error:Execution failed for task ‘:app:compileDebugJavaWithJavac’. java.lang.IllegalArgumentException: com.android.example.devsummit.archdemo.di.component.MyTestComponent was annotated with more than one @Scope annotation @Binds@Binds：可以理解为关联，首先它是跟@Provides使用地方是一样的，不同的在于@Provides 注解的方法都是有具体实现的，而@Binds修饰的只有方法定义，并没有具体的实现的，在方法定义中方法参数必须是 返回值的实现类。这样创建实体类的地方就不用在Modules 中实现了，例如： @Binds @Singleton abstract AccountManagerDelegate accountManagerDelegate(AccountManagerDelegateImpl delegate); Module 中不一定要具体实现，可以用@Binds关联实体，这样在编译过程中会自动创建Fractory 以及实现的，AccountManagerDelegate中还可以使用该Module中 @Provides 提供的实体类 @BindsInstanceComponent 可以在创建 Component 的时候绑定依赖实例，用以注入。这就是@BindsInstance注解的作用，只能在 Component.Builder 中使用。 @Module public final class HomeActivityModule { private final HomeActivity activity; public HomeActivityModule(HomeActivity activity) { this.activity = activity; } @Provides @ActivityScope // 自定义作用域 Activity provideActivity() { return activity; } } 而使用@BindsInstance的话会更加简单: @ActivityScope @Component public interface HomeActivityComponent { @Component.Builder interface Builder { @BindsInstance Builder activity(Activity activity); HomeActivityComponent build(); } } 注意在调用build()创建 Component 之前，所有@BindsInstance方法必须先调用。上面例子中 HomeActivityComponent 还可以注入 Activity 类型的依赖，但是不能注入 HomeActivity，因为 Dagger 2 是使用具体类型作为依据的（也就是只能使用@Inject Activity activity而不是@Inject HomeActivity activity）。 如果@BindsInstance方法的参数可能为 null，需要再用@Nullable标记，同时标注 Inject 的地方也需要用@Nullable标记。这时 Builder 也可以不调用@BindsInstance方法，这样 Component 会默认设置 instance 为 null 注意：dagger.android 扩展库可以极大地简化在 Android 项目中使用 Dagger 2 的过程，但是还是有些限制，SubComponent.Builder 不能自定义 @BindsInstance 方法，SubCompoennt 的 Module 不能有含参数的构造函数，否则AndroidInjection.inject(this)在创建 SubComponent 时无法成功。 参考资料Dagger 2 完全解析打破Dagger2使用窘境：Dagger-Android详解（https://github.com/qingmei2/Sample_dagger2）dagger组件化]]></content>
      <categories>
        <category>android知识点</category>
      </categories>
      <tags>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP基础]]></title>
    <url>%2F2019%2F03%2F20%2Fjava-http%2F</url>
    <content type="text"><![CDATA[HTTP（HyperText Transfer Protocol)超文本传输协议是互联网上应用最为广泛的一种网络协议。由于信息是明文传输，所以被认为是不安全的。 为了理解HTTP，我们有必要事先了解一下TCP/IP协议族。其是互联网相关联的协议集合的总称，通常使用的网络就是在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集，除此之外，还包括大家所熟知的FTP，DNS，TCP，UDP，IP等等协议。 OSI的七层协议其核心思想就是把数据信息包装起来，即封装：发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输线路是怎样的、是否能确保传输送达等问题。 TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。下面的图表试图显示不同的TCP/IP和其他的协议在最初OSI（Open System Interconnect）模型中的位置： HTTP 方法下面的表格比较了两种 HTTP 方法：GET 和 POSTHTTP 请求方法 持久连接HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。为了解决上述 TCP 连接的问题，HTTP/1.1 和部分 HTTP/1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP/1.1 中，所有的连接默认都是持久连接。 管线化持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。 CookieHTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。Cookie是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。 cookie的用途 会话管理1.1 记录用户的登录状态是cookie最常用的用途。通常web服务器会在用户登录成功后下发一个签名来标记session的有效性，这样免去了用户多次认证和登录网站。1.2 记录用户的访问状态，例如导航啊，用户的注册流程啊。 个性化信息2.1 Cookie也经常用来记忆用户相关的信息，以方便用户在使用和自己相关的站点服务。例如：ptlogin会记忆上一次登录的用户的QQ号码，这样在下次登录的时候会默认填写好这个QQ号码。2.2 Cookie也被用来记忆用户自定义的一些功能。用户在设置自定义特征的时候，仅仅是保存在用户的浏览器中，在下一次访问的时候服务器会根据用户本地的cookie来表现用户的设置。例如google将搜索设置（使用语言、每页的条数，以及打开搜索结果的方式等等）保存在一个COOKIE里。 记录用户的行为最典型的是公司的TCSS系统。它使用Cookie来记录用户的点击流和某个产品或商业行为的操作率和流失率。当然功能可以通过IP或http header中的referrer实现，但是Cookie更精准一些。 WebView中的Cookie机制WebView是基于webkit内核的UI控件，相当于一个浏览器客户端。它会在本地维护每次会话的cookie(保存在data/data/package_name/app_WebView/Cookies)数据就保存在Cookies那个文件里，其实是个数据库，把后缀改成.db用数据库打开可以看到里面的表结构，主要有host_key, name, value, path等，host_key其实就是domain.当WebView加载URL的时候,WebView会从本地读取该URL对应的cookie，并携带该cookie与服务器进行通信。WebView通过android.webkit.CookieManager类来维护cookie。CookieManager是 WebView的cookie管理类。 okhttp中的cookie详见之前的文章：OKHttp深入理解 Cookie的缺陷cookie会被附加在每个HTTP请求中，所以无形中增加了流量。由于在HTTP请求中的cookie是明文传递的，所以安全性成问题。（除非用HTTPS)Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。 HTTP报文简介HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。 请求报文结构请求报文的首部内容由以下数据组成： 请求行 —— 包含用于请求的方法、请求 URI 和 HTTP 版本。首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及RFC里未定义的首部如 Cookie 等） 请求报文的示例，如下： 响应报文结构响应报文的首部内容由以下数据组成： 状态行 —— 包含表明响应结果的状态码、原因短语和 HTTP 版本。首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及RFC里未定义的首部如 Cookie 等） 响应报文的示例，如下： HTTP状态码HTTP 状态码的职责是当客户端向服务端发送请求时，描述返回的请求结果。状态码类型: 1XX：Informational(信息性状态码)，接收的请求正在处理2XX：Success(成功状态码)，请求正常处理完毕3XX：Redirection(重定向状态码)，需要进行附加操作以完成请求4XX：Client Error(客户端错误状态码)，服务器无法处理请求5XX：Server Error(服务器错误状态码)，服务器处理请求出错 TCP三次握手四次挥手在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 如下图所示，SYN（synchronous）是TCP/IP建立连接时使用的握手信号、Sequence number（序列号）、Acknowledge number（确认号码），三个箭头指向就代表三次握手，完成三次握手，客户端与服务器开始传送数据。 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 四次挥手: 第一次挥手:客户端A发送一个FIN.用来关闭客户A到服务器B的数据传送 第二次挥手:服务器B收到这个FIN. 它发回一个ACK，确认序号为收到的序号+1。和SYN一样，一个FIN将占用一个序号 第三次挥手:服务器B关闭与客户端A的连接，发送一个FIN给客户端A 第四次挥手:客户端A发回ACK报文确认，并将确认序号设置为序号加1 TCP和UDP的区别我这里简单列举几个: 1、基于连接与无连接;UDP是无连接的，即发送数据之前不需要建立连接 2、TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付 ，即不保证可靠交付Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。 3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。 5、TCP对系统资源要求较多，UDP对系统资源要求较少。 HTTP 2.0目标是改善用户在Web时的速度体验。可以说HTTP 2.0是SPDY的升级版(其实也是基于SPDY设计的)。 参考资料HTTP基础Cookie介绍及在Android中的使用TCP三次握手和四次挥手]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[https加密解析]]></title>
    <url>%2F2019%2F03%2F19%2Fjava-https%2F</url>
    <content type="text"><![CDATA[HTTPS全称为Hypertext Transfer Protocol over Secure Socket Layer，中文含义为“超文本传输安全协议”。 HTTP协议是没有加密无状态的明文传输协议，如果APP采用HTTP传输数据，则会泄露传输内容，可能被中间人劫持，修改传输的内容。HTTPS相当于HTTP的安全版本，作用如下： 认证用户和服务器，确保数据发送到正确的客户机和服务器；(身份认证)加密数据以防止数据中途被窃取；（内容加密）维护数据的完整性，确保数据在传输过程中不被改变。（数据完整性） Https通讯原理HTTPS是HTTP over SSL/TLS，HTTP是应用层协议，TCP是传输层协议，在应用层和传输层之间，增加了一个安全套接层SSL/TLS：TLS协议主要有五部分：应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS协议本身又是有record协议传输的，record协议的格式如上图最右所示。SSL/TLS层负责客户端和服务器之间的加解密算法协商、密钥交换、通信连接的建立，安全连接的建立过程如下所示：简单描述如下： 浏览器将自己支持的一套加密算法、HASH算法发送给网站。 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 浏览器获得网站证书之后，开始验证证书的合法性，如果证书信任，则生成一串随机数字作为通讯过程中对称加密的秘钥。然后取出证书中的公钥，将这串数字以及HASH的结果进行加密，然后发给网站。 网站接收浏览器发来的数据之后，通过私钥进行解密，然后HASH校验，如果一致，则使用浏览器发来的数字串使加密一段握手消息发给浏览器。 浏览器解密，并HASH校验，没有问题，则握手结束。接下来的传输过程将由之前浏览器生成的随机密码并利用对称加密算法进行加密。 数字证书、CA信息安全的基础依赖密码学，密码学涉及算法和密钥，算法一般是公开的，而密钥需要得到妥善的保护，密钥如何产生、分配、使用和回收，这涉及公钥基础设施。 公钥基础设施（PKI）是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。公钥存储在数字证书中，标准的数字证书一般由可信数字证书认证机构(CA，根证书颁发机构)签发，此证书将用户的身份跟公钥链接在一起。CA必须保证其签发的每个证书的用户身份是唯一的。 链接关系（证书链）通过注册和发布过程创建，取决于担保级别，链接关系可能由CA的各种软件或在人为监督下完成。PKI的确定链接关系的这一角色称为注册管理中心（RA，也称中级证书颁发机构或者中间机构）。RA确保公钥和个人身份链接，可以防抵赖。如果没有RA，CA的Root 证书遭到破坏或者泄露，由此CA颁发的其他证书就全部失去了安全性，所以现在主流的商业数字证书机构CA一般都是提供三级证书，Root 证书签发中级RA证书，由RA证书签发用户使用的证书。 X509证书链，左边的是CA根证书，中间的是RA中间机构，右边的是用户： .pfx格式和.cer格式的区别购买的证书，格式为.pfx，带有公钥和私钥，附带一个密码。还有一种格式为.cer的证书，这种证书是没有私钥的。 带有私钥的证书 由Public Key Cryptography Standards #12，PKCS#12标准定义，包含了公钥和私钥的二进制格式的证书形式，以pfx作为证书文件后缀名(导出私钥,是需要输入密码的)。 二进制编码的证书 证书中没有私钥，DER 编码二进制格式的证书文件，以cer作为证书文件后缀名。 Base64编码的证书证书中没有私钥，BASE64 编码格式的证书文件，也是以cer作为证书文件后缀名。 https加密加密算法一般分为对称加密与非对称加密。HTTPS一般使用的加密与HASH算法如下： 非对称加密算法：RSA，DSA/DSS对称加密算法：AES，RC4，3DESHASH算法：MD5，SHA1，SHA256 对称加密客户端与服务器使用相同的密钥对消息进行加密优点：1.加密强度高，很难被破解 2.计算量小，仅为非对称加密计算量的 0.1%缺点：1.无法安全的生成和管理密钥 2.服务器管理大量客户端密钥复杂 非对称加密非对称指加密与解密的密钥为两种密钥。服务器提供公钥，客户端通过公钥对消息进行加密，并由服务器端的私钥对密文进行解密。优点：安全缺点： 1. 性能低下，CPU 计算资源消耗巨大，一次完全的 TLS 握手，密钥交换时的非对称加密解密占了整个握手过程的 90% 以上。而对称加密的计算量只相当于非对称加密的 0.1%，因此如果对应用层使用非对称加密，性能开销过大，无法承受。2. 非对称加密对加密内容长度有限制，不能超过公钥的长度。比如现在常用的公钥长度是 2048 位，意味着被加密消息内容不能超过 256 字节。 其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。 非对称密钥加密最大的一个问题，就是无法证明公钥本身就是货真价实的公钥。比如，正准备和某台服务器建立非对称密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。为了解决上述问题，可以使用由数字证书认证机构(CA，Certificate Authority)和其相关机关颁发的公开密钥证书。 Hash算法（摘要算法）Hash算法特别的地方在于它是一种单向算法，用户可以通过hash算法对目标信息生成一段特定长度的唯一hash值，却不能通过这个hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。 常见的Hash算法有MD2、MD4、MD5、HAVAL、SHA HTTPS采用混合加密机制HTTPS采用对称密钥加密和非对称密钥加密两者并用的混合加密机制，在交换密钥环节使用非对称密钥加密方式（安全地交换在稍后的对称密钥加密中要使用的密钥），之后的建立通信交换报文阶段则使用对称密钥加密方式。 所以，AES+RSA结合才更好，AES加密数据，且密钥随机生成，RSA用对方（服务器）的公钥加密随机生成的AES密钥。传输时要把密文，加密的AES密钥和自己的公钥传给对方（服务器）。对方（服务器）接到数据后，用自己的私钥解密AES密钥，再拿AES密钥解密数据得到明文。这样就综合了两种加密体系的优点。下面代码展示OkHttp添加拦截器实现（要对response.code()做处理，只有在和后台约定好的返回码下才走解密的逻辑，具体看自己的需求）： public class DataEncryptInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { //请求 Request request = chain.request(); RequestBody oldRequestBody = request.body(); Buffer requestBuffer = new Buffer(); oldRequestBody.writeTo(requestBuffer); String oldBodyStr = requestBuffer.readUtf8(); requestBuffer.close(); MediaType mediaType = MediaType.parse(&quot;text/plain; charset=utf-8&quot;); //生成随机AES密钥并用serverPublicKey进行RSA加密 SecretKeySpec appAESKeySpec = EncryptUtils.generateAESKey(256); String appAESKeyStr = EncryptUtils.covertAESKey2String(appAESKeySpec); String appEncryptedKey = RSAUtils.encryptDataString(appAESKeyStr, serverPublicKey); //计算body 哈希 并使用app私钥RSA签名 String appSignature = RSAUtils.signature(oldBodyStr, appPrivateKey); //随机AES密钥加密oldBodyStr String newBodyStr = EncryptUtils.encryptAES(appAESKeySpec, oldBodyStr); RequestBody newBody = RequestBody.create(mediaType, newBodyStr); //构造新的request request = request.newBuilder() .header(&quot;Content-Type&quot;, newBody.contentType().toString()) .header(&quot;Content-Length&quot;, String.valueOf(newBody.contentLength())) .method(request.method(), newBody) .header(&quot;appEncryptedKey&quot;, appEncryptedKey) .header(&quot;appSignature&quot;, appSignature) .header(&quot;appPublicKey&quot;, appPublicKeyStr) .build(); //响应 Response response = chain.proceed(request); if (response.code() == 200) {//只有约定的返回码才经过加密，才需要走解密的逻辑 //获取响应头 String serverEncryptedKey = response.header(&quot;serverEncryptedKey&quot;); //用app的RSA私钥解密AES加密密钥 String serverDecryptedKey = RSAUtils.decryptDataString(serverEncryptedKey, appPrivateKey); SecretKeySpec serverAESKeySpec = EncryptUtils.covertString2AESKey(serverDecryptedKey); //用AES密钥解密oldResponseBodyStr ResponseBody oldResponseBody = response.body(); String oldResponseBodyStr = oldResponseBody.string(); String newResponseBodyStr = EncryptUtils.decryptAES(serverAESKeySpec, oldResponseBodyStr); oldResponseBody.close(); //构造新的response ResponseBody newResponseBody = ResponseBody.create(mediaType, newResponseBodyStr); response = response.newBuilder().body(newResponseBody).build(); } response.close(); //返回 return response; } } 参考资料https://www.cnblogs.com/alisecurity/p/5939336.htmlHttps原理和实现Android Okhttp网络请求加解密实现方案]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android中使用https]]></title>
    <url>%2F2019%2F03%2F18%2Fandroid-https%2F</url>
    <content type="text"><![CDATA[本案例将ca证书放在本地，这里使用.pfx格式的证书 单向验证有两种写法，先展示一种接近okhttp官方写法的方法: private void setCertificates(Context context) { try { //将ca证书导入输入流 InputStream inputStream = context.getResources().openRawResource(R.raw.aaa); //keystore添加证书内容和密码 KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(inputStream, CLIENT_KET_PASSWORD.toCharArray()); //证书工厂类，生成证书 CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;); //生成证书，添加别名 keyStore.setCertificateEntry(&quot;test1&quot;, certificateFactory.generateCertificate(inputStream)); //信任管理器工厂 TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); //构建一个ssl上下文，加入ca证书格式，与后台保持一致 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); //参数，添加受信任证书和生成随机数 sslContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom()); //获得scoket工厂 SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory(); mOkHttpClient.sslSocketFactory(sslSocketFactory); //设置ip授权认证：如果已经安装该证书，可以不设置，否则需要设置 mOkHttpClient.hostnameVerifier(new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { return true; } }); inputStream.close(); } catch (Exception e) { e.printStackTrace(); } } 第二种写法，同样有效: private void setCertificates(Context context) { try { //将ca证书导入输入流 InputStream inputStream = context.getResources().openRawResource(R.raw.aaa); //keystore添加证书内容和密码 KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(inputStream, CLIENT_KET_PASSWORD.toCharArray()) //key管理器工厂 KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore, CLIENT_KET_PASSWORD.toCharArray()); //构建一个ssl上下文，加入ca证书格式，与后台保持一致 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); //参数，添加受信任证书和生成随机数 sslContext.init(keyManagerFactory.getKeyManagers(), null, new SecureRandom()); //获得scoket工厂 SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory(); mOkHttpClient.sslSocketFactory(sslSocketFactory); //设置ip授权认证：如果已经安装该证书，可以不设置，否则需要设置 mOkHttpClient.hostnameVerifier(new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { return true; } }); inputStream.close(); } catch (Exception e) { e.printStackTrace(); } } 值得注意的是，keystore的格式，keystore拓展名对应格式： JKS:.jks/.ksJCEKS:.jcePKCS12:.p12/.pfxBKS:.bksUBER:.ubr 所以，如果ca证书用的是.pfx，那么可以这样写： KeyStore keyStore = KeyStore.getInstance(&quot;PKCS12&quot;); 如果是.cer的话那么，就用: KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); 双向验证双向验证的前提是，你的app同样生成一个jks的密钥文件，服务器那边会同时有个“cer文件”与之对应。注意： Java平台默认识别jks格式的证书文件，但是android平台只识别bks格式的证书文件，所以这里还需要将jks的文件转成bks 通过jks文件生成对应的cer文件： keytool -export -alias test1.jks -file test2.cer -keystore test1.jks -storepass 123456 如果服务端报错keystore文件格式不正确，则我们再将cer文件转换成jks文件： keytool -import -alias test2.cer -file test2.cer -keystore test3.jks 客户端代码如下： private void setCertificates(Context context) { try { //将ca证书导入输入流 InputStream inputStream = context.getResources().openRawResource(R.raw.aaa); //keystore添加证书内容和密码 KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(inputStream, CLIENT_KET_PASSWORD.toCharArray()); //证书工厂类，生成证书 CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;); //生成证书，添加别名 keyStore.setCertificateEntry(&quot;test1&quot;, certificateFactory.generateCertificate(inputStream)); //信任管理器工厂 TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); trustManagerFactory.init(keyStore); //双向验证，配置服务器验证客户端的证书 InputStream inputStream1 = context.getResources().openRawResource(R.raw.bbb); KeyStore keyStore1 = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore1.load(inputStream1, CLIENT_KET_PASSWORD_1.toCharArray()); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); keyManagerFactory.init(keyStore1, CLIENT_KET_PASSWORD_1.toCharArray()); //构建一个ssl上下文，加入ca证书格式，与后台保持一致 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;); //参数，添加受信任证书和生成随机数 sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom()); //获得scoket工厂 SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory(); mOkHttpClient.sslSocketFactory(sslSocketFactory); //设置ip授权认证：如果已经安装该证书，可以不设置，否则需要设置 mOkHttpClient.hostnameVerifier(new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { return true; } }); inputStream.close(); } catch (Exception e) { e.printStackTrace(); } } 中间人劫持攻击https也不是绝对安全的，如下图所示为中间人劫持攻击，中间人可以获取到客户端与服务器之间所有的通信内容:中间人截取客户端发送给服务器的请求，然后伪装成客户端与服务器进行通信;将服务器返回给客户端的内容发送给客户端，伪装成服务器与客户端进行通信。通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。使用中间人攻击手段，必须要让客户端信任中间人的证书，如果客户端不信任，则这种攻击手段也无法发挥作用。 造成中间人劫持的原因是：没有对服务端证书及域名做校验或者校验不完整。下面是错误的写法：正确的写法是真正实现TrustManger的checkServerTrusted()，对服务器证书域名进行强校验或者真正实现HostnameVerifier的verify()方法。真正实现TrustManger的checkServerTrusted()代码如下:其中serverCert是APP中预埋的服务器端公钥证书 对服务器证书域名进行强校验:真正实现HostnameVerifier的verify()方法： 另外一种写法证书锁定，直接用预埋的证书来生成TrustManger，过程如上面介绍okhttp使用https方式 参考资料okhttp实现https请求okhttp官方https的api方法手机如何抓取HTTPS的请求数据]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MpAndroidChart实现多点的特殊标记]]></title>
    <url>%2F2019%2F03%2F12%2Fmpchart-point-label%2F</url>
    <content type="text"><![CDATA[最近在开发时遇到这样一种需求，为一些特殊点显示标签，类似默认显示多个markview。如下图（demo）： 在网上并没有相关资料，在此做下记录分享 下面上代码: 首先创建一个类继承LineChart,重写init()方法： @Override protected void init() { super.init(); //获取屏幕宽度,上图最边上标签，会根据屏幕宽度适配 WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE); DisplayMetrics metrics = new DisplayMetrics(); wm.getDefaultDisplay().getMetrics(metrics); mRenderer = new HbFundLineChartRenderer(this, mAnimator, mViewPortHandler, metrics.widthPixels); } 接下来是主要内容,也就是自己实现的LineChartRenderer即渲染器,用来画点、线等.首先是一些变量,分别是标记控件的宽高边距等,这里写的是一些根据我们需求来的默认值： private int mWidth;//屏幕宽度,在构造方法中传进来赋值 private float hViewLength = Utils.convertDpToPixel(30f);//vie宽30dp private float vViewLength = Utils.convertDpToPixel(20f);//view高20dp private float viewRect= Utils.convertDpToPixel(4f);//矩形高低差 然后,在LineChartRenderer中有一个drawValues,它是主要负责根据值来画点的,我们要做的就是在super()之后加上我们自己的东西： @Override public void drawValues(Canvas c) { super.drawValues(c); if (isShowLabel) { LineDataSet dataSetByIndex = (LineDataSet) mChart.getLineData().getDataSetByIndex(0); Transformer trans = mChart.getTransformer(dataSetByIndex.getAxisDependency()); Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);//抗锯齿画笔 paint.setTextSize(Utils.convertDpToPixel(textSixe));//设置字体大小 //画首中尾三个label float[] firstFloat = getFloat(dataSetByIndex.getValues(), 0);//根据数据集获取点 drawPointLabel(trans, paint, c, firstFloat); float[] middleFloat = getFloat(dataSetByIndex.getValues(), (dataSetByIndex.getValues().size() - 1) / 2); drawPointLabel(trans, paint, c, middleFloat); float[] endFloat = getFloat(dataSetByIndex.getValues(), dataSetByIndex.getValues().size() - 1); drawPointLabel(trans, paint, c, endFloat); } } 首先获取点的数据集,然后得到Transformer,它可以根据点数据集里的某一点来得到这个点在屏幕中的位置然后分别传入transformer、画笔、画布对象、点,进行绘制： private void drawPointLabel(Transformer trans, Paint paint, Canvas c, float[] floatPosition) { MPPointD maxPoint = trans.getPixelForValues(floatPosition[0], floatPosition[1]); float highX = (float) maxPoint.x; float highY = (float) maxPoint.y; TextView view = (TextView) LayoutInflater.from(mContext).inflate(R.layout.mark_view, null, false); if (highX &gt; mWidth - mWidth / 4) {//标识朝左 view.setBackgroundResource(R.mipmap.sm_lable_bg_buy_r); Bitmap bitmap = createBitmap(view, (int) hViewLength, (int) vViewLength); c.drawBitmap(bitmap, (int) (highX - hViewLength), (int) (highY - vViewLength - viewRect), paint); } else if (highX &lt; mWidth / 4) {//标识朝右 view.setBackgroundResource(R.mipmap.sm_lable_bg_buy_l); Bitmap bitmap = createBitmap(view, (int) hViewLength, (int) vViewLength); c.drawBitmap(bitmap, (int) (highX), (int) (highY - vViewLength - viewRect), paint); } else {//标识居中 view.setBackgroundResource(R.mipmap.sm_lable_bg_buy_c); Bitmap bitmap = createBitmap(view, (int) hViewLength, (int) vViewLength); c.drawBitmap(bitmap, (int) (highX - hViewLength / 2), (int) (highY - vViewLength - viewRect), paint); } } 此处，我们随意定义几个点，可以根据实际需求进行设置： private float[] getFloat(List&lt;Entry&gt; lists, int index) { float[] maxEntry = new float[2]; maxEntry[0] = lists.get(index).getX(); maxEntry[1] = lists.get(index).getY(); return maxEntry; } view转bitmap方法如下： private Bitmap createBitmap(View v, int width, int height) { //测量使得view指定大小 int measuredWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY); int measuredHeight = View.MeasureSpec.makeMeasureSpec(height, View.MeasureSpec.EXACTLY); v.measure(measuredWidth, measuredHeight); //调用layout方法布局后，可以得到view的尺寸大小 v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight()); Bitmap bmp = Bitmap.createBitmap(v.getWidth(), v.getHeight(), Bitmap.Config.ARGB_8888); Canvas c = new Canvas(bmp); v.draw(c); return bmp; } 最后附上代码（内部测试demo，多余功能请忽略） 参考资料：https://www.jianshu.com/p/1877b8c2fc6c]]></content>
      <categories>
        <category>android ui</category>
      </categories>
      <tags>
        <tag>chart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Lock]]></title>
    <url>%2F2019%2F03%2F07%2Fjava-reentrantlock%2F</url>
    <content type="text"><![CDATA[synchronized是java中的一个关键字，也就是说是Java语言内置的特性。那么为什么会出现Lock呢？ 如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁会有三种情况： 1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有2）线程执行发生异常，此时JVM会让线程自动释放锁3）这个主要是在等待唤醒机制里面的wait()方法，在等待的时候立即释放锁，方便其他的线程使用锁。 那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此我们需要不论程序的代码块执行的如何最终都将锁对象进行释放，方便其他线程的执行。 虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，同时为了更好地释放锁。为了更清晰的表达如何加锁和释放锁,JDK5以后提供了一个新的锁对象Lock。另外，通过Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的。 总结一下，也就是说Lock提供了比synchronized更多的功能。但是要注意以下几点： 1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。2）synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，必须要手动释放锁3）在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态4）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；5）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。6）Lock可以提高多个线程进行读操作的效率。 locks包结构java.util.concurrent.locks包为锁和等待条件提供一个框架的接口和类，结构如下图所示： Lock和ReadWriteLock是两大锁根接口，Lock代表实现类是ReentrantLock（可重入锁），ReadWriteLock（读写锁）的代表实现类是ReentrantReadWriteLock。Lock 接口支持那些语义不同（重入、公平等）的锁规则，可以在非阻塞式结构的上下文（包括 hand-over-hand 和锁重排算法）中使用这些规则。主要的实现是 ReentrantLock。ReadWriteLock 接口以类似方式定义了一些读取者可以共享而写入者独占的锁。此包只提供了一个实现，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。 Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 Lock的使用下面我们就来探讨一下java.util.concurrent.locks包中常用的类和接口。通过查看Lock的源码可知，Lock是一个接口： public interface Lock { void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition(); } 由于在前面讲到如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的： Lock lock = ...; lock.lock(); try{ //处理任务 }catch(Exception ex){ }finally{ lock.unlock(); //释放锁 } tryLock()方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。tryLock(long time, TimeUnit unit)方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。 Lock lock = ...; if(lock.tryLock()) { try{ //处理任务 }catch(Exception ex){ }finally{ lock.unlock(); //释放锁 } }else { //如果不能获取锁，则直接做其他事情 } lockInterruptibly()方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。由于lockInterruptibly()的声明中抛出了异常，所以lock.lockInterruptibly()必须放在try块中或者在调用lockInterruptibly()的方法外声明抛出InterruptedException。因此lockInterruptibly()一般的使用形式如下： public void method() throws InterruptedException { lock.lockInterruptibly(); try { //..... }catch (InterruptedException e){ } finally { lock.unlock(); } } 注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。调用interrupt()方法不能中断正在运行过程中的线程，只能中断阻塞过程中的线程。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，只有在进行等待的情况下，是可以响应中断的。而用synchronized修饰的话，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。 ReentrantLockReentrantLock，意思是“可重入锁”。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。 ReentrantLock的类图如下：ReentrantLock的内部类Sync继承了AQS(AQS根本上是通过一个双向队列来实现的;线程构造成一个节点，一个线程先尝试获得锁，如果获取锁失败，就将该线程加到队列尾部)，分为公平锁FairSync和非公平锁NonfairSync。公平锁的获取，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock的公平与否，可以通过它的构造函数来决定。 在获取锁的tryAcquire（）方法中，非公平锁与公平锁唯一不同是多了以下判断hasQueuedPredecessors()。该方法主要是对同步队列中当前节点是否有前驱节点进行判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。方法如下： public final boolean hasQueuedPredecessors() { // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. // 同步队列尾节点 Node t = tail; // Read fields in reverse initialization order // 同步队列头节点 Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); } 事实上，公平锁往往没有非公平锁的效率高，但是，并不是任何场景都是以TPS作为唯一指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越能够得到优先满足。 平锁与非公平锁相比，耗时更多，线程上下文切换次数更多。公平锁保证了锁的获取按照FIFO原则，而代价则是进行大量的线程切换。非公平锁虽然可能导致线程饥饿，但却有极少的线程切换，保证了其更大的吞吐量。 Condition同jdk中的等待/通知机制类似，只不过Condition是用在重入锁这里的。有了Condition，线程就可以在合适的时间等待，在合适的时间继续执行。 Condition接口包含以下方法： // 让当前线程等待，并释放锁 void await() throws InterruptedException; // 和await类似，但在等待过程中不会相应中断 void awaitUninterruptibly(); long awaitNanos(long nanosTimeout) throws InterruptedException; boolean await(long time, TimeUnit unit) throws InterruptedException; boolean awaitUntil(Date deadline) throws InterruptedException; // 唤醒等待中的线程 void signal(); // 唤醒等待中的所有线程 void signalAll(); ReadWriteLockReadWriteLock也是一个接口，在它里面只定义了两个方法： public interface ReadWriteLock { Lock readLock(); Lock writeLock(); } 一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。 ReentrantReadWriteLockReentrantReadWriteLock实现了ReadWriteLock接口。ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。 thread1和thread2可以同时进行读操作，这样就大大提升了读操作的效率。 不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。 锁的相关概念 可重入锁&#160;&#160;&#160;&#160;如果锁具备可重入性，则称作为可重入锁。像synchronized和Lock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。&#160;&#160;&#160;&#160;我们在之前文章已经讲解过，详见： Java Synchronized探究 可中断锁&#160;&#160;&#160;&#160;顾名思义，就是可以相应中断的锁。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。&#160;&#160;&#160;&#160;前面的lockInterruptibly()已经体现了Lock的可中断性。 公平锁&#160;&#160;&#160;&#160;公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。&#160;&#160;&#160;&#160;非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。&#160;&#160;&#160;&#160;在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。&#160;&#160;&#160;&#160;而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。 读写锁&#160;&#160;&#160;&#160;读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。&#160;&#160;&#160;&#160;ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。 参考资料https://www.cnblogs.com/dolphin0520/p/3923167.htmlhttps://blog.csdn.net/chengyuqiang/article/details/79181229https://www.cnblogs.com/fuck1/p/5432806.htmlhttps://blog.csdn.net/qq_38293564/article/details/80515718#t3https://blog.csdn.net/i_am_kop/article/details/80958856]]></content>
      <categories>
        <category>同步</category>
      </categories>
      <tags>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的volatile]]></title>
    <url>%2F2019%2F03%2F04%2Fjava-volatile%2F</url>
    <content type="text"><![CDATA[volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。同synchronized相比（synchronized通常称为重量级锁），volatile更轻量级。 volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识 Java内存模型首先来看看如下代码 public class TestVolatile { boolean status = false; /** * 状态切换为true */ public void changeStatus(){ status = true; } /** * 若状态为true，则running。 */ public void run(){ if(status){ System.out.println(&quot;running....&quot;); } } } 上面这个例子，在多线程环境里，假设线程1执行changeStatus()方法后,线程2运行run()方法，可以保证输出”running…..”吗？答案是NO! 因为对于共享变量status来说，线程A的修改，对于线程B来讲，是”不可见”的。也就是说，线程B此时可能无法观测到status已被修改为true。那么什么是可见性呢？所谓可见性，是指当一条线程修改了共享变量的值，新值对于其他线程来说是可以立即得知的。很显然，上述的例子中是没有办法做到内存可见性的。 java虚拟机有自己的内存模型（Java Memory Model，JMM），JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。 JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。这三者之间的交互关系如下需要注意的是，JMM是个抽象的内存模型，所以所谓的本地内存，主内存都是抽象概念，并不一定就真实的对应cpu缓存和物理内存。当然如果是出于理解的目的，这样对应起来也无不可。 大概了解了JMM的简单定义后，问题就很容易理解了，对于普通的共享变量来讲，比如我们上文中的status，线程1将其修改为true这个动作发生在线程1的本地内存中，此时还未同步到主内存中去；而线程2缓存了status的初始值false，此时可能没有观测到status的值被修改了，所以就导致了上述的问题。那么这种共享变量在多线程模型中的不可见性如何解决呢？比较粗暴的方式自然就是加锁，但是此处使用synchronized或者Lock这些方式太重量级了。比较合理的方式其实就是volatile volatile具备两种特性： 1.保证此变量对所有的线程的可见性。 当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去，这个写会操作会导致其他线程中的缓存无效2.禁止指令重排序优化。 有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置；指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理） 上面的例子只需将status声明为volatile，即可保证在线程A将其修改为true时，线程B可以立刻得知 volatile boolean status = false; 可见性： 通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。 可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。 在Java 中 volatile、synchronized 和 final 实现可见性。 原子性： 原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。再比如y = x;实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。 在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。 有序性： Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。 Volatile原理 Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。 在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。 而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过上图的 CPU cache 这一步。 volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 留意复合类操作需要注意的是，我们一直在拿volatile和synchronized做对比，仅仅是因为这两个关键字在某些内存语义上有共通之处，volatile并不能完全替代synchronized，它依然是个轻量级锁，在很多场景下，volatile并不能胜任。看下这个例子： public class Counter { public static volatile int num = 0; //使用CountDownLatch来等待计算线程执行完 static CountDownLatch countDownLatch = new CountDownLatch(30); public static void main(String []args) throws InterruptedException { //开启30个线程进行累加操作 for(int i=0;i&lt;30;i++){ new Thread(){ public void run(){ for(int j=0;j&lt;10000;j++){ num++;//自加操作 } countDownLatch.countDown(); } }.start(); } //等待计算线程执行完 countDownLatch.await(); System.out.println(num); } } 执行结果： 238921 针对这个示例，一些同学可能会觉得疑惑，如果用volatile修饰的共享变量可以保证可见性，那么结果不应该是300000么? 问题就出在num++这个操作上，因为num++不是个原子性的操作，而是个复合操作。我们可以简单讲这个操作理解为由这三步组成: 1.读取 2.加一 3.赋值 所以，在多线程环境下，有可能线程A将num读取到本地内存中，此时其他线程可能已经将num增大了很多，线程A依然对过期的num进行自加，重新写到主存中，最终导致了num的结果不合预期，而是小于30000。 解决num++操作的原子性问题针对num++这类复合类的操作，可以使用java并发包中的原子操作类原子操作类是通过循环CAS的方式来保证其原子性的。 public class Counter { //使用原子操作类 public static AtomicInteger num = new AtomicInteger(0); //使用CountDownLatch来等待计算线程执行完 static CountDownLatch countDownLatch = new CountDownLatch(30); public static void main(String []args) throws InterruptedException { //开启30个线程进行累加操作 for(int i=0;i&lt;30;i++){ new Thread(){ public void run(){ for(int j=0;j&lt;10000;j++){ num.incrementAndGet();//原子性的num++,通过循环CAS方式 } countDownLatch.countDown(); } }.start(); } //等待计算线程执行完 countDownLatch.await(); System.out.println(num); } } 执行结果: 300000 禁止指令重排序volatile还有一个特性：禁止指令重排序优化。 重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。但是重排序也需要遵守一定规则： 1.重排序操作不会对存在数据依赖关系的操作进行重排序。 比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。 2.重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变 比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。 重排序在单线程模式下是一定会保证最终结果的正确性，但是在多线程环境下，问题就出来了，来开个例子，我们对第一个TestVolatile的例子稍稍改进，再增加个共享变量a public class TestVolatile { int a = 1; boolean status = false; /** * 状态切换为true */ public void changeStatus(){ a = 2;//1 status = true;//2 } /** * 若状态为true，则running。 */ public void run(){ if(status){//3 int b = a+1;//4 System.out.println(b); } } } 假设线程A执行changeStatus后，线程B执行run，我们能保证在4处，b一定等于3么？ 答案依然是无法保证！上面我们提到过，为了提供程序并行度，编译器和处理器可能会对指令进行重排序，而上例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。 使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序 volatile禁止指令重排序也有一些规则，简单列举一下： 1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序 2.当地一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序 3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序 使用volatile关键字的场景ynchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 1）对变量的写操作不依赖于当前值2）该变量没有包含在具有其他变量的不变式中 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 下面代码显示了一个非线程安全的数值范围类。它包含了一个不变式 —— 下界总是小于或等于上界： @NotThreadSafe public class NumberRange { private int lower, upper; public int getLower() { return lower; } public int getUpper() { return upper; } public void setLower(int value) { if (value &gt; upper) throw new IllegalArgumentException(...); lower = value; } public void setUpper(int value) { if (value &lt; lower) throw new IllegalArgumentException(...); upper = value; } } 这种方式限制了范围的状态变量，因此将 lower 和 upper 字段定义为 volatile 类型不能够充分实现类的线程安全；从而仍然需要使用同步。否则，如果凑巧两个线程在同一时间使用不一致的值执行 setLower 和 setUpper 的话，则会使范围处于不一致的状态。例如，如果初始状态是 (0, 5)，同一时间内，线程 A 调用 setLower(4) 并且线程 B 调用 setUpper(3)，显然这两个操作交叉存入的值是不符合条件的，那么两个线程都会通过用于保护不变式的检查，使得最后的范围值是 (4, 3) —— 一个无效值。至于针对范围的其他操作，我们需要使 setLower() 和 setUpper() 操作原子化 —— 而将字段定义为 volatile 类型是无法实现这一目的的。 下面列举几个Java中使用volatile的几个场景。 1.状态标记量 volatile boolean flag = false; while(!flag){ doSomething(); } public void setFlag() { flag = true; } volatile boolean inited = false; //线程1: context = loadContext(); inited = true; //线程2: while(!inited ){ sleep() } doSomethingwithconfig(context); 2.double check class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null) instance = new Singleton(); } } return instance; } } 总结 简单总结下，volatile是一种轻量级的同步机制，它主要有两个特性：一是保证共享变量对所有线程的可见性；二是禁止指令重排序优化。同时需要注意的是，volatile对于单个的共享变量的读/写具有原子性，但是像num++这种复合操作，volatile无法保证其原子性，当然文中也提出了解决方案，就是使用并发包中的原子操作类，通过循环CAS地方式来保证num++操作的原子性。 参考资料https://www.cnblogs.com/zhengbin/p/5654805.htmlhttps://www.cnblogs.com/chengxiao/p/6528109.htmlhttps://www.cnblogs.com/dolphin0520/p/3920373.html不变式举例]]></content>
      <categories>
        <category>同步</category>
      </categories>
      <tags>
        <tag>volatile</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Synchronized探究]]></title>
    <url>%2F2019%2F03%2F01%2FJava-Synchronized%2F</url>
    <content type="text"><![CDATA[在java中，每一个对象都有一把内置锁，当程序中的某一块代码被同步块包起来的时候（synchronized(this){…}），相当于电脑用this指向的对象的内置锁把这块代码锁起来了，只有拥有能解开着这把锁钥匙的线程才能进入到同步块，其他的线程只能在同步块外面排队，只有等拥有钥匙的人执行完同步块归还钥匙的时候，电脑在把钥匙随机分配给外面等待的一个线程。 根据锁的对象不同可以分为两种：对象锁和类锁，对象锁指的是java中的实例对象，类锁指的是Class对象（说到底，不管是对象锁还是类锁，其实锁的都是对象，只是类锁锁的对象是全局唯一的；类锁如static函数和class literals）。但归根结底还是一个对象对应一把内置锁。 需要明确的几个问题： synchronized关键字可以作为函数的修饰符，也可作为函数内的语句，也就是平时说的同步方法和同步语句块。如果 再细的分类，synchronized可作用于instance变量、object reference（对象引用）、static函数和class literals(类名称字面常量)身上。 无论synchronized关键字加在方法上还是对象上，它取得的锁都是对象，而不是把一段代码或函数当作锁――而且同步方法很可能还会被其他线程的对象访问。 每个对象只有一个锁（lock）与之相关联。被synchronized修饰的方法被锁的对象不同，则实际运行中线程之间互不干扰。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制 synchronized在修饰方法的时候如果没有使用“（）”指明被锁的对象，默认是调用这个方法的对象 synchronized 代码块若将一个大的方法声明为synchronized 将会大大影响效率，典型地，若将线程类的方法 run() 声明为 synchronized ，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何 synchronized 方法的调用都永远不会成功。Java 为我们提供了更好的解决办法，那就是 synchronized 块。除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象。这时锁就是对象，谁拿到这个锁谁就可以运行它所控制的那段代码。当有一个明确的对象作为锁时，就可以这样写程序，但当没有明确的对象作为锁，只是想让一段代码同步时，可以创建一个特殊的instance变量（它得是一个对象）来充当锁： class Foo implements Runnable { private byte[] lock = new byte[0]; // 特殊的instance变量 Public void methodA() { synchronized(lock) { //… } } //….. } 注：零长度的byte数组对象创建起来将比任何对象都经济――查看编译后的字节码：生成零长度的byte[]对象只需3条操作码，而Object lock = new Object()则需要7行操作码。 synchronized 静态方法将synchronized作用于static 函数，示例代码如下： Class Foo { // 同步的static 函数 public synchronized static void methodAAA() { //…. } public void methodBBB() { synchronized(Foo.class) // class literal(类名称字面常量) } } 代码中的methodBBB()方法是把class literal作为锁的情况，它和同步的static函数产生的效果是一样的，取得的锁很特别，是当前调用这个方法的对象所属的类（Class，而不再是由这个Class产生的某个具体对象了）。 synchronized底层原理Java 虚拟机中的同步(Synchronization)基于进入和退出Monitor对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。同步方法是由方法调用指令读取运行时常量池中方法表结构的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。 同步代码块：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁； 在JVM中，对象在内存中的布局分为三块区域：对象头、实例变量和填充数据。如下：实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。 填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。 对象头：Hotspot虚拟机的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。 Mark Word：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit），但是如果对象是数组类型，则需要三个机器码，因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。 Monitor：我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。Nest:用来实现重入锁的计数。HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。 Java虚拟机对synchronize的优化：锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段。 偏向锁偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。 轻量级锁倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。 自旋锁轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。 锁消除消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。 锁膨胀如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。 如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（膨胀）到整个操作序列的外部（由多次加锁编程只加锁一次）。 /** * 消除StringBuffer同步锁 * / public class StringBufferRemoveSync { public void add(String str1, String str2) { //StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用 //因此sb属于不可能共享的资源,JVM会自动消除内部的锁 StringBuffer sb = new StringBuffer(); sb.append(str1).append(str2); } public static void main(String[] args) { StringBufferRemoveSync rmsync = new StringBufferRemoveSync(); for (int i = 0; i &lt; 10000000; i++) { rmsync.add(&quot;abc&quot;, &quot;123&quot;); } } } synchronize的可重入性：从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。如下： public class AccountingSync implements Runnable{ static AccountingSync instance=new AccountingSync(); static int i=0; static int j=0; @Override public void run() { for(int j=0;j&lt;1000000;j++){ //this,当前实例对象锁 synchronized(this){ i++; increase();//synchronized的可重入性 } } } public synchronized void increase(){ j++; } public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); } } 正如代码所演示的，在获取当前实例对象锁后进入synchronized代码块执行同步代码，并在代码块中调用了当前实例对象的另外一个synchronized方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现，需要特别注意另外一种情况，当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1。 线程中断：正如中断二字所表达的意义，在线程运行(run方法)中间打断它，在Java中，提供了以下3个有关线程中断的方法 //中断线程（实例方法） public void Thread.interrupt(); //判断线程是否被中断（实例方法） public boolean Thread.isInterrupted(); //判断是否被中断并清除当前中断状态（静态方法） public static boolean Thread.interrupted(); 等待唤醒机制与synchronize：所谓等待唤醒机制本篇主要指的是notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。 多线程下数据同步这类锁/关键字主要是为了维护数据在高并发情况下的一致性/稳定性。 数据库中的锁共享锁(Share Lock) 又称为读锁 多个线程可并发的获得某个数据的共享锁锁，并行读取数据。在数据存在共享锁期间，不能修改数据，不能加排他锁。如MySQL中，在查询语句最后加上LOCK IN SHARE MODE。 排他锁(eXclusive Lock) 又称为写锁 同能只能有一个线程可以获得某个数据的排他锁。在线程获取排他锁后，该线程可对数据读写，但是其他线程不能对该数据添加任何锁。 volatile 如果一个共享变量被声明成volatile，java线程内存模型将会确保所有线程看到这个变量的值是一致的。 基本策略: 写操作时，会有Lock前缀指定，处理器会立马将修改直接写回系统内存，并且其他处理器会将该值在其上的高速缓存标为无效。可能带来的性能消耗: 写操作实时写回内存，锁总线/锁内存。优势: 一些场景上相比synchronized，执行成本更低(不会引起线程上下文切换以及调度)，使用更方便。 关于volatile的详细理解，可以参考我的这篇文章： Java中的volatile locksynchronized存在问题：如果获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此我们需要不论程序的代码块执行的如何最终都将锁对象进行释放，方便其他线程的执行。 Lock提供了比synchronized更多的功能，但并非内置特性。详见：Java Lock 参考资料https://www.jianshu.com/p/ea9a482ece5fhttps://www.cnblogs.com/mingyao123/p/7424911.htmlhttps://blog.dreamtobe.cn/2015/11/13/java_synchronized/]]></content>
      <categories>
        <category>同步</category>
      </categories>
      <tags>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OKHttp深入理解]]></title>
    <url>%2F2019%2F02%2F27%2FOKHttp%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[OKHttp请求流程OKHttp的请求流程图如下所示： 如下为使用OKHttp进行Get请求的步骤： //1.新建OKHttpClient客户端 OkHttpClient client = new OkHttpClient(); //新建一个Request对象 Request request = new Request.Builder() .url(url) .build(); //2.Response为OKHttp中的响应 Response response = client.newCall(request).execute(); 首先，我们会在请求的时候初始化一个Call的实例，然后根据同步和异步的不同，分别调用它的 execute() 和 enqueue() 方法，但是它们进行网络访问的逻辑都是一样的，内部最后都会执行到getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器以及访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。 分发器Dispatcher使用 OkHttp 的时候，我们会创建一个 RealCall 并将其加入到双端队列中。但是请注意这里的双端队列的名称是 runningSyncCalls，也就是说这种请求是同步请求，会在当前的线程中立即被执行。所以，下面的 getResponseWithInterceptorChain() 就是这个同步的执行过程。而当我们执行完毕的时候，又会调用 Dispatcher 的 finished(RealCall) 方法把该请求从队列中移除。所以，这种同步的请求无法体现分发器的“分发”功能。 除了同步的请求，还有异步类型的请求：当我们拿到了 RealCall 的时候，调用它的 enqueue(Callback responseCallback) 方法并设置一个回调即可。该方法会执行下面这行代码： client.dispatcher().enqueue(new AsyncCall(responseCallback)); 当我们调用了 Dispatcher 的 enqueue(AsyncCall) 方法的时候也会将 AsyncCall 加入到一个队列中，并会在请求执行完毕的时候从该队列中移除，只是这里的队列是 runningAsyncCalls 或者 readyAsyncCalls。它们都是一个双端队列，并用来存储异步类型的请求。它们的区别是，runningAsyncCalls 是正在执行的队列，当正在执行的队列达到了限制的时候，就会将其放置到就绪队列 readyAsyncCalls 中： synchronized void enqueue(AsyncCall call) { if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) { runningAsyncCalls.add(call); executorService().execute(call); } else { readyAsyncCalls.add(call); } } 当把该请求加入到了正在执行的队列之后，我们会立即使用一个线程池来执行该 AsyncCall。这样这个请求的责任链就会在一个线程池当中被异步地执行了。这里的线程池由 executorService() 方法返回： public synchronized ExecutorService executorService() { if (executorService == null) { executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp Dispatcher&quot;, false)); } return executorService; } 显然，当线程池不存在的时候会去创建一个线程池。除了上面的这种方式，我们还可以在构建 OkHttpClient 的时候，自定义一个 Dispacher，并在其构造方法中为其指定一个线程池。 拦截器 在配置 OkHttpClient时设置的interceptors；[eg. 最常用的:日志拦截器] 负责失败重试以及重定向的 RetryAndFollowUpInterceptor；会根据服务器返回的信息判断这个请求是否可以重定向，或者是否有必要进行重试 桥拦截器 BridgeInterceptor 用于从用户的请求中构建网络请求，然后使用该请求访问网络，最后从网络响应当中构建用户响应。[简单的说: 只是用来对请求进行包装，并将服务器响应转换成用户友好的响应] 负责读取缓存直接返回、更新缓存的 CacheInterceptor 负责和服务器建立连接的ConnectInterceptor；这里并没有真正地从网络中获取数据，而仅仅是打开一个连接。在获取连接对象的时候，使用了连接池 ConnectionPool 来复用连接。 public final class ConnectInterceptor implements Interceptor { @Override public Response intercept(Chain chain) throws IOException { RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;); HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); } } 这里的HttpCodec 用来编码请求并解码响应，RealConnection 用来向服务器发起连接。它们会在下一个拦截器中被用来从服务器中获取响应信息。 StreamAllocation相当于一个管理类，维护了服务器连接、并发流和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象。当我们调用 streamAllocation 的 newStream() 方法的时候，最终会经过一系列的判断到达 StreamAllocation 中的 findConnection() 方法。该方法会被放置在一个循环当中被不停地调用以得到一个可用的连接。它优先使用当前已经存在的连接，不然就使用连接池中存在的连接，再不行的话，就创建一个新的连接。我们使用连接复用的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。 配置 OkHttpClient 时设置的 networkInterceptors；[for web socket,自行了解] 服务器请求拦截器 CallServerInterceptor 用来向服务器发起请求并获取数据。 位置决定了功能，最后一个 Interceptor 一定是负责和服务器实际通讯的，重定向、缓存等一定是在实际通讯之前的 源码如下： Response getResponseWithInterceptorChain() throws IOException { // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) { interceptors.addAll(client.networkInterceptors()); } interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0, originalRequest, this, eventListener, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); return chain.proceed(originalRequest); } 这里，我们创建了一个列表对象之后把 client 中的拦截器、重连拦截器、桥拦截器、缓存拦截器、网络连接拦截器和服务器请求拦截器等依次加入到列表中。然后，我们用这个列表创建了一个拦截器链。这里使用了责任链设计模式，每当一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。当我们自定义一个拦截器的时候，也会被加入到这个拦截器链条里。 连接管理：ConnectionPool与请求的缓存类似，OkHttp 的连接池也使用一个双端队列来缓存已经创建的连接： private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); OkHttp 的缓存管理分成两个步骤，一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理。在 ConnectionPool 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 add() 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。 在 ConnectionPool 中存在一个静态的线程池： private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp ConnectionPool&quot;, true)); 每当我们向连接池中插入一个连接的时候就会调用下面的方法，将连接插入到双端队列的同时，会调用上面的线程池来执行清理缓存的任务： void put(RealConnection connection) { assert (Thread.holdsLock(this)); if (!cleanupRunning) { cleanupRunning = true; // 使用线程池执行清理任务 executor.execute(cleanupRunnable); } // 将新建的连接插入到双端队列中 connections.add(connection); } 这里的清理任务是 cleanupRunnable，是一个 Runnable 类型的实例。它会在方法内部调用 cleanup() 方法来清理无效的连接。 在从缓存的连接中取出连接来判断是否应该将其释放的时候使用到了两个变量 maxIdleConnections 和 keepAliveDurationNs，分别表示最大允许的闲置的连接的数量和连接允许存活的最长的时间。默认空闲连接最大数目为5个，keepalive 时间最长为5分钟。该方法会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。 Responsebytes()大小有限制，建议用byteStream()。源码如下： public final byte[] bytes() throws IOException { long contentLength = contentLength(); if (contentLength &gt; Integer.MAX_VALUE) { throw new IOException(&quot;Cannot buffer entire body for content length: &quot; + contentLength); } ... } public final InputStream byteStream() { return source().inputStream(); } 缓存使用okhttp的cache，首先需指定缓存路径和大小 private OkHttpClient initClient() { File cacheFile = new File(config.getCacheFilePath()); if (!cacheFile.exists()) { cacheFile.mkdir(); } //缓存大小为30M int cacheSize = 30 * 1024 * 1024; //创建缓存对象 Cache cache = new Cache(getContext(), cacheFile, cacheSize); OkHttpClient.Builder builder = new OkHttpClient.Builder(); builder.addInterceptor(new SercurityKeyInteraptor()) .addInterceptor(new HttpLoggingInterceptor()) .connectTimeout(config.getConnectTimeout(), TimeUnit.SECONDS) .writeTimeout(config.getWriteTimeout(), TimeUnit.SECONDS) .readTimeout(config.getReadTimeout(), TimeUnit.SECONDS) .cache(cache) .cookieJar(new FundCookie()); return mOkHttpClient = builder.build(); } 其次在构造Request时配置缓存策略 CacheControl cc = new CacheControl.Builder() //不使用缓存，但是会保存缓存数据 //.noCache() //不使用缓存，同时也不保存缓存数据 // .noStore() //只使用缓存，（如果我们要加载的数据本身就是本地数据时，可以使用这个，不过目前尚未发现使用场景） //.onlyIfCached() //手机可以接收响应时间小于当前时间加上10s的响应 // .minFresh(10,TimeUnit.SECONDS) //手机可以接收有效期不大于10s的响应 // .maxAge(10,TimeUnit.SECONDS) //手机可以接收超出5s的响应 .maxStale(5,TimeUnit.SECONDS) .build(); Request request = new Request.Builder() .cacheControl(cc) .url(&quot;http://192.168.152.2:8080/cache&quot;).build(); 如果直接使用CacheControl中的常量，则不用调用上面那么多的方法，使用方式如下： Request request = new Request.Builder() //强制使用网络 // .cacheControl(CacheControl.FORCE_NETWORK) //强制使用缓存 .cacheControl(CacheControl.FORCE_CACHE) .url(&quot;http://192.168.152.2:8080/cache&quot;).build(); OkHttp的Cache是根据URL以及请求参数来生成的，并且不支持POST请求。 CacheInterceptor拦截器实现读写操作,读写操作都是通过okio实现,快速,高效流 读: 根据缓存策略实现读取缓存,返回Response,Okhttp中实现的是轻量级 LruCache缓存模式[最近最少使用原则]。然后关于DiskLruCache是如何管理缓存文件的，这个其实也很好理解，首先的原则就是按照LRU这种最近最少使用删除的原则，当总的大小超过限定大小后，删除最近最少使用的缓存文件，它的LRU算法是使用LinkedHashMap进行维护的，这样来保证，保留的缓存文件都是更常使用的。 写: 根据缓存策略,将服务端返回的数据写入磁盘 Okhttp缓存相关的类有如下： CacheControl（HTTP中的Cache-Control和Pragma缓存控制） CacheControl是用于描述HTTP的Cache-Control和Pragma字段的类，用于指定缓存的规则。 CacheStrategy（缓存策略类） CacheStrategy是用于判定使用缓存数据还是网络请求的决策类。 Cache（缓存类） 对外开放的缓存类，提供了缓存的增删改查接口。 InternalCache（内部缓存类） 对内使用的缓存类接口，没有具体实现，只是封装了Cache的使用。 DiskLruCache（文件化的LRU缓存类） 这是真正实现缓存功能的类，将数据存储在文件中，并使用LRU规则（由LinkedHashMap实现），控制对缓存文件的增删改查。 Cookies3.0之后OKHttp是加了CookieJar和Cookie两个类的，通过实现CookieJar即可管理cookie。加载Cookie时,IP地址与域名是有区别的。如果访问的是IP地址,Cookie是不会从publicsuffixes.gz文件中读取Cookie数据。publicsuffixes.gz 就是一个类似apk一样的压缩文件,可以解压通过Txt查看里面的内容。官文提供的原始文件内容: https://publicsuffix.org private class FundCookie implements CookieJar { private final ConcurrentHashMap&lt;String, List&lt;Cookie&gt;&gt; cookieStore = new ConcurrentHashMap&lt;&gt;(); @Override public void saveFromResponse(HttpUrl url, List&lt;Cookie&gt; cookies) { /* * Cookie name 不能重复:需要人为管控 */ cookieStore.put(url.host(), cookies); } @Override public List&lt;Cookie&gt; loadForRequest(HttpUrl url) { /* * 不能用url.host来获取Cookie值,因为在请求过程中可能存在 301 重定向问题,导致重定向的url无法获取Cookie值, * 但它与其它接口属于同一个 domain * 解决办法:将本地所有的Cookie都上传给接口,后台解析会去匹配 KEY-VALUE[SESSION name- Cookie value] * 所以必要保证 不同的domain对应的SESSION name 不能重复 */ List&lt;Cookie&gt; curCookies = new ArrayList&lt;&gt;(); for (List&lt;Cookie&gt; entry : cookieStore.values()) { curCookies.addAll(entry); } return curCookies; } } HTTPSOkhttp默认是支持https网络请求的，但是支持的Https网站必须是CA机构认证了的，对于自签名的网址，还是不能访问的，访问直接抛出如下异常信息： onFailure: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found. 针对https的处理，目前主要有两种方式： 客户端默认信任全部证书对自签名网址进行证书的单独处理 具体可以参看我的这篇文章：android中使用https Gzip http request header中声明Accept-Encoding: gzip，告知服务器客户端接受gzip的数据。 服务器支持的情况下，返回gzip后的response body，同时加入以下header： Content-Encoding: gzip：表明body是gzip过的数据 Content-Length:117：表示body gzip压缩后的数据大小，便于客户端使用。 或 Transfer-Encoding: chunked：分块传输编码 Okhttp 如果header中没有Accept-Encoding，默认自动添加 ，且标记变量transparentGzip为true。 针对返回结果，如果同时满足以下三个条件： transparentGzip为true，即之前自动添加了Accept-Encoding header中标明了Content-Encoding为gzip 有body 移除 Content-Encoding、Content-Length，并对结果进行解压缩。 开发者没有添加Accept-Encoding时，自动添加Accept-Encoding: gzip 自动添加的request，response支持自动解压 手动添加不负责解压缩 自动解压时移除Content-Length，所以上层Java代码想要contentLength时为-1 自动解压时移除 Content-Encoding 自动解压时，如果是分块传输编码，Transfer-Encoding: chunked不受影响。 HttpUrlConnection: 4.4版本之后与okhttp相仿 参考资料https://juejin.im/post/5bc89fbc5188255c713cb8a5#heading-10让 okhttp 支持 post缓存https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>OKHttp</tag>
        <tag>Gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android多线程]]></title>
    <url>%2F2019%2F02%2F27%2Fandroid%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言在Android开发中经常会使用到多线程，这里主要是总结Android开发中常见的多线程实现方式，以及这些多线程实现方式的一些特点多线程实现方式主要有： 实现Thread的run()方法或者实现Runable接口 HandlerThread AsyncTask LoaderManager Thread直接使用Thread实现方式，这种方式简单，但不是很优雅。适合数量很少（偶尔一两次）的异步任务，但要处理的异步任务很多的话，使用该方式会导致创建大量的线程，这会影响用户交互。 关键字join、sleep、yield join() method suspends the execution of the calling thread until the object called finishes its execution. 也就是说，t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。 join()方法是让出执行资源（如：CPU时间片），使得其它线程可以获得执行的资源。所以调用join()方法会使进入阻塞状态，该线程被唤醒后会进入runable状态，等待下一个时间片的到来才能再次执行。 sleep()不会让出资源，只是处于睡眠状态（类似只执行空操作）。调用sleep()方法会使进入等待状态，当等待时间到后，如果还在时间片内，则直接进入运行状态，否则进入runable状态，等待下个时间片。 Yield()方法是停止当前线程，让同等优先权的线程运行。如果没有同等优先权的线程，那么Yield()方法将不会起作用。 suspend()可能导致死锁，因此弃用 HandlerThreadHandlerThread，这种方式适合子线程有序的执行异步操作，异步任务的执行一个接着一个。 HandlerThread的内部实现机制很简单，在创建新的线程后，使该线程成为一个Looper线程，让该线程不断的从MessageQueue取出消息并处理。 就应用程序而言，Android系统中JAVA的应用程序和其他系统上相同，都是靠消息驱动来工作的，他们大致的工作原理如下： 1、有一个消息队列，可以往这个消息队列中投递消息。 2、有一个消息循环，不断从消息队列中取出消息，然后处理。 在Android中，一个线程对应一个Looper对象，而一个Looper对象又对应一个MessageQueue（用于存放message）。 循环者Looper类，消息处理类Handler，消息类Message。 Looper对象用来为一个线程开启一个消息循环，用来操作MessgeQueue。默认情况下，Android中新创建的线程是没有开启消息循环的。（主线程除外） 消息处理类（Handler）允许发送和处理Message和Rannable对象到其所在线程的MessageQueue中。（它主要有两个作用：1、将Message或Runnable应用post()方法或sendMessage()方法发送到MessageQueue中，在发送时可以指定延时时间、发送时间或者要携带的bundle数据。当MessageQueue循环到该Message时，调用相应的Handler对象的handlerMessage()方法对其进行处理。2、在子线程中与主线程进行通信，也就是在工作线程中与UI线程进行通信。） 另外，在一个线程中只能有一个Looper和MessageQueue，但是可以有多个Handler,而且这些Handler可以共享一个Looper和MessageQueue。 消息类(Message)被存放在MessageQueue中，一个MessageQueue中可以包含多个Message对象。每个Message对象可以通过Messhe.obtain()方法或者Handler.obtainMessage()方法获得。Message是一个final类，所以不可被继承。 AsyncTaskAsyncTask的内部使用了两个线程池，使用AsyncTask执行异步操作时，会先在SerialExecutor进行一个顺序排队， 后再用ThreadPoolExcutor线程池为你分配一个线程并执行。而整个应用的AsyncTask任务都在排同一条队，有可能等待排队的任务很多，所以一般不会使用AsyncTask执行一些优先级比较高的异步任务。 当然我们是可以跳过不需要进行排队，直接就通过线程池分配一个线程并执行异步任务，但需要注意同时执行太多的异步任务，会影响用户体验，我想Google就是为了限制同时创建太多的线程才会采用一个排队机制的 /** @hide */ public static void setDefaultExecutor(Executor exec) { sDefaultExecutor = exec; } 该方法是隐藏，但可使用反射，设置一个线程池。 AsyncTask， 通常用于耗时的异步处理，且时效性要求不是非常高的那种异步操作。如果时效性要求非常高的操作，不建议使用这个方式，因为AsyncTask的默认实现是有内部排队机制，且是整个应用的AsyncTask的任务进行排队，所以不能保证异步任务能很快的被执行。 LoaderManagerLoaderManager，当请求处理时机需要根据Activity的生命周期进行调整，或需要时刻监测数据的变化，那LoaderManager是很不错的解决方案。 LoaderManager可以解决的问题包括： 1.加载的数据有变化时，会自动通知我们，而不自己监控数据的变化情况，如：用CursorLoader来加载数据库数据，当数据库数据有变化时，可是个展示变化的数据 2.数据的请求处理时机会结合Activity和Fragment的生命周期进行调整，如：若Acivity销毁了，那就不会再去请求新的数据 1.LoaderManager LoaderManager用来负责管理与Activity或者Fragment联系起来的一个或多个Loaders对象. 每个Activity或者Fragment都有唯一的一个LoaderManager实例(通过getLoaderManager()方法获得),用来启动,停止,保持,重启,关闭它的Loaders,这些功能可通过调用initLoader()/restartLoader()/destroyLoader()方法来实现. LoaderManager并不知道数据如何装载以及何时需要装载.相反,它只需要控制它的Loaders们开始,停止,重置他们的Load行为,在配置变换或数据变化时保持loaders们的状态,并使用接口来返回load的结果. 2.Loader Loades负责在一个单独线程中执行查询,监控数据源改变,当探测到改变时将查询到的结果集发送到注册的监听器上.Loader是一个强大的工具,具有如下特点 (1)它封装了实际的数据载入. Activity或Fragment不再需要知道如何载入数据.它们将该任务委托给了Loader,Loader在后台执行查询要求并且将结果返回给Activity或Fragment. (2)客户端不需要知道查询如何执行.Activity或Fragment不需要担心查询如何在独立的线程中执行,Loder会自动执行这些查询操作. (3)它是一种安全的事件驱动方式. Loader检测底层数据,当检测到改变时,自动执行并载入最新数据. 这使得使用Loader变得容易,客户端可以相信Loader将会自己自动更新它的数据. Activity或Fragment所需要做的就是初始化Loader,并且对任何反馈回来的数据进行响应.除此之外,所有其他的事情都由Loader来解决. Loader：该类用于数据的加载 ，类型参数D用于指定Loader加载的数据类型 public class Loader&lt;D&gt; { } 一般我们不直接继承Loader，而是继承AsyncTaskLoader，因为Loader的加载工作并不是在异步线程中。而AsyncTaskLoader实现了异步线程，加载流程在子线程中执行。注意：对该类的调用应该在主线程中完成。 Loader负责数据加载逻辑，LoaderManager负责Loader的调度，开发者只需要自定义自己的Loader，实现数据的加载逻辑，而不再关注数据加载时由于Activity销毁引发的问题。 注意：其实AsyncTaskLoader内部实现异步的方式是使用AsyncTask完成的，上面我们说过AsyncTask的内部是有一个排队机制，但AsyncTaskLoader内部使用AsyncTask进行数据异步加载时，异步任务并不进行排队。而直接由线程池分配新线程来执行。 参考资料https://blog.csdn.net/baidu_36385172/article/details/79705915https://www.cnblogs.com/diysoul/p/5124886.html]]></content>
      <categories>
        <category>android知识点</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github博客搭建]]></title>
    <url>%2F2019%2F02%2F20%2Fgithub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[基本命令hexo clean #/清除静态页面缓存（清除 public 文件夹) hexo g #生成或 hexo generate hexo s #启动本地服务器 或者hexo server,这一步之后就可以通过localhost:4000查看了 hexo d #部署到github hexo clean &amp; hexo g &amp; hexo s #一键启动 hexo new page xxx #创建页面命令 文件目录 post source/_post 新建一个文章 draft source/_drafts 新建一个草稿文件 page source 新建一个页面文件 hexo添加分类和标签:--- title: title #文章標題 date: 2016-06-01 23:47:44 #文章生成時間 categories: &quot;Hexo教程&quot; #文章分類目錄 可以省略 tags: #文章標籤 可以省略 - 标签1 - 标签2 description: #你對本頁的描述 可以省略 --- hexo目录结构 markdown编辑器说明：在Hexo中插入图片时，请按照以下步骤进行设置 （1）将站点配置文件中的 post_asset_folde 选项设置成 true （2）在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件 （3）此时使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将待添加的图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加了图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片]（title/example.PNG “示例图片”） 添加图片 使用 Hexo Admin 插件（难用）Hexo Admin 是一个本地在线式文章管理器，可以用直观可视化的方式新建、编辑博客文章、page页面，添加标签、分类等，并且支持剪贴板粘贴图片（自动在source_images_目录中创建文件） 在Hexo网站目录下，安装 Hexo Admin 插件 npm install –save hexo-admin 启动本地服务器并打开管理界面，即可使用 hexo server -d open localhost:4000/admin/ 参考资料：https://www.cnblogs.com/jackyroc/p/7681938.html https://www.cnblogs.com/fengxiongZz/p/7707219.html https://blog.csdn.net/wsmrzx/article/details/81478945 https://www.jianshu.com/p/df46bca5889d]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
