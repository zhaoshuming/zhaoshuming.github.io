<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[android多线程]]></title>
    <url>%2F2019%2F02%2F27%2Fandroid%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Thread直接使用Thread实现方式，这种方式简单，但不是很优雅。适合数量很少（偶尔一两次）的异步任务，但要处理的异步任务很多的话，使用该方式会导致创建大量的线程，这会影响用户交互。 1.joinjoin() method suspends the execution of the calling thread until the object called finishes its execution.也就是说，t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续；通常用于在main()主线程内，等待其它线程完成再结束main()主线程。 join()方法是让出执行资源（如：CPU时间片），使得其它线程可以获得执行的资源。所以调用join()方法会使进入阻塞状态，该线程被唤醒后会进入runable状态，等待下一个时间片的到来才能再次执行。 sleep()不会让出资源，只是处于睡眠状态（类似只执行空操作）。调用sleep()方法会使进入等待状态，当等待时间到后，如果还在时间片内，则直接进入运行状态，否则进入runable状态，等待下个时间片。 HandlerThreadHandlerThread，这种方式适合子线程有序的执行异步操作，异步任务的执行一个接着一个。 HandlerThread的内部实现机制很简单，在创建新的线程后，使该线程成为一个Looper线程，让该线程不断的从MessageQueue取出消息并处理。 就应用程序而言，Android系统中JAVA的应用程序和其他系统上相同，都是靠消息驱动来工作的，他们大致的工作原理如下： 1、有一个消息队列，可以往这个消息队列中投递消息。 2、有一个消息循环，不断从消息队列中取出消息，然后处理。 在Android中，一个线程对应一个Looper对象，而一个Looper对象又对应一个MessageQueue（用于存放message）。 循环者Looper类，消息处理类Handler，消息类Message。 Looper对象用来为一个线程开启一个消息循环，用来操作MessgeQueue。默认情况下，Android中新创建的线程是没有开启消息循环的。（主线程除外） 消息处理类（Handler）允许发送和处理Message和Rannable对象到其所在线程的MessageQueue中。（它主要有两个作用：1、将Message或Runnable应用post()方法或sendMessage()方法发送到MessageQueue中，在发送时可以指定延时时间、发送时间或者要携带的bundle数据。当MessageQueue循环到该Message时，调用相应的Handler对象的handlerMessage()方法对其进行处理。2、在子线程中与主线程进行通信，也就是在工作线程中与UI线程进行通信。） 另外，在一个线程中只能有一个Looper和MessageQueue，但是可以有多个Handler,而且这些Handler可以共享一个Looper和MessageQueue。 消息类(Message)被存放在MessageQueue中，一个MessageQueue中可以包含多个Message对象。每个Message对象可以通过Messhe.obtain()方法或者Handler.obtainMessage()方法获得。Message是一个final类，所以不可被继承。 AsyncTaskAsyncTask的内部使用了两个线程池，使用AsyncTask执行异步操作时，会先在SerialExecutor进行一个顺序排队， 后再用ThreadPoolExcutor线程池为你分配一个线程并执行。而整个应用的AsyncTask任务都在排同一条队，有可能等待排队的任务很多，所以一般不会使用AsyncTask执行一些优先级比较高的异步任务。 当然我们是可以跳过不需要进行排队，直接就通过线程池分配一个线程并执行异步任务，但需要注意同时执行太多的异步任务，会影响用户体验，我想Google就是为了限制同时创建太多的线程才会采用一个排队机制的 /** @hide */ public static void setDefaultExecutor(Executor exec) { sDefaultExecutor = exec; } 该方法是隐藏，但可使用反射，设置一个线程池。 AsyncTask， 通常用于耗时的异步处理，且时效性要求不是非常高的那种异步操作。如果时效性要求非常高的操作，不建议使用这个方式，因为AsyncTask的默认实现是有内部排队机制，且是整个应用的AsyncTask的任务进行排队，所以不能保证异步任务能很快的被执行。 LoaderManagerLoaderManager，当请求处理时机需要根据Activity的生命周期进行调整，或需要时刻监测数据的变化，那LoaderManager是很不错的解决方案。 LoaderManager可以解决的问题包括： 1.加载的数据有变化时，会自动通知我们，而不自己监控数据的变化情况，如：用CursorLoader来加载数据库数据，当数据库数据有变化时，可是个展示变化的数据 2.数据的请求处理时机会结合Activity和Fragment的生命周期进行调整，如：若Acivity销毁了，那就不会再去请求新的数据 1.LoaderManager LoaderManager用来负责管理与Activity或者Fragment联系起来的一个或多个Loaders对象. 每个Activity或者Fragment都有唯一的一个LoaderManager实例(通过getLoaderManager()方法获得),用来启动,停止,保持,重启,关闭它的Loaders,这些功能可通过调用initLoader()/restartLoader()/destroyLoader()方法来实现. LoaderManager并不知道数据如何装载以及何时需要装载.相反,它只需要控制它的Loaders们开始,停止,重置他们的Load行为,在配置变换或数据变化时保持loaders们的状态,并使用接口来返回load的结果. 2.Loader Loades负责在一个单独线程中执行查询,监控数据源改变,当探测到改变时将查询到的结果集发送到注册的监听器上.Loader是一个强大的工具,具有如下特点 (1)它封装了实际的数据载入. Activity或Fragment不再需要知道如何载入数据.它们将该任务委托给了Loader,Loader在后台执行查询要求并且将结果返回给Activity或Fragment. (2)客户端不需要知道查询如何执行.Activity或Fragment不需要担心查询如何在独立的线程中执行,Loder会自动执行这些查询操作. (3)它是一种安全的事件驱动方式. Loader检测底层数据,当检测到改变时,自动执行并载入最新数据. 这使得使用Loader变得容易,客户端可以相信Loader将会自己自动更新它的数据. Activity或Fragment所需要做的就是初始化Loader,并且对任何反馈回来的数据进行响应.除此之外,所有其他的事情都由Loader来解决. Loader：该类用于数据的加载 ，类型参数D用于指定Loader加载的数据类型 public class Loader&lt;D&gt; { } 一般我们不直接继承Loader，而是继承AsyncTaskLoader，因为Loader的加载工作并不是在异步线程中。而AsyncTaskLoader实现了异步线程，加载流程在子线程中执行。注意：对该类的调用应该在主线程中完成。 Loader负责数据加载逻辑，LoaderManager负责Loader的调度，开发者只需要自定义自己的Loader，实现数据的加载逻辑，而不再关注数据加载时由于Activity销毁引发的问题。 注意：其实AsyncTaskLoader内部实现异步的方式是使用AsyncTask完成的，上面我们说过AsyncTask的内部是有一个排队机制，但AsyncTaskLoader内部使用AsyncTask进行数据异步加载时，异步任务并不进行排队。而直接由线程池分配新线程来执行。 参考资料https://blog.csdn.net/baidu_36385172/article/details/79705915https://www.cnblogs.com/diysoul/p/5124886.html]]></content>
      <categories>
        <category>android知识点</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github博客搭建]]></title>
    <url>%2F2019%2F02%2F20%2Fgithub%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[基本命令hexo clean #/清除静态页面缓存（清除 public 文件夹) hexo g #生成或 hexo generate hexo s #启动本地服务器 或者hexo server,这一步之后就可以通过http://localhost:4000查看了 hexo d #部署到github hexo clean &amp; hexo g &amp; hexo s #一键启动 hexo new page xxx #创建页面命令 文件目录 post source/_post 新建一个文章 draft source/_drafts 新建一个草稿文件 page source 新建一个页面文件 hexo添加分类和标签:--- title: title #文章標題 date: 2016-06-01 23:47:44 #文章生成時間 categories: &quot;Hexo教程&quot; #文章分類目錄 可以省略 tags: #文章標籤 可以省略 - 标签1 - 标签2 description: #你對本頁的描述 可以省略 --- hexo目录结构 markdown编辑器说明：在Hexo中插入图片时，请按照以下步骤进行设置 （1）将站点配置文件中的 post_asset_folde 选项设置成 true （2）在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件 （3）此时使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将待添加的图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加了图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片]（title/example.PNG “示例图片”） 添加图片 使用 Hexo Admin 插件（难用）Hexo Admin 是一个本地在线式文章管理器，可以用直观可视化的方式新建、编辑博客文章、page页面，添加标签、分类等，并且支持剪贴板粘贴图片（自动在source_images_目录中创建文件） 在Hexo网站目录下，安装 Hexo Admin 插件 npm install –save hexo-admin 启动本地服务器并打开管理界面，即可使用 hexo server -d open http://localhost:4000/admin/ 参考资料：https://www.cnblogs.com/jackyroc/p/7681938.html https://www.cnblogs.com/fengxiongZz/p/7707219.html https://blog.csdn.net/wsmrzx/article/details/81478945]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
