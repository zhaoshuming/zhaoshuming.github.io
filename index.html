<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="1ilOhMWnNE">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/09/android-rxjava-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/09/android-rxjava-principle/" itemprop="url">RxJava2原理解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-09T15:03:10+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇主要对以下三个方面进行讲解：</p>
<ul>
<li>RxJava是流式编程，在每一条流中，都至少包含三个要素：源头/被订阅者(Observable或Flowable)、订阅者(Observer或subscriber)、触发时机(subscribe()方法)；</li>
<li>其次就是线程切换（subscribeOn()和observeOn()）；</li>
<li>最后就是数据操作(如map()、flatMap()等)。</li>
</ul>
<h2 id="1、订阅（subscribe）"><a href="#1、订阅（subscribe）" class="headerlink" title="1、订阅（subscribe）"></a>1、订阅（subscribe）</h2><p>首先看下最简单的情况：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {
        // doSomething, eg: 
        // emitter.onNext(&quot;onNext&quot;);
        // emitter.onComplete();
    }
}).subscribe();
</code></pre><p>一条RxJava流若是没有调用subscribe()方法，该流便无法执行，即<strong>必须由subscribe()确定了订阅关系后这条流才能生效</strong>，原因如下：</p>
<pre><code>// Observable.java
public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) {
    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);
    // 可以直接忽略RxJavaPlugins的相关方法，不影响我们理解原理
    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source)); 
 }
// 无论调用subscribe的哪个重载方法，最终都会走到这个方法
public final void subscribe(Observer&lt;? super T&gt; observer) {
    ... // 省去不重要代码
    subscribeActual(observer);
    ...
}
protected abstract void subscribeActual(Observer&lt;? super T&gt; observer);
</code></pre><p>可以看到subscribe()里面主要是调用了subscribeActual，而subscribeActual是一个抽象方法，所以具体实现在子类中，这里的子类便是ObservableCreate，再来看它的实现：</p>
<pre><code>// ObservableCreate.java
public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) {
    this.source = source;
}
protected void subscribeActual(Observer&lt;? super T&gt; observer) {
    CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);
    observer.onSubscribe(parent);
    try {
        source.subscribe(parent);
    } catch (Throwable ex) {
        Exceptions.throwIfFatal(ex);
        parent.onError(ex);
    }
}
</code></pre><p><strong>ObservableCreate中subscribeActual的实现就是将我们的observer封装成CreateEmitter（ObservableEmitter的实现类），再执行observer.onSubscribe，确保onSubscribe总能在onNext等其他订阅行为之前执行，接着就是我们的核心代码：source.subscribe(parent)，source便是我们一开始创建流时新建的ObservableOnSubscribe对象，而parent则是封装后的CreateEmitter，所以其实此时执行的便是在创建ObservableOnSubscribe时实现的public void subscribe(ObservableEmitter<string> emitter) throws Exception方法，此时整条流的订阅关系便成立了。</string></strong></p>
<p>现在我们知道，事件流的执行实际上是由子类实现的subscribeActual控制的，所以其他的Observable创建方式也是一样的道理，这里再以fromIterable为例看一下：</p>
<pre><code>// Observable.java
public static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source) {
    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);
    return RxJavaPlugins.onAssembly(new ObservableFromIterable&lt;T&gt;(source));
}

// ObservableFromIterable.java
public ObservableFromIterable(Iterable&lt;? extends T&gt; source) {
    this.source = source;
}
@Override
public void subscribeActual(Observer&lt;? super T&gt; s) {
    Iterator&lt;? extends T&gt; it;
    try {
        it = source.iterator();
    } catch (Throwable e) {
        Exceptions.throwIfFatal(e);
        EmptyDisposable.error(e, s);
        return;
    }
    boolean hasNext;
    try {
        hasNext = it.hasNext();
    } catch (Throwable e) {
        Exceptions.throwIfFatal(e);
        EmptyDisposable.error(e, s);
        return;
    }
    if (!hasNext) {
        EmptyDisposable.complete(s);
        return;
    }
    FromIterableDisposable&lt;T&gt; d = new FromIterableDisposable&lt;T&gt;(s, it);
    s.onSubscribe(d);
    if (!d.fusionMode) {
        d.run();
    }
}    
</code></pre><p>可以看到，这里是将observer和我们的数据源列表封装为FromIterableDisposable，然后执行d.run()，下面看下run的实现：</p>
<pre><code>// FromIterableDisposable.java
FromIterableDisposable(Observer&lt;? super T&gt; actual, Iterator&lt;? extends T&gt; it) {
    this.actual = actual;
    this.it = it;
}
void run() {
    boolean hasNext;
    do {
        if (isDisposed()) {
            return;
        }
        T v;
        try {
            v = ObjectHelper.requireNonNull(it.next(), &quot;The iterator returned a null value&quot;);
        } catch (Throwable e) {
            Exceptions.throwIfFatal(e);
            actual.onError(e);
            return;
        }
        actual.onNext(v);
        if (isDisposed()) {
            return;
        }
        try {
            hasNext = it.hasNext();
        } catch (Throwable e) {
            Exceptions.throwIfFatal(e);
            actual.onError(e);
            return;
        }
    } while (hasNext);
    if (!isDisposed()) {
        actual.onComplete();
    }
}
</code></pre><p>在run方法中不停地遍历数据源列表，然后根据实际情况执行对应的事件处理方法(actual.onNext(v);等，actual即为我们传进来的observer)，这便完成了RxJava流的处理。</p>
<p>总结：<strong>RxJava2的订阅原理其实便是在subcribe时执行子类中实现的subscribeActual方法，该方法最终会去调用observer相关的订阅方法，可理解为观察者模式的一种变形。</strong></p>
<h2 id="2、线程切换"><a href="#2、线程切换" class="headerlink" title="2、线程切换"></a>2、线程切换</h2><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><pre><code>// Observable.java
public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) {
    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);
    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));
    }
</code></pre><p>subscribeOn时其实也是创建了一个Observable子类去实现subscribeActual方法：</p>
<pre><code>// ObservableSubscribeOn.java
public void subscribeActual(final Observer&lt;? super T&gt; s) {
    final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);
    s.onSubscribe(parent);
    parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));
}
</code></pre><p>这里将下游的Observer s封装成SubscribeOnObserver后又封装成Runnable的实现类SubscribeTask，在run方法中source.subscribe(parent)：</p>
<pre><code>// ObservableSubscribeOn.java
final class SubscribeTask implements Runnable {
    private final SubscribeOnObserver&lt;T&gt; parent;
    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) {
        this.parent = parent;
    }
    @Override
    public void run() {
        source.subscribe(parent);
    }
}
</code></pre><p>然后通过scheduler.scheduleDirect(new SubscribeTask(parent))将这个Task放到Worker中：</p>
<pre><code>// Scheduler.java
public Disposable scheduleDirect(@NonNull Runnable run) {
    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);
}
public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {
    final Worker w = createWorker();
    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
    DisposeTask task = new DisposeTask(decoratedRun, w);
    w.schedule(task, delay, unit);
    return task;
}
public abstract Worker createWorker();
</code></pre><p>而createWorker由Scheduler子类实现，即我们执行的线程类型，如AndroidSchedulers.mainThread()、Schedulers.io()，这里以mainThread()为例，</p>
<pre><code>// AndroidSchedulers.java
public static Scheduler mainThread() {
    return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);
}
private static final Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(new Callable&lt;Scheduler&gt;() {
    @Override 
    public Scheduler call() throws Exception {
        return MainHolder.DEFAULT;
    }
});
private static final class MainHolder {
    static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper()));
}
</code></pre><p>RxAndroidPlugins里面的非常简单，这里最终返回的就是HandlerScheduler，因此来看下它实现的createWorker和schedule方法：</p>
<pre><code>// HandlerScheduler.java
public Worker createWorker() { return new HandlerWorker(handler); }
</code></pre><p>在HandlerWorker中实现schedule(task, delay, unit)：</p>
<pre><code>// HandlerWorker.java
public Disposable schedule(Runnable run, long delay, TimeUnit unit) {
    ...
    ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);
    Message message = Message.obtain(handler, scheduled);
    message.obj = this; // Used as token for batch disposal of this worker&apos;s runnables.
    handler.sendMessageDelayed(message, unit.toMillis(delay));
    ....
    return scheduled;
}
</code></pre><p>这里将handler（由上面创建DEFAULT Scheduler时可知，该handler为UI线程的handler）和run又再次封装为ScheduledRunnable，然后通过handler发送到主线程处理，因此便保证了订阅操作（source.subscribe(parent)）执行在主线程。</p>
<p>同时，由上面可知，rx流由subscribe开始触发，然后执行source.subscribe(observer)，然而source可能也是上游操作后的产物（如map），因此便会触发上游内部的subscribe，直到源头，即<strong>rx流由subscribe开始触发，然后逆向向上寻找直到源头，才开始真正的执行</strong>。因此，若是有多个subscribeOn，最终的subscribe也是被放到最上面的subscribeOn（即第一个）指定的线程中执行，<strong>这便是指定多个subscribeOn只有第一个生效的原因</strong>。</p>
<p>总结：<strong>其实就是将订阅操作放到Runnable中执行，并结合handler机制将Runnable发送到主线程，对于其他线程（不同的线程模式会创建不同的Scheduler，并持有对应的线程池）则是将Runnable交给指定线程池处理。这便保证了在指定线程获取/处理数据源（observable）。</strong></p>
<h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h3><pre><code>// Observable.java
public final Observable&lt;T&gt; observeOn(Scheduler scheduler) {
    return observeOn(scheduler, false, bufferSize());
}
public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {
    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);
    ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);
    return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));
}
</code></pre><p>observeOn的线程切换则是在ObservableObserveOn中处理的：</p>
<pre><code>// ObservableObserveOn.java
protected void subscribeActual(Observer&lt;? super T&gt; observer) {
    if (scheduler instanceof TrampolineScheduler) {
         source.subscribe(observer);
    } else {
        Scheduler.Worker w = scheduler.createWorker();
        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));
    }
}
</code></pre><p>这里也是根据指定线程类型创建Worker（可参考上面subscribeOn原理），并将observer和w一同放到ObserveOnObserver中：</p>
<pre><code>// ObserveOnObserver.java
public void onNext(T t) {
    ....
    schedule();
}
void schedule() {
    if (getAndIncrement() == 0) {
        worker.schedule(this);
    }
}
public void run() {
    if (outputFused) {
        drainFused();
    } else {
         drainNormal();
    }
}
void drainNormal() {
    ...
    for (;;) {
        ...
        for (;;) {
            ...
            a.onNext(v);
        }
        ...
    }
}
</code></pre><p>可以看到，onNext执行的是schedule，而schedule则是将该对象直接放到指定线程的Worker中，然后在run中去执行对应的事件处理方法（onNext等），因此便实现了将下游的observer放到指定线程执行的目的，当然，这里只是将其直接下游的observer放到指定线程而已，对于其下游的下游则不一定。<strong>也就是说，observeOn可以有多个，每个都是对其直接下游做线程切换，若是下游不再切换，则所有下游都在该指定线程中执行。</strong></p>
<p>总结:<strong>observeOn其实就是将下游的observer放到指定线程里面去执行。</strong></p>
<h2 id="3、数据变换"><a href="#3、数据变换" class="headerlink" title="3、数据变换"></a>3、数据变换</h2><p>在事件从源头流到最终观察者的过程中，我们可以对事件进行操作转换，这里以map和flatMap为例进行解析。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><pre><code>// Observable.java
public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {
    ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);
    return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));
}
</code></pre><p>执行map操作时其实是<strong>将上游的observable和我们自己实现的mapper封住成一个ObservableMap</strong>，所以具体实现就是在ObservableMap的subscribeActual中：</p>
<pre><code>// ObservableMap.java
public void subscribeActual(Observer&lt;? super U&gt; t) {
    source.subscribe(new MapObserver&lt;T, U&gt;(t, function));
}
</code></pre><p>看到这句是不是很熟悉，从上面的订阅原理可知，到这里其实真正执行的便是MapObserver中的onNext等方法了，而其onNext里便是先执行map转换，再将转换结果交给下游的observer执行：</p>
<pre><code>// MapObserver.java
@Override
public void onNext(T t) {
    if (done) { // error or complete
        return;
    }
    if (sourceMode != NONE) {
        actual.onNext(null);
        return;
    }
    U v;
    try {
    v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;);
    } catch (Throwable ex) {
        fail(ex);
    return;
    }
    actual.onNext(v);
}
</code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>我们调用的flatMap最终执行的是该重载方法：</p>
<pre><code>// Observable.java
public final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, boolean delayErrors, int maxConcurrency, int bufferSize) {
     ...
     return RxJavaPlugins.onAssembly(new ObservableFlatMap&lt;T, R&gt;(this, mapper, delayErrors, maxConcurrency, bufferSize));
}
</code></pre><p>因此看下ObservableFlatMap：</p>
<pre><code>// ObservableFlatMap.java
public ObservableFlatMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends ObservableSource&lt;? extends U&gt;&gt; mapper, boolean delayErrors, int maxConcurrency, int bufferSize) {
    super(source);
    this.mapper = mapper;
    this.delayErrors = delayErrors;
    this.maxConcurrency = maxConcurrency;
    this.bufferSize = bufferSize;
}
@Override
public void subscribeActual(Observer&lt;? super U&gt; t) {
    if (ObservableScalarXMap.tryScalarXMapSubscribe(source, t, mapper)) {
    return;
    }
    source.subscribe(new MergeObserver&lt;T, U&gt;(t, mapper, delayErrors, maxConcurrency, bufferSize));
}
</code></pre><p>所以实际的操作是在MergeObserver，这里我们就看下onNext就好了：</p>
<pre><code>// MergeObserver.java
public void onNext(T t) {
    // safeguard against misbehaving sources
    if (done) {
        return;
    }
    ObservableSource&lt;? extends U&gt; p;
    try {
        p = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper returned a null ObservableSource&quot;);
    } catch (Throwable e) {
        Exceptions.throwIfFatal(e);
        s.dispose();
        onError(e);
        return;
    }
    if (maxConcurrency != Integer.MAX_VALUE) {
        synchronized (this) {
            if (wip == maxConcurrency) {
                sources.offer(p);
                return;
            }
            wip++;
        }
    }
    subscribeInner(p);
}
</code></pre><p>可以看到，这里是想<strong>将上游传进来的对象通过我们自己实现的mapper进行转换，然后再执行subscribeInner(p)</strong>（maxConcurrency默认就是Integer.MAX_VALUE），因此看下subscribeInner(p)：</p>
<pre><code>// MergeObserver.java
void subscribeInner(ObservableSource&lt;? extends U&gt; p) {
    for (;;) {
        if (p instanceof Callable) {
            if (tryEmitScalar(((Callable&lt;? extends U&gt;)p)) &amp;&amp; maxConcurrency != Integer.MAX_VALUE) {
                boolean empty = false;
                synchronized (this) {
                    p = sources.poll();
                    if (p == null) {
                        wip--;
                        empty = true;
                    }
                }
                if (empty) {
                    drain();
                    break;
                }
            } else {
                break;
            }
        } else {
            InnerObserver&lt;T, U&gt; inner = new InnerObserver&lt;T, U&gt;(this, uniqueId++);
            if (addInner(inner)) {
                p.subscribe(inner);
            }
            break;
        }
    }
}
</code></pre><p>这里是个无线循环，根据是否为Callable类型执行不同的逻辑，一般Observable.just为Callable，而from类型的则不是。这里看下from的逻辑，毕竟Callable类型又没指定maxConcurrency的话，是直接break，所以没什么好看的。而非Callable类型的，可以看到这里又封装成了InnerObserver，而for循环并没有什么用。</p>
<p>总结：<strong>在执行操作符方法(如map、flatMap等)时，会生成对应的Observable对象，在该对象中实现具体业务逻辑，对上游流下来的数据进行操作，再将处理后的结果交给下游的的订阅者继续处理。</strong></p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>RxJava2事件流的产生由subscribe方法调用subscribeActual(observer)触发，而subscribeActual由Observable子类实现，每个子类里的实现逻辑不同，可能会先执行自己的操作（如map或flatMap等 ），但最终都会调用source.subscribe，source即为该节点的上游数据源，因此需要上游操作执行完才能拿到source，最终便形成逐级逆向向上获取数据源（Observable或Flowable），即形成了从最开始的源头发射数据一路向下经过各个节点的操作后交给最终观察者的链式模型。</p>
<p>而对于线程切换，subscribeOn即是将订阅操作（observer）放到Runnable中执行，并将Runnable放到指定线程里操作；observeOn则是将下游的observer放到指定线程里面去执行。</p>
<h2 id="5、参考资料"><a href="#5、参考资料" class="headerlink" title="5、参考资料"></a>5、参考资料</h2><p><a href="https://blog.csdn.net/reakingf/article/details/84845705" target="_blank" rel="noopener">https://blog.csdn.net/reakingf/article/details/84845705</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/07/android-rxjava-role/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/07/android-rxjava-role/" itemprop="url">RxJava2五种被观察者及背压</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-07T13:17:26+08:00">
                2019-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RxJava五种被观察者为Flowable, Observable，Single, Completable, Maybe。</p>
<p>五种被观察者可通过toFlowable, toObservable，toSingle, toCompletable, toMaybe相互转换。</p>
<h2 id="1、Flowable"><a href="#1、Flowable" class="headerlink" title="1、Flowable"></a>1、Flowable</h2><h3 id="1-1、Flowable简介"><a href="#1-1、Flowable简介" class="headerlink" title="1.1、Flowable简介"></a>1.1、Flowable简介</h3><p>Flowable类，用于实现Reactive-Streams模式，并提供工厂方法，中间运算符以及使用反应式数据流的能力。</p>
<p>Reactive-Streams使用Flowable运行，Flowable实现了Publishers。因此，许多运算符直接接受Publishers，并允许与其他Reactive-Streams的实现进行直接交互操作</p>
<pre><code>public abstract class Flowable&lt;T&gt; implements Publisher&lt;T&gt;
</code></pre><p><strong>Flowable为操作符提供128个元素的默认缓冲区大小，可通过bufferSize() 方法获取，可通过系统参数rx2.buffer-size全局覆盖</strong>。但是大多数运算符都有重载，允许显式设置其内部缓冲区大小。</p>
<pre><code>/** The default buffer size. */
static final int BUFFER_SIZE;
static {
    BUFFER_SIZE = Math.max(16, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128));
}

/**
 * Returns the default internal buffer size used by most async operators.
 * &lt;p&gt;The value can be overridden via system parameter {@code rx2.buffer-size}
 * &lt;em&gt;before&lt;/em&gt; the Flowable class is loaded.
 * @return the default internal buffer size.
 */
public static int bufferSize() {
    return BUFFER_SIZE;
}
</code></pre><h3 id="1-2、Flowable官方图解"><a href="#1-2、Flowable官方图解" class="headerlink" title="1.2、Flowable官方图解"></a>1.2、Flowable官方图解</h3><p><img src="/2019/08/07/android-rxjava-role/rxjava-flowable.jpg" alt><br>1）看到上图有点疑问，不是在说Flowable嘛，怎么图解里的说明是Observable呢？</p>
<p>2）其实在官方文档里面Flowable和Observable都使用的是上面这个图解，因此这两个类肯定是提供相似功能，既然是相似，那么这幅图就是他们的共性，那不同的地方是什么呢？</p>
<p>不同之处是：<strong>Flowable支持Backpressure，Observable不支持Backpressure；只有在需要处理背压问题时，才需要使用Flowable</strong>。</p>
<p>由于<strong>只有在上下游运行在不同的线程中，且上游发射数据的速度大于下游接收处理数据的速度时，才会产生背压问题</strong>；<br>所以，如果能够确定：<br>1、上下游运行在同一个线程中，<br>2、上下游工作在不同的线程中，但是下游处理数据的速度不慢于上游发射数据的速度，<br>3、上下游工作在不同的线程中，但是数据流中只有一条数据<br>则不会产生背压问题，就没有必要使用Flowable，以免影响性能。</p>
<p>类似于Observable,在使用Flowable时，也可以通过create操作符创建发射数据流，代码如下：</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
                e.onNext(1);
                e.onNext(2);
                e.onNext(3);
                e.onComplete();
            }
        }, BackpressureStrategy.BUFFER) //create方法中多了一个BackpressureStrategy类型的参数
        .subscribeOn(Schedulers.newThread())//为上下游分别指定各自的线程
        .observeOn(Schedulers.newThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Subscription s) {   //onSubscribe回调的参数不是Disposable而是Subscription
                s.request(Long.MAX_VALUE);            //注意此处，暂时先这么设置
            }

            @Override
            public void onNext(Integer integer) {
                System.out.println(&quot;接收----&gt; &quot; + integer);
            }

            @Override
            public void onError(Throwable t) {
            }

            @Override
            public void onComplete() {
                System.out.println(&quot;接收----&gt; 完成&quot;);
            }
        });
</code></pre><p>运行结果如下：</p>
<pre><code>System.out: 接收----&gt; 1
System.out: 接收----&gt; 2
System.out: 接收----&gt; 3
System.out: 接收----&gt; 完成
</code></pre><p>发射与处理数据流在形式上与Observable大同小异，发射器中均有onNext，onError，onComplete方法，订阅器中也均有onSubscribe，onNext，onError，onComplete方法。<br>但是在细节方面还是有三点不同：<br>一、create方法中多了一个BackpressureStrategy类型的参数。<br>二、订阅器Subscriber中，方法onSubscribe回调的参数不是Disposable而是Subscription，多了行代码：s.request(Long.MAX_VALUE);<br>三、Flowable发射数据时，使用特有的发射器FlowableEmitter，不同于Observable的ObservableEmitter</p>
<h3 id="1-3、Backpressure"><a href="#1-3、Backpressure" class="headerlink" title="1.3、Backpressure"></a>1.3、Backpressure</h3><p>在通过create操作符创建Flowable时，多了一个BackpressureStrategy类型的参数，BackpressureStrategy是个枚举，源码如下：</p>
<pre><code>/**
 * Represents the options for applying backpressure to a source sequence.
 */
public enum BackpressureStrategy {
    /**
     * OnNext events are written without any buffering or dropping.
     * Downstream has to deal with any overflow.
     * &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators.
     */
    MISSING,
    /**
     * Signals a MissingBackpressureException in case the downstream can&apos;t keep up.
     */
    ERROR,
    /**
     * Buffers &lt;em&gt;all&lt;/em&gt; onNext values until the downstream consumes it.
     */
    BUFFER,
    /**
     * Drops the most recent onNext value if the downstream can&apos;t keep up.
     */
    DROP,
    /**
     * Keeps only the latest onNext value, overwriting any previous value if the
     * downstream can&apos;t keep up.
     */
    LATEST
}
</code></pre><p><strong>当上游发送数据的速度快于下游接收数据的速度，且运行在不同的线程中时，Flowable通过自身特有的异步缓存池，来缓存没来得及处理的数据，缓存池的容量上限为128</strong></p>
<p>BackpressureStrategy的作用便是用来设置Flowable通过异步缓存池缓存数据的策略。在源码FlowableCreate类中，可以看到五个泛型分别对应五个java类，通过代理模式对原始的发射器进行了包装：</p>
<pre><code>Override
public void subscribeActual(Subscriber&lt;? super T&gt; t) {
    BaseEmitter&lt;T&gt; emitter;

    switch (backpressure) {
        case MISSING: {
            emitter = new MissingEmitter&lt;T&gt;(t);
            break;
        }
        case ERROR: {
            emitter = new ErrorAsyncEmitter&lt;T&gt;(t);
            break;
        }
        case DROP: {
            emitter = new DropAsyncEmitter&lt;T&gt;(t);
            break;
        }
        case LATEST: {
            emitter = new LatestAsyncEmitter&lt;T&gt;(t);
            break;
        }
        default: {
            emitter = new BufferAsyncEmitter&lt;T&gt;(t, bufferSize());
            break;
        }
    }

    t.onSubscribe(emitter);
    try {
        source.subscribe(emitter);
    } catch (Throwable ex) {
        Exceptions.throwIfFatal(ex);
        emitter.onError(ex);
    }
}
</code></pre><h4 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h4><p>对应于ErrorAsyncEmitter<t>类，在其源码</t></p>
<pre><code>static final class ErrorAsyncEmitter&lt;T&gt; extends NoOverflowBaseAsyncEmitter&lt;T&gt; {
        private static final long serialVersionUID = 338953216916120960L;

        ErrorAsyncEmitter(Subscriber&lt;? super T&gt; actual) {
            super(actual);
        }

        @Override
        void onOverflow() {
            onError(new MissingBackpressureException(&quot;create: could not emit value due to lack of requests&quot;));
        }

    }

abstract static class NoOverflowBaseAsyncEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; {

        private static final long serialVersionUID = 4127754106204442833L;

        NoOverflowBaseAsyncEmitter(Subscriber&lt;? super T&gt; actual) {
            super(actual);
        }

        @Override
        public final void onNext(T t) {
            if (isCancelled()) {
                return;
            }

            if (t == null) {
                onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));
                return;
            }

            if (get() != 0) {
                actual.onNext(t);
                BackpressureHelper.produced(this, 1);
            } else {
                onOverflow();
            }
        }

        abstract void onOverflow();
    }
</code></pre><p>onOverflow方法中可以看到，<strong>在此策略下，如果放入Flowable的异步缓存池中的数据超限了，则会抛出MissingBackpressureException异常。父类的onNext中，在判断get() != 0，即缓存池未满的情况下，才会让被代理类调用onNext方法</strong>。运行如下代码：</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
                for (int i = 1; i &lt;= 129; i++) {
                    e.onNext(i);
                }
                e.onComplete();
            }
        }, BackpressureStrategy.ERROR)
        .subscribeOn(Schedulers.newThread())
        .observeOn(Schedulers.newThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Subscription s) {
                s.request(Long.MAX_VALUE);            //注意此处，暂时先这么设置
            }

            @Override
            public void onNext(Integer integer) {
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException ignore) {
                }
                System.out.println(integer);
            }

            @Override
            public void onError(Throwable t) {
                t.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println(&quot;接收----&gt; 完成&quot;);
            }
        });
</code></pre><p>创建并通过Flowable发射129条数据，Subscriber的onNext方法睡10秒之后再开始接收，运行后会发现控制台打印如下异常：</p>
<pre><code>W/System.err: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests
W/System.err:     at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411)
W/System.err:     at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377)
</code></pre><p>如果将Flowable发射数据的条数改为128，则不会出现此异常。</p>
<h4 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h4><p>对应于DropAsyncEmitter<t>类，通过DropAsyncEmitter类和它父类NoOverflowBaseAsyncEmitter的源码</t></p>
<pre><code>static final class DropAsyncEmitter&lt;T&gt; extends NoOverflowBaseAsyncEmitter&lt;T&gt; {
    private static final long serialVersionUID = 8360058422307496563L;

    DropAsyncEmitter(Subscriber&lt;? super T&gt; actual) {
        super(actual);
    }

    @Override
    void onOverflow() {
        // nothing to do
    }
}
</code></pre><p>可以看到，DropAsyncEmitter的onOverflow是个空方法，没有执行任何操作。所以<strong>在此策略下，如果Flowable的异步缓存池满了，会丢掉上游发送的数据</strong>。</p>
<p>存池中数据的清理，并不是Subscriber接收一条，便清理一条，而是存在一个延迟，等累积一段时间后统一清理一次。也就是Subscriber接收到第96条数据时，缓存池才开始清理数据，之后Flowable发射的数据才得以放入。如果数据处于缓存池存满的状态时，则被丢弃。</p>
<h4 id="LATEST"><a href="#LATEST" class="headerlink" title="LATEST"></a>LATEST</h4><p>对应于LatestAsyncEmitter<t>类<br>与Drop策略一样，如果缓存池满了，会丢掉将要放入缓存池中的数据，不同的是，不管缓存池的状态如何，<strong>LATEST都会将最后一条数据强行放入缓存池中</strong>，来保证观察者在接收到完成通知之前，能够接收到Flowable最新发射的一条数据。</t></p>
<h4 id="BUFFER"><a href="#BUFFER" class="headerlink" title="BUFFER"></a>BUFFER</h4><p>Flowable处理背压的默认策略，对应于BufferAsyncEmitter<t>类</t></p>
<p>其部分源码为：</p>
<pre><code>static final class BufferAsyncEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; {
        private static final long serialVersionUID = 2427151001689639875L;
        final SpscLinkedArrayQueue&lt;T&gt; queue;
        . . . . . .
        final AtomicInteger wip;
        BufferAsyncEmitter(Subscriber&lt;? super T&gt; actual, int capacityHint) {
            super(actual);
            this.queue = new SpscLinkedArrayQueue&lt;T&gt;(capacityHint);
            this.wip = new AtomicInteger();
        }
        . . . . . .
}
</code></pre><p>在其构造方法中可以发现，其内部维护了一个缓存池SpscLinkedArrayQueue，其大小不限，此策略下，<strong>如果Flowable默认的异步缓存池满了，会通过此缓存池暂存数据，它与Observable的异步缓存池一样，可以无限制向里添加数据，不会抛出MissingBackpressureException异常，但会导致OOM</strong>。</p>
<p>和使用Observable时一样，都会导致内存剧增，最后导致OOM,不同的是使用Flowable内存增长的速度要慢得多，那是因为基于Flowable发射的数据流，以及对数据加工处理的各操作符都添加了背压支持，附加了额外的逻辑，其运行效率要比Observable低得多。</p>
<h4 id="MISSING"><a href="#MISSING" class="headerlink" title="MISSING"></a>MISSING</h4><p>对应于MissingEmitter<t>类，通过其源码：</t></p>
<pre><code>static final class MissingEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; {


        private static final long serialVersionUID = 3776720187248809713L;

        MissingEmitter(Subscriber&lt;? super T&gt; actual) {
            super(actual);
        }

        @Override
        public void onNext(T t) {
            if (isCancelled()) {
                return;
            }

            if (t != null) {
                actual.onNext(t);
            } else {
                onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));
                return;
            }

            for (;;) {
                long r = get();
                if (r == 0L || compareAndSet(r, r - 1)) {
                    return;
                }
            }
        }

    }
</code></pre><p>可以发现，在传递数据时</p>
<pre><code>actual.onNext(t);
</code></pre><p>并没有对缓存池的状态进行判断，所以在此策略下，通过Create方法创建的Flowable相当于没有指定背压策略，不会对通过onNext发射的数据做缓存或丢弃处理，需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）指定背压策略。</p>
<p>onBackpressureXXX背压操作符：<strong>Flowable除了通过create创建的时候指定背压策略，也可以在通过其它创建操作符just，fromArray等创建后通过背压操作符指定背压策略</strong>。</p>
<blockquote>
<p>onBackpressureBuffer()对应BackpressureStrategy.BUFFER<br>onBackpressureDrop()对应BackpressureStrategy.DROP<br>onBackpressureLatest()对应BackpressureStrategy.LATEST</p>
</blockquote>
<p>例如代码</p>
<pre><code>Flowable.range(0, 500)
        .onBackpressureDrop()
        .subscribeOn(Schedulers.newThread())
        .observeOn(Schedulers.newThread())
        .subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(@NonNull Integer integer) throws Exception {
                System.out.println(integer);
            }
        });
</code></pre><h4 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h4><p>Subscription与Disposable均是观察者与可观察对象建立订阅状态后回调回来的参数，如同<strong>通过Disposable的dispose()方法可以取消Observer与Oberverable的订阅关系一样，通过Subscription的cancel()方法也可以取消Subscriber与Flowable的订阅关系</strong>。<br>不同的是接口Subscription中多了一个方法request(long n)，如上面代码中的：</p>
<pre><code>s.request(Long.MAX_VALUE);   
</code></pre><p>Flowable在设计的时候，采用了一种新的思路——<strong>响应式拉取</strong>方式，来<strong>设置下游对数据的请求数量，上游可以根据下游的需求量，按需发送数据。如果不显示调用request则默认下游的需求量为零，上游Flowable发射的数据不会交给下游Subscriber处理。</strong></p>
<p>多次调用request，数字会累积。</p>
<p>上游并没有根据下游的实际需求，发送数据，而是能发送多少，就发送多少，不管下游是否需要。而且超出下游需求之外的数据，仍然放到了异步缓存池中。这点我们可以通过以下代码来验证：</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
                for (int i = 1; i &lt; 130; i++) {
                    System.out.println(&quot;发射----&gt;&quot; + i);
                    e.onNext(i);
                }
                e.onComplete();
            }
        }, BackpressureStrategy.ERROR)
        .subscribeOn(Schedulers.newThread())
        .observeOn(Schedulers.newThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Subscription s) {
                s.request(1);
            }

            @Override
            public void onNext(Integer integer) {
                System.out.println(&quot;接收------&gt;&quot; + integer);
            }

            @Override
            public void onError(Throwable t) {
                t.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println(&quot;接收------&gt;完成&quot;);
            }
        });
</code></pre><p>通过Flowable发射130条数据，通过s.request(1)设置下游的数据请求量为1条，设置缓存策略为BackpressureStrategy.ERROR，如果异步缓存池超限，会导致MissingBackpressureException异常。久违的异常出现了，所以超出下游需求之外的数据，仍然放到了异步缓存池中，并导致缓存池溢出。</p>
<p>那么上游如何才能按照下游的请求数量发送数据呢，虽然通过request可以设置下游的请求数量，但是上游并没有获取到这个数量，如何获取呢？这便需要用到Flowable与Observable的第三点区别，Flowable特有的发射器FlowableEmitter</p>
<h4 id="FlowableEmitter"><a href="#FlowableEmitter" class="headerlink" title="FlowableEmitter"></a>FlowableEmitter</h4><p>flowable的发射器FlowableEmitter与observable的发射器ObservableEmitter均继承自Emitter<br>比较两者源码可以发现：</p>
<pre><code>public interface ObservableEmitter&lt;T&gt; extends Emitter&lt;T&gt; {

    void setDisposable(Disposable d);

    void setCancellable(Cancellable c);

    boolean isDisposed();

    ObservableEmitter&lt;T&gt; serialize();
}
</code></pre><p>与</p>
<pre><code>public interface FlowableEmitter&lt;T&gt; extends Emitter&lt;T&gt; {

    void setDisposable(Disposable s);

    void setCancellable(Cancellable c);

    long requested();

    boolean isCancelled();

    FlowableEmitter&lt;T&gt; serialize();
}
</code></pre><p>接口FlowableEmitter中多了一个方法</p>
<pre><code>long requested();
</code></pre><p>上游在发送数据的时候并不需要考虑下游需不需要，而只需要考虑异步缓存池中是否放得下，放得下便发，放不下便暂停。所以，通过e.requested()获取到的值，并不是下游真正的数据请求数量，而是异步缓存池中可放入数据的数量。数据放入缓存池中后，再由缓存池按照下游的数据请求量向下传递，待到传递完的数据累积到95条之后，将其清除，腾出空间存放新的数据。如果下游处理数据缓慢，则缓存池向下游传递数据的速度也相应变慢，进而没有传递完的数据可清除，也就没有足够的空间存放新的数据，上游通过e.requested()获取的值也就变成了0，如果此时，再发送数据的话，则会根据BackpressureStrategy背压策略的不同，抛出MissingBackpressureException异常，或者丢掉这条数据。</p>
<p>我们<strong>可以通过这个方法来获取当前未完成的请求数量，上游只需要在e.requested()等于0时，暂停发射数据，便可解决背压问题。</strong></p>
<h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>下面，对其通过Flowable做些改进，让其既不会产生背压问题，也不会引起异常或者数据丢失。<br>代码如下：</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
                int i = 0;
                while (true) {
                    if (e.requested() == 0) continue;//此处添加代码，让flowable按需发送数据
                    System.out.println(&quot;发射----&gt;&quot; + i);
                    i++;
                    e.onNext(i);
                }
            }
        }, BackpressureStrategy.MISSING)
        .subscribeOn(Schedulers.newThread())
        .observeOn(Schedulers.newThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {
            private Subscription mSubscription;

            @Override
            public void onSubscribe(Subscription s) {
                s.request(1);            //设置初始请求数据量为1
                mSubscription = s;
            }

            @Override
            public void onNext(Integer integer) {
                try {
                    Thread.sleep(50);
                    System.out.println(&quot;接收------&gt;&quot; + integer);
                    mSubscription.request(1);//每接收到一条数据增加一条请求量
                } catch (InterruptedException ignore) {
                }
            }

            @Override
            public void onError(Throwable t) {
            }

            @Override
            public void onComplete() {
            }
        });
</code></pre><p>下游处理数据的速度Thread.sleep(50)赶不上上游发射数据的速度，不同的是，我们在下游onNext(Integer integer) 方法中，每接收一条数据增加一条请求量，</p>
<pre><code>mSubscription.request(1)
</code></pre><p>在上游添加代码</p>
<pre><code>if(e.requested()==0)continue;
</code></pre><p>让上游按需发送数据，上游严格按照下游的需求量发送数据，不会产生MissingBackpressureException异常，或者丢失数据。</p>
<h2 id="2、Observable"><a href="#2、Observable" class="headerlink" title="2、Observable"></a>2、Observable</h2><h3 id="2-1、Observable简介"><a href="#2-1、Observable简介" class="headerlink" title="2.1、Observable简介"></a>2.1、Observable简介</h3><p>Observable类是不支持背压的，Observable是Reactive的一个抽象基类，Observable提供工厂方法，中间运算符以及消费同步和/或异步数据流的功能。</p>
<p>Observable类中的多数运算符接受一个或者多个ObservableSource，ObservableSource是非背压的基本接口，Observable实现了这个接口。</p>
<p>public abstract class Observable<t> implements ObservableSource<t><br>默认情况下，Observable的为其运算符提供128个元素的缓冲区大小运行，可看考Flowable.bufferSize()，可以通过系统参数rx2.buffer-size全局覆盖。但是，大多数运算符都有重载，允许设置其内部缓冲区大小。</t></t></p>
<h3 id="2-2、Flowable和Observable对比"><a href="#2-2、Flowable和Observable对比" class="headerlink" title="2.2、Flowable和Observable对比"></a>2.2、Flowable和Observable对比</h3><p>在上面已经说明了二者最大的区别。</p>
<p>官方也给出的解释是：</p>
<blockquote>
<p>The design of this class was derived from the Reactive-Streams design and specification by removing any backpressure-related infrastructure and implementation detail, replacing the org.reactivestreams.Subscription with Disposable as the primary means to dispose of a flow.</p>
</blockquote>
<p>中文翻译：</p>
<blockquote>
<p>该类的设计源自Reactive-Streams设计和规范，通过删除任何与背压相关的基本结构和实现细节，将Disposable替换为org.reactivestreams.Subscription作为处理流的主要方式。</p>
</blockquote>
<p>从代码层面上做简单的说明,Flowable实现了Publisher接口，Publisher源码如下:</p>
<pre><code>public interface Publisher&lt;T&gt; {

    /**
     * Request {@link Publisher} to start streaming data.
     * &lt;p&gt;
     * This is a &quot;factory method&quot; and can be called multiple times, each time starting a new {@link Subscription}.
     * &lt;p&gt;
     * Each {@link Subscription} will work for only a single {@link Subscriber}.
     * &lt;p&gt;
     * A {@link Subscriber} should only subscribe once to a single {@link Publisher}.
     * &lt;p&gt;
     * If the {@link Publisher} rejects the subscription attempt or otherwise fails it will
     * signal the error via {@link Subscriber#onError}.
     *
     * @param s the {@link Subscriber} that will consume signals from this {@link Publisher}
     */
    public void subscribe(Subscriber&lt;? super T&gt; s);
}
</code></pre><p>Observable实现了ObservableSource接口，ObservableSource源码如下</p>
<p>public interface ObservableSource<t> {</t></p>
<pre><code>/**
 * Subscribes the given Observer to this ObservableSource instance.
 * @param observer the Observer, not null
 * @throws NullPointerException if {@code observer} is null
 */
void subscribe(Observer&lt;? super T&gt; observer);
</code></pre><p>}<br>对比ObservableSource和Publisher，都有一个同名的接口subscribe()</p>
<h3 id="2-4、形象理解ObservableSource和Publisher有何异同"><a href="#2-4、形象理解ObservableSource和Publisher有何异同" class="headerlink" title="2.4、形象理解ObservableSource和Publisher有何异同"></a>2.4、形象理解ObservableSource和Publisher有何异同</h3><p>ObservableSource：可观察源</p>
<p>Publisher：发布者</p>
<p>subscribe：订阅</p>
<p>Subscriber：订阅者</p>
<p>Observer：观察者</p>
<p>对于ObservableSource，可以将subscribe(Observer observer)理解为Observer通过subscribe订阅了ObservableSource</p>
<p>对于Publisher，可以将subscribe(Subscriber s)理解为Subscriber通过subscribe订阅了Publisher</p>
<p>上面的解释可能比较抽象，通俗的举个例子，来个角色扮演</p>
<p>第一组：报刊（ObservableSource）、报刊订阅者（Observer）、订阅报刊的行为（subscribe)</p>
<p>第二组：报刊发布人(Publisher)、报刊订阅者（Subscriber）、订阅报刊的行为（subscribe)</p>
<p>把这个场景串起来讲就是：报刊订阅者订阅了报刊，或者说报刊订阅者在报刊发布人手中订阅了报刊。</p>
<p><strong>这其实是典型的观察者模式，所不同的是信息的发布者是ObservableSource还是Publisher，信息的订阅者是Observer还是Subscriber，统一的行为都是subscribe。</strong></p>
<h2 id="3、Single"><a href="#3、Single" class="headerlink" title="3、Single"></a>3、Single</h2><h3 id="3-1、Single简介"><a href="#3-1、Single简介" class="headerlink" title="3.1、Single简介"></a>3.1、Single简介</h3><pre><code>public abstract class Single&lt;T&gt; implements SingleSource&lt;T&gt; 
</code></pre><p>Single实现了SingleSource</p>
<pre><code>/**
 * Represents a basic {@link Single} source base interface,
 * consumable via an {@link SingleObserver}.
 * &lt;p&gt;
 * This class also serves the base type for custom operators wrapped into
 * Single via {@link Single#create(SingleOnSubscribe)}.
 *
 * @param &lt;T&gt; the element type
 * @since 2.0
 */
public interface SingleSource&lt;T&gt; {

    /**
     * Subscribes the given SingleObserver to this SingleSource instance.
     * @param observer the SingleObserver, not null
     * @throws NullPointerException if {@code observer} is null
     */
    void subscribe(SingleObserver&lt;? super T&gt; observer);
}
</code></pre><p>Single类为单个值响应实现Reactive Pattern。</p>
<p><strong>Single和Observable类似，所不同的是Single只能发出一个值，要么发射成功要么发射失败，也没有“onComplete”作为完成时的回调</strong></p>
<p>Single类实现了基类SingleSource的接口，SingleObserver作为Single发出来的消息的默认消费者，SingleObserver通过subscribe(SingleObserver&lt;? super T&gt; observer)在Single中订阅消息</p>
<pre><code>public interface SingleObserver&lt;T&gt; {

    /**
     * Provides the SingleObserver with the means of cancelling (disposing) the
     * connection (channel) with the Single in both
     * synchronous (from within {@code onSubscribe(Disposable)} itself) and asynchronous manner.
     * @param d the Disposable instance whose {@link Disposable#dispose()} can
     * be called anytime to cancel the connection
     * @since 2.0
     */
    void onSubscribe(Disposable d);

    /**
     * Notifies the SingleObserver with a single item and that the {@link Single} has finished sending
     * push-based notifications.
     * &lt;p&gt;
     * The {@link Single} will not call this method if it calls {@link #onError}.
     *
     * @param value
     *          the item emitted by the Single
     */
    void onSuccess(T value);

    /**
     * Notifies the SingleObserver that the {@link Single} has experienced an error condition.
     * &lt;p&gt;
     * If the {@link Single} calls this method, it will not thereafter call {@link #onSuccess}.
     *
     * @param e
     *          the exception encountered by the Single
     */
    void onError(Throwable e);
}
</code></pre><h3 id="3-2、Single与Observable的区别"><a href="#3-2、Single与Observable的区别" class="headerlink" title="3.2、Single与Observable的区别"></a>3.2、Single与Observable的区别</h3><p>Single只能发送单个消息，不能发送消息流，而且观察者接收到消息也只有两种情况，要么接收成功，要么接收失败</p>
<h3 id="3-3、Single官方图解"><a href="#3-3、Single官方图解" class="headerlink" title="3.3、Single官方图解"></a>3.3、Single官方图解</h3><p><img src="/2019/08/07/android-rxjava-role/rxjava-single.jpg" alt></p>
<h2 id="4、Completable"><a href="#4、Completable" class="headerlink" title="4、Completable"></a>4、Completable</h2><h3 id="4-1、Completable简介"><a href="#4-1、Completable简介" class="headerlink" title="4.1、Completable简介"></a>4.1、Completable简介</h3><p>Completable类<strong>表示延迟计算，没有任何值，只表示完成或异常</strong>。</p>
<p>Completable的行为类似于Observable，在计算完成后只能发出完成或错误信号，由onComplete或onError接口来处理，没有onNext或onSuccess等回调接口</p>
<p>Completable实现了基类CompletableSource的接口，CompletableObserver通过subscribe()方法在Completable处订阅消息。</p>
<p>Completable遵循协议：onSubscribe (onComplete | onError)</p>
<pre><code>public abstract class Completable implements CompletableSource


public interface CompletableSource {

    /**
     * Subscribes the given CompletableObserver to this CompletableSource instance.
     * @param cs the CompletableObserver, not null
     * @throws NullPointerException if {@code cs} is null
     */
    void subscribe(CompletableObserver cs);
}


public interface CompletableObserver {

    void onSubscribe(Disposable d);

    void onComplete();

    void onError(Throwable e);
}
</code></pre><p>从源码中我们可以看到CompletableObserver里面有三个接口：</p>
<p>1）onSubscribe中传入参数Disposable，由Completable调用一次，在CompletableObserver实例上设置Disposable，然后可以随时取消订阅。</p>
<p>2）onComplete一旦延迟计算正常完成将会被调用</p>
<p>3）onError 一旦延迟计算抛出异常将会被调用</p>
<h3 id="4-3、Completable示例"><a href="#4-3、Completable示例" class="headerlink" title="4.3、Completable示例"></a>4.3、Completable示例</h3><p>注意：<strong> 通过Disposable调用dispose()取消订阅，后面的消息无法接收。</strong></p>
<p>运行下面的例子，可以看到在调用dispose后，onStart被回调后，后续的消息就收不到了；去掉dispose，onStart回调后，三秒后onComplete将会被回调</p>
<pre><code> private void doCompletable() {
        Disposable d = Completable.complete()
                .delay(3, TimeUnit.SECONDS, Schedulers.io())
                .subscribeWith(new DisposableCompletableObserver() {
                    @Override
                    public void onStart() {
                        System.out.println(&quot;Started&quot;);
                    }

                    @Override
                    public void onError(Throwable error) {
                        error.printStackTrace();
                    }

                    @Override
                    public void onComplete() {
                        System.out.println(&quot;onComplete!&quot;);
                    }
                });


        d.dispose();

    }

运行完毕的结果是：
10-02 11:10:34.797 15565-15565/hq.demo.net I/System.out: Started

注释d.dispose()后在运行结果是：
10-02 14:34:19.490 23232-23232/hq.demo.net I/System.out: Started
10-02 14:34:22.492 23232-23483/hq.demo.net I/System.out: Done!
</code></pre><p>上面使用的是DisposableCompletableObserver通过subscribeWith来订阅消息，返回一个Disposable可以通过dispose来取消订阅关系，DisposableCompletableObserver是CompletableObserve的子类，只是增加了可取消订阅的功能。当然也能通过CompletableObserve方法操作，但是无法取消订阅关系，除此外没什么本质区别。</p>
<h2 id="5、Maybe"><a href="#5、Maybe" class="headerlink" title="5、Maybe"></a>5、Maybe</h2><h3 id="5-1、Maybe简介"><a href="#5-1、Maybe简介" class="headerlink" title="5.1、Maybe简介"></a>5.1、Maybe简介</h3><p>Maybe类<strong>表示延迟计算和单个值的发射，这个值可能根本没有或异常。</strong></p>
<p>Maybe类实现MaybeSource的接口，MaybeObserver通过subscribe(MaybeObserver)在Maybe处订阅消息</p>
<p>Maybe遵循协议：onSubscribe (onSuccess | onError | onComplete)，也就是Maybe发射消息后，可能会回调的接口是onSuccess | onError | onComplete</p>
<pre><code>public abstract class Maybe&lt;T&gt; implements MaybeSource&lt;T&gt;

public interface MaybeSource&lt;T&gt; {

    /**
     * Subscribes the given MaybeObserver to this MaybeSource instance.
     * @param observer the MaybeObserver, not null
     * @throws NullPointerException if {@code observer} is null
     */
    void subscribe(MaybeObserver&lt;? super T&gt; observer);
}


public interface MaybeObserver&lt;T&gt; {
    void onSubscribe(Disposable d);
    void onSuccess(T value);
    void onError(Throwable e);
    void onComplete();
}
</code></pre><h3 id="5-3、Maybe示例"><a href="#5-3、Maybe示例" class="headerlink" title="5.3、Maybe示例"></a>5.3、Maybe示例</h3><p>下面是个例子，注意让线程睡多少秒可以修改测试dispose，与Completable类似，但是<strong>无论怎么onStart()都会被回调</strong>，为什么onStart()都会被回调呢？可以看DisposableMaybeObserver源码，在订阅消息的时候就会首先回调onSubscribe，这个时候dispose还没有运行了，这个动作发生在订阅的时候，没有订阅何来取消订阅呢。</p>
<pre><code>public abstract class DisposableMaybeObserver&lt;T&gt; implements MaybeObserver&lt;T&gt;, Disposable {
    final AtomicReference&lt;Disposable&gt; s = new AtomicReference&lt;Disposable&gt;();

    @Override
    public final void onSubscribe(Disposable s) {
        if (DisposableHelper.setOnce(this.s, s)) {
            onStart();
        }
    }

    /**
     * Called once the single upstream Disposable is set via onSubscribe.
     */
    protected void onStart() {
    }

    @Override
    public final boolean isDisposed() {
        return s.get() == DisposableHelper.DISPOSED;
    }

    @Override
    public final void dispose() {
        DisposableHelper.dispose(s);
    }
}
</code></pre><p>下面是实例的运行和结果</p>
<pre><code>private void doMaybe() {

        new Thread(new Runnable() {
            @Override
            public void run() {
                Disposable d = Maybe.just(&quot;Hello World&quot;)
                        .delay(3, TimeUnit.SECONDS, Schedulers.io())
                        .subscribeWith(new DisposableMaybeObserver&lt;String&gt;() {
                            @Override
                            public void onStart() {
                                System.out.println(&quot;Started&quot;);
                            }

                            @Override
                            public void onSuccess(String value) {
                                System.out.println(&quot;Success: &quot; + value);
                            }

                            @Override
                            public void onError(Throwable error) {
                                error.printStackTrace();
                            }

                            @Override
                            public void onComplete() {
                                System.out.println(&quot;Done!&quot;);
                            }
                        });

                try {
                    Thread.sleep(4000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                d.dispose();
            }
        }).start();

    }


运行结果是：
10-02 15:01:53.320 25573-25649/hq.demo.net I/System.out: Started
10-02 15:01:56.324 25573-25654/hq.demo.net I/System.out: Success: Hello World

如果把Thread.sleep(4000)修改为Thread.sleep(2000)运行结果是：
10-02 15:05:34.362 25840-25872/hq.demo.net I/System.out: Started
</code></pre><p>上面例子使用DisposableMaybeObserver通过subscribeWith在Maybe处订阅，并返回一个Disposable，可以通过Disposable调用dispose来取消订阅。当然我们也可以通过下面的方式来完成，但是无法取消订阅关系：</p>
<pre><code>private void doMaybe() {
    Maybe.just(&quot;Hello World&quot;)
            .delay(3, TimeUnit.SECONDS, Schedulers.io())
            .subscribe(new MaybeObserver&lt;String&gt;() {
                @Override
                public void onSubscribe(Disposable d) {
                    System.out.println(&quot;Started&quot;);
                }

                @Override
                public void onSuccess(String value) {
                    System.out.println(&quot;Success: &quot; + value);
                }

                @Override
                public void onError(Throwable e) {
                    e.printStackTrace();
                }

                @Override
                public void onComplete() {
                    System.out.println(&quot;Done!&quot;);
                }
            });

    }
</code></pre><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>Single、Completable、Maybe是简化的Observable，只是具有少部分功能：</p>
<blockquote>
<p><strong>Single：只能发射一条单一数据或者一条异常通知，不能发射完成通知，数据与通知只能发射一个，二选一<br>Completable：只能发射一条完成通知或者一条异常通知，不能发射数据，要么发射完成通知要么发射异常通知，二选一<br>Maybe：只能发射一条单一数据，和发射一条完成通知，或者一条异常通知，完成通知和异常通知二选一，只能在发射完成通知或异常通知之前发射数据，否则发射数据无效</strong></p>
</blockquote>
<h2 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h2><p><a href="https://blog.csdn.net/weixin_36709064/article/details/82911270" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36709064/article/details/82911270</a><br><a href="https://www.jianshu.com/p/ff8167c1d191/" target="_blank" rel="noopener">Flowable背压支持</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/06/android-rxjava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/06/android-rxjava/" itemprop="url">RxJava2操作符汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-06T17:04:12+08:00">
                2019-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>RxJava是一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库</strong>(a library for composing asynchronous and event-based programs using observable sequences for the Java VM)。</p>
<p>RxJava能帮助我们在实现异步执行的前提下保持代码的清晰。它的原理就是创建一个Observable来完成异步任务，组合使用各种不同的链式操作，来实现各种复杂的操作，最终将任务的执行结果发射给Observer进行处理。</p>
<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>RxJava 有以下三个基本的元素：<br>1.被观察者（Observable）<br>2.观察者（Observer）<br>3.订阅（subscribe）</p>
<p>1.创建被观察者：</p>
<pre><code>Observable observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
});
</code></pre><p>2.创建观察者：</p>
<pre><code>Observer observer = new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
};
</code></pre><p>3.订阅</p>
<pre><code>observable.subscribe(observer);
</code></pre><p>也可以链式调用</p>
<h3 id="RxJava-中的调度器"><a href="#RxJava-中的调度器" class="headerlink" title="RxJava 中的调度器"></a>RxJava 中的调度器</h3><table>
<thead>
<tr>
<th>调度器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Schedulers.computation( )</td>
<td>用于使用计算任务，如事件循环和回调处理</td>
</tr>
<tr>
<td>Schedulers.immediate( )</td>
<td>当前线程</td>
</tr>
<tr>
<td>Schedulers.io( )</td>
<td>用于 IO 密集型任务，如果异步阻塞 IO 操作</td>
</tr>
<tr>
<td>Schedulers.newThread( )</td>
<td>创建一个新的线程</td>
</tr>
<tr>
<td>AndroidSchedulers.mainThread()</td>
<td>Android 的 UI 线程，用于操作 UI</td>
</tr>
</tbody>
</table>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul>
<li>每次掉用过onError或onComplete其中一个方法后，就会掉用dispose()方法</li>
<li>CompositeDisposable可以容纳多个disposable，每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可快速解除所有添加的Disposable类.</li>
</ul>
<h2 id="2、创建操作符"><a href="#2、创建操作符" class="headerlink" title="2、创建操作符"></a>2、创建操作符</h2><h3 id="create"><a href="#create" class="headerlink" title="create()"></a>create()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source)
</code></pre><p>作用：创建一个被观察者</p>
<h3 id="just"><a href="#just" class="headerlink" title="just()"></a>just()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; just(T item) 
......
public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10)
</code></pre><p>作用：创建一个被观察者，并发送事件，发送的事件不可以超过10个以上。</p>
<p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=================onComplete &quot;);
    }
});

看看打印结果：
=================onSubscribe
=================onNext 1
=================onNext 2
=================onNext 3
=================onComplete 
</code></pre><h3 id="fromArray"><a href="#fromArray" class="headerlink" title="fromArray()"></a>fromArray()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items)
</code></pre><p>作用：这个方法和 just() 类似，只不过 fromArray 可以传入多于10个的变量，并且可以传入一个数组。</p>
<h3 id="fromIterable"><a href="#fromIterable" class="headerlink" title="fromIterable()"></a>fromIterable()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source)
</code></pre><p>作用：这个方法和 fromArray() 类似，直接发送一个 List 集合数据给观察者</p>
<h3 id="fromCallable"><a href="#fromCallable" class="headerlink" title="fromCallable()"></a>fromCallable()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromCallable(Callable&lt;? extends T&gt; supplier)
</code></pre><p>作用：这里的 Callable 是 java.util.concurrent 中的 Callable，Callable 和 Runnable 的用法基本一致，只是它会返回一个结果值，这个结果值就是发给观察者的。</p>
<p>示例如下：</p>
<pre><code>Observable.fromCallable(new Callable &lt; Integer &gt; () {

    @Override
    public Integer call() throws Exception {
        return 1;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + integer);
    }
});
</code></pre><h3 id="fromFuture"><a href="#fromFuture" class="headerlink" title="fromFuture()"></a>fromFuture()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future)
</code></pre><p>作用：参数中的 Future 是 java.util.concurrent 中的 Future，Future 的作用是增加了 cancel() 等方法操作 Callable，它可以通过 get() 方法来获取 Callable 返回的值。</p>
<p>示例如下：</p>
<pre><code>FutureTask &lt; String &gt; futureTask = new FutureTask &lt; &gt; (new Callable &lt; String &gt; () {
    @Override
    public String call() throws Exception {
        Log.d(TAG, &quot;CallableDemo is Running&quot;);
        return &quot;返回结果&quot;;
    }
});

Observable.fromFuture(futureTask)
    .doOnSubscribe(new Consumer &lt; Disposable &gt; () {
    @Override
    public void accept(Disposable disposable) throws Exception {
        futureTask.run();
    }
})
.subscribe(new Consumer &lt; String &gt; () {
    @Override
    public void accept(String s) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + s);
    }
});
</code></pre><p>doOnSubscribe() 的作用就是只有订阅时才会发送事件。</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer()"></a>defer()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; defer(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)
</code></pre><p>作用：这个方法的作用就是直到被观察者被订阅后才会创建被观察者。</p>
<p>示例如下：</p>
<pre><code>// i 要定义为成员变量
Integer i = 100;

Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() {
    @Override
    public ObservableSource&lt;? extends Integer&gt; call() throws Exception {
        return Observable.just(i);
    }
});

i = 200;

Observer observer = new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
};

observable.subscribe(observer);

i = 300;

observable.subscribe(observer);

打印结果如下：

================onNext 200
================onNext 300
</code></pre><p>因为 defer() 只有观察者订阅的时候才会创建新的被观察者，所以每订阅一次就会打印一次，并且都是打印 i 最新的值。</p>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer()"></a>timer()</h3><pre><code>public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit) 
</code></pre><p>作用：当到指定时间后就会发送一个 0L 的值给观察者。</p>
<p>示例如下：</p>
<pre><code>Observable.timer(2, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;===============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><h3 id="interval"><a href="#interval" class="headerlink" title="interval()"></a>interval()</h3><pre><code>public static Observable&lt;Long&gt; interval(long period, TimeUnit unit)
public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit)
</code></pre><p>作用：每隔一段时间就会发送一个事件，这个事件是从0开始，不断增1的数字。</p>
<p>示例如下：</p>
<pre><code>Observable.interval(4, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});

打印结果：
05-20 20:48:10.321 28723-28723/com.example.louder.rxjavademo D/chan: ==============onSubscribe 
05-20 20:48:14.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 0
05-20 20:48:18.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 1
05-20 20:48:22.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 2
05-20 20:48:26.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 3
05-20 20:48:30.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 4
05-20 20:48:34.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 5
</code></pre><p>从时间就可以看出每隔4秒就会发出一次数字递增1的事件。这里说下 interval() 第三个方法的 initialDelay 参数，这个参数的意思就是 onSubscribe 回调之后，再次回调 onNext 的间隔时间。</p>
<h3 id="intervalRange"><a href="#intervalRange" class="headerlink" title="intervalRange()"></a>intervalRange()</h3><pre><code>public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)
public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)
</code></pre><p>作用：可以指定发送事件的开始值和数量，其他与 interval() 的功能一样。</p>
<p>示例如下：</p>
<pre><code>Observable.intervalRange(2, 5, 2, 1, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
打印结果：
05-21 00:03:01.672 2504-2504/com.example.louder.rxjavademo D/chan: ==============onSubscribe 
05-21 00:03:03.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 2
05-21 00:03:04.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 3
05-21 00:03:05.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 4
05-21 00:03:06.673 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 5
05-21 00:03:07.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 6
</code></pre><p>可以看出收到5次 onNext 事件，并且是从 2 开始的。</p>
<h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><pre><code>public static Observable&lt;Integer&gt; range(final int start, final int count)
</code></pre><p>作用：同时发送一定范围的事件序列。</p>
<p>示例如下：</p>
<pre><code>Observable.range(2, 5)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});

打印结果：
==============onSubscribe 
==============onNext 2
==============onNext 3
==============onNext 4
==============onNext 5
==============onNext 6
</code></pre><h3 id="rangeLong"><a href="#rangeLong" class="headerlink" title="rangeLong()"></a>rangeLong()</h3><pre><code>public static Observable&lt;Long&gt; rangeLong(long start, long count)
</code></pre><p>作用：与 range() 一样，只是数据类型为 Long</p>
<h3 id="empty-amp-never-amp-error"><a href="#empty-amp-never-amp-error" class="headerlink" title="empty() &amp; never() &amp; error()"></a>empty() &amp; never() &amp; error()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; empty()
public static &lt;T&gt; Observable&lt;T&gt; never()
public static &lt;T&gt; Observable&lt;T&gt; error(final Throwable exception)
</code></pre><p>作用：<br>1.empty() ： 直接发送 onComplete() 事件<br>2.never()：不发送任何事件<br>3.error()：发送 onError() 事件</p>
<p>示例如下：</p>
<pre><code>Observable.empty()
.subscribe(new Observer &lt; Object &gt; () {

    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe&quot;);
    }

    @Override
    public void onNext(Object o) {
        Log.d(TAG, &quot;==================onNext&quot;);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot; + e);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete&quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>==================onSubscribe
==================onComplete
</code></pre><p>换成 never() 的打印结果：</p>
<pre><code>==================onSubscribe
</code></pre><p>换成 error() 的打印结果：</p>
<pre><code>==================onSubscribe
==================onError java.lang.NullPointerException
</code></pre><h3 id="amb"><a href="#amb" class="headerlink" title="amb()"></a>amb()</h3><p>public static <t> Observable<t> amb(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources)</t></t></p>
<p>作用：amb() 要传入一个 Observable 集合，但是<strong>只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃</strong>。</p>
<p>示例如下：</p>
<pre><code>ArrayList &lt; Observable &lt; Long &gt;&gt; list = new ArrayList &lt; &gt; ();
list.add(Observable.intervalRange(1, 5, 2, 1, TimeUnit.SECONDS));
list.add(Observable.intervalRange(6, 5, 0, 1, TimeUnit.SECONDS));
Observable.amb(list)
.subscribe(new Consumer &lt; Long &gt; () {
    @Override
    public void accept(Long aLong) throws Exception {
        Log.d(TAG, &quot;========================aLong &quot; + aLong);
    }
});
打印结果：
05-26 10:21:29.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 6
05-26 10:21:30.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 7
05-26 10:21:31.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 8
05-26 10:21:32.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 9
05-26 10:21:33.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 10
</code></pre><h2 id="3、转换操作符"><a href="#3、转换操作符" class="headerlink" title="3、转换操作符"></a>3、转换操作符</h2><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map可以将被观察者发送的数据类型转变成其他的类型</p>
<pre><code>public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)
</code></pre><p>以下代码将 Integer 类型的数据转换成 String：</p>
<pre><code>Observable.just(1, 2, 3)
.map(new Function &lt; Integer, String &gt; () {
    @Override
    public String apply(Integer integer) throws Exception {
        return &quot;I&apos;m &quot; + integer;
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.e(TAG, &quot;===================onSubscribe&quot;);
    }

    @Override
    public void onNext(String s) {
        Log.e(TAG, &quot;===================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});

打印结果：
===================onSubscribe
===================onNext I&apos;m 1
===================onNext I&apos;m 2
===================onNext I&apos;m 3
</code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><p>这个方法可以将事件序列中的元素进行整合加工，返回一个新的被观察者。flatMap() 其实与 map() 类似，但是 flatMap() 返回的是一个 Observerable。</p>
<pre><code>public final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)
</code></pre><p>现在有一个需求就是要将 Person 集合中的每个元素中的 Plan 的 action 打印出来。首先用 map() 来实现这个需求看看：</p>
<pre><code>Observable.fromIterable(personList)
.map(new Function &lt; Person, List &lt; Plan &gt;&gt; () {
    @Override
    public List &lt; Plan &gt; apply(Person person) throws Exception {
        return person.getPlanList();
    }
})
.subscribe(new Observer &lt; List &lt; Plan &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(List &lt; Plan &gt; plans) {
        for (Plan plan: plans) {
            List &lt; String &gt; planActionList = plan.getActionList();
            for (String action: planActionList) {
                Log.d(TAG, &quot;==================action &quot; + action);
            }
        }
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>可以看到 onNext() 用了嵌套 for 循环来实现，如果代码逻辑复杂起来的话，可能需要多重循环才可以实现。现在看下使用 flatMap() 实现：</p>
<pre><code>Observable.fromIterable(personList)
.flatMap(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () {
    @Override
    public ObservableSource &lt; Plan &gt; apply(Person person) {
        return Observable.fromIterable(person.getPlanList());
    }
})
.flatMap(new Function &lt; Plan, ObservableSource &lt; String &gt;&gt; () {
    @Override
    public ObservableSource &lt; String &gt; apply(Plan plan) throws Exception {
        return Observable.fromIterable(plan.getActionList());
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;==================action: &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>从代码可以看出，只需要两个 flatMap() 就可以完成需求，并且代码逻辑非常清晰。</p>
<h3 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap()"></a>concatMap()</h3><p>concatMap() 和 flatMap() 基本上是一样的，只不过 <strong>concatMap() 转发出来的事件是有序的</strong>，不管是否延时，而 flatMap() 是无序的。</p>
<pre><code>public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)
public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, int prefetch)
</code></pre><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer()"></a>buffer()</h3><p>从需要发送的事件当中获取一定数量的事件，并将这些事件放到缓冲区当中一并发出。</p>
<pre><code>public final Observable&lt;List&lt;T&gt;&gt; buffer(int count, int skip)
</code></pre><p>buffer 有两个参数，一个是 count，另一个 skip。<strong>count 缓冲区元素的数量，skip 就代表缓冲区满了之后，发送下一次事件序列的时候要跳过多少元素</strong>。这样说可能还是有点抽象，直接看代码：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.buffer(2, 1)
.subscribe(new Observer &lt; List &lt; Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(List &lt; Integer &gt; integers) {
        Log.d(TAG, &quot;================缓冲区大小： &quot; + integers.size());
        for (Integer i: integers) {
            Log.d(TAG, &quot;================元素： &quot; + i);
        }
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
打印结果：
================缓冲区大小： 2
================元素： 1
================元素： 2
================缓冲区大小： 2
================元素： 2
================元素： 3
================缓冲区大小： 2
================元素： 3
================元素： 4
================缓冲区大小： 2
================元素： 4
================元素： 5
================缓冲区大小： 1
================元素： 5
</code></pre><p>从结果可以看出，每次发送事件，指针都会往后移动一个元素再取值，直到指针移动到没有元素的时候就会停止取值。</p>
<h3 id="scan"><a href="#scan" class="headerlink" title="scan()"></a>scan()</h3><p>将数据以一定的逻辑聚合起来。</p>
<pre><code>public final Observable&lt;T&gt; scan(BiFunction&lt;T, T, T&gt; accumulator)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.scan(new BiFunction &lt; Integer, Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer, Integer integer2) throws Exception {
        Log.d(TAG, &quot;====================apply &quot;);
        Log.d(TAG, &quot;====================integer &quot; + integer);
        Log.d(TAG, &quot;====================integer2 &quot; + integer2);
        return integer + integer2;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
打印结果：
====================accept 1
====================apply 
====================integer 1
====================integer2 2
====================accept 3
====================apply 
====================integer 3
====================integer2 3
====================accept 6
====================apply 
====================integer 6
====================integer2 4
====================accept 10
====================apply 
====================integer 10
====================integer2 5
====================accept 15
</code></pre><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy()"></a>groupBy()</h3><p>将发送的数据进行分组，每个分组都会返回一个被观察者。</p>
<pre><code>public final &lt;K&gt; Observable&lt;GroupedObservable&lt;K, T&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(5, 2, 3, 4, 1, 6, 8, 9, 7, 10)
.groupBy(new Function &lt; Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer) throws Exception {
        return integer % 3;
    }
})
.subscribe(new Observer &lt; GroupedObservable &lt; Integer, Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;====================onSubscribe &quot;);
    }

    @Override
    public void onNext(GroupedObservable &lt; Integer, Integer &gt; integerIntegerGroupedObservable) {
        Log.d(TAG, &quot;====================onNext &quot;);
        integerIntegerGroupedObservable.subscribe(new Observer &lt; Integer &gt; () {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;====================GroupedObservable onSubscribe &quot;);
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(TAG, &quot;====================GroupedObservable onNext  groupName: &quot; + integerIntegerGroupedObservable.getKey() + &quot; value: &quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;====================GroupedObservable onError &quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;====================GroupedObservable onComplete &quot;);
            }
        });
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;====================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;====================onComplete &quot;);
    }
});
</code></pre><h3 id="window"><a href="#window" class="headerlink" title="window()"></a>window()</h3><p>发送指定数量的事件时，就将这些事件分为一组。window 中的 count 的参数就是代表指定的数量，例如将 count 指定为2，那么每发2个数据就会将这2个数据分成一组。</p>
<pre><code>public final Observable&lt;Observable&lt;T&gt;&gt; window(long count)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.window(2)
.subscribe(new Observer &lt; Observable &lt; Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=====================onSubscribe &quot;);
    }

    @Override
    public void onNext(Observable &lt; Integer &gt; integerObservable) {
        integerObservable.subscribe(new Observer &lt; Integer &gt; () {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;=====================integerObservable onSubscribe &quot;);
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(TAG, &quot;=====================integerObservable onNext &quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;=====================integerObservable onError &quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;=====================integerObservable onComplete &quot;);
            }
        });
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=====================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=====================onComplete &quot;);
    }
});
打印结果：
=====================onSubscribe 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 1
=====================integerObservable onNext 2
=====================integerObservable onComplete 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 3
=====================integerObservable onNext 4
=====================integerObservable onComplete 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 5
=====================integerObservable onComplete 
=====================onComplete 
</code></pre><p>从结果可以发现，window() 将 1~5 的事件分成了3组。</p>
<h2 id="4、功能操作符"><a href="#4、功能操作符" class="headerlink" title="4、功能操作符"></a>4、功能操作符</h2><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn()"></a>subscribeOn()</h3><p>指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效。如果不指定，则默认为主线程。</p>
<pre><code>public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler)
</code></pre><h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn()"></a>observeOn()</h3><p>指定观察者的线程，可以切换线程，每指定一次就会生效一次。</p>
<pre><code>public final Observable&lt;T&gt; observeOn(Scheduler scheduler)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3)
.observeOn(Schedulers.newThread())
.flatMap(new Function &lt; Integer, ObservableSource &lt; String &gt;&gt; () {
    @Override
    public ObservableSource &lt; String &gt; apply(Integer integer) throws Exception {
        Log.d(TAG, &quot;======================flatMap Thread name &quot; + Thread.currentThread().getName());
        return Observable.just(&quot;chan&quot; + integer);
    }
})
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;======================onNext Thread name &quot; + Thread.currentThread().getName());
        Log.d(TAG, &quot;======================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
打印结果：
======================onSubscribe
======================flatMap Thread name RxNewThreadScheduler-1
======================flatMap Thread name RxNewThreadScheduler-1
======================flatMap Thread name RxNewThreadScheduler-1
======================onNext Thread name main
======================onNext chan1
======================onNext Thread name main
======================onNext chan2
======================onNext Thread name main
======================onNext chan3
======================onComplete
</code></pre><p>从打印结果可以知道，observeOn 成功切换了线程。</p>
<h3 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h3><p>延迟一段事件发送事件， onSubscribe 回调之后 onNext 延时后才会回调。</p>
<pre><code>public final Observable&lt;T&gt; delay(long delay, TimeUnit unit)
</code></pre><h3 id="doOnEach"><a href="#doOnEach" class="headerlink" title="doOnEach()"></a>doOnEach()</h3><p>Observable 每发送一件事件之前都会先回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnEach(final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        //      e.onError(new NumberFormatException());
        e.onComplete();
    }
})
.doOnEach(new Consumer &lt; Notification &lt; Integer &gt;&gt; () {
    @Override
    public void accept(Notification &lt; Integer &gt; integerNotification) throws Exception {
        Log.d(TAG, &quot;==================doOnEach &quot; + integerNotification.getValue());
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================doOnEach 1
==================onNext 1
==================doOnEach 2
==================onNext 2
==================doOnEach 3
==================onNext 3
==================doOnEach null
==================onComplete 
</code></pre><p>从结果就可以看出每发送一个事件之前都会回调 doOnEach 方法，并且可以取出 onNext() 发送的值。</p>
<h3 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext()"></a>doOnNext()</h3><p>Observable 每发送 onNext() 之前都会先回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext)
</code></pre><h3 id="doAfterNext"><a href="#doAfterNext" class="headerlink" title="doAfterNext()"></a>doAfterNext()</h3><p>Observable 每发送 onNext() 之后都会回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doAfterNext(Consumer&lt;? super T&gt; onAfterNext)
</code></pre><h3 id="doOnComplete"><a href="#doOnComplete" class="headerlink" title="doOnComplete()"></a>doOnComplete()</h3><p>Observable 每发送 onComplete() 之前都会回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnComplete(Action onComplete)
</code></pre><h3 id="doOnError"><a href="#doOnError" class="headerlink" title="doOnError()"></a>doOnError()</h3><p>Observable 每发送 onError() 之前都会回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError)
</code></pre><h3 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe()"></a>doOnSubscribe()</h3><p>Observable 每发送 onSubscribe() 之前都会回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnSubscribe(Consumer&lt;? super Disposable&gt; onSubscribe)
</code></pre><h3 id="doOnDispose"><a href="#doOnDispose" class="headerlink" title="doOnDispose()"></a>doOnDispose()</h3><p>当调用 Disposable 的 dispose() 之后回调该方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnDispose(Action onDispose)
</code></pre><h3 id="doOnLifecycle"><a href="#doOnLifecycle" class="headerlink" title="doOnLifecycle()"></a>doOnLifecycle()</h3><p>在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅。第二个参数的回调方法的作用与 doOnDispose() 是一样的。</p>
<pre><code>public final Observable&lt;T&gt; doOnLifecycle(final Consumer&lt;? super Disposable&gt; onSubscribe, final Action onDispose)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnLifecycle(new Consumer&lt;Disposable&gt;() {
    @Override
    public void accept(Disposable disposable) throws Exception {
        Log.d(TAG, &quot;==================doOnLifecycle accept&quot;);
    }
}, new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnLifecycle Action&quot;);
    }
})
.doOnDispose(
    new Action() {
        @Override
        public void run() throws Exception {
            Log.d(TAG, &quot;==================doOnDispose Action&quot;);
        }
})
.subscribe(new Observer&lt;Integer&gt;() {
    private Disposable d;
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
        this.d = d;
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
        d.dispose();
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }

});
打印结果：
 ==================doOnLifecycle accept
==================onSubscribe 
==================onNext 1
==================doOnDispose Action
==================doOnLifecycle Action
</code></pre><p>可以看到当在 onNext() 方法进行取消订阅操作后，doOnDispose() 和 doOnLifecycle() 都会被回调。<br>如果使用 doOnLifecycle 进行取消订阅，来看看打印结果：</p>
<pre><code>==================doOnLifecycle accept
==================onSubscribe 
</code></pre><p>可以发现 doOnDispose Action 和 doOnLifecycle Action 都没有被回调。</p>
<h3 id="doOnTerminate-amp-doAfterTerminate"><a href="#doOnTerminate-amp-doAfterTerminate" class="headerlink" title="doOnTerminate() &amp; doAfterTerminate()"></a>doOnTerminate() &amp; doAfterTerminate()</h3><p>doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。</p>
<pre><code>public final Observable&lt;T&gt; doOnTerminate(final Action onTerminate)
public final Observable&lt;T&gt; doAfterTerminate(Action onFinally)
</code></pre><h3 id="doFinally"><a href="#doFinally" class="headerlink" title="doFinally()"></a>doFinally()</h3><p>在所有事件发送完毕之后回调该方法。</p>
<pre><code>public final Observable&lt;T&gt; doFinally(Action onFinally)
</code></pre><p>这里可能你会有个问题，那就是 doFinally() 和 doAfterTerminate() 到底有什么区别？区别就是在于取消订阅，如果取消订阅之后 doAfterTerminate() 就不会被回调，而 <strong>doFinally() 无论怎么样都会被回调，且都会在事件序列的最后</strong>。</p>
<h3 id="onErrorReturn"><a href="#onErrorReturn" class="headerlink" title="onErrorReturn()"></a>onErrorReturn()</h3><p>当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列。</p>
<pre><code>public final Observable&lt;T&gt; onErrorReturn(Function&lt;? super Throwable, ? extends T&gt; valueSupplier)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.onErrorReturn(new Function&lt;Throwable, Integer&gt;() {
    @Override
    public Integer apply(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================onErrorReturn &quot; + throwable);
        return 404;
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onErrorReturn java.lang.NullPointerException
==================onNext 404
==================onComplete 
</code></pre><h3 id="onErrorResumeNext"><a href="#onErrorResumeNext" class="headerlink" title="onErrorResumeNext()"></a>onErrorResumeNext()</h3><p>当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列。</p>
<pre><code>public final Observable&lt;T&gt; onErrorResumeNext(Function&lt;? super Throwable, ? extends ObservableSource&lt;? extends T&gt;&gt; resumeFunction)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() {
    @Override
    public ObservableSource&lt;? extends Integer&gt; apply(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================onErrorResumeNext &quot; + throwable);
        return Observable.just(4, 5, 6);
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onErrorResumeNext java.lang.NullPointerException
==================onNext 4
==================onNext 5
==================onNext 6
==================onComplete 
</code></pre><h3 id="onExceptionResumeNext"><a href="#onExceptionResumeNext" class="headerlink" title="onExceptionResumeNext()"></a>onExceptionResumeNext()</h3><p>与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception。</p>
<pre><code>public final Observable&lt;T&gt; onExceptionResumeNext(final ObservableSource&lt;? extends T&gt; next)
</code></pre><h3 id="retry"><a href="#retry" class="headerlink" title="retry()"></a>retry()</h3><p>如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数。</p>
<pre><code>public final Observable&lt;T&gt; retry(long times)
</code></pre><h3 id="retryUntil"><a href="#retryUntil" class="headerlink" title="retryUntil()"></a>retryUntil()</h3><p>出现错误事件之后，可以通过此方法判断是否继续发送事件。指示Observable遇到错误时，是否让Observable重新订阅。</p>
<pre><code>public final Observable&lt;T&gt; retryUntil(final BooleanSupplier stop)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new Exception(&quot;404&quot;));
    }
})
.retryUntil(new BooleanSupplier() {
    @Override
    public boolean getAsBoolean() throws Exception {
        if (i == 6) {
            return true;
        }
        return false;
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onError 
</code></pre><h3 id="retryWhen"><a href="#retryWhen" class="headerlink" title="retryWhen()"></a>retryWhen()</h3><p>当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。<strong>如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件。</strong></p>
<pre><code>public final void safeSubscribe(Observer&lt;? super T&gt; s)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; String &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; String &gt; e) throws Exception {
        e.onNext(&quot;chan&quot;);
        e.onNext(&quot;ze&quot;);
        e.onNext(&quot;de&quot;);
        e.onError(new Exception(&quot;404&quot;));
        e.onNext(&quot;haha&quot;);
    }
})
.retryWhen(new Function &lt; Observable &lt; Throwable &gt; , ObservableSource &lt;? &gt;&gt; () {
    @Override
    public ObservableSource &lt;? &gt; apply(Observable &lt; Throwable &gt; throwableObservable) throws Exception {
        return throwableObservable.flatMap(new Function &lt; Throwable, ObservableSource &lt;? &gt;&gt; () {
            @Override
            public ObservableSource &lt;? &gt; apply(Throwable throwable) throws Exception {
                if(!throwable.toString().equals(&quot;java.lang.Exception: 404&quot;)) {
                    return Observable.just(&quot;可以忽略的异常&quot;);
                } else {
                    return Observable.error(new Throwable(&quot;终止啦&quot;));
                }
            }
        });
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;==================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot; + e.toString());
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext chan
==================onNext ze
==================onNext de
==================onError java.lang.Throwable: 终止啦

将 onError(new Exception(&quot;404&quot;)) 改为 onError(new Exception(&quot;303&quot;)) 看看打印结果：
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
......
从结果可以看出，会不断重复发送消息。
</code></pre><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>重复发送被观察者的事件，times 为发送次数。</p>
<pre><code>public final Observable&lt;T&gt; repeat(long times)
</code></pre><h3 id="repeatWhen"><a href="#repeatWhen" class="headerlink" title="repeatWhen()"></a>repeatWhen()</h3><p>这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件。</p>
<pre><code>public final Observable&lt;T&gt; repeatWhen(final Function&lt;? super Observable&lt;Object&gt;, ? extends ObservableSource&lt;?&gt;&gt; handler)
</code></pre><p>repeatWhen可以实现重订阅功能，而触发重订阅两个关键因素:<br>1.Obervable完成一次订阅，就是Observable调用onComplete<br>2.当Observable调用onComplete就会进入到repeatWhen方法里面，是否要触发重订阅，就需要通过repeatWhen的Function方法所返回的ObservableSource确定，如果返回的是onNext则触发重订阅，而返回的是onComplete/onError则不会触发重订阅</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {
                emitter.onComplete();
            }
        }).doOnComplete(new Action() {
            @Override
            public void run() throws Exception {
                Log.d(TAG, &quot;触发重订阅&quot;);
            }
        }).repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() {

            private int n = 0;

            @Override
            public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception {
                return objectObservable.flatMap(new Function&lt;Object, ObservableSource&lt;?&gt;&gt;() {
                    @Override
                    public ObservableSource&lt;?&gt; apply(Object o) throws Exception {
                        if (n != 3) {
                            n++;
                            return Observable.timer(3, TimeUnit.SECONDS);
                        } else {
                            return Observable.empty();
                        }
                    }
                });
            }
        }).subscribe(new Observer&lt;String&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(String s) {
                Log.d(TAG, &quot;onNext: &quot; + s);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;onError: &quot; + e);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;onComplete: &quot;);
            }
        });

运行结果:
08-02 10:26:13.187 D/MainActivity-vv: 触发重订阅
08-02 10:26:16.196 D/MainActivity-vv: 触发重订阅
08-02 10:26:19.204 D/MainActivity-vv: 触发重订阅
08-02 10:26:22.206 D/MainActivity-vv: 触发重订阅
</code></pre><p>repeatWhen可以用于延时轮询，在doOnComplete进行操作</p>
<h2 id="5、组合操作符"><a href="#5、组合操作符" class="headerlink" title="5、组合操作符"></a>5、组合操作符</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>可以将多个观察者组合在一起，然后按照之前发送顺序发送事件。需要注意的是，concat() 最多只可以发送4个事件。</p>
<pre><code>public static &lt;T&gt; Observable&lt;T&gt; concat(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)
</code></pre><p>示例如下：</p>
<pre><code>Observable.concat(Observable.just(1, 2),
Observable.just(3, 4),
Observable.just(5, 6),
Observable.just(7, 8))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
打印如下：
================onNext 1
================onNext 2
================onNext 3
================onNext 4
================onNext 5
================onNext 6
================onNext 7
================onNext 8
</code></pre><h3 id="concatArray"><a href="#concatArray" class="headerlink" title="concatArray()"></a>concatArray()</h3><p>与 concat()  作用一样，不过 concatArray() 可以发送多于 4 个被观察者。</p>
<pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArray(ObservableSource&lt;? extends T&gt;... sources)
</code></pre><h3 id="3-3-merge-amp-mergeArray"><a href="#3-3-merge-amp-mergeArray" class="headerlink" title="3.3 merge() &amp; mergeArray()"></a>3.3 merge() &amp; mergeArray()</h3><p>这个方法与 concat() 作用基本一样，只是 concat() 是串行发送事件，而<strong> merge() 并行发送事件</strong>。</p>
<pre><code>public static &lt;T&gt; Observable&lt;T&gt; merge(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)
</code></pre><p>现在来演示 concat() 和 merge() 的区别:</p>
<pre><code>Observable.merge(
Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {
    @Override
    public String apply(Long aLong) throws Exception {
        return &quot;A&quot; + aLong;
    }
}),
Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {
    @Override
    public String apply(Long aLong) throws Exception {
        return &quot;B&quot; + aLong;
    }
}))
    .subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;=====================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
打印结果如下：
05-21 16:10:31.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B0
05-21 16:10:31.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A0
05-21 16:10:32.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A1
05-21 16:10:32.126 12801-12850/com.example.rxjavademo D/chan: =====================onNext B1
05-21 16:10:33.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A2
05-21 16:10:33.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B2
05-21 16:10:34.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A3
05-21 16:10:34.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B3
05-21 16:10:35.124 12801-12849/com.example.rxjavademo D/chan: =====================onNext A4
05-21 16:10:35.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B4
05-21 16:10:36.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A5
05-21 16:10:36.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B5
......
从结果可以看出，A 和 B 的事件序列都可以发出，将以上的代码换成 concat() 看看打印结果：
05-21 16:17:52.352 14597-14621/com.example.rxjavademo D/chan: =====================onNext A0
05-21 16:17:53.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A1
05-21 16:17:54.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A2
05-21 16:17:55.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A3
05-21 16:17:56.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A4
05-21 16:17:57.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A5
......
从结果可以知道，只有等到第一个被观察者发送完事件之后，第二个被观察者才会发送事件。
</code></pre><p>mergeArray() 与 merge() 的作用是一样的，只是它可以发送4个以上的被观察者。</p>
<h3 id="concatArrayDelayError-amp-mergeArrayDelayError"><a href="#concatArrayDelayError-amp-mergeArrayDelayError" class="headerlink" title="concatArrayDelayError() &amp; mergeArrayDelayError()"></a>concatArrayDelayError() &amp; mergeArrayDelayError()</h3><p>在 concatArray() 和 mergeArray() 两个方法当中，如果其中有一个被观察者发送了一个 Error 事件，那么就会停止发送事件，如果你想 <strong>onError() 事件延迟到所有被观察者都发送完事件后再执行</strong>的话，就可以使用  concatArrayDelayError() 和 mergeArrayDelayError()</p>
<pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)
public static &lt;T&gt; Observable&lt;T&gt; mergeArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)
</code></pre><p>示例如下：</p>
<pre><code>Observable.concatArrayDelayError(
Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onError(new NumberFormatException());
    }
}), Observable.just(2, 3, 4))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {

    }
});
打印结果如下：
===================onNext 1
===================onNext 2
===================onNext 3
===================onNext 4
===================onError 
</code></pre><p>从结果可以看到，onError 事件是在所有被观察者发送完事件才发送的。mergeArrayDelayError() 也是有同样的作用。</p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h3><p>会将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。</p>
<pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; zip(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper)
</code></pre><p>示例如下：</p>
<pre><code>Observable.zip(Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS)
    .map(new Function&lt;Long, String&gt;() {
        @Override
        public String apply(Long aLong) throws Exception {
            String s1 = &quot;A&quot; + aLong;
            Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);
            return s1;
        }}),
        Observable.intervalRange(1, 6, 1, 1, TimeUnit.SECONDS)
            .map(new Function&lt;Long, String&gt;() {
            @Override
            public String apply(Long aLong) throws Exception {
                String s2 = &quot;B&quot; + aLong;
                Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);
                return s2;
            }
        }),
        new BiFunction&lt;String, String, String&gt;() {
            @Override
            public String apply(String s, String s2) throws Exception {
                String res = s + s2;
                return res;
            }
        })
.subscribe(new Observer&lt;String&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;===================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
上面代码中有两个 Observable，第一个发送事件的数量为5个，第二个发送事件的数量为6个。现在来看下打印结果：
05-22 09:10:39.952 5338-5338/com.example.rxjavademo D/chan: ===================onSubscribe 
05-22 09:10:40.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A1
05-22 09:10:40.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B1
===================onNext A1B1
05-22 09:10:41.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A2
05-22 09:10:41.954 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B2
===================onNext A2B2
05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A3
05-22 09:10:42.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B3
05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================onNext A3B3
05-22 09:10:43.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A4
05-22 09:10:43.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B4
05-22 09:10:43.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A4B4
05-22 09:10:44.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A5
05-22 09:10:44.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B5
05-22 09:10:44.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A5B5
===================onComplete 
</code></pre><p>可以发现最终接收到的事件数量是5，那么为什么第二个 Observable 没有发送第6个事件呢？因为在这之前第一个 Observable 已经发送了 onComplete 事件，所以第二个 Observable 不会再发送事件。</p>
<h3 id="combineLatest-amp-combineLatestDelayError"><a href="#combineLatest-amp-combineLatestDelayError" class="headerlink" title="combineLatest() &amp;  combineLatestDelayError()"></a>combineLatest() &amp;  combineLatestDelayError()</h3><pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; combineLatest(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; combiner)
</code></pre><p>combineLatest() 的作用与 zip() 类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，<strong>只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送</strong>，这样可能还是比较抽象，看看以下例子代码：</p>
<pre><code>Observable.combineLatest(
Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS)
    .map(new Function &lt; Long, String &gt; () {@Override
    public String apply(Long aLong) throws Exception {
        String s1 = &quot;A&quot; + aLong;
        Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);
        return s1;
    }
}),
Observable.intervalRange(1, 5, 2, 2, TimeUnit.SECONDS)
    .map(new Function &lt; Long, String &gt; () {@Override
    public String apply(Long aLong) throws Exception {
        String s2 = &quot;B&quot; + aLong;
        Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);
        return s2;
    }
}),
new BiFunction &lt; String, String, String &gt; () {@Override
    public String apply(String s, String s2) throws Exception {
        String res = s + s2;
        return res;
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;===================最终接收到的事件 &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
分析上面的代码，Observable A 会每隔1秒就发送一次事件，Observable B 会隔2秒发送一次事件。来看看打印结果：
05-22 11:41:20.859 15104-15104/? D/chan: ===================onSubscribe 
05-22 11:41:21.859 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A1
05-22 11:41:22.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A2
05-22 11:41:22.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B1
05-22 11:41:22.862 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A2B1
05-22 11:41:23.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A3
===================最终接收到的事件 A3B1
05-22 11:41:24.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A4
05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B2
05-22 11:41:24.861 15104-15128/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B1
05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B2
05-22 11:41:26.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B3
05-22 11:41:26.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B3
05-22 11:41:28.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B4
05-22 11:41:28.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B4
05-22 11:41:30.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B5
05-22 11:41:30.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B5
===================onComplete 
</code></pre><p>分析上述结果可以知道，当发送 A1 事件之后，因为 B 并没有发送任何事件，所以根本不会发生结合。当 B 发送了 B1 事件之后，就会与 A 最近发送的事件 A2 结合成 A2B1，这样只有后面一有被观察者发送事件，这个事件就会与其他被观察者最近发送的事件结合起来了。</p>
<p>因为 combineLatestDelayError() 就是多了延迟发送 onError() 功能，这里就不再赘述了。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>与 scan() 操作符的作用也是将发送数据以一定逻辑聚合起来，这两个的区别在于 <strong>scan() 每处理一次数据就会将事件发送给观察者，而 reduce() 会将所有数据聚合在一起才会发送事件给观察者。</strong></p>
<pre><code>public final Maybe&lt;T&gt; reduce(BiFunction&lt;T, T, T&gt; reducer)
</code></pre><p>示例如下：<br>    Observable.just(0, 1, 2, 3)<br>    .reduce(new BiFunction &lt; Integer, Integer, Integer &gt; () {<br>        @Override<br>        public Integer apply(Integer integer, Integer integer2) throws Exception {<br>            int res = integer + integer2;<br>            Log.d(TAG, “====================integer “ + integer);<br>            Log.d(TAG, “====================integer2 “ + integer2);<br>            Log.d(TAG, “====================res “ + res);<br>            return res;<br>        }<br>    })<br>    .subscribe(new Consumer &lt; Integer &gt; () {<br>        @Override<br>        public void accept(Integer integer) throws Exception {<br>            Log.d(TAG, “==================accept “ + integer);<br>        }<br>    });<br>    打印结果：<br>    ====================integer 0<br>    ====================integer2 1<br>    ====================res 1<br>    ====================integer 1<br>    ====================integer2 2<br>    ====================res 3<br>    ====================integer 3<br>    ====================integer2 3<br>    ====================res 6<br>    ==================accept 6<br>从结果可以看到，其实就是前2个数据聚合之后，然后再与后1个数据进行聚合，一直到没有数据为止。</p>
<h3 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h3><p>将数据收集到数据结构当中。</p>
<pre><code>public final &lt;U&gt; Single&lt;U&gt; collect(Callable&lt;? extends U&gt; initialValueSupplier, BiConsumer&lt;? super U, ? super T&gt; collector)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.collect(new Callable &lt; ArrayList &lt; Integer &gt;&gt; () {
    @Override
    public ArrayList &lt; Integer &gt; call() throws Exception {
        return new ArrayList &lt; &gt; ();
    }
},
new BiConsumer &lt; ArrayList &lt; Integer &gt; , Integer &gt; () {
    @Override
    public void accept(ArrayList &lt; Integer &gt; integers, Integer integer) throws Exception {
        integers.add(integer);
    }
})
.subscribe(new Consumer &lt; ArrayList &lt; Integer &gt;&gt; () {
    @Override
    public void accept(ArrayList &lt; Integer &gt; integers) throws Exception {
        Log.d(TAG, &quot;===============accept &quot; + integers);
    }
});
打印结果：
===============accept [1, 2, 3, 4]
</code></pre><h3 id="startWith-amp-startWithArray"><a href="#startWith-amp-startWithArray" class="headerlink" title="startWith() &amp; startWithArray()"></a>startWith() &amp; startWithArray()</h3><p>在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出。</p>
<pre><code>public final Observable&lt;T&gt; startWith(T item)
public final Observable&lt;T&gt; startWithArray(T... items)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(5, 6, 7)
.startWithArray(2, 3, 4)
.startWith(1)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + integer);
    }
});
打印结果：
================accept 1
================accept 2
================accept 3
================accept 4
================accept 5
================accept 6
================accept 7
</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>返回被观察者发送事件的数量。</p>
<pre><code>public final Single&lt;Long&gt; count()
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3)
.count()
.subscribe(new Consumer &lt; Long &gt; () {
    @Override
    public void accept(Long aLong) throws Exception {
        Log.d(TAG, &quot;=======================aLong &quot; + aLong);
    }
});
打印结果：
=======================aLong 3
</code></pre><h2 id="6、过滤操作符"><a href="#6、过滤操作符" class="headerlink" title="6、过滤操作符"></a>6、过滤操作符</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送。<br>    public final Observable<t> filter(Predicate&lt;? super T&gt; predicate)</t></p>
<p>示例如下：</p>
<pre><code> Observable.just(1, 2, 3)
    .filter(new Predicate &lt; Integer &gt; () {
        @Override
        public boolean test(Integer integer) throws Exception {
            return integer &lt; 2;
        }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
以上代码只有小于2的事件才会发送，来看看打印结果：
==================onSubscribe 
==================onNext 1
==================onComplete 
</code></pre><h3 id="ofType"><a href="#ofType" class="headerlink" title="ofType()"></a>ofType()</h3><p>过滤不符合该类型事件</p>
<pre><code>public final &lt;U&gt; Observable&lt;U&gt; ofType(final Class&lt;U&gt; clazz)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, &quot;chan&quot;, &quot;zhide&quot;)
.ofType(Integer.class)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre><h3 id="skip-amp-skipLast"><a href="#skip-amp-skipLast" class="headerlink" title="skip() &amp; skipLast()"></a>skip() &amp; skipLast()</h3><p>跳过正序某些事件，count 代表跳过事件的数量</p>
<pre><code>public final Observable&lt;T&gt; skip(long count)
</code></pre><p>skipLast() 作用也是跳过某些事件，不过它是用来跳过正序的后面的事件。</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p>过滤事件序列中的重复事件。</p>
<pre><code>public final Observable&lt;T&gt; distinct() 
</code></pre><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged()"></a>distinctUntilChanged()</h3><p>过滤掉连续重复的事件</p>
<pre><code>public final Observable&lt;T&gt; distinctUntilChanged()
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 3, 2, 1)
.distinctUntilChanged()
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果:
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 2
==================onNext 1
==================onComplete 
</code></pre><p>因为事件序列中连续出现两次3，所以第二次3并不会发出。</p>
<h3 id="take-amp-takeLast"><a href="#take-amp-takeLast" class="headerlink" title="take() &amp; takeLast()"></a>take() &amp; takeLast()</h3><p>控制观察者接收的事件的数量。</p>
<pre><code>public final Observable&lt;T&gt; take(long count)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.take(3)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre><p>takeLast() 的作用就是控制观察者只能接受事件序列的后面几件事情。</p>
<h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce()"></a>debounce()</h3><p>如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者。</p>
<pre><code>public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit)
</code></pre><p>throttleWithTimeout() 与此方法的作用一样。</p>
<h3 id="firstElement-amp-amp-lastElement"><a href="#firstElement-amp-amp-lastElement" class="headerlink" title="firstElement() &amp;&amp; lastElement()"></a>firstElement() &amp;&amp; lastElement()</h3><p>firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素。</p>
<pre><code>public final Maybe&lt;T&gt; firstElement()
public final Maybe&lt;T&gt; lastElement()
</code></pre><h3 id="elementAt-amp-elementAtOrError"><a href="#elementAt-amp-elementAtOrError" class="headerlink" title="elementAt() &amp; elementAtOrError()"></a>elementAt() &amp; elementAtOrError()</h3><p>elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 。</p>
<pre><code>public final Maybe&lt;T&gt; elementAt(long index)
public final Single&lt;T&gt; elementAtOrError(long index)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.elementAt(0)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
打印结果：
====================accept 1
</code></pre><p>将 elementAt() 的值改为5，这时是没有打印结果的，因为没有满足条件的元素。<br>替换 elementAt() 为 elementAtOrError()，代码如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.elementAtOrError(5)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
</code></pre><p>这时候会抛出 NoSuchElementException 异常。</p>
<h2 id="7、条件操作符"><a href="#7、条件操作符" class="headerlink" title="7、条件操作符"></a>7、条件操作符</h2><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><p>判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false。</p>
<pre><code>public final Single&lt;Boolean&gt; all(Predicate&lt;? super T&gt; predicate)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.all(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 5;
    }
})
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;==================aBoolean &quot; + aBoolean);
    }
});
打印结果：
==================aBoolean true
</code></pre><h3 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile()"></a>takeWhile()</h3><p>可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送</p>
<pre><code>public final Observable&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.takeWhile(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
打印结果：
========================integer 1
========================integer 2
</code></pre><h3 id="skipWhile"><a href="#skipWhile" class="headerlink" title="skipWhile()"></a>skipWhile()</h3><p>可以设置条件，当某个数据满足条件时不发送该数据，反之则发送。</p>
<pre><code>public final Observable&lt;T&gt; skipWhile(Predicate&lt;? super T&gt; predicate)
</code></pre><h3 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil()"></a>takeUntil()</h3><p>可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了。</p>
<pre><code>public final Observable&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; stopPredicate
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5, 6)
.takeUntil(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &gt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
打印结果：
========================integer 1
========================integer 2
========================integer 3
========================integer 4
</code></pre><h3 id="skipUntil"><a href="#skipUntil" class="headerlink" title="skipUntil()"></a>skipUntil()</h3><p>当 <strong>skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者。skipUntil() 里的 Observable 并不会发送事件给观察者。</strong></p>
<pre><code>public final &lt;U&gt; Observable&lt;T&gt; skipUntil(ObservableSource&lt;U&gt; other)
</code></pre><p>示例如下：</p>
<pre><code>Observable.intervalRange(1, 5, 0, 1, TimeUnit.SECONDS)
.skipUntil(Observable.intervalRange(6, 5, 3, 1, TimeUnit.SECONDS))
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;========================onSubscribe &quot;);
    }

    @Override
    public void onNext(Long along) {
        Log.d(TAG, &quot;========================onNext &quot; + along);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;========================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;========================onComplete &quot;);
    }
});
打印结果：
05-26 10:08:50.574 13023-13023/com.example.rxjavademo D/chan: ========================onSubscribe 
05-26 10:08:53.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 4
05-26 10:08:54.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 5
========================onComplete 
</code></pre><h3 id="sequenceEqual"><a href="#sequenceEqual" class="headerlink" title="sequenceEqual()"></a>sequenceEqual()</h3><p>判断两个  Observable 发送的事件是否相同。</p>
<pre><code>public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2)
</code></pre><h3 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h3><p>判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false。</p>
<pre><code>public final Single&lt;Boolean&gt; contains(final Object element)
</code></pre><h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h3><p>判断事件序列是否为空。</p>
<pre><code>public final Single&lt;Boolean&gt; isEmpty()
</code></pre><h3 id="defaultIfEmpty"><a href="#defaultIfEmpty" class="headerlink" title="defaultIfEmpty()"></a>defaultIfEmpty()</h3><p>如果观察者只发送一个 onComplete() 事件，这个方法会发送一个值。</p>
<pre><code>public final Observable&lt;T&gt; defaultIfEmpty(T defaultItem)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onComplete();
    }
})
.defaultIfEmpty(666)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + integer);
    }
});
打印结果：
========================onNext 666
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/post/5b17560e6fb9a01e2862246f" target="_blank" rel="noopener">https://juejin.im/post/5b17560e6fb9a01e2862246f</a><br><a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">https://gank.io/post/560e15be2dca930e00da1083</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/28/flutter-integration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/28/flutter-integration/" itemprop="url">Flutter集成Android项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-28T16:31:43+08:00">
                2019-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hybrid-Develop/" itemprop="url" rel="index">
                    <span itemprop="name">Hybrid Develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在现有项目上集成Flutter"><a href="#在现有项目上集成Flutter" class="headerlink" title="在现有项目上集成Flutter"></a>在现有项目上集成Flutter</h2><p>1.在andorid工程目录上级目录下执行命令:</p>
<pre><code>flutter create -t module xxxx(想要创建的flutter项目名)
</code></pre><p>执行完后，一个和Android项目平级的flutter项目就已经创建好了。</p>
<p>2.添加flutter到当前Android项目：<br>在Android项目根目录下的settings.gradle文件中，添加如下代码：</p>
<pre><code>setBinding(new Binding([gradle: this]))
evaluate(new File(
        settingsDir.parentFile,
        &quot;flutter_hybrid/.android/include_flutter.groovy&quot;
))
</code></pre><p>然后，在项目的app目录下，build.gradle文件中，添加如下dependency:</p>
<pre><code>implementation project(&apos;:flutter&apos;)
</code></pre><p>如上，添加完之后，准备工作就完成了。</p>
<h2 id="集成Flutter页面跳转"><a href="#集成Flutter页面跳转" class="headerlink" title="集成Flutter页面跳转"></a>集成Flutter页面跳转</h2><h3 id="通过继承FlutterActivity跳到默认页面"><a href="#通过继承FlutterActivity跳到默认页面" class="headerlink" title="通过继承FlutterActivity跳到默认页面"></a>通过继承FlutterActivity跳到默认页面</h3><p>1.Application：初始化Flutter</p>
<pre><code>public class App extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
        FlutterMain.startInitialization(this);
    }
}
</code></pre><p>2.Activity：继承FlutterActivity</p>
<pre><code>/**
 * debug模式原生跳转到flutter界面会出现白屏，release包就不会出现白屏了
 */
public class MainFlutterActivity extends FlutterActivity {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    GeneratedPluginRegistrant.registerWith(this);
  }
</code></pre><p>这样以后，我们就可以跳转这个MainFlutterActivity，实现在Android工程里面进入Flutter工程的默认页面了。</p>
<h3 id="通过FlutterView跳到指定页面"><a href="#通过FlutterView跳到指定页面" class="headerlink" title="通过FlutterView跳到指定页面"></a>通过FlutterView跳到指定页面</h3><p>首先通过Flutter.createFlutterView方法来创建一个FlutterView类型的View。它有三个构造参数：</p>
<pre><code>public static FlutterView createView(Activity activity, Lifecycle lifecycle, String initialRoute)
</code></pre><p>三个参数分别是：<br>1.Activity，即当前附着的Activity</p>
<p>2.LifeCycle，且是不能为空(NonNull)的，这也就要求我们必须用AppCompatActivity来承载FlutterView了，如果我们的Activity继承自android.app.Activity是没有getLifeCycle()这个方法的。</p>
<pre><code>public class FlutterViewActivity extends AppCompatActivity 复制代码
</code></pre><p>3.initialRoute这是一个String类型的变量，根据不同的标识跳转不同的Flutter页面：</p>
<pre><code>Widget _widgetForRoute(String route) {
  switch (route) {
    case &apos;route1&apos;:
      return  MyHomePage(title: &apos;Flutter Demo Home Page1&apos;);
    case &apos;route2&apos;:
      return  MyHomePage(title: &apos;Flutter Demo Home Page2&apos;);
    default:
        return  MyHomePage(title: &apos;Flutter Demo Home Page2&apos;);
  }
}
</code></pre><p>然后在当前Activity的OnCreate方法中，执行：</p>
<pre><code>FlutterView flutterView = Flutter.createView(this, getLifecycle(), &quot;route1&quot;);    
setContentView(flutterView);

//或者：

setContentView(R.layout.activity_flutter);
rlContainer = findViewById(R.id.rl_container);
rlContainer.addView(flutterView)
</code></pre><h2 id="集成到现有项目遇到的坑"><a href="#集成到现有项目遇到的坑" class="headerlink" title="集成到现有项目遇到的坑"></a>集成到现有项目遇到的坑</h2><p>Check failed: vm. Must be able to initialize the VM：</p>
<pre><code>E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.
    [ERROR:flutter/runtime/dart_vm.cc(241)] Could not setup VM data to bootstrap the VM from.
    [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance.
 A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.

SIGABRT
    0x146b
    #00    pc 0002210c    /system/lib/libc.so (tgkill+12) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #01    pc 00013165    /system/lib/libc.so (pthread_kill+48) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #02    pc 00013379    /system/lib/libc.so (raise+10) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #03    pc 000120a3    /system/lib/libc.so [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #04    pc 000219c0    /system/lib/libc.so (abort+4) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #05    pc 00af85ab    /data/app-lib/xxx.debug-1/libflutter.so [armeabi-v7a::a12434e0b53806a35730000001000000]
</code></pre><p>经github上<a href="https://github.com/flutter/flutter/issues/24679" target="_blank" rel="noopener">#24679</a>及其他issue参考，得出以下解决方案：</p>
<blockquote>
<p>Import flutter module to your HOST app(set binding, implementation, and instantiate view/fragment)<br>When you clean/rebuild from HOST app, flutter module does not generate properly<br>You need to open your flutter module in a separate AS<br>flutter clean<br>cd .android<br>./gradlew clean<br>./gradlew assembleDebug<br>Return to host app and run app(do not sync or rebuild) :)</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>本项目执行清理命令。./gradlew clean<br>进入 flutter module 项目执行清理命令。flutter packages get;flutter clean<br>进入 flutter module 的 .android 项目执行清理命令和打包操作。./gradlew clean;./gradlew assemble<br>回到本项目执行打包命令。./gradlew assemble</p>
</blockquote>
<p>直接执行下面命令即可：</p>
<pre><code>$ ./gradlew clean;cd ../flutter_module;flutter packages get;flutter clean;cd .android/;./gradlew clean;./gradlew assemble;cd /d/workspace/app_proj/;./gradlew installDebug
</code></pre><p>后续假设你 flutter module 没有更新过，那么以后修改本地项目之后，就直接执行./gradlew installDebug。 注意不要用studio工具运行、rebuild或clean。</p>
<h3 id="flutter-assets"><a href="#flutter-assets" class="headerlink" title="flutter_assets"></a>flutter_assets</h3><p>assets下缺少flutter_assets也有可能造成此问题。具体可以参考：<a href="https://www.jianshu.com/p/2d0bba84e57e" target="_blank" rel="noopener">https://www.jianshu.com/p/2d0bba84e57e</a></p>
<h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><p>按照上述方式，debug版本没问题，release却报错。需加以下混淆：</p>
<pre><code>-keep class io.flutter.app.** { *; }
-keep class io.flutter.plugin.** { *; }
-keep class io.flutter.util.** { *; }
-keep class io.flutter.view.** { *; }
-keep class io.flutter.** { *; }
-keep class io.flutter.plugins.** { *; }
-keep class myapp.flutter.** { *; }
</code></pre><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><h3 id="Flutter-调用Android"><a href="#Flutter-调用Android" class="headerlink" title="Flutter 调用Android"></a>Flutter 调用Android</h3><p>java</p>
<pre><code>new MethodChannel(flutterView, FlutterToAndroidCHANNEL).setMethodCallHandler(new MethodChannel.MethodCallHandler() {
    @Override
    public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) {

        //接收来自flutter的指令withoutParams
        if (methodCall.method.equals(&quot;withoutParams&quot;)) {

            //跳转到指定Activity
            Intent intent = new Intent(NativeActivity.this, NativeActivity.class);
            startActivity(intent);

            //返回给flutter的参数
            result.success(&quot;success&quot;);
        }
        //接收来自flutter的指令withParams
        else if (methodCall.method.equals(&quot;withParams&quot;)) {

            //解析参数
            String text = methodCall.argument(&quot;flutter&quot;);

            //带参数跳转到指定Activity
            Intent intent = new Intent(NativeActivity.this, NativeActivity.class);
            intent.putExtra(&quot;test&quot;, text);
            startActivity(intent);

            //返回给flutter的参数
            result.success(&quot;success&quot;);
        } else {
            result.notImplemented();
        }
    }
});
</code></pre><p>dart</p>
<pre><code>Future&lt;Null&gt; _jumpToNative() async {
  String result = await toAndroidPlugin.invokeMethod(&apos;withoutParams&apos;);

  print(result);
}


Future&lt;Null&gt; _jumpToNativeWithParams() async {

  Map&lt;String, String&gt; map = { &quot;flutter&quot;: &quot;这是一条来自flutter的参数&quot; };

  String result = await toAndroidPlugin.invokeMethod(&apos;withParams&apos;, map);

  print(result);
}
</code></pre><h3 id="Android-向-Flutter-传参"><a href="#Android-向-Flutter-传参" class="headerlink" title="Android 向 Flutter 传参"></a>Android 向 Flutter 传参</h3><p>java</p>
<pre><code>new EventChannel(flutterView, AndroidToFlutterCHANNEL)
            .setStreamHandler(new EventChannel.StreamHandler() {
                @Override
                public void onListen(Object o, EventChannel.EventSink eventSink) {
                    String androidParmas = &quot;来自android原生的参数&quot;;
                    eventSink.success(androidParmas);
                }

                @Override
                public void onCancel(Object o) {

                }
            });
</code></pre><p>dart</p>
<pre><code> void _startfromAndroiPlugin(){
   if(_fromAndroiSub == null){
     _fromAndroiSub =  fromAndroiPlugin.receiveBroadcastStream()
     .listen(_onfromAndroiEvent,onError: _onfromAndroiError);
   }
 }

void _onfromAndroiEvent(Object event) {
   setState(() {
     _nativeParams = event;
   });
 }

 void _onfromAndroiError(Object error) {
   setState(() {
     _nativeParams = &quot;error&quot;;
     print(error);
   });
 }
</code></pre><p>有几处 要注意一一对应：</p>
<pre><code>public static final String FlutterToAndroidCHANNEL = &quot;com.litngzhe.toandroid/plugin&quot;; 
public static final String AndroidToFlutterCHANNEL= &quot;com.litngzhe.toflutter/plugin&quot;;

new MethodChannel(flutterView, FlutterToAndroidCHANNEL)
new EventChannel(flutterView, AndroidToFlutterCHANNEL) 


//dart中 获取到插件与原生的交互通道 MethodChannel 中 涉及到的方法名要要统一
static const toAndroidPlugin = const MethodChannel(&apos;com.litngzhe.toandroid/plugin&apos;);
static const fromAndroiPlugin = const EventChannel(&apos;com.litngzhe.toflutter/plugin&apos;); 
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/chinaltz/FlutterDemo" target="_blank" rel="noopener">FlutterDemo</a><br><a href="https://juejin.im/post/5c74dbeee51d45708f2a20c6" target="_blank" rel="noopener">https://juejin.im/post/5c74dbeee51d45708f2a20c6</a><br><a href="https://github.com/flutter/flutter/issues/24679" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/24679</a><br><a href="https://github.com/flutter/flutter/issues/25147" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/25147</a><br><a href="https://mp.weixin.qq.com/s/OGbH3G3wHVTUt-0EJit8RA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OGbH3G3wHVTUt-0EJit8RA</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/25/dart-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/25/dart-knowledge/" itemprop="url">Dart语言基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-25T18:31:42+08:00">
                2019-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hybrid-Develop/" itemprop="url" rel="index">
                    <span itemprop="name">Hybrid Develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>在Dart中，一切都是对象，一切对象都是class的实例，哪怕是数字类型、方法甚至null都是对象，所有的对象都是继承自Object</li>
<li>虽然Dart是强类型语言，但变量类型是可选的，因为Dart可以自动推断变量类型</li>
<li>Dart支持范型，List&lt;int&gt;表示一个整型的数据列表，List&lt;dynamic&gt;则是一个对象的列表，其中可以装任意对象</li>
<li>Dart支持顶层方法（如main方法），也支持类方法或对象方法，同时你也可以在方法内部创建方法</li>
<li>Dart支持顶层变量，也支持类变量或对象变量</li>
<li>跟Java不同的是，Dart没有public protected private等关键字，如果某个变量以下划线（_）开头，代表这个变量在库中是私有的</li>
<li>Dart中变量可以以字母或下划线开头，后面跟着任意组合的字符或数字</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>以下代码是Dart中定义变量的方法：</p>
<pre><code>main() {
  var a = 1;
  int b = 10;
  String s = &quot;hello&quot;;
  dynamic c = 0.5;

  var count = 10; 
  final Num = count;  // final 只能赋值一次
  const Num1 = 10; // const赋值必须是编译时常量
}
</code></pre><p>你<strong>可以明确指定某个变量的类型，如int bool String，也可以用var或 dynamic来声明一个变量，Dart会自动推断其数据类型</strong>。</p>
<p>使用final或const，不要使用var或其他类型，一个被final修饰的变量只能被赋值一次，一个被const修饰的变量是一个编译时常量（const常量毫无疑问也是final常量）。final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量；而 const 要求在声明时初始化，并且赋值必需为编译时常量。</p>
<p>注意：<strong>没有赋初值的变量都会有默认值null</strong><br>注意：实例变量可以是final的但不能是const的</p>
<h3 id="内建数据类型"><a href="#内建数据类型" class="headerlink" title="内建数据类型"></a>内建数据类型</h3><p>Dart有如下几种内建的数据类型：</p>
<ul>
<li>numbers</li>
<li>strings</li>
<li>booleans</li>
<li>lists(或者是arrays)</li>
<li>maps</li>
<li>runes（UTF-32字符集的字符）</li>
<li><p>symbols<br>下面用一段代码来演示以上各类数据类型：</p>
<pre><code>main() {
  // numbers
  var a = 0;
  int b = 1;
  double c = 0.1;

  // strings
  var s1 = &apos;hello&apos;;
  String s2 = &quot;world&quot;;

  // booleans
  var real = true;
  bool isReal = false;

  // lists
  var arr = [1, 2, 3, 4, 5];
  List&lt;String&gt; arr2 = [&apos;hello&apos;, &apos;world&apos;, &quot;123&quot;, &quot;456&quot;];
  List&lt;dynamic&gt; arr3 = [1, true, &apos;haha&apos;, 1.0];

  // maps
  var map = new Map();
  map[&apos;name&apos;] = &apos;zhangsan&apos;;
  map[&apos;age&apos;] = 10;
  Map m = new Map();
  m[&apos;a&apos;] = &apos;a&apos;;

  //runes，Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符
  var clapping = &apos;\u{1f44f}&apos;;
  print(clapping); // 打印的是拍手emoji的表情

  // symbols
  print(#s == new Symbol(&quot;s&quot;)); // true
}
</code></pre></li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Dart是一个面向对象的编程语言，所以即使是<strong>函数也是一个对象</strong>，也有一种类型Function，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。虽然Dart推荐你给函数加上返回值，但是不加返回值的函数同样可以正常工作，另外你还可以用=&gt;代替return语句，比如下面的代码：</p>
<pre><code>// 声明返回值
int add(int a, int b) {
  return a + b;
}

// 不声明返回值
add2(int a, int b) {
  return a + b;
}

// =&gt;是return语句的简写
add3(a, b) =&gt; a + b; 

main() {
  print(add(1, 2)); // 3
  print(add2(2, 3)); // 5
  print(add3(1, 2)); // 3
}
</code></pre><h4 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h4><pre><code>sayHello({String name}) {
  print(&quot;hello, my name is $name&quot;);
}

sayHello2({name: String}) {
  print(&quot;hello, my name is $name&quot;);
}

main() {
  // 打印 hello, my name is zhangsan
  sayHello(name: &apos;zhangsan&apos;);

  // 打印 hello, my name is wangwu
  sayHello2(name: &apos;wangwu&apos;);
}
</code></pre><p>可以看到，定义命名参数时，你<strong>可以以 {type paramName} 或者 {paramName: type} 两种方式声明参数</strong>，而调用命名参数时，需要以 funcName(paramName: paramValue) 的形式调用。</p>
<p>命名参数的<strong>参数并不是必须的</strong>，所以上面的代码中，如果调用sayHello()不带任何参数，也是可以的，只不过最后打印出来的结果是：hello, my name is null，在Flutter开发中，你<strong>可以使用@required注解来标识一个命名参数，这代表该参数是必须的</strong>，你不传则会报错，比如下面的代码：</p>
<pre><code>const Scrollbar({Key key, @required Widget child})
</code></pre><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>使用<strong>中括号[]括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面</strong>，如下代码所示：</p>
<pre><code>sayHello(String name, int age, [String hobby]) { // 位置参数可以有多个，比如[String a, int b]
  StringBuffer sb = new StringBuffer();
  sb.write(&quot;hello, this is $name and I am $age years old&quot;);
  if (hobby != null) {
    sb.write(&quot;, my hobby is $hobby&quot;);
  }
  print(sb.toString());
}

main() {
  // hello, this is zhangsan and I am 20 years old
  sayHello(&quot;zhangsan&quot;, 20);
  // hello, this is zhangsan and I am 20 years old, my hobby is play football
  sayHello(&quot;zhangsan&quot;, 20, &quot;play football&quot;);
}
</code></pre><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>你可以为命名参数或者位置参数设置默认值，如下代码所示：</p>
<pre><code>// 命名参数的默认值
int add({int a, int b = 3}) { // 不能写成：int add({a: int, b: int = 3})
  return a + b;
}

// 位置参数的默认值
int sum(int a, int b, [int c = 3]) {
  return a + b + c;
}
</code></pre><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h4><p>不论在Dart还是Flutter中，必须都需要一个顶层的main()函数，它<strong>是整个应用的入口函数，main()函数的返回值是void，还有一个可选的参数，参数类型是List&lt;String&gt;</strong>。</p>
<h4 id="函数作为一类对象"><a href="#函数作为一类对象" class="headerlink" title="函数作为一类对象"></a>函数作为一类对象</h4><p>你可以将一个函数作为参数传给另一个函数，比如下面的代码：</p>
<pre><code>printNum(int a) {
  print(&quot;$a&quot;);
}

main() {
  //  依次打印：
  //  1
  //  2
  //  3
  var arr = [1, 2, 3];
  arr.forEach(printNum);
}
</code></pre><p>你也可以将一个函数赋值给某个变量，比如下面的代码：</p>
<pre><code>printNum(int a) {
  print(&quot;$a&quot;);
}

main() {
  var f1 = printNum;
  Function f2 = printNum;
  var f3 = (int a) =&gt; print(&quot;a = $a&quot;);
  f1(1);
  f2(2);
  f3(6);
}
</code></pre><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>大多数函数都是有名称的，比如main() printName()等，但是你也可以写匿名函数，如果你对Java比较熟悉，那下面的Dart代码你肯定也不会陌生：</p>
<pre><code>test(Function callback) {
  callback(&quot;hello&quot;);
}

main() {
  test((param) {
    // 打印hello
    print(param);
  });
}
</code></pre><p>匿名函数类似于Java中的接口，往往在某个函数的参数为函数时使用到。</p>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p><strong>所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null</strong></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Dart中的运算符与Java中的类似，比如++a a == b b ? a : b，但是也有一些与Java不太一样的运算符，下面用代码说明：</p>
<pre><code>main() {
  // 与Java相同的运算符操作

  int a = 1;
  ++a;
  a++;
  var b = 1;
  print(a == b);  // false
  print(a * b); // 3
  bool real = false;
  real ? print(&apos;real&apos;) : print(&apos;not real&apos;); // not real
  print(real &amp;&amp; a == b); // false
  print(real || a == 3); // true
  print(a != 2); // true
  print(a &lt;= b); // false
  var c = 9;
  c += 10;
  print(&quot;c = $c&quot;); // c = 19
  print(1&lt;&lt;2); // 4

  // 与Java不太一样的运算符操作

  // is运算符用于判断一个变量是不是某个类型的数据
  // is!则是判断变量不是某个类型的数据
  var s = &quot;hello&quot;;
  print(s is String); // true
  var num = 6;
  print(num is! String); // true

  // ~/才是取整运算符，如果使用/则是除法运算，不取整
  int k = 1;
  int j = 2;
  print(k / j); // 0.5
  print(k ~/ j); // 0

  // as运算符类似于Java中的cast操作，将一个对象强制类型转换
  (emp as Person).teach();

  // ??=运算符 如果 ??= 运算符前面的变量为null，则赋值，否则不赋值
  var param1 = &quot;hello&quot;, param2 = null;
  param1 ??= &quot;world&quot;;
  param2 ??= &quot;world&quot;;
  print(&quot;param1 = $param1&quot;); // param1 = hello
  print(&quot;param2 = $param2&quot;); // param2 = world

  // ?.运算符
  var str1 = &quot;hello world&quot;;
  var str2 = null;
  print(str1?.length); // 11
  print(str2?.length); // null 
  print(str2.length); // 报错
}
</code></pre><h4 id="运算符（级联操作）"><a href="#运算符（级联操作）" class="headerlink" title="..运算符（级联操作）"></a>..运算符（级联操作）</h4><p>如果你对Java中的建造者模式比较熟悉的话，Dart中的..运算符也很好理解，先看下面的代码：</p>
<pre><code>class Person {
  eat() {
    print(&quot;I am eating...&quot;);
  }

  sleep() {
    print(&quot;I am sleeping...&quot;);
  }

  study() {
    print(&quot;I am studying...&quot;);
  }
}

main() {
  // 依次打印
  //  I am eating...
  //  I am sleeping...
  //  I am studying...
  new Person()..eat()
      ..sleep()
      ..study();
}
</code></pre><p>可以看到，使用<strong>..调用某个对象的方法（或者成员变量）时，返回值是这个对象本身</strong>，所以你可以接着使用..调用这个对象的其他方法，这不就类似于Java中的建造者模式，每次build某个属性时，都返回一个this对象吗。</p>
<h3 id="typedefs"><a href="#typedefs" class="headerlink" title="typedefs"></a>typedefs</h3><p>typedef 本质上为 一个方法签名提供了一个别名。官网上介绍TypeDef的时候有一句话说道：<br>“If we change the code to use explicit names and retain type information”<br>使用typedef会保留方法的类型信息。</p>
<p>考虑下面的代码，哪一个没有使用 typedef。</p>
<pre><code>class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

 // Initial, broken implementation.
 int sort(Object a, Object b) =&gt; 0;

main() {
  SortedCollection coll = new SortedCollection(sort);

  // All we know is that compare is a function,
  // but what type of function?
  assert(coll.compare is Function);
}
</code></pre><p>当 f 分配到 compare 的时候类型信息丢失了。f的类型是 (Object, Object) → int(→ 意味着返回的)，然而compare 的类型是方法。如果我们使用显式的名字更改代码并保留类型信息，则开发者和工具都可以使用这些信息。</p>
<pre><code>typedef int Compare(Object a, Object b);

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

 // Initial, broken implementation.
 int sort(Object a, Object b) =&gt; 0;

main() {
  SortedCollection coll = new SortedCollection(sort);
  assert(coll.compare is Function);
  assert(coll.compare is Compare);
}
</code></pre><p>请注意目前 typedefs 仅限于函数类型。</p>
<p>因为 typedefs 是简单的别名，所以它提供了一种方法来检查任何函数的类型。比如：</p>
<pre><code>typedef int Compare(int a, int b);

int sort(int a, int b) =&gt; a - b;

main() {
  assert(sort is Compare); // True!
}
</code></pre><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>if / else switch for /while try / catch语句跟Java中都类似，<strong>try / catch语句可能稍有不同</strong>，下面用一段代码说明：</p>
<pre><code>main() {
  // if else语句
  int score = 80;
  if (score &lt; 60) {
    print(&quot;so bad!&quot;);
  } else if (score &gt;= 60 &amp;&amp; score &lt; 80) {
    print(&quot;just so so!&quot;);
  } else if (score &gt;= 80) {
    print(&quot;good job!&quot;);
  }

  // switch语句
  String a = &quot;hello&quot;;
  // case语句中的数据类型必须是跟switch中的类型一致
  switch (a) {
    case &quot;hello&quot;:
      print(&quot;haha&quot;);
      break;
    case &quot;world&quot;:
      print(&quot;heihei&quot;);
      break;
    default:
      print(&quot;WTF&quot;);
  }

  // for语句
  List&lt;String&gt; list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
  for (int i = 0; i &lt; list.length; i++) {
    print(list[i]);
  }
  for (var i in list) {
    print(i);
  }
  // 这里的箭头函数参数必须用圆括号扩起来
  list.forEach((item) =&gt; print(item));

  // while语句
  int start = 1;
  int sum = 0;
  while (start &lt;= 100) {
    sum += start;
    start++;
  }
  print(sum);

  // try catch语句
  try {
    print(1 ~/ 0);
  } catch (e) {
    // IntegerDivisionByZeroException
    print(e);
  }
  try {
    1 ~/ 0;
  } on IntegerDivisionByZeroException { // 捕获指定类型的异常
    print(&quot;error&quot;); // 打印出error
  } finally {
    print(&quot;over&quot;); // 打印出over
  }
}
</code></pre><h4 id="rethrow"><a href="#rethrow" class="headerlink" title="rethrow"></a>rethrow</h4><p>rethrow语句用来处理一个异常，同时<strong>希望这个异常能够被其它调用的部分使用</strong>:</p>
<pre><code>final foo = &apos;&apos;;

void misbehave() {
   try {
     foo = &quot;1&quot;;
   } catch (e) {
     print(&apos;2&apos;);
     rethrow;// 如果不重新抛出异常，main函数中的catch语句执行不到
   }
}

void main() {
   try {
     misbehave();
   } catch (e) {
     print(&apos;3&apos;);
   }
}
</code></pre><h3 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h3><h4 id="类的定义与构造方法"><a href="#类的定义与构造方法" class="headerlink" title="类的定义与构造方法"></a>类的定义与构造方法</h4><p>Dart中的类没有访问控制，所以你不需要用private, protected, public等修饰成员变量或成员函数，一个简单的类如下代码所示：</p>
<pre><code>class Person {
  String name;
  int age;
  String gender;
  Person(this.name, this.age, this.gender);
  sayHello() {
    print(&quot;hello, this is $name, I am $age years old, I am a $gender&quot;);
  }
}
</code></pre><p>上面的Person类中有3个成员变量，一个构造方法和一个成员方法，看起来<strong>比较奇怪的是Person的构造方法，里面传入的3个参数都是this.xxx，而且没有大括号{}包裹的方法体</strong>，这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码：</p>
<pre><code>Person(String name, int age, String gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
}
</code></pre><p>要调用Person类的成员变量或成员方法，可以用下面的代码：</p>
<pre><code>var p = new Person(&quot;zhangsan&quot;, 20, &quot;male&quot;);
p.sayHello(); // hello, this is zhangsan, I am 20 years old, I am a male
p.age = 50;
p.gender = &quot;female&quot;;
p.sayHello(); // hello, this is zhangsan, I am 50 years old, I am a female
</code></pre><p>类除了有跟类名相同的构造方法外，<strong>还可以添加命名的构造方法</strong>，如下代码所示：</p>
<pre><code>class Point {
  num x, y;
  Point(this.x, this.y);
  // 类的命名构造方法
  Point.origin() {
    x = 0;
    y = 0;
  }
}

main() {
  // 调用Point类的命名构造方法origin()
  var p = new Point.origin();
  var p2 = new Point(1, 2);
}
</code></pre><p>Dart中使用extends关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：</p>
<pre><code>class Human {
  String name;
  Human.fromJson(Map data) {
    print(&quot;Human&apos;s fromJson constructor&quot;);
  }
}

class Man extends Human {
  Man.fromJson(Map data) : super.fromJson(data) {
    print(&quot;Man&apos;s fromJson constructor&quot;);
  }
}
</code></pre><p>由于<strong>Human类没有默认构造方法，只有一个命名构造方法fromJson，所以在Man类继承Human类时，需要调用父类的fromJson方法做初始化，而且必须使用Man.fromJson(Map data) : super.fromJson(data)这种写法</strong>，而不是像Java那样将super写到花括号中。Dart语言中，<strong>子类不会继承父类的命名构造函数</strong>。如果不显式提供子类的构造函数，系统就提供默认的构造函数。</p>
<p>有时候你仅仅只是在某个类的构造方法中，调用这个类的另一个构造方法，你可以这么写：</p>
<pre><code>class Point {
  num x, y;
  Point(this.x, this.y);
  // 命名构造方法调用了默认的构造方法
  Point.alongXAxis(num x) : this(x, 0);
}
</code></pre><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>除了调用父类的构造函数，也可以通过初始化列表<strong>在子类的构造函数体前（大括号前）来初始化实例的变量值，使用逗号,分隔</strong>。如下所示：</p>
<pre><code>class Point {
   num x;
   num y;

   Point(this.x, this.y);

   // 初始化列表在构造函数运行前设置实例变量。
   Point.fromJson(Map jsonMap)
   : x = jsonMap[&apos;x&apos;],
     y = jsonMap[&apos;y&apos;] {
      print(&apos;In Point.fromJson(): ($x, $y)&apos;);
   }
 }
</code></pre><p>注意：上述代码，初始化程序无法访问 this 关键字。</p>
<h4 id="类的成员方法"><a href="#类的成员方法" class="headerlink" title="类的成员方法"></a>类的成员方法</h4><p>一个类的成员方法是一个函数，为这个类提供某些行为。上面的代码中已经有了一些类的成员方法的定义，这些定义方式跟Java很类似，你可以为某个类的成员变量提供getter/setter方法，如下代码：</p>
<pre><code>class Rectangle {
  num left, top, width, height;

  // 构造方法传入left, top, width, height几个参数
  Rectangle(this.left, this.top, this.width, this.height);

  // right, bottom两个成员变量提供getter/setter方法
  num get right =&gt; left + width;
  set right(num value) =&gt; left = value - width;
  num get bottom =&gt; top + height;
  set bottom(num value) =&gt; top = value - height;
}
</code></pre><h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><p>使用abstract修饰一个类，则这个类是抽象类，抽象类中可以有抽象方法和非抽象方法，抽象方法没有方法体，需要子类去实现，如下代码：</p>
<pre><code>abstract class Doer {
  // 抽象方法，没有方法体，需要子类去实现
  void doSomething();
  // 普通的方法
  void greet() {
    print(&quot;hello world!&quot;);
  }
}

class EffectiveDoer extends Doer {
  // 实现了父类的抽象方法
  void doSomething() {
    print(&quot;I&apos;m doing something...&quot;);
  }
}
</code></pre><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>Dart中有类似于C++中的运算符重载语法，比如下面的代码定义了一个向量类，重载了向量的+ -运算：</p>
<pre><code>class Vector {
  num x, y;
  Vector(this.x, this.y);
  Vector operator +(Vector v) =&gt; new Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) =&gt; new Vector(x - v.x, y - v.y);
  printVec() {
    print(&quot;x: $x, y: $y&quot;);
  }
}

main() {
  Vector v1 = new Vector(1, 2);
  Vector v2 = new Vector(3, 4);
  (v1 - v2).printVec(); // -2, -2
  (v1 + v2).printVec(); // 4, 6
}
</code></pre><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>使用enum关键字定义一个枚举类，这个语法跟Java类似，如下代码：</p>
<pre><code>enum Color { red, green, blue }
</code></pre><h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p>mixins是一个重复使用类中代码的方式，比如下面的代码：</p>
<pre><code>class A {
  a() {
    print(&quot;A&apos;s a()&quot;);
  }
}

class B {
  b() {
    print(&quot;B&apos;s b()&quot;);
  }
}

// 使用with关键字，表示类C是由类A和类B混合而构成
class C = A with B;

main() {
  C c = new C();
  c.a(); // A&apos;s a()
  c.b(); // B&apos;s b()
}
</code></pre><p>Dart和Java一样只支持单继承。而且Dart中没有和Java一样提供Interface字段去声明一个接口。如果想使用和Java接口一样的功能可以使用Mixins和implements两种方式，分别解释下两种方式：</p>
<ul>
<li><strong>Mixins : 指能够将另一个或多个类的功能添加到您自己的类中，而无需继承这些类</strong></li>
<li><p><strong>implements : 将一个类作为接口使用</strong></p>
<pre><code>class A {
  void a() {
    print(&apos;a&apos;);
  }
}

class B implements A {
  @override
  void a() {
    print(&apos;override a&apos;);
  }
}

class C {
  void c() {
    print(&apos;c&apos;);
  }
}

class E {
  String e = &apos;eeee&apos;;
}

class D extends A with C, E {
  void c() {
    print(&apos;c is D&apos;);
  }

  void d() {
    c();
  }
}
</code></pre></li>
</ul>
<p>首先看B implements A，所以此时A相对于B来说就是一个接口，所以他要实现B中的方法。换句话说，<strong>Dart每个类都是接口</strong></p>
<h4 id="静态成员变量和静态成员方法"><a href="#静态成员变量和静态成员方法" class="headerlink" title="静态成员变量和静态成员方法"></a>静态成员变量和静态成员方法</h4><pre><code>// 类的静态成员变量和静态成员方法
class Cons {
  static const name = &quot;zhangsan&quot;;
  static sayHello() {
    print(&quot;hello, this is ${Cons.name}&quot;);
  }
}

main() {
  Cons.sayHello(); // hello, this is zhangsan
  print(Cons.name); // zhangsan
}
</code></pre><h3 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h3><p>Java和C++语言都有泛型，Dart语言也不例外，使用泛型有很多好处，比如：<br>正确指定泛型类型会产生更好的生成代码。<br>泛型可以减小代码的复杂度<br>Dart内置的数据类型List就是一个泛型数据类型，你可以往List中塞任何你想的数据类型比如整型、字符串、布尔值等</p>
<h3 id="Dart库（Libraries）"><a href="#Dart库（Libraries）" class="headerlink" title="Dart库（Libraries）"></a>Dart库（Libraries）</h3><p>Dart目前已经有很多的库提供给开发者，许多功能不需要开发者自己去实现，只需要导入对应的包即可，使用import语句来导入某个包，比如下面的代码：</p>
<pre><code>import &apos;dart:html&apos;;
</code></pre><p>如果你想导入自己写的某个代码文件，使用相对路径即可，例如当前有一个demo.dart文件，跟该文件同级目录下有个util.dart文件，文件代码如下：</p>
<pre><code>// util.dart文件内容

int add(int a, int b) {
  return a + b;
}
</code></pre><p>在demo.dart文件中如果要引用util.dart文件，使用下面的方式导入：</p>
<pre><code>import &apos;./util.dart&apos;;

main() {
  print(add(1, 2));
}
</code></pre><p>你可以<strong>使用as关键字为导入的某个包设置一个前缀，或者说别名</strong>，比如下面的代码：</p>
<pre><code>import &apos;package:lib1/lib1.dart&apos;;
import &apos;package:lib2/lib2.dart&apos; as lib2;

// Uses Element from lib1.
Element element1 = Element();

// Uses Element from lib2.
lib2.Element element2 = lib2.Element();
</code></pre><p>你也可以在导入包时<strong>使用show hide关键字来导入某个包中的部分功能</strong>，比如下面的代码：</p>
<pre><code>// 只导入foo
import &apos;package:lib1/lib1.dart&apos; show foo;

// 导入除了foo的所有其他部分
import &apos;package:lib2/lib2.dart&apos; hide foo;
</code></pre><p>导入包时使用<strong>deferred as可以让这个包懒加载</strong>，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如下面的代码：</p>
<pre><code>import &apos;package:greetings/hello.dart&apos; deferred as hello;
</code></pre><p>利用<strong>library identifier（库标识符）声明库</strong>：</p>
<pre><code>// 声明库，名ballgame
library ballgame;

// 导入html库
import &apos;dart:html&apos;;

// ...代码从这里开始... 
</code></pre><h4 id="关联文件与库"><a href="#关联文件与库" class="headerlink" title="关联文件与库"></a>关联文件与库</h4><p>添加实现文件，把<strong>part fileUri</strong>放在有库的文件，其中fileURI是实现文件的路径。然后在实现文件中，添加部分标识符（<strong>part of identifier</strong>），其中标识符是库的名称。下面的示例使用的一部分，在三个文件来实现部分库。</p>
<p>第一个文件，ballgame.dart，声明球赛库，导入其他需要的库，并指定ball.dart和util.dart是此库的部分：</p>
<pre><code>library ballgame;

import &apos;dart:html&apos;;
// ...其他导入在这里...

part &apos;ball.dart&apos;;
part &apos;util.dart&apos;;

// ...代码从这里开始...
</code></pre><p>第二、三个文件ball.dart、util.dart，实现了球赛库的一部分：</p>
<pre><code>part of ballgame;

// ...代码从这里开始...
</code></pre><h4 id="重新导出库-Re-exporting-libraries"><a href="#重新导出库-Re-exporting-libraries" class="headerlink" title="重新导出库(Re-exporting libraries)"></a>重新导出库(Re-exporting libraries)</h4><p>可以通过重新导出部分库或者全部库来组合或重新打包库。例如，你可能有实现为一组较小的库集成为一个较大库。或者你可以创建一个库，提供了从另一个库方法的子集:</p>
<pre><code>// In french.dart:
library french;

hello() =&gt; print(&apos;Bonjour!&apos;);
goodbye() =&gt; print(&apos;Au Revoir!&apos;);


// In togo.dart:
library togo;

import &apos;french.dart&apos;;
export &apos;french.dart&apos; show hello;


// In another .dart file:
import &apos;togo.dart&apos;;

void main() {
    hello();   //print bonjour
    goodbye(); //FAIL
}
</code></pre><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>Dart是单线程模型，也就没有了所谓的主线程/子线程之分。</p>
<p>Dart提供了类似ES7中的async await等异步操作，Dart库大多方法返回 Future 和 Stream 对象。这些方法是异步的：它们在设置一个可能的耗时操作（比如 I/O 操作）之后返回，而无需等待操作完成。</p>
<p>async和await往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成async，并给其中的耗时操作加上await关键字，如果这个方法有返回值，你需要将返回值塞到Future中并返回，如下代码所示：</p>
<pre><code>Future checkVersion() async {
  var version = await lookUpVersion();
  // Do something with version
}
</code></pre><p>下面的代码使用Dart从网络获取数据并打印出来：</p>
<pre><code>import &apos;dart:async&apos;;
import &apos;package:http/http.dart&apos; as http;

Future&lt;String&gt; getNetData() async{
  http.Response res = await http.get(&quot;https://www.baidu.com&quot;);
  return res.body;
}

main() {
  getNetData().then((str) {
    print(str);
  });
}
</code></pre><h4 id="Even-Looper"><a href="#Even-Looper" class="headerlink" title="Even-Looper"></a>Even-Looper</h4><p>Dart是单线程模型，也就没有了所谓的主线程/子线程之分。<br>Dart也是Event-Looper以及Event-Queue的模型，所有的事件都是通过EventLooper的依次执行。而Dart的Event Loop就是：</p>
<ul>
<li>从EventQueue中获取Event</li>
<li>处理Event</li>
<li>直到EventQueue为空</li>
</ul>
<p><img src="/2019/06/25/dart-knowledge/event-loop.png" alt><br>而这些Event包括了用户输入，点击，Timer，文件IO等</p>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>一旦某个Dart的函数开始执行，它将执行到这个函数结束，也就是<strong>Dart的函数不会被其他Dart代码打断</strong>。</p>
<p>Dart中没有线程的概念，只有isolate，每个isolate都是隔离的，并不会共享内存。而一个Dart程序是在Main isolate的main函数开始，而<strong>在Main函数结束后，Main isolate线程开始一个一个（one by one）的开始处理Event Queue中的每一个Event</strong>。</p>
<p><img src="/2019/06/25/dart-knowledge/event-loop-and-main.png" alt title="Main isolate"></p>
<h4 id="Event-Queue以及Microtask-Queue"><a href="#Event-Queue以及Microtask-Queue" class="headerlink" title="Event Queue以及Microtask Queue"></a>Event Queue以及Microtask Queue</h4><p>Dart中的Main Isolate只有一个Event Looper，但是存在两个Event Queue:Event Queue以及Microtask Queue。</p>
<p><strong><em>Microtask Queue存在的意义是：希望通过这个Queue来处理稍晚一些的事情，但是在下一个消息到来之前需要处理完的事情。</em></strong></p>
<p>当<strong>Event Looper正在处理Microtask Queue中的Event时候，Event Queue中的Event就停止了处理了</strong>，此时App不能绘制任何图形，不能处理任何鼠标点击，不能处理文件IO等等</p>
<p>Event-Looper挑选Task的执行顺序为：1.优先全部执行完Microtask Queue中的Event；2.直到Microtask Queue为空时，才会执行Event Queue中的Event：</p>
<p><img src="/2019/06/25/dart-knowledge/both-queues.png" alt title="both-queues"><br><strong>Dart中只能知道Event处理的先后顺序，但是并不知道某个Event执行的具体时间点，因为它的处理模型是一个单线程循环</strong>，而不是基于时钟调度（即它的执行只是按照Event处理完，就开始循环下一个Event，而与Java中的Thread调度不一样，没有时间调度的概念），也就是我们既是指定另一个Delay Time的Task，希望它在预期的时间后开始执行，它有可能不会在那个时间执行，需要看是否前面的Event是否已经Dequeue。</p>
<h4 id="异步任务调度"><a href="#异步任务调度" class="headerlink" title="异步任务调度"></a>异步任务调度</h4><p>当有代码可以在后续任务执行的时候，有两种方式，通过dart:async这个Lib中的API即可：</p>
<ul>
<li>使用Future类，可以将任务加入到Event Queue的队尾</li>
<li>使用scheduleMicrotask函数，将任务加入到Microtask Queue队尾</li>
</ul>
<p>当使用EventQueue时，需要考虑清楚，<strong>尽量避免microtask queue过于庞大，否则会阻塞其他事件的处理</strong>：</p>
<p><img src="/2019/06/25/dart-knowledge/scheduling-tasks.png" alt title="scheduling-tasks"></p>
<h4 id="使用Future"><a href="#使用Future" class="headerlink" title="使用Future"></a>使用Future</h4><p>一般常用的Future构造函数：</p>
<pre><code>new Future((){
    //  doing something
});
</code></pre><p>而一般常用的还有当有分治任务时，需要将一个大任务拆成很多小任务一步步执行时，就需要使用到Future.then函数来拆解任务</p>
<pre><code>void main(){
new Future(() =&gt; futureTask)  //  异步任务的函数
        .then((m) =&gt; &quot;futueTask execute result:$m&quot;)  //   任务执行完后的子任务
        .then((m) =&gt; m.length)  //  其中m为上个任务执行完后的返回的结果
        .then((m) =&gt; printLength(m))
        .whenComplete(() =&gt; whenTaskCompelete);  //  当所有任务完成后的回调函数
}

int futureTask() {
    return 21; 
}

void printLength(int length) {
    print(&quot;Text Length:$length&quot;);
}

void whenTaskCompelete() {
    print(&quot;Task Complete&quot;);
}
</code></pre><p>当任务需要延迟执行时，可以使用new Future.delay来将任务延迟执行，而如上所述，只有当Main isolate的Event Queue处于Idle的状态时，才会延迟1s执行，否则等待的时间会比1s长很多</p>
<pre><code>new Future.delayed(const Duration(seconds: 1), () =&gt; futureTask);
</code></pre><p>当需要做动画的时候，不要使用Future，而需要使用<a href="https://api.dartlang.org/stable/1.24.3/dart-html/Window/animationFrame.html" target="_blank" rel="noopener">animateFrame</a></p>
<p>PS:</p>
<ul>
<li>Future中的then并没有创建新的Event丢到Event Queue中，而只是一个普通的Function Call，在FutureTask执行完后，立即开始执行</li>
<li>当Future在then函数之前已经执行完成了，则会创建一个task，将该task的添加到microtask queue中，并且该任务将会执行通过then传入的函数</li>
<li>Future只是创建了一个Event，将Event插入到了Event Queue的队尾</li>
<li>使用Future.value构造函数的时候，就会和第二条一样，创建Task丢到microtask Queue中执行then传入的函数</li>
<li>Future.sync构造函数执行了它传入的函数之后，也会立即创建Task丢到microtask Queue中执行</li>
</ul>
<h4 id="使用scheduleMicrotask"><a href="#使用scheduleMicrotask" class="headerlink" title="使用scheduleMicrotask"></a>使用scheduleMicrotask</h4><p>在最顶层的调用关系中，使用该函数即可：</p>
<pre><code>async.scheduleMicrotask(() =&gt; microtask());

void microtask(){
  //  doing something
}
</code></pre><h4 id="使用isolate以及Worker"><a href="#使用isolate以及Worker" class="headerlink" title="使用isolate以及Worker"></a>使用isolate以及Worker</h4><p>当有计算很繁重的任务时，则需要使用isolate或者Worker来执行，以保持App对用户操作的及时响应。Isolate的实现可能是一个单独的线程，或者一个单独的进程，需要看Dart VM是如何实现的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/06aebcad0543" target="_blank" rel="noopener">https://www.jianshu.com/p/06aebcad0543</a><br><a href="https://www.jianshu.com/p/9e5f4c81cc7d" target="_blank" rel="noopener">https://www.jianshu.com/p/9e5f4c81cc7d</a><br><a href="https://www.jianshu.com/p/a4affde4c8ca" target="_blank" rel="noopener">Flutter–Dart中的异步</a><br><a href="https://dart.dev/articles/archive/event-loop" target="_blank" rel="noopener">https://dart.dev/articles/archive/event-loop</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/25/flutter-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/25/flutter-knowledge/" itemprop="url">Flutter知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-25T18:22:12+08:00">
                2019-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hybrid-Develop/" itemprop="url" rel="index">
                    <span itemprop="name">Hybrid Develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h2><p>在Flutter中，View相当于是Widget。<strong>Widget仅支持一帧</strong>，并且在每一帧上，Flutter的框架都会创建一个Widget实例树(相当于一次性绘制整个界面)。在Flutter中的widget是不可变的，这允许widget变得超级轻量。</p>
<h3 id="Widget状态"><a href="#Widget状态" class="headerlink" title="Widget状态"></a>Widget状态</h3><p>在Flutter中Widget是不可变的，不会直接更新，而必须使用Widget的状态。这是<strong>Stateful和Stateless widget</strong>的概念的来源。一个Stateless Widget就像它的名字，是一个没有状态信息的widget。</p>
<p>这里要注意的重要一点是无状态和有状态widget的核心特性是相同的。每一帧它们都会重新构建，不同之处在于<strong>StatefulWidget有一个State对象，它可以跨帧存储状态数据并恢复它</strong>。</p>
<p>如果你有疑问，那么要记住这个规则：<strong>如果一个widget发生了变化（例如用户与它交互），它就是有状态的。但是，如果一个子widget对变化做出反应，而其父widget对变化没有反应，那么包含的父widget仍然可以是无状态的widget。</strong></p>
<h3 id="Widget编写"><a href="#Widget编写" class="headerlink" title="Widget编写"></a>Widget编写</h3><p>在Android中，您通过XML编写布局，但在Flutter中，使用widget树来编写布局。<br>可以查看Flutter所提供的所有布局: <a href="https://flutterchina.club/widgets/layout/" target="_blank" rel="noopener">Flutter widget layout</a></p>
<p>在Android中，您可以从父级控件调用addChild或removeChild以动态添加或删除View。 在Flutter中，因为widget是不可变的，所以没有addChild。相反，您可以传入一个函数，该函数返回一个widget给父项，并通过布尔值控制该widget的创建。</p>
<p>在Flutter中，可以通过动画库给widget添加动画，将widget包装到Animation中。与Android相似，在Flutter中，您有一个AnimationController和一个Interpolator， 它是Animation类的扩展，例如CurvedAnimation。您将控制器和动画传递到AnimationWidget中，并告诉控制器启动动画。<br>See <a href="https://flutter.io/widgets/animation/" target="_blank" rel="noopener">https://flutter.io/widgets/animation/</a> and <a href="https://flutter.io/tutorials/animation" target="_blank" rel="noopener">https://flutter.io/tutorials/animation</a> for more specific details.</p>
<p>Flutter有两个类可以帮助您绘制画布，CustomPaint和CustomPainter，它们实现您的算法以绘制到画布。<br>在这个人气较高的的StackOverFlow答案中，您可以看到签名painter是如何实现的：请参阅<a href="https://stackoverflow.com/questions/46241071/create-signature-area-for-mobile-app-in-dart-flutter" target="_blank" rel="noopener">https://stackoverflow.com/questions/46241071/create-signature-area-for-mobile-app-in-dart-flutter</a></p>
<h3 id="如何构建自定义-Widgets"><a href="#如何构建自定义-Widgets" class="headerlink" title="如何构建自定义 Widgets"></a>如何构建自定义 Widgets</h3><p>在Flutter中，<strong>一个自定义widget通常是通过组合其它widget来实现的，而不是继承</strong>。</p>
<p>我们来看看如何构建持有一个label的CustomButton。这是通过将Text与RaisedButton组合来实现的，而不是扩展RaisedButton并重写其绘制方法实现：</p>
<pre><code>class CustomButton extends StatelessWidget {
  final String label;
  CustomButton(this.label);

  @override
  Widget build(BuildContext context) {
    return new RaisedButton(onPressed: () {}, child: new Text(label));
  }
}
</code></pre><h2 id="Intents"><a href="#Intents" class="headerlink" title="Intents"></a>Intents</h2><p>Flutter不具有Intents的概念，但如果需要的话，Flutter可以通过Native整合来触发Intents。</p>
<p>要在Flutter中切换屏幕，您可以访问路由以绘制新的Widget。 管理多个屏幕有两个核心概念和类：<strong>Route 和 Navigator</strong>。Route是应用程序的“屏幕”或“页面”的抽象（可以认为是Activity）， Navigator是管理Route的Widget。Navigator可以通过push和pop route以实现页面切换。</p>
<p>在Flutter中，可以将具有指定Route的Map传递到顶层MaterialApp实例</p>
<pre><code>void main() {
  runApp(new MaterialApp(
    home: new MyAppHome(), // becomes the route named &apos;/&apos;
    routes: &lt;String, WidgetBuilder&gt; {
      &apos;/a&apos;: (BuildContext context) =&gt; new MyPage(title: &apos;page A&apos;),
      &apos;/b&apos;: (BuildContext context) =&gt; new MyPage(title: &apos;page B&apos;),
      &apos;/c&apos;: (BuildContext context) =&gt; new MyPage(title: &apos;page C&apos;),
    },
  ));
}
</code></pre><p>然后，您可以通过Navigator来切换到命名路由的页面。</p>
<pre><code>Navigator.of(context).pushNamed(&apos;/b&apos;);
</code></pre><p>Intents的另一个主要的用途是调用外部组件，如Camera或File picker。为此，您需要和native集成（或使用现有的库）</p>
<h3 id="处理外部传入的Intents"><a href="#处理外部传入的Intents" class="headerlink" title="处理外部传入的Intents"></a>处理外部传入的Intents</h3><p>Flutter可以通过直接与Android层通信并请求共享的数据来处理来自Android的Intents</p>
<p>在这个例子中，我们注册文本共享intent，所以其他应用程序可以共享文本到我们的Flutter应用程序</p>
<p>这个应用程序的基本流程是我们<strong>首先处理Android端的共享文本数据，然后等待Flutter请求数据，然后通过MethodChannel发送</strong>。</p>
<p>首先在在AndroidManifest.xml中注册我们想要处理的intent:</p>
<pre><code>&lt;activity
       android:name=&quot;.MainActivity&quot;
       android:launchMode=&quot;singleTop&quot;
       android:theme=&quot;@style/LaunchTheme&quot;
       android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection&quot;
       android:hardwareAccelerated=&quot;true&quot;
       android:windowSoftInputMode=&quot;adjustResize&quot;&gt;
       &lt;!-- This keeps the window background of the activity showing
            until Flutter renders its first frame. It can be removed if
            there is no splash screen (such as the default splash screen
            defined in @style/LaunchTheme). --&gt;
       &lt;meta-data
           android:name=&quot;io.flutter.app.android.SplashScreenUntilFirstFrame&quot;
           android:value=&quot;true&quot; /&gt;
       &lt;intent-filter&gt;
           &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;
           &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
       &lt;/intent-filter&gt;
       &lt;intent-filter&gt;
           &lt;action android:name=&quot;android.intent.action.SEND&quot; /&gt;
           &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
           &lt;data android:mimeType=&quot;text/plain&quot; /&gt;
       &lt;/intent-filter&gt;
   &lt;/activity&gt;
</code></pre><p>然后，在MainActivity中处理intent，一旦我们从intent中获得共享文本数据，我们就会持有它，直到Flutter在完成准备就绪时请求它。</p>
<pre><code>public class MainActivity extends FlutterActivity {
    String sharedText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        GeneratedPluginRegistrant.registerWith(this);
        Intent intent = getIntent();
        String action = intent.getAction();
        String type = intent.getType();

        if (Intent.ACTION_SEND.equals(action) &amp;&amp; type != null) {
            if (&quot;text/plain&quot;.equals(type)) {
                handleSendText(intent); // Handle text being sent
            }
        }

        new MethodChannel(getFlutterView(), &quot;app.channel.shared.data&quot;).setMethodCallHandler(new MethodChannel.MethodCallHandler() {
            @Override
            public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) {
                if (methodCall.method.contentEquals(&quot;getSharedText&quot;)) {
                    result.success(sharedText);
                    sharedText = null;
                }
            }
        });
    }


    void handleSendText(Intent intent) {
        sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);
    }
}
</code></pre><p>最后，在Flutter中，在渲染Flutter视图时请求数据：</p>
<pre><code>class _SampleAppPageState extends State&lt;SampleAppPage&gt; {
  static const platform = const MethodChannel(&apos;app.channel.shared.data&apos;);
  String dataShared = &quot;No data&quot;;

  @override
  void initState() {
    super.initState();
    getSharedText();
  }

  @override
  Widget build(BuildContext context) {
    return new Scaffold(body: new Center(child: new Text(dataShared)));
  }

  getSharedText() async {
    var sharedData = await platform.invokeMethod(&quot;getSharedText&quot;);
    if (sharedData != null) {
      setState(() {
        dataShared = sharedData;
      });
    }
  }
}
</code></pre><h3 id="startActivityForResult-在Flutter中等价于什么"><a href="#startActivityForResult-在Flutter中等价于什么" class="headerlink" title="startActivityForResult 在Flutter中等价于什么"></a>startActivityForResult 在Flutter中等价于什么</h3><p>处理Flutter中所有路由的Navigator类可用于从已经push到栈的路由中获取结果。 这可以通过等待push返回的Future来完成。例如，如果您要启动让用户选择其位置的位置的路由，则可以执行以下操作：</p>
<pre><code>Map coordinates = await Navigator.of(context).pushNamed(&apos;/location&apos;);
</code></pre><p>然后在你的位置路由中，一旦用户选择了他们的位置，你可以将结果”pop”出栈：</p>
<pre><code>Navigator.of(context).pop({&quot;lat&quot;:43.821757,&quot;long&quot;:-79.226392});
</code></pre><h2 id="异步UI"><a href="#异步UI" class="headerlink" title="异步UI"></a>异步UI</h2><h3 id="runOnUiThread-在Flutter中等价于什么"><a href="#runOnUiThread-在Flutter中等价于什么" class="headerlink" title="runOnUiThread 在Flutter中等价于什么"></a>runOnUiThread 在Flutter中等价于什么</h3><p>Dart是单线程执行模型，<strong>支持Isolates（在另一个线程上运行Dart代码的方式）、事件循环和异步编程</strong>。 除非您启动一个Isolate，否则您的Dart代码将在主UI线程中运行，并由事件循环驱动（译者语：和JavaScript一样）。</p>
<h3 id="AsyncTask和IntentService在Flutter中等价于什么"><a href="#AsyncTask和IntentService在Flutter中等价于什么" class="headerlink" title="AsyncTask和IntentService在Flutter中等价于什么"></a>AsyncTask和IntentService在Flutter中等价于什么</h3><p>由于Flutter是单线程的，运行一个事件循环（如Node.js），所以您不必担心线程管理或者使用AsyncTasks、IntentServices。</p>
<p>要异步运行代码，可以将函数声明为异步函数，并在该函数中等待这个耗时任务</p>
<pre><code>loadData() async {
  String dataURL = &quot;https://jsonplaceholder.typicode.com/posts&quot;;
  http.Response response = await http.get(dataURL);
  setState(() {
    widgets = JSON.decode(response.body);
  });
}
</code></pre><p>这就是典型的进行网络或数据库调用的方式</p>
<p>在Android上，当您继承AsyncTask时，通常会覆盖3个方法，OnPreExecute、doInBackground和onPostExecute。 在Flutter中没有这种模式的等价物，因为您只需等待一个长时间运行的函数，而Dart的事件循环将负责其余的事情。但是，有时您可能需要处理大量数据，导致UI可能会挂起。在这种情况下，与AsyncTask一样，在Flutter中，可以利用多个CPU内核来执行耗时或计算密集型任务。这是通过使用<strong>Isolates</strong>来完成的。</p>
<p>Isolate是一个独立的执行线程，它运行时不会与主线程共享任何内存。这意味着你不能从该线程访问变量或通过调用setState来更新你的UI。</p>
<h3 id="OkHttp在Flutter中等价于什么"><a href="#OkHttp在Flutter中等价于什么" class="headerlink" title="OkHttp在Flutter中等价于什么"></a>OkHttp在Flutter中等价于什么</h3><p>当使用受欢迎的“http”package时，Flutter进行网络信非常简单。</p>
<p>虽然<a href="https://pub.dartlang.org/packages/http" target="_blank" rel="noopener">“http” package </a>没有实现OkHttp的所有功能，但“http” package 抽象出了许多常用的API，可以简单有效的发起网络请求。</p>
<p>您可以通过在pubspec.yaml中添加依赖项来使用它</p>
<pre><code>dependencies:
  ...
  http: &apos;&gt;=0.11.3+12&apos;
</code></pre><p>在Android中，当您执行耗时任务时，通常会显示进度指示器。在Flutter中，这可以通过渲染<strong>Progress Indicator widget</strong>来实现。您可以通过编程方式显示Progress Indicator ， 通过布尔值通知Flutter在耗时任务发起之前更新其状态。</p>
<h2 id="项目结构和资源"><a href="#项目结构和资源" class="headerlink" title="项目结构和资源"></a>项目结构和资源</h2><h3 id="在哪里存储分辨率相关的图片文件-HDPI-XXHDPI"><a href="#在哪里存储分辨率相关的图片文件-HDPI-XXHDPI" class="headerlink" title="在哪里存储分辨率相关的图片文件? HDPI/XXHDPI"></a>在哪里存储分辨率相关的图片文件? HDPI/XXHDPI</h3><p>Flutter遵循像iOS这样简单的3种分辨率格式: 1x, 2x, and 3x.</p>
<p>创建一个名为images的文件夹，并为每个图像文件生成一个@2x和@3x文件，并将它们放置在如下这样的文件夹中:</p>
<pre><code>…/my_icon.png
…/2.0x/my_icon.png
…/3.0x/my_icon.png
</code></pre><p>然后，您需要在pubspec.yaml文件中声明这些图片:</p>
<pre><code>assets:
 - images/a_dot_burr.jpeg
 - images/a_dot_ham.jpeg
</code></pre><p>然后您可以使用AssetImage访问您的图像</p>
<pre><code>return new AssetImage(&quot;images/a_dot_burr.jpeg&quot;);
</code></pre><h3 id="在哪里存储字符串-如何存储不同的语言"><a href="#在哪里存储字符串-如何存储不同的语言" class="headerlink" title="在哪里存储字符串? 如何存储不同的语言"></a>在哪里存储字符串? 如何存储不同的语言</h3><p>目前，最好的做法是创建一个名为Strings的类</p>
<pre><code>class Strings{
  static String welcomeMessage = &quot;Welcome To Flutter&quot;;
}
</code></pre><p>然后在你的代码中，你可以像访问你的字符串一样：</p>
<pre><code>new Text(Strings.welcomeMessage)
</code></pre><p>Flutter对Android的可访问性提供了基本的支持，虽然这个功能正在进行中。</p>
<p>鼓励Flutter开发者使用<a href="https://pub.dev/packages/intl" target="_blank" rel="noopener">intl package</a>进行国际化和本地化</p>
<h3 id="Android-Gradle-vs-Flutter-pubspec-yaml"><a href="#Android-Gradle-vs-Flutter-pubspec-yaml" class="headerlink" title="Android Gradle vs Flutter pubspec.yaml"></a>Android Gradle vs Flutter pubspec.yaml</h3><p>在Android中，您可以在Gradle文件来添加依赖项。</p>
<p>在Flutter中，虽然在Flutter项目中的Android文件夹下有Gradle文件，但只有在添加平台相关所需的依赖关系时才使用这些文件。 否则，应该使用pubspec.yaml声明用于Flutter的外部依赖项。</p>
<p>发现好的flutter packages的一个好地方 <a href="https://pub.dartlang.org/flutter/packages/" target="_blank" rel="noopener">Pub</a></p>
<h2 id="Activities-和-Fragments"><a href="#Activities-和-Fragments" class="headerlink" title="Activities 和 Fragments"></a>Activities 和 Fragments</h2><p>在Flutter中，这两个概念都等同于Widget。</p>
<h3 id="如何监听Android-Activity生命周期事件"><a href="#如何监听Android-Activity生命周期事件" class="headerlink" title="如何监听Android Activity生命周期事件"></a>如何监听Android Activity生命周期事件</h3><p>在Android中，您可以覆盖Activity的方法来捕获Activity的生命周期回调。</p>
<p>在Flutter中您可以通过<strong>挂接到WidgetsBinding观察并监听didChangeAppLifecycleState更改事件来监听</strong>生命周期事件</p>
<p>您可以监听到的生命周期事件是</p>
<ul>
<li>resumed - 应用程序可见并响应用户输入。这是来自Android的onResume</li>
<li>inactive - 应用程序处于非活动状态，并且未接收用户输入。此事件在Android上未使用，仅适用于iOS</li>
<li>paused - 应用程序当前对用户不可见，不响应用户输入，并在后台运行。这是来自Android的暂停</li>
<li><p>suspending - 该应用程序将暂时中止。这在iOS上未使用</p>
<p>  class _LifecycleWatcherState extends State<lifecyclewatcher> with WidgetsBindingObserver {</lifecyclewatcher></p>
<pre><code>AppLifecycleState _lastLifecyleState;

@override
void initState() {
  super.initState();
  WidgetsBinding.instance.addObserver(this);
}

@override
void dispose() {
  WidgetsBinding.instance.removeObserver(this);
  super.dispose();
}

@override
void didChangeAppLifecycleState(AppLifecycleState state) {
  setState(() {
    _lastLifecyleState = state;
  });
}

@override
Widget build(BuildContext context) {
  if (_lastLifecyleState == null)
    return new Text(&apos;This widget has not observed any lifecycle changes.&apos;, textDirection: TextDirection.ltr);
  return new Text(&apos;The most recent lifecycle state this widget observed was: $_lastLifecyleState.&apos;,
      textDirection: TextDirection.ltr);
}
</code></pre><p>  }</p>
</li>
</ul>
<h2 id="Layouts"><a href="#Layouts" class="headerlink" title="Layouts"></a>Layouts</h2><h3 id="LinearLayout在Flutter中相当于什么"><a href="#LinearLayout在Flutter中相当于什么" class="headerlink" title="LinearLayout在Flutter中相当于什么"></a>LinearLayout在Flutter中相当于什么</h3><p>在Android中，使用LinearLayout来使您的控件呈水平或垂直排列。在Flutter中，您可以使用Row或Co​​lumn来实现相同的结果:</p>
<pre><code>@override
Widget build(BuildContext context) {
  return new Row(
    mainAxisAlignment: MainAxisAlignment.center,
    children: &lt;Widget&gt;[
      new Text(&apos;Row One&apos;),
      new Text(&apos;Row Two&apos;),
      new Text(&apos;Row Three&apos;),
      new Text(&apos;Row Four&apos;),
    ],
  );
}
</code></pre><h3 id="RelativeLayout在Flutter中等价于什么"><a href="#RelativeLayout在Flutter中等价于什么" class="headerlink" title="RelativeLayout在Flutter中等价于什么"></a>RelativeLayout在Flutter中等价于什么</h3><p>RelativeLayout用于使widget相对于彼此位置排列。在Flutter中，有几种方法可以实现相同的结果</p>
<p>您可以通过使用Column、Row和Stack的组合来实现RelativeLayout的效果。您可以为widget构造函数指定相对于父组件的布局规则。</p>
<p>一个在Flutter中构建RelativeLayout的好例子，请参考在StackOverflow上: <a href="https://stackoverflow.com/questions/44396075/equivalent-of-relativelayout-in" target="_blank" rel="noopener">https://stackoverflow.com/questions/44396075/equivalent-of-relativelayout-in</a> -flutter</p>
<h3 id="ScrollView在Flutter中等价于什么"><a href="#ScrollView在Flutter中等价于什么" class="headerlink" title="ScrollView在Flutter中等价于什么"></a>ScrollView在Flutter中等价于什么</h3><p>在Android中，ScrollView允许您包含一个子控件，以便在用户设备的屏幕比控件内容小的情况下，使它们可以滚动。</p>
<p>在Flutter中，最简单的方法是使用ListView。但<strong>在Flutter中，一个ListView既是一个ScrollView，也是一个Android ListView</strong>。</p>
<h2 id="手势检测和触摸事件处理"><a href="#手势检测和触摸事件处理" class="headerlink" title="手势检测和触摸事件处理"></a>手势检测和触摸事件处理</h2><h3 id="如何将一个onClick监听器添加到Flutter中的widget"><a href="#如何将一个onClick监听器添加到Flutter中的widget" class="headerlink" title="如何将一个onClick监听器添加到Flutter中的widget"></a>如何将一个onClick监听器添加到Flutter中的widget</h3><p>在Flutter中，添加触摸监听器有两种方法:</p>
<ol>
<li><p>如果Widget支持事件监听，则可以将一个函数传递给它并进行处理。例如，RaisedButton有一个onPressed参数:</p>
<pre><code>@override
Widget build(BuildContext context) {
  return new RaisedButton(
      onPressed: () {
        print(&quot;click&quot;);
      },
      child: new Text(&quot;Button&quot;));
}
</code></pre></li>
<li><p>如果Widget不支持事件监听，则可以将该Widget包装到GestureDetector中，并将处理函数传递给onTap参数:</p>
<pre><code>class SampleApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new Scaffold(
        body: new Center(
      child: new GestureDetector(
        child: new FlutterLogo(
          size: 200.0,
        ),
        onTap: () {
          print(&quot;tap&quot;);
        },
      ),
    ));
  }
}
</code></pre></li>
</ol>
<h3 id="如何处理widget上的其他手势"><a href="#如何处理widget上的其他手势" class="headerlink" title="如何处理widget上的其他手势"></a>如何处理widget上的其他手势</h3><p>使用GestureDetector，可以监听多种手势，例如:</p>
<p>Tap</p>
<blockquote>
<p>onTapDown<br>onTapUp<br>onTap<br>onTapCancel</p>
</blockquote>
<p>Double tap</p>
<blockquote>
<p>onDoubleTap 用户快速连续两次在同一位置轻敲屏幕.</p>
</blockquote>
<p>长按</p>
<blockquote>
<p>onLongPress</p>
</blockquote>
<p>垂直拖动</p>
<blockquote>
<p>onVerticalDragStart<br>onVerticalDragUpdate<br>onVerticalDragEnd</p>
</blockquote>
<p>水平拖拽</p>
<blockquote>
<p>onHorizontalDragStart<br>onHorizontalDragUpdate<br>onHorizontalDragEnd</p>
</blockquote>
<h2 id="Listview-amp-Adapter"><a href="#Listview-amp-Adapter" class="headerlink" title="Listview &amp; Adapter"></a>Listview &amp; Adapter</h2><h3 id="ListView在Flutter中相当于什么"><a href="#ListView在Flutter中相当于什么" class="headerlink" title="ListView在Flutter中相当于什么"></a>ListView在Flutter中相当于什么</h3><p>在Flutter中，ListView就是一个ListView！</p>
<p>在Android ListView中，您可以创建一个适配器，然后您可以将它传递给ListView，该适配器将使用适配器返回的内容来展示每一行。 然而，你必须确保在合适的时机回收行，否则，你会得到各种疯狂的视觉和内存问题。</p>
<p>在Flutter中，由于Flutter的不可变的widget模型，将一个Widgets列表传递给的ListView，而Flutter将负责确保它们快速平滑地滚动。</p>
<h3 id="怎么知道哪个列表项被点击"><a href="#怎么知道哪个列表项被点击" class="headerlink" title="怎么知道哪个列表项被点击"></a>怎么知道哪个列表项被点击</h3><p>在Android中，ListView有一个方法’onItemClickListener’来确定哪个列表项被点击。 Flutter中可以更轻松地通过您传入的处理回调来进行操作：</p>
<pre><code>_getListData() {
   List&lt;Widget&gt; widgets = [];
   for (int i = 0; i &lt; 100; i++) {
     widgets.add(new GestureDetector(
       child: new Padding(
           padding: new EdgeInsets.all(10.0),
           child: new Text(&quot;Row $i&quot;)),
       onTap: () {
         print(&apos;row tapped&apos;);
       },
     ));
   }
   return widgets;
 }
</code></pre><h3 id="如何动态更新ListView"><a href="#如何动态更新ListView" class="headerlink" title="如何动态更新ListView"></a>如何动态更新ListView</h3><p>需要更新适配器并调用notifyDataSetChanged。在Flutter中，如果setState（）中更新widget列表，您会发现没有变化， 这是因为当setState被调用时，Flutter渲染引擎会遍历所有的widget以查看它们是否已经改变。 当遍历到你的ListView时，它会做一个==运算，以查看两个ListView是否相同，因为没有任何改变，因此没有更新数据。</p>
<p>要更新您的ListView，然后在setState中创建一个新的List（）并将所有旧数据复制到新列表中。这是实现更新的简单方法（译者语：此时状态改变，ListView被<strong>重新构建</strong>）</p>
<p>然而，<strong>推荐的方法是使用ListView.Builder</strong>。当您拥有动态列表或包含大量数据的列表时，此方法非常有用。 这实际上相当于在Android上使用RecyclerView，它会自动为您回收列表元素：</p>
<pre><code>@override
 Widget build(BuildContext context) {
   return new Scaffold(
       appBar: new AppBar(
         title: new Text(&quot;Sample App&quot;),
       ),
       body: new ListView.builder(
           itemCount: widgets.length,
           itemBuilder: (BuildContext context, int position) {
             return getRow(position);
           }));
 }

Widget getRow(int i) {
   return new GestureDetector(
     child: new Padding(
         padding: new EdgeInsets.all(10.0),
         child: new Text(&quot;Row $i&quot;)),
     onTap: () {
       setState(() {
         widgets.add(getRow(widgets.length + 1));
         print(&apos;row $i&apos;);
       });
     },
   );
 }
</code></pre><p>我们不是创建一个“新的ListView”，而是创建一个新的ListView.builder，它接受两个参数，即列表的初始长度和一个ItemBuilder函数。ItemBuilder函数非常类似于Android适配器中的getView函数，它需要一个位置并返回要为该位置渲染的行。</p>
<p>最后，但最重要的是，如果您注意到onTap函数，在里面，我们不会再重新创建列表，而只是添加新元素到列表。</p>
<h2 id="使用-Text"><a href="#使用-Text" class="headerlink" title="使用 Text"></a>使用 Text</h2><h3 id="如何在-Text-widget上设置自定义字体"><a href="#如何在-Text-widget上设置自定义字体" class="headerlink" title="如何在 Text widget上设置自定义字体"></a>如何在 Text widget上设置自定义字体</h3><p>在Android SDK（从Android O开始）中，创建一个Font资源文件并将其传递到TextView的FontFamily参数中。</p>
<p>在Flutter中，首先你需要把你的字体文件放在项目文件夹中（最好的做法是创建一个名为assets的文件夹）</p>
<p>接下来在pubspec.yaml文件中，声明字体：</p>
<pre><code>fonts:
   - family: MyCustomFont
     fonts:
       - asset: fonts/MyCustomFont.ttf
       - style: italic
</code></pre><p>最后，将字体应用到Text widget:</p>
<pre><code>@override
Widget build(BuildContext context) {
  return new Scaffold(
    appBar: new AppBar(
      title: new Text(&quot;Sample App&quot;),
    ),
    body: new Center(
      child: new Text(
        &apos;This is a custom font text&apos;,
        style: new TextStyle(fontFamily: &apos;MyCustomFont&apos;),
      ),
    ),
  );
}
</code></pre><h3 id="如何在Text上定义样式"><a href="#如何在Text上定义样式" class="headerlink" title="如何在Text上定义样式"></a>如何在Text上定义样式</h3><p>Text的样式参数需要一个TextStyle对象，您可以在其中自定义许多参数。</p>
<h2 id="表单输入"><a href="#表单输入" class="headerlink" title="表单输入"></a>表单输入</h2><h3 id="Input的”hint”在flutter中相当于什么"><a href="#Input的”hint”在flutter中相当于什么" class="headerlink" title="Input的”hint”在flutter中相当于什么"></a>Input的”hint”在flutter中相当于什么</h3><p>在Flutter中，您可以通过向Text Widget的装饰构造函数参数添加<strong>InputDecoration对象</strong>，轻松地为输入框显示占位符文本</p>
<pre><code>body: new Center(
  child: new TextField(
    decoration: new InputDecoration(hintText: &quot;This is a hint&quot;),
  )
)
</code></pre><h3 id="如何显示验证错误"><a href="#如何显示验证错误" class="headerlink" title="如何显示验证错误"></a>如何显示验证错误</h3><p>就像您如何使用“hint”一样，您可以将InputDecoration对象传递给Text的装饰构造函数。</p>
<p>但是，您不希望首先显示错误，并且通常会在用户输入一些无效数据时显示该错误。这可以通过更新状态并传递一个新的InputDecoration对象来完成：</p>
<pre><code>class _SampleAppPageState extends State&lt;SampleAppPage&gt; {
  String _errorText;

  @override
  Widget build(BuildContext context) {
    return new Scaffold(
      appBar: new AppBar(
        title: new Text(&quot;Sample App&quot;),
      ),
      body: new Center(
        child: new TextField(
          onSubmitted: (String text) {
            setState(() {
              if (!isEmail(text)) {
                _errorText = &apos;Error: This is not an email&apos;;
              } else {
                _errorText = null;
              }
            });
          },
          decoration: new InputDecoration(hintText: &quot;This is a hint&quot;, errorText: _getErrorText()),
        ),
      ),
    );
  }

  _getErrorText() {
    return _errorText;
  }

  bool isEmail(String em) {
    String emailRegexp =
        r&apos;^(([^&lt;&gt;()[\]\\.,;:\s@\&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@\&quot;]+)*)|(\&quot;.+\&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$&apos;;

    RegExp regExp = new RegExp(p);

    return regExp.hasMatch(em);
  }
}
</code></pre><h2 id="Flutter-插件"><a href="#Flutter-插件" class="headerlink" title="Flutter 插件"></a>Flutter 插件</h2><p>如何使用 GPS sensor<br>要访问GPS传感器，您可以使用社区插件 <a href="https://pub.dartlang.org/packages/location" target="_blank" rel="noopener">https://pub.dartlang.org/packages/location</a></p>
<p>如何访问相机<br>访问相机的流行社区插件是 <a href="https://pub.dartlang.org/packages/image_picker" target="_blank" rel="noopener">https://pub.dartlang.org/packages/image_picker</a></p>
<p>如何使用Facebook登陆<br>要访问Facebook Connect功能，您可以使用 <a href="https://pub.dartlang.org/packages/flutter_facebook_connect" target="_blank" rel="noopener">https://pub.dartlang.org/packages/flutter_facebook_connect</a> .</p>
<p>如何构建自定义集成Native功能<br>如果有Flutter或其社区插件缺失的平台特定功能，那么您可以自己按照以下教程构建<a href="https://flutterchina.club/developing-packages/" target="_blank" rel="noopener">https://flutterchina.club/developing-packages/</a><br>简而言之，Flutter的插件架构就像在Android中使用Event bus一样：您可以发出消息并让接收者进行处理并将结果返回给您，在这种情况下，接收者将是iOS或Android。</p>
<p>如何在我的Flutter应用程序中使用NDK<br>自定义插件首先会与Android应用程序通信，您可以在其中调用native标记的函数。一旦Native完成了相应操作，就可以将响应消息发回给Flutter并呈现结果。</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Flutter很好的实现了一个美丽的Material Design，它会满足很多样式和主题的需求。 与Android中使用XML声明主题不同，在Flutter中，您可以<strong>通过顶层widget声明主题</strong>。</p>
<p>MaterialApp是一个方便的widget，它包装了许多Material Design应用通常需要的widget，它通过添加Material特定功能构建在WidgetsApp上。</p>
<p>如果你不想使用Material Components，那么你可以声明一个顶级widget-WidgetsApp，它是一个便利的类，它包装了许多应用程序通常需要的widget。</p>
<p>要自定义Material Components的颜色和样式，您可以将ThemeData对象传递到MaterialApp widget中，例如在下面的代码中，您可以看到主色板设置为蓝色，并且所有选择区域的文本颜色都应为红色。</p>
<pre><code>class SampleApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new MaterialApp(
      title: &apos;Sample App&apos;,
      theme: new ThemeData(
        primarySwatch: Colors.blue,
        textSelectionColor: Colors.red
      ),
      home: new SampleAppPage(),
    );
  }
}
</code></pre><p>Scaffold 是 Material library 中提供的一个widget, 它提供了默认的导航栏、标题和包含主屏幕widget树的body属性。widget树可以很复杂。</p>
<h2 id="数据库和本地存储"><a href="#数据库和本地存储" class="headerlink" title="数据库和本地存储"></a>数据库和本地存储</h2><h3 id="如何在Flutter中访问Shared-Preferences"><a href="#如何在Flutter中访问Shared-Preferences" class="headerlink" title="如何在Flutter中访问Shared Preferences ?"></a>如何在Flutter中访问Shared Preferences ?</h3><p>在Flutter中，您可以通过使用插件Shared_Preferences来访问此功能</p>
<p>这个插件包装了<a href="https://pub.dartlang.org/packages/shared_preferences" target="_blank" rel="noopener">Shared Preferences</a>和NSUserDefaults（与iOS相同）的功能</p>
<pre><code>import &apos;package:flutter/material.dart&apos;;
import &apos;package:shared_preferences/shared_preferences.dart&apos;;

void main() {
  runApp(
    new MaterialApp(
      home: new Scaffold(
        body: new Center(
          child: new RaisedButton(
            onPressed: _incrementCounter,
            child: new Text(&apos;Increment Counter&apos;),
          ),
        ),
      ),
    ),
  );
}

_incrementCounter() async {
  SharedPreferences prefs = await SharedPreferences.getInstance();
  int counter = (prefs.getInt(&apos;counter&apos;) ?? 0) + 1;
  print(&apos;Pressed $counter times.&apos;);
  prefs.setInt(&apos;counter&apos;, counter);
}
</code></pre><h3 id="如何在Flutter中访问SQLite"><a href="#如何在Flutter中访问SQLite" class="headerlink" title="如何在Flutter中访问SQLite"></a>如何在Flutter中访问SQLite</h3><p>在Android中，您可以使用SQLite存储，通过SQL查询的结构化数据。</p>
<p>在Flutter中，您可以使用<a href="https://pub.dartlang.org/packages/sqflite" target="_blank" rel="noopener">SQFlite插件</a>来访问SQFlite此功能</p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>在Android中，您可以使用Firebase云消息传递为您的应用设置推送通知。</p>
<p>在Flutter中，您可以使用<a href="https://github.com/flutter/plugins/tree/master/packages/firebase_messaging" target="_blank" rel="noopener">Firebase_Messaging</a>插件访问此功能</p>
<blockquote>
<p>注意：在中国无法使用Firebase服务。</p>
</blockquote>
<h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>YAML是一个类似 XML的标记语言。YAML强调以数据为中心，并不是以标识语言为重点</p>
<p>规范：</p>
<ul>
<li>大小写敏感</li>
<li>缩进代表层级，使用空格，默认2个空格（flutter工具做了处理，tab也可以）</li>
<li>#表示注释内容</li>
<li>: 表示键值对，注意后面要空格</li>
<li>{} 表示键值表</li>
<li>表示列表，注意后面要空格</li>
<li>[] 表示数组，注意每项之间有空格</li>
<li><p>? 表示复杂的键</p>
<pre><code># 依赖库
dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^0.1.2

flutter:
  #使用Material图标
  uses-material-design: true
  #assets文件
  assets:
    - images/1.png
    - images/2.gif
  #字体样式
  fonts:
     #family与fonts是一个整体，列表的一项
     - family: Schyler
       fonts:
         - asset: fonts/Schyler-Regular.ttf
         - asset: fonts/Schyler-Italic.ttf
           style: italic
     - family: Trajan Pro
       fonts:
         - asset: fonts/TrajanPro.ttf
         - asset: fonts/TrajanPro_Bold.ttf
           weight: 700
</code></pre></li>
</ul>
<p>-可转化为[]，:也可以转化为{}，转化后类似json</p>
<pre><code>dependencies: {flutter: {sdk: flutter}, cupertino_icons: ^0.1.2}
assets: [images/1.png, images/2.gif]
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://flutterchina.club/flutter-for-android" target="_blank" rel="noopener">Flutter for Android 开发者</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/25/hybird-redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/25/hybird-redux/" itemprop="url">Redux概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-25T16:36:23+08:00">
                2019-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hybrid-Develop/" itemprop="url" rel="index">
                    <span itemprop="name">Hybrid Develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redux是一个状态管理器。</p>
<p>Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers）。</p>
<h3 id="Redux核心概念"><a href="#Redux核心概念" class="headerlink" title="Redux核心概念"></a>Redux核心概念</h3><ul>
<li>actions</li>
<li>store</li>
<li>reducers</li>
</ul>
<p><img src="/2019/06/25/hybird-redux/redux.jpg" alt></p>
<p><strong>Actions</strong><br>简单地，<strong>Actions就是事件。Actions传递来自这个应用（用户接口，内部事件比如API调用和表单提交）的数据给store。store只获取来自Actions的信息</strong>。内部Actions就是简单的具有一个type属性（通常是常量）的JavaScript对象，这个对象描述了action的类型以及传递给store的负载信息:</p>
<pre><code>{
    type: LOGIN_FORM_SUBMIT,
    payload: {username: &apos;alex&apos;, password: &apos;123456&apos;}
}
</code></pre><p><strong>Reducers</strong><br>在函数式JavaScript中reducer基于数组reduce方法，接收一个回调（reducer）让你从多个值中获得单个值，整数和，或者一个一系列值的累积。在Redux中，<strong>reducer就是获得这个应用的当前状态和事件然后返回一个新状态的函数</strong>。理解reducer是怎样工作的至关重要，因为它们完成大部分工作。这是一个非常简单的reducer，通过获取当前state和一个action作为参数，再返回下一个state：</p>
<pre><code>function handleAuth(state, action) {
    return _.assign({}, state, {
        auth: action.payload  
    });
}
</code></pre><p>对于更多复杂的项目，使用Redux提供的combineReducers()实例是必要的（推荐）。它把在这个应用中所有的reducer结合在一起成为单个索引reducer。每一个reducer负责它自己那部分应用的状态，这个状态参数和其他reducer的不一样。<strong>combineReducers()实例使文件结构更容易维护</strong>。<br>如果一个对象（state）只改变一些值，Redux就创建一个新的对象，那些没有改变的值将会指向旧的对象而且新的值将会被创建。这对性能是极好的。为了让它更有效率你可以添加 Immutable.js</p>
<pre><code>const rootReducer = combineReducers({
    handleAuth: handleAuth,
    editProfile: editProfile,
    changePassword: changePassword
});
</code></pre><p><strong>Store</strong><br>Store对象<strong>保存应用的状态并提供一些帮助方法来存取状态，分发状态以及注册监听。全部state由一个store来表示</strong>。任何action通过reducer返回一个新的状态对象。这就使得Redux非常简单以及可预测。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.im/post/5d04790a6fb9a07efa09164d" target="_blank" rel="noopener">完全理解 redux（从零实现一个 redux）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/30/android-binder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/30/android-binder/" itemprop="url">Android IBinder机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-30T13:15:05+08:00">
                2019-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android系统Binder机制中的四个组件Client、Server、Service Manager和Binder驱动程序的关系如下图所示：</p>
<p><img src="/2019/05/30/android-binder/binder.jpg" alt></p>
<ol>
<li><p>Client、Server和Service Manager实现在用户空间中，Binder驱动程序实现在内核空间中</p>
</li>
<li><p>Binder驱动程序和Service Manager在Android平台中已经实现，开发者只需要在用户空间实现自己的Client和Server</p>
</li>
<li><p>Binder驱动程序提供设备文件/dev/binder与用户空间交互，Client、Server和Service Manager通过open和ioctl文件操作函数与Binder驱动程序进行通信</p>
</li>
<li><p>Client和Server之间的进程间通信通过Binder驱动程序间接实现</p>
</li>
<li><p>Service Manager是一个守护进程，用来管理Server，并向Client提供查询Server接口的能力</p>
</li>
</ol>
<h3 id="Android-整体架构"><a href="#Android-整体架构" class="headerlink" title="Android 整体架构"></a>Android 整体架构</h3><p>我们先来大概看下 Android 这座大山的整体轮廓。我们先从 Android 的整体架构来看看 Binder 是处于什么地位，这张图引自 Android 项目开源网站：<a href="https://source.android.com：" target="_blank" rel="noopener">https://source.android.com：</a></p>
<p><img src="/2019/05/30/android-binder/android-system.webp" alt></p>
<p>从下往上依次为</p>
<ul>
<li>内核层：Linux 内核和各类硬件设备的驱动，这里需要注意的是，Binder IPC 驱动也是在这一层实现，比较特殊</li>
<li>硬件抽象层：封装「内核层」硬件驱动，提供可供「系统服务层」调用的统一硬件接口</li>
<li>系统服务层：提供核心服务，并且提供可供「应用程序框架层」调用的接口</li>
<li>Binder IPC 层：作为「系统服务层」与「应用程序框架层」的 IPC 桥梁，互相传递接口调用的数据，实现跨进层的通讯</li>
<li>应用程序框架层：这一层可以理解为 Android SDK，提供四大组件，View 绘制体系等平时开发中用到的基础部件</li>
</ul>
<p>在一个大的项目里面，<strong>分层</strong>是非常重要的，处于最底层的接口最具有「通用性」，接口粒度最细，越往上层通用性降低。理论上来说上面的每一层都可以「开放」给开发者调用，例如开发者可以直接调用硬件抽象层的接口去操作硬件，或者直接调用系统服务层中的接口去直接操作系统服务，甚至是像 Windows 开发一样，开发者可以在内核层写程序，运行在内核中。不过开放带来的问题就是开发者权利太大，对于系统的稳定性是没有任何好处的，一个病毒制作者写了一个内核层的病毒，系统也许永远也起不来了。所以谷歌的做法是将开发者的权利收拢到了「应用程序框架层」，开发者只能调用这一层提供的接口。</p>
<p>上面的层次中，内核层与硬件抽象层均用 C/C++ 实现，系统服务层是以 Java 实现，硬件抽象层编译为 so 文件，以 JNI 的形式供系统服务层使用。系统服务层中的服务随系统的启动而启动，只要不关机，就会一直运行。这些服务干什么事情呢？其实很简单，就是完成一个手机该有的核心功能如短信的收发管理、电话的接听、挂断以及应用程序的包管理、Activity 的管理等等。每一个服务均运行在一个独立进程中，因为是以 Java 实现，所以本质上来说就是运行在一个独立进程的 Dalvik 虚拟机中。问题就来了，开发者的 APP 运行在一个新的进程空间，如何调用到系统服务层中的接口呢？答案是 IPC（Inter-Process Communication），进程间通讯，缩写与 RPC（Remote Procedure Call）是不一样的，实现原理也是不一样的。每一个系统服务在应用层序框架层都有一个 Manager 与之对应，方便开发者调用其相关的功能，具体关系大致如下</p>
<p><img src="/2019/05/30/android-binder/ipc.webp" alt></p>
<p>IPC 的方式有很多种，例如 socket、共享内存、管道、消息队列等等，我们就不去深究为何要使用 Binder 而不使用其他方式去做，到目前为止，这座大山的面目算是有个大概的轮廓了。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><strong>Android 从下而上分了内核层、硬件抽象层、系统服务层、Binder IPC 层、应用程序框架层</strong></li>
<li><strong>Android 中「应用程序框架层」以 SDK 的形式开放给开发者使用，「系统服务层」中的核心服务随系统启动而运行，通过应用层序框架层提供的 Manager 实时为应用程序提供服务调用。系统服务层中每一个服务运行在自己独立的进程空间中，应用程序框架层中的 Manager 通过 Binder IPC 的方式调用系统服务层中的服务。</strong></li>
</ul>
<h3 id="Binder-IPC-的架构"><a href="#Binder-IPC-的架构" class="headerlink" title="Binder IPC 的架构"></a>Binder IPC 的架构</h3><p>下面我们就来看看 Binder IPC 的架构是怎样的</p>
<p><img src="/2019/05/30/android-binder/ipc-binder.webp" alt></p>
<p>Binder IPC 属于 C/S 结构，Client 部分是用户代码，用户代码最终会调用 Binder Driver 的 transact 接口，Binder Driver 会调用 Server，这里的 Server 与 service 不同，可以理解为 Service 中 onBind 返回的 Binder 对象，请注意区分下:</p>
<ul>
<li>Client：用户需要实现的代码，如 AIDL 自动生成的接口类</li>
<li>Binder Driver：在内核层实现的 Driver</li>
<li>Server：这个 Server 就是 Service 中 onBind 返回的 IBinder 对象</li>
</ul>
<p>需要注意的是，上面绿色的色块部分都是属于用户需要实现的部分，而蓝色部分是系统去实现了。也就是说 Binder Driver 这块并不需要知道，Server 中会开启一个线程池去处理客户端调用。为什么要用线程池而不是一个单线程队列呢？试想一下，如果用单线程队列，则会有任务积压，多个客户端同时调用一个服务的时候就会有来不及响应的情况发生，这是绝对不允许的。</p>
<p>对于调用 Binder Driver 中的 transact 接口，客户端可以手动调用，也可以通过 AIDL 的方式生成的代理类来调用，服务端可以继承 Binder 对象，也可以继承 AIDL 生成的接口类的 Stub 对象。</p>
<p>切记，这里 Server 的实现是线程池的方式，而不是单线程队列的方式，区别在于，单线程队列的话，Server 的代码是线程安全的，线程池的话，Server 的代码则不是线程安全的，需要开发者自己做好多线程同步。</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li><strong>Binder IPC 属于 C/S 架构，包括 Client、Driver、Server 三个部分</strong></li>
<li><strong>Client 可以手动调用 Driver 的 transact 接口，也可以通过 AIDL 生成的 Proxy 调用</strong></li>
<li><strong>Server 中会启动一个「线程池」来处理 Client 的调用请求，处理完成后将结果返回给 Driver，Driver 再返回给 Client</strong></li>
</ul>
<p>这里就回答了两个问题：Service 中通过 AIDL 提供的接口并不是线程安全的，同理 ContentProvider 底层也是使用 Binder，同样不是线程安全的，至于是否需要做多线程保护，看业务而定，最好是做好多线程同步，以防万一。</p>
<h3 id="使用-AIDL-实现-Binder-IPC"><a href="#使用-AIDL-实现-Binder-IPC" class="headerlink" title="使用 AIDL 实现 Binder IPC"></a>使用 AIDL 实现 Binder IPC</h3><p>Android 给了我们更好用的方式那就是 AIDL，假如我们要做一个上报数据的功能，运行在 Service 中，在后台上报数据，接口定义如下</p>
<h4 id="IReporter-aidl"><a href="#IReporter-aidl" class="headerlink" title="IReporter.aidl"></a>IReporter.aidl</h4><pre><code>package com.android.binder;

interface IReporter {

    int report(String values, int type);
}
</code></pre><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>AidlService.java</p>
<pre><code>public class AidlService extends Service {

    public static final class Reporter extends IReporter.Stub {

        @Override
        public int report(String values, int type) throws RemoteException {
            return type;
        }
    }

    private Reporter mReporter;

    public AidlService() {
        mReporter = new Reporter();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mReporter;
    }
}
</code></pre><p>继承了 AIDL 自动生成的 Stub 对象，它是什么呢？我们可以看下它的定义</p>
<h4 id="IReporter-java"><a href="#IReporter-java" class="headerlink" title="IReporter.java"></a>IReporter.java</h4><pre><code>public interface IReporter extends android.os.IInterface
{

    public static abstract class Stub extends android.os.Binder implements com.android.binder.IReporter {
        ...

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException
        {
            switch (code)
            {
                case INTERFACE_TRANSACTION:
                {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_report:
                {
                    data.enforceInterface(DESCRIPTOR);
                    java.lang.String _arg0;
                    _arg0 = data.readString();
                    int _arg1;
                    _arg1 = data.readInt();
                    int _result = this.report(_arg0, _arg1);
                    reply.writeNoException();
                    reply.writeInt(_result);
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }
    }

...

}
</code></pre><p>自动生成的 IReporter 类自动给我们处理了一些参数的组包和解包而已，在 case 语句中调用了 this.report 即可调用到自己的业务逻辑部分了。</p>
<h4 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h4><p>该部分已经被 Binder 类给封装了，暴露给开发者的已经是很简单的使用方式了，即继承 Binder，实现 onTransact 即可。</p>
<h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>MainActivity.java</p>
<pre><code>private IReporter mReporterAidl;

private class AidlConnection implements ServiceConnection {

    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        mReporterAidl = IReporter.Stub.asInterface(service);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        mReporterAidl = null;
    }
}

...

@Override
protected void onCreate(Bundle savedInstanceState) {

    ...

    Intent intent = new Intent(this, AidlService.class);
    bindService(intent, new AidlConnection(), BIND_AUTO_CREATE);
}
</code></pre><p>这里调用了 Stub 对象的 asInterface，具体做了什么呢？</p>
<pre><code>public static com.android.binder.IReporter asInterface(android.os.IBinder obj)
{
    if ((obj==null)) {
        return null;
    }
    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
    if (((iin!=null)&amp;&amp;(iin instanceof com.android.binder.IReporter))) {
        return ((com.android.binder.IReporter)iin);
    }
    return new com.android.binder.IReporter.Stub.Proxy(obj);
}
</code></pre><p>先查找本地接口是否存在，判断是否是本地调用，如果是则直接返回 IReporter 的对象，否则返回 Stub.Proxy 对象，这个 Proxy 对象是做什么的呢？</p>
<pre><code>private static class Proxy implements com.android.binder.IReporter
{
    private android.os.IBinder mRemote;
    Proxy(android.os.IBinder remote)
    {
        mRemote = remote;
    }
    @Override public android.os.IBinder asBinder()
    {
        return mRemote;
    }
    public java.lang.String getInterfaceDescriptor()
    {
        return DESCRIPTOR;
    }
    @Override public int report(java.lang.String values, int type) throws android.os.RemoteException
    {
        android.os.Parcel _data = android.os.Parcel.obtain();
        android.os.Parcel _reply = android.os.Parcel.obtain();
        int _result;
        try {
            _data.writeInterfaceToken(DESCRIPTOR);
            _data.writeString(values);
            _data.writeInt(type);
            mRemote.transact(Stub.TRANSACTION_report, _data, _reply, 0);
            _reply.readException();
            _result = _reply.readInt();
        }
        finally {
            _reply.recycle();
            _data.recycle();
        }
        return _result;
    }
}
</code></pre><p>基本上已经很明了了，就是一个代理对象，对调用接口参数做组包而已，然后调用了 mRemote.transact 接口。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><ul>
<li><strong>AIDL 自动生成了 Stub 类</strong></li>
<li><strong>在 Service 端继承 Stub 类，Stub 类中实现了 onTransact 方法实现了「解包」的功能</strong></li>
<li><strong>在 Client 端使用 Stub 类的 Proxy 对象，该对象实现了「组包」并且调用 transact 的功能</strong></li>
</ul>
<p>有了 AIDL 之后，IReporter 接口就变得有意义了，Client 调用接口，Server 端实现接口，一切「组包」、「解包」的逻辑封装在了 Stub 类中，一切就是那么完美。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/bdef9e3178c9" target="_blank" rel="noopener">https://www.jianshu.com/p/bdef9e3178c9</a><br><a href="https://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/6618363</a><br><a href="https://blog.csdn.net/Mr_LiaBill/article/details/49837851" target="_blank" rel="noopener">Android IBinder机制简单介绍</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/java-constant-pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/java-constant-pool/" itemprop="url">Java常量池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-29T10:32:54+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Java知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享。</p>
<h3 id="Jvm虚拟内存分布"><a href="#Jvm虚拟内存分布" class="headerlink" title="Jvm虚拟内存分布"></a>Jvm虚拟内存分布</h3><p><img src="/2019/05/29/java-constant-pool/java_memory.png" alt><br> <strong>程序计数器</strong>是jvm执行程序的流水线，存放一些跳转指令。</p>
<p> <strong>本地方法栈</strong>是jvm调用操作系统方法所使用的栈。</p>
<p> <strong>虚拟机栈</strong>是jvm执行java代码所使用的栈。</p>
<p> <strong>方法区</strong>存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。</p>
<p> <strong>虚拟机堆</strong>是jvm执行java代码所使用的堆。</p>
<h3 id="Java常量池分类"><a href="#Java常量池分类" class="headerlink" title="Java常量池分类"></a>Java常量池分类</h3><p>Java中的常量池，实际上分为两种形态：<strong>静态常量池和运行时常量池</strong>。</p>
<p>所谓<strong>静态常量池，即*.class文件中的常量池</strong>，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。这种常量池主要用于存放两大类常量：<strong>字面量(Literal)和符号引用量(Symbolic References)</strong>，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p>
<blockquote>
<p><strong>类和接口的全限定名<br>字段名称和描述符<br>方法名称和描述符</strong></p>
</blockquote>
<p>而<strong>运行时常量池</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p>
<p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。</p>
<h3 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h3><p>常量池是为了<strong>避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享</strong>。<br>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。<br>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</p>
<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，减少对象数量从而改善应用所需的对象结构的方式。实现方式一般是通过HashMap完成。java常量池的设计初中也是为了减少内存占用，同时保证访问安全。继承Number的包装类常量池存储使用数组，String使用继承自HashTable的StringTable</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>接下来我们引用一些网络上流行的常量池例子，然后借以讲解。</p>
<pre><code> 1 String s1 = &quot;Hello&quot;;
 2 String s2 = &quot;Hello&quot;;
 3 String s3 = &quot;Hel&quot; + &quot;lo&quot;;
 4 String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;);
 5 String s5 = new String(&quot;Hello&quot;);
 6 String s6 = s5.intern();
 7 String s7 = &quot;H&quot;;
 8 String s8 = &quot;ello&quot;;
 9 String s9 = s7 + s8;
10           
11 System.out.println(s1 == s2);  // true
12 System.out.println(s1 == s3);  // true
13 System.out.println(s1 == s4);  // false
14 System.out.println(s1 == s9);  // false
15 System.out.println(s4 == s5);  // false
16 System.out.println(s1 == s6);  // true
</code></pre><p> 首先说明一点，在java 中，直接使用==操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用String.equals()。</p>
<p> s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。</p>
<p> s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = “Hel” + “lo”;在class文件中被优化成String s3 = “Hello”，所以s1 == s3成立。只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。</p>
<p> s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(“lo”)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</p>
<p>配上一张简图理清思路：</p>
<p><img src="/2019/05/29/java-constant-pool/constant_1.jpg" alt><br>s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，不能在编译期被确定，所以不做优化，只能等到运行时，在堆中创建s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同。</p>
<p><img src="/2019/05/29/java-constant-pool/constant_2.png" alt><br> s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。<br> s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。</p>
<p>特例1</p>
<pre><code>public static final String A = &quot;ab&quot;; // 常量A
public static final String B = &quot;cd&quot;; // 常量B
public static void main(String[] args) {
     String s = A + B;  // 将两个常量用+连接对s进行初始化 
     String t = &quot;abcd&quot;;   
    if (s == t) {   
         System.out.println(&quot;s等于t，它们是同一个对象&quot;);   
     } else {   
         System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);   
     }   
 } 
s等于t，它们是同一个对象
</code></pre><p>A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了。也就是说：String s=A+B; 等同于：String s=”ab”+”cd”;</p>
<p>特例2</p>
<pre><code>public static final String A; // 常量A
public static final String B;    // 常量B
static {   
     A = &quot;ab&quot;;   
     B = &quot;cd&quot;;   
 }   
 public static void main(String[] args) {   
    // 将两个常量用+连接对s进行初始化   
     String s = A + B;   
     String t = &quot;abcd&quot;;   
    if (s == t) {   
         System.out.println(&quot;s等于t，它们是同一个对象&quot;);   
     } else {   
         System.out.println(&quot;s不等于t，它们不是同一个对象&quot;);   
     }   
 } 
s不等于t，它们不是同一个对象
</code></pre><p>A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。</p>
<p>至此，我们可以得出三个非常重要的结论：</p>
<blockquote>
<p><strong>必须要关注编译期的行为，才能更好的理解常量池。<br>运行时常量池中的常量，基本来源于各个class文件中的常量池。<br>程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。</strong></p>
</blockquote>
<p>以上所讲仅涉及字符串常量池，实际上还有整型常量池、浮点型常量池(java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；两种浮点数类型的包装类Float,Double并没有实现常量池技术) 等等，但都大同小异，只不过数值类型的常量池不可以手动添加常量，程序启动时常量池中的常量就已经确定了，比如整型常量池中的常量范围：-128~127，（Byte,Short,Integer,Long,Character,Boolean）<strong>这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象</strong>。</p>
<p>例如在自动装箱时，把int变成Integer的时候，是有规则的，当你的int的值在-128-IntegerCache.high(127) 时，返回的不是一个新new出来的Integer对象，而是一个已经缓存在堆 中的Integer对象，（我们可以这样理解，系统已经把-128到127之 间的Integer缓存到一个Integer数组中去了，如果你要把一个int变成一个Integer对象，首先去缓存中找，找到的话直接返回引用给你就 行了，不必再新new一个），如果不在-128-IntegerCache.high(127) 时会返回一个新new出来的Integer对象。  </p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>说了这么多理论，接下来让我们触摸一下真正的常量池。</p>
<p>前文提到过，class文件中存在一个静态常量池，这个常量池是由编译器生成的，用来存储java源文件中的字面量(本文仅仅关注字面量)，假设我们有如下java代码：</p>
<pre><code>1 String s = &quot;hi&quot;;
</code></pre><p>为了方便起见，就这么简单，没错！将代码编译成class文件后，用winhex打开二进制格式的class文件。如图：<br><img src="/2019/05/29/java-constant-pool/class.png" alt><br>简单讲解一下class文件的结构，开头的4个字节是class文件魔数，用来标识这是一个class文件，说白话点就是文件头，既：CA FE BA BE。</p>
<p>紧接着4个字节是java的版本号，这里的版本号是34，因为笔者是用jdk8编译的，版本号的高低和jdk版本的高低相对应，高版本可以兼容低版本，但低版本无法执行高版本。所以，如果哪天读者想知道别人的class文件是用什么jdk版本编译的，就可以看这4个字节。</p>
<p>接下来就是常量池入口，入口处用2个字节标识常量池常量数量，本例中数值为00 1A，翻译成十进制是26，也就是有25个常量，其中第0个常量是特殊值，所以只有25个常量。</p>
<p>常量池中存放了各种类型的常量，他们都有自己的类型，并且都有自己的存储规范，本文只关注字符串常量，字符串常量以01开头(1个字节)，接着用2个字节记录字符串长度，然后就是字符串实际内容。本例中为：01 00 02 68 69。</p>
<p>接下来再说说运行时常量池，由于运行时常量池在方法区中，我们可以通过jvm参数：-XX:PermSize、-XX:MaxPermSize来设置方法区大小，从而间接限制常量池大小。</p>
<p>假设jvm启动参数为：-XX:PermSize＝2M -XX:MaxPermSize＝2M，然后运行如下代码：</p>
<pre><code>1 //保持引用，防止自动垃圾回收
2 List&lt;String&gt; list = new ArrayList&lt;String&gt;();
3         
4 int i = 0;
5         
6 while(true){
7     //通过intern方法向常量池中手动添加常量
8     list.add(String.valueOf(i++).intern());
9 }
</code></pre><p>程序立刻会抛出：Exception in thread “main” java.lang.outOfMemoryError: PermGen space异常。PermGen space正是方法区，足以说明常量池在方法区中。</p>
<p>在jdk8中，移除了方法区，转而用Metaspace区域替代，所以我们需要使用新的jvm参数：-XX:MaxMetaspaceSize=2M，依然运行如上代码，抛出：java.lang.OutOfMemoryError: Metaspace异常。同理说明运行时常量池是划分在Metaspace区域中。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/syp172654682/p/8082625.html" target="_blank" rel="noopener">https://www.cnblogs.com/syp172654682/p/8082625.html</a><br><a href="https://www.jianshu.com/p/aaa80665542d" target="_blank" rel="noopener">https://www.jianshu.com/p/aaa80665542d</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/28/java-annotation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/java-annotation/" itemprop="url">Java注解（Annotation）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T18:11:29+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Java知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。</p>
<p>注解本质是一个继承了Annotation的特殊接口，其具体实现类是Java运行时生成的动态代理类。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：<br>   @Documented – 注解是否将包含在JavaDoc中<br>   @Retention – 什么时候使用该注解<br>   @Target – 注解用于什么地方<br>   @Inherited – 是否允许子类继承该注解</p>
<p>  1.）@Retention – 定义该注解的生命周期<br>  ●   RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。<br>  ●   RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式<br>  ●   RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p>
<p>  2.）Target – 表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括<br>  ● ElementType.CONSTRUCTOR: 用于描述构造器<br>  ● ElementType.FIELD: 成员变量、对象、属性（包括enum实例）<br>  ● ElementType.LOCAL_VARIABLE: 用于描述局部变量<br>  ● ElementType.METHOD: 用于描述方法<br>  ● ElementType.PACKAGE: 用于描述包<br>  ● ElementType.PARAMETER: 用于描述参数<br>  ● ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</p>
<p> 3.)@Documented – 一个简单的Annotations 标记注解，没有成员，表示是否将注解信息添加在java 文档中。</p>
<p> 4.)@Inherited – 定义该注释和子类的关系<br>   @Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。<br>   注意：Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。<br>   当Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p>
<h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>自定义注解类编写的一些规则:</p>
<ol>
<li>Annotation 型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</li>
<li>参数成员只能用public 或默认(default) 这两个访问权修饰</li>
<li>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</li>
<li>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li>
<li>注解也可以没有定义成员,，不过这样注解就没啥用了<br>PS:自定义注解需要使用到元注解</li>
</ol>
<h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><p>创建注解处理器，利用反射对注解加以处理。AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口。所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息：</p>
<p>方法1：<t extends annotation> T getAnnotation(Class<t> annotationClass):返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</t></t></p>
<p>方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。</p>
<p>方法3：boolean is AnnotationPresent(Class annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false.</p>
<p>方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/lylwo317/article/details/52163304" target="_blank" rel="noopener">Java注解（Annotation）原理详解</a><br><a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="noopener">https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Shuming Zhao">
            
              <p class="site-author-name" itemprop="name">Shuming Zhao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuming Zhao</span>

  
</div>

<div class="powered-by"><i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人，
<span id="busuanzi_container_site_pv">访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
</span>
</div>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
