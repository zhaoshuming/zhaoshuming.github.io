<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="1ilOhMWnNE">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/07/android-kotlin-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/07/android-kotlin-flow/" itemprop="url">Kotlin Coroutines Flow</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-07T10:50:07+08:00">
                2020-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Flow 有点类似 RxJava 的 Observable。因为 Observable 也有 Cold 、Hot 之分。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Flow 能够返回多个异步计算的值，例如下面的 flow builder :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">    for (i in 1..5) &#123;</span><br><span class="line">        delay(100)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.collect&#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 Flow 接口，只有一个 collect 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Flow&lt;out T&gt; &#123;</span><br><span class="line">    @InternalCoroutinesApi</span><br><span class="line">    public suspend fun collect(collector: FlowCollector&lt;T&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果熟悉 RxJava 的话，则可以理解为 collect() 对应subscribe()，而 emit() 对应onNext()。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>除了刚刚展示的 flow builder 可以用于创建 flow，还有其他的几种方式：</p>
<p>flowOf()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowOf(1,2,3,4,5)</span><br><span class="line">    .onEach &#123;</span><br><span class="line">        delay(100)</span><br><span class="line">    &#125;</span><br><span class="line">    .collect&#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>asFlow()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listOf(1, 2, 3, 4, 5).asFlow()</span><br><span class="line">    .onEach &#123;</span><br><span class="line">        delay(100)</span><br><span class="line">    &#125;.collect &#123;</span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>channelFlow()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">channelFlow &#123;</span><br><span class="line">    for (i in 1..5) &#123;</span><br><span class="line">        delay(100)</span><br><span class="line">        send(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.collect&#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的 channelFlow builder 跟 flow builder 是有一定差异的。</p>
<p>flow 是 <strong>Cold Stream</strong>。在没有切换线程的情况下，生产者和消费者是<strong>同步非阻塞</strong>的。<br>channel 是 <strong>Hot Stream</strong>。而 channelFlow 实现了生产者和消费者<strong>异步非阻塞</strong>模型。</p>
<p>看下面的示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//使用 flow builder 的情况，大致花费1秒</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        flow &#123;</span><br><span class="line">            for (i in 1..5) &#123;</span><br><span class="line">                delay(100)</span><br><span class="line">                emit(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.collect&#123;</span><br><span class="line">            delay(100)</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(&quot;cost $time&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用 channelFlow builder 的情况，大致花费700毫秒：</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val time = measureTimeMillis&#123;</span><br><span class="line">        channelFlow &#123;</span><br><span class="line">            for (i in 1..5) &#123;</span><br><span class="line">                delay(100)</span><br><span class="line">                send(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.collect&#123;</span><br><span class="line">            delay(100)</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(&quot;cost $time&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当然，flow 如果切换线程的话，花费的时间也是大致700毫秒，跟使用 channelFlow builder 效果差不多。</span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val time = measureTimeMillis&#123;</span><br><span class="line">        flow &#123;</span><br><span class="line">            for (i in 1..5) &#123;</span><br><span class="line">                delay(100)</span><br><span class="line">                emit(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.flowOn(Dispatchers.IO)</span><br><span class="line">            .collect &#123;</span><br><span class="line">                delay(100)</span><br><span class="line">                println(it)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print(&quot;cost $time&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="切换线程"><a href="#切换线程" class="headerlink" title="切换线程"></a>切换线程</h3><p>相比于 RxJava 需要使用 observeOn、subscribeOn 来切换线程，flow 会更加简单。<strong>只需使用 flowOn</strong>，下面的例子中，展示了 flow builder 和 map 操作符都会受到 flowOn 的影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flow &#123;</span><br><span class="line">    for (i in 1..5) &#123;</span><br><span class="line">        delay(100)</span><br><span class="line">        emit(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.map &#123;</span><br><span class="line">    it * it</span><br><span class="line">&#125;.flowOn(Dispatchers.IO)</span><br><span class="line">.collect &#123;</span><br><span class="line">    println(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 collect() 指定哪个线程，则需要看整个 flow 处于哪个 CoroutineScope 下。</p>
<p>值得注意的地方，<strong>不要使用 withContext() 来切换 flow 的线程</strong>。</p>
<h3 id="flow-取消"><a href="#flow-取消" class="headerlink" title="flow 取消"></a>flow 取消</h3><p>如果 flow 是在一个挂起函数内被挂起了，那么 flow 是可以被取消的，否则不能取消。</p>
<h3 id="Terminal-flow-operators"><a href="#Terminal-flow-operators" class="headerlink" title="Terminal flow operators"></a>Terminal flow operators</h3><p>Flow 的 API 有点类似于 Java Stream 的 API。它也同样拥有 Intermediate Operations、Terminal Operations。</p>
<p>Flow 的 Terminal 运算符可以是 <strong>suspend</strong> 函数，如 collect、single、reduce、toList 等；也可以是 <strong>launchIn</strong> 运算符，用于在指定 CoroutineScope 内使用 flow。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ExperimentalCoroutinesApi // tentatively stable in 1.3.0</span><br><span class="line">public fun &lt;T&gt; Flow&lt;T&gt;.launchIn(scope: CoroutineScope): Job = scope.launch &#123;</span><br><span class="line">    collect() // tail-call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整理一下 Flow 的 Terminal 运算符</p>
<ul>
<li>collect</li>
<li>single/first</li>
<li>toList/toSet/toCollection</li>
<li>count</li>
<li>fold/reduce</li>
<li>launchIn/produceIn/broadcastIn</li>
</ul>
<h2 id="Flow-VS-Sequences"><a href="#Flow-VS-Sequences" class="headerlink" title="Flow VS Sequences"></a>Flow VS Sequences</h2><p>每一个 Flow 其内部是按照顺序执行的，这一点跟 Sequences 很类似。</p>
<p>Flow 跟 Sequences 之间的区别是<strong> Flow 不会阻塞主线程的运行</strong>，而 Sequences 会阻塞主线程的运行。</p>
<h2 id="Flow-VS-RxJava"><a href="#Flow-VS-RxJava" class="headerlink" title="Flow VS RxJava"></a>Flow VS RxJava</h2><p>Kotlin 协程库的设计本身也参考了 RxJava ，下图展示了如何从 RxJava 迁移到 Kotlin 协程。(火和冰形象地表示了 Hot、Cold Stream)</p>
<p><img src="/2020/09/07/android-kotlin-flow/flow_vs_rxjava.webp" alt></p>
<h3 id="Cold-Stream"><a href="#Cold-Stream" class="headerlink" title="Cold Stream"></a>Cold Stream</h3><p>flow 的代码块只有调用 <strong>collect()</strong> 才开始运行，正如 RxJava 创建的 Observables 只有调用 subscribe() 才开始运行一样。</p>
<h3 id="Hot-Stream"><a href="#Hot-Stream" class="headerlink" title="Hot Stream"></a>Hot Stream</h3><p>如图上所示，可以借助 Kotlin Channel 来实现 Hot Stream。</p>
<h3 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h3><p>Flow 完成时（正常或出现异常时），如果需要执行一个操作，它可以通过两种方式完成：imperative、declarative。</p>
<p><strong>1.imperative</strong></p>
<p>通过使用 try … finally 实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        flow &#123;</span><br><span class="line">            for (i in 1..5) &#123;</span><br><span class="line">                delay(100)</span><br><span class="line">                emit(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.collect &#123; println(it) &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        println(&quot;Done&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2.declarative</strong></p>
<p>通过 onCompletion() 函数实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        for (i in 1..5) &#123;</span><br><span class="line">            delay(100)</span><br><span class="line">            emit(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.onCompletion &#123; println(&quot;Done&quot;) &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.onCompleted</strong> （借助扩展函数实现）</p>
<p>借助扩展函数可以实现类似 RxJava 的 onCompleted() 功能，只有在<strong>正常结束时才会被调用</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; Flow&lt;T&gt;.onCompleted(action: () -&gt; Unit) = flow &#123;</span><br><span class="line"></span><br><span class="line">    collect &#123; value -&gt; emit(value) &#125;</span><br><span class="line"></span><br><span class="line">    action()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的使用类似于 onCompletion()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        for (i in 1..5) &#123;</span><br><span class="line">            delay(100)</span><br><span class="line">            emit(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.onCompleted &#123; println(&quot;Completed...&quot;) &#125;</span><br><span class="line">        .collect&#123;println(it)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是假如 Flow 异常结束时，是不会执行 onCompleted() 函数的。</p>
<h3 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h3><p>Backpressure 是响应式编程的功能之一。RxJava2 Flowable 支持的 Backpressure 策略，包括：</p>
<ul>
<li>MISSING：创建的 Flowable 没有指定背压策略，不会对通过 OnNext 发射的数据做缓存或丢弃处理。</li>
<li>ERROR：如果放入 Flowable 的异步缓存池中的数据超限了，则会抛出 MissingBackpressureException 异常。</li>
<li>BUFFER：Flowable 的异步缓存池同 Observable 的一样，没有固定大小，可以无限制添加数据，不会抛出 MissingBackpressureException 异常，但会导致 OOM。</li>
<li>DROP：如果 Flowable 的异步缓存池满了，会丢掉将要放入缓存池中的数据。</li>
<li>LATEST：如果缓存池满了，会丢掉将要放入缓存池中的数据。这一点跟 DROP 策略一样，不同的是，不管缓存池的状态如何，LATEST 策略会将最后一条数据强行放入缓存池中。</li>
</ul>
<p>而 Flow 的 Backpressure 是通过 suspend 函数实现。</p>
<p><strong>buffer()</strong> 对应 BUFFER 策略，<strong>conflate()</strong> 对应 LATEST 策略。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">fun currTime() = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">var start: Long = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        (1..5)</span><br><span class="line">            .asFlow()</span><br><span class="line">            .onStart &#123; start = currTime() &#125;</span><br><span class="line">            .onEach &#123;</span><br><span class="line">                delay(100)</span><br><span class="line">                println(&quot;Emit $it ($&#123;currTime() - start&#125;ms) &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            .buffer()</span><br><span class="line">            .collect &#123;</span><br><span class="line">                println(&quot;Collect $it starts ($&#123;currTime() - start&#125;ms) &quot;)</span><br><span class="line">                delay(500)</span><br><span class="line">                println(&quot;Collect $it ends ($&#123;currTime() - start&#125;ms) &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;Cost $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">Emit 1 (104ms) </span><br><span class="line">Collect 1 starts (108ms) </span><br><span class="line">Emit 2 (207ms) </span><br><span class="line">Emit 3 (309ms) </span><br><span class="line">Emit 4 (411ms) </span><br><span class="line">Emit 5 (513ms) </span><br><span class="line">Collect 1 ends (613ms) </span><br><span class="line">Collect 2 starts (613ms) </span><br><span class="line">Collect 2 ends (1114ms) </span><br><span class="line">Collect 3 starts (1114ms) </span><br><span class="line">Collect 3 ends (1615ms) </span><br><span class="line">Collect 4 starts (1615ms) </span><br><span class="line">Collect 4 ends (2118ms) </span><br><span class="line">Collect 5 starts (2118ms) </span><br><span class="line">Collect 5 ends (2622ms) </span><br><span class="line">Collected in 2689 ms</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        (1..5)</span><br><span class="line">            .asFlow()</span><br><span class="line">            .onStart &#123; start = currTime() &#125;</span><br><span class="line">            .onEach &#123;</span><br><span class="line">                delay(100)</span><br><span class="line">                println(&quot;Emit $it ($&#123;currTime() - start&#125;ms) &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            .conflate()</span><br><span class="line">            .collect &#123;</span><br><span class="line">                println(&quot;Collect $it starts ($&#123;currTime() - start&#125;ms) &quot;)</span><br><span class="line">                delay(500)</span><br><span class="line">                println(&quot;Collect $it ends ($&#123;currTime() - start&#125;ms) &quot;)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;Cost $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">Emit 1 (106ms) </span><br><span class="line">Collect 1 starts (110ms) </span><br><span class="line">Emit 2 (213ms) </span><br><span class="line">Emit 3 (314ms) </span><br><span class="line">Emit 4 (419ms) </span><br><span class="line">Emit 5 (520ms) </span><br><span class="line">Collect 1 ends (613ms) </span><br><span class="line">Collect 5 starts (613ms) </span><br><span class="line">Collect 5 ends (1113ms) </span><br><span class="line">Cost 1162 ms</span><br></pre></td></tr></table></figure></p>
<h4 id="DROP-策略"><a href="#DROP-策略" class="headerlink" title="DROP 策略"></a>DROP 策略</h4><p>RxJava 的 contributor：David Karnok， 他写了一个<a href="https://github.com/akarnokd/kotlin-flow-extensions" target="_blank" rel="noopener">kotlin-flow-extensions</a>库，其中包括：FlowOnBackpressureDrop.kt，这个类支持 DROP 策略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Drops items from the upstream when the downstream is not ready to receive them.</span><br><span class="line"> */</span><br><span class="line">@FlowPreview</span><br><span class="line">fun &lt;T&gt; Flow&lt;T&gt;.onBackpressurureDrop() : Flow&lt;T&gt; = FlowOnBackpressureDrop(this)</span><br></pre></td></tr></table></figure></p>
<p>使用这个库的话，可以通过使用 Flow 的扩展函数 onBackpressurureDrop() 来支持 DROP 策略。</p>
<h2 id="Flow-异常处理"><a href="#Flow-异常处理" class="headerlink" title="Flow 异常处理"></a>Flow 异常处理</h2><p>Flow 可以使用传统的 try…catch 来捕获异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        emit(1)</span><br><span class="line">        try &#123;</span><br><span class="line">            throw RuntimeException()</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            e.stackTrace</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.onCompletion &#123; println(&quot;Done&quot;) &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，也可以使用 catch 操作符来捕获异常。</p>
<h3 id="catch-操作符"><a href="#catch-操作符" class="headerlink" title="catch 操作符"></a>catch 操作符</h3><p>上面讲述过 onCompletion 操作符。但是 onCompletion 不能捕获异常，只能用于判断是否有异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        emit(1)</span><br><span class="line">        throw RuntimeException()</span><br><span class="line">    &#125;.onCompletion &#123; cause -&gt;</span><br><span class="line">        if (cause != null)</span><br><span class="line">            println(&quot;Flow completed exceptionally&quot;)</span><br><span class="line">        else</span><br><span class="line">            println(&quot;Done&quot;)</span><br><span class="line">    &#125;.collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1</span><br><span class="line">Flow completed exceptionally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p>catch 操作符可以<strong>捕获来自上游的异常</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">        emit(1)</span><br><span class="line">        throw RuntimeException()</span><br><span class="line">    &#125;</span><br><span class="line">    .onCompletion &#123; cause -&gt;</span><br><span class="line">        if (cause != null)</span><br><span class="line">            println(&quot;Flow completed exceptionally&quot;)</span><br><span class="line">        else</span><br><span class="line">            println(&quot;Done&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    .catch&#123; println(&quot;catch exception&quot;) &#125;</span><br><span class="line">    .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1</span><br><span class="line">Flow completed exceptionally</span><br><span class="line">catch exception</span><br></pre></td></tr></table></figure></p>
<p>上面的代码如果把 onCompletion、catch 交换一下位置，则 <strong>catch 操作符捕获到异常后，不会影响到下游</strong>。因此，onCompletion 操作符不再打印”Flow completed exceptionally”</p>
<p>catch 操作符用于<strong>实现异常透明化处理</strong>。例如在 catch 操作符内，可以使用 throw 再次抛出异常、可以使用 emit() 转换为发射值、可以用于打印或者其他业务逻辑的处理等等。</p>
<p>但是，<strong>catch 只是中间操作符不能捕获下游的异常</strong>，类似 collect 内的异常。对于下游的异常，可以<strong>多次使用 catch</strong> 操作符来解决。</p>
<p>对于 collect 内的异常，除了传统的 try…catch 之外，还可以借助 onEach 操作符。把业务逻辑放到 onEach 操作符内，在 onEach 之后是 catch 操作符，最后是 collect()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    flow &#123;</span><br><span class="line">         ......</span><br><span class="line">    &#125;</span><br><span class="line">    .onEach &#123;</span><br><span class="line">          ......</span><br><span class="line">    &#125;</span><br><span class="line">   .catch &#123; ... &#125;</span><br><span class="line">   .collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="retry、retryWhen-操作符"><a href="#retry、retryWhen-操作符" class="headerlink" title="retry、retryWhen 操作符"></a>retry、retryWhen 操作符</h3><p>像 RxJava 一样，Flow 也有重试的操作符。</p>
<p>如果上游遇到了异常，并使用了 retry 操作符，则 retry 会让 Flow 最多重试 retries 指定的次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public fun &lt;T&gt; Flow&lt;T&gt;.retry(</span><br><span class="line">    retries: Long = Long.MAX_VALUE,</span><br><span class="line">    predicate: suspend (cause: Throwable) -&gt; Boolean = &#123; true &#125;</span><br><span class="line">): Flow&lt;T&gt; &#123;</span><br><span class="line">    require(retries &gt; 0) &#123; &quot;Expected positive amount of retries, but had $retries&quot; &#125;</span><br><span class="line">    return retryWhen &#123; cause, attempt -&gt; attempt &lt; retries &amp;&amp; predicate(cause) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如，下面打印了三次”Emitting 1”、”Emitting 2”，最后两次是通过 retry 操作符打印出来的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    (1..5).asFlow().onEach &#123;</span><br><span class="line">        if (it == 3) throw RuntimeException(&quot;Error on $it&quot;)</span><br><span class="line">    &#125;.retry(2) &#123;</span><br><span class="line"></span><br><span class="line">        if (it is RuntimeException) &#123;</span><br><span class="line">            return@retry true</span><br><span class="line">        &#125;</span><br><span class="line">        false</span><br><span class="line">    &#125;</span><br><span class="line">    .onEach &#123; println(&quot;Emitting $it&quot;) &#125;</span><br><span class="line">    .catch &#123; it.printStackTrace() &#125;</span><br><span class="line">    .collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">Emitting 1</span><br><span class="line">Emitting 2</span><br><span class="line">Emitting 1</span><br><span class="line">Emitting 2</span><br><span class="line">Emitting 1</span><br><span class="line">Emitting 2</span><br><span class="line">java.lang.RuntimeException: Error on 3</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
<p><strong>retry 操作符最终调用的是 retryWhen 操作符</strong>。下面的代码跟刚才的执行结果一致：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    (1..5).asFlow().onEach &#123;</span><br><span class="line">        if (it == 3) throw RuntimeException(&quot;Error on $it&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    .onEach &#123; println(&quot;Emitting $it&quot;) &#125;</span><br><span class="line">    .retryWhen &#123; cause, attempt -&gt;</span><br><span class="line">        attempt &lt; 2</span><br><span class="line">    &#125;</span><br><span class="line">    .catch &#123; it.printStackTrace() &#125;</span><br><span class="line">    .collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为 retryWhen 操作符的参数是谓词，当谓词返回 true 时才会进行重试。谓词还接收一个 attempt 作为参数表示尝试的次数，该次数是从0开始的。</p>
<h2 id="Flow-Lifecycle"><a href="#Flow-Lifecycle" class="headerlink" title="Flow Lifecycle"></a>Flow Lifecycle</h2><p>RxJava 的 do 操作符能够监听 Observables 的生命周期的各个阶段。</p>
<p>Flow 并没有多那么丰富的操作符来监听其生命周期的各个阶段，<strong>目前只有 onStart、onCompletion 来监听 Flow 的创建和结束</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    (1..5).asFlow().onEach &#123;</span><br><span class="line">        if (it == 3) throw RuntimeException(&quot;Error on $it&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    .onStart &#123; println(&quot;Starting flow&quot;) &#125;</span><br><span class="line">    .onEach &#123; println(&quot;On each $it&quot;) &#125;</span><br><span class="line">    .catch &#123; println(&quot;Exception : $&#123;it.message&#125;&quot;) &#125;</span><br><span class="line">    .onCompletion &#123; println(&quot;Flow completed&quot;) &#125;</span><br><span class="line">    .collect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">Starting flow</span><br><span class="line">On each 1</span><br><span class="line">On each 2</span><br><span class="line">Flow completed</span><br><span class="line">Exception : Error on 3</span><br></pre></td></tr></table></figure></p>
<h2 id="Flow-线程操作"><a href="#Flow-线程操作" class="headerlink" title="Flow 线程操作"></a>Flow 线程操作</h2><p>Flow 只需使用 flowOn 操作符，而不必像 RxJava 需要去深入理解 observeOn、subscribeOn 之间的区别。</p>
<p>RxJava 的 observeOn 操作符，接收一个 Scheduler 参数，用来指定下游操作运行在特定的线程调度器 Scheduler 上。Flow 的 <strong>flowOn 操作符，接收一个 CoroutineContext 参数，影响的是上游的操作</strong>。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">val customerDispatcher = Executors.newFixedThreadPool(5).asCoroutineDispatcher()</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    flow &#123;</span><br><span class="line">        for (i in 1..5) &#123;</span><br><span class="line">            delay(100)</span><br><span class="line">            emit(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.map &#123;</span><br><span class="line">            it * it</span><br><span class="line">        &#125;.flowOn(Dispatchers.IO)</span><br><span class="line">        .map &#123;</span><br><span class="line">            it+1</span><br><span class="line">        &#125;</span><br><span class="line">        .flowOn(customerDispatcher)</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(&quot;$&#123;Thread.currentThread().name&#125;: $it&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flow builder 和两个 map 操作符都会受到两个flowOn的影响，其中 flow builder 和 map 操作符都会受到第一个flowOn的影响并使用 Dispatchers.io 线程池，第二个 map 操作符会切换到指定的 customerDispatcher 线程池。</p>
<h3 id="buffer-实现并发操作"><a href="#buffer-实现并发操作" class="headerlink" title="buffer 实现并发操作"></a>buffer 实现并发操作</h3><p>上面介绍了 buffer 操作符对应 RxJava Backpressure 中的 BUFFER 策略。</p>
<p>事实上 buffer 操作符也可以并发地执行任务，它是除了使用 flowOn 操作符之外的另一种方式，只是不能显示地指定 Dispatchers。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        flow &#123;</span><br><span class="line">            for (i in 1..5) &#123;</span><br><span class="line">                delay(100)</span><br><span class="line">                emit(i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .buffer()</span><br><span class="line">        .collect &#123; value -&gt;</span><br><span class="line">            delay(300)</span><br><span class="line">            println(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Collected in $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">Collected in 1676 ms</span><br></pre></td></tr></table></figure></p>
<p>在上述例子中，所有的 delay 所花费的时间是2000ms。然而通过 buffer 操作符并发地执行 emit，再顺序地执行 collect 函数后，所花费的时间在 1700ms 左右。</p>
<h3 id="flatMapMerge-实现并行操作"><a href="#flatMapMerge-实现并行操作" class="headerlink" title="flatMapMerge 实现并行操作"></a>flatMapMerge 实现并行操作</h3><p>在讲解并行操作之前，先来了解一下并发和并行的区别。</p>
<ul>
<li>并发(concurrency)：是指一个处理器同时处理多个任务。</li>
<li>并行(parallelism)：是多个处理器或者是多核的处理器同时处理多个不同的任务。并行是同时发生的多个并发事件，具有并发的含义，而并发则不一定是并行。</li>
</ul>
<p>RxJava 可以借助 flatMap 操作符实现并行，亦可以使用 ParallelFlowable 类实现并行操作。Flow 也有相应的操作符 <strong>flatMapMerge</strong> 可以实现并行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val result = arrayListOf&lt;Int&gt;()</span><br><span class="line">    for (index in 1..100)&#123;</span><br><span class="line">        result.add(index)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.asFlow()</span><br><span class="line">        .flatMapMerge &#123;</span><br><span class="line">            flow &#123;</span><br><span class="line">                emit(it)</span><br><span class="line">            &#125;</span><br><span class="line">            .flowOn(Dispatchers.IO)</span><br><span class="line">        &#125;</span><br><span class="line">        .collect &#123; println(&quot;$it&quot;) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Flow-其他的操作符"><a href="#Flow-其他的操作符" class="headerlink" title="Flow 其他的操作符"></a>Flow 其他的操作符</h2><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>在使用 transform 操作符时，可以<strong>任意多次调用 emit</strong> ，这是 transform 跟 map 最大的区别：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    (1..5).asFlow()</span><br><span class="line">        .transform &#123;</span><br><span class="line">            emit(it * 2)</span><br><span class="line">            delay(100)</span><br><span class="line">            emit(it * 4)</span><br><span class="line">        &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>transform 也<strong>可以使用 emit 发射任意值</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    (1..5).asFlow()</span><br><span class="line">        .transform &#123;</span><br><span class="line">            emit(it * 2)</span><br><span class="line">            delay(100)</span><br><span class="line">            emit(&quot;emit $it&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>take 操作符只取前几个 emit 发射的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    (1..5).asFlow()</span><br><span class="line">        .take(2)</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>类似于 Kotlin 集合中的 reduce 函数，能够<strong>对集合进行计算操作</strong>。</p>
<p>例如，对平方数列求和：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val sum = (1..5).asFlow()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .reduce &#123; a, b -&gt; a + b &#125;</span><br><span class="line"></span><br><span class="line">    println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如，计算阶乘：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val sum = (1..5).asFlow().reduce &#123; a, b -&gt; a * b &#125;</span><br><span class="line"></span><br><span class="line">    println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h3><p>也类似于 Kotlin 集合中的 fold 函数，<strong>fold 也需要设置初始值</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val sum = (1..5).asFlow()</span><br><span class="line">        .map &#123; it * it &#125;</span><br><span class="line">        .fold(0) &#123; a, b -&gt; a + b &#125;</span><br><span class="line"></span><br><span class="line">    println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，初始值为0就类似于使用 reduce 函数实现对平方数列求和。</p>
<p>而对于计算阶乘：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val sum = (1..5).asFlow().fold(1) &#123; a, b -&gt; a * b &#125;</span><br><span class="line"></span><br><span class="line">    println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip 是<strong>可以将2个 flow 进行合并</strong>的操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val flowA = (1..5).asFlow()</span><br><span class="line">    val flowB = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;,&quot;five&quot;)</span><br><span class="line">    flowA.zip(flowB) &#123; a, b -&gt; &quot;$a and $b&quot; &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1 and one</span><br><span class="line">2 and two</span><br><span class="line">3 and three</span><br><span class="line">4 and four</span><br><span class="line">5 and five</span><br></pre></td></tr></table></figure></p>
<p>zip 操作符会把 flowA 中的一个 item 和 flowB 中对应的一个 item 进行合并。即使 flowB 中的每一个 item 都使用了 delay() 函数，在合并过程中也会等待 delay() 执行完后再进行合并。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val flowA = (1..5).asFlow()</span><br><span class="line">    val flowB = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;).onEach &#123; delay(100) &#125;</span><br><span class="line"></span><br><span class="line">    val time = measureTimeMillis &#123;</span><br><span class="line">        flowA.zip(flowB) &#123; a, b -&gt; &quot;$a and $b&quot; &#125;</span><br><span class="line">            .collect &#123; println(it) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;Cost $time ms&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1 and one</span><br><span class="line">2 and two</span><br><span class="line">3 and three</span><br><span class="line">4 and four</span><br><span class="line">5 and five</span><br><span class="line">Cost 561 ms</span><br></pre></td></tr></table></figure></p>
<p>如果 flowA 中 item 个数大于 flowB 中 item 个数，<strong>执行合并后新的 flow 的 item 个数 = 较小的 flow 的 item 个数</strong>。：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val flowA = (1..6).asFlow()</span><br><span class="line">    val flowB = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;,&quot;five&quot;)</span><br><span class="line">    flowA.zip(flowB) &#123; a, b -&gt; &quot;$a and $b&quot; &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1 and one</span><br><span class="line">2 and two</span><br><span class="line">3 and three</span><br><span class="line">4 and four</span><br><span class="line">5 and five</span><br></pre></td></tr></table></figure></p>
<h3 id="combine"><a href="#combine" class="headerlink" title="combine"></a>combine</h3><p>combine 虽然也是合并，但是跟 zip 不太一样。</p>
<p>使用 combine 合并时，<strong>每次从 flowA 发出新的 item ，会将其与 flowB 的最新的 item 合并</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val flowA = (1..5).asFlow().onEach &#123; delay(100)  &#125;</span><br><span class="line">    val flowB = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;,&quot;five&quot;).onEach &#123; delay(200)  &#125;</span><br><span class="line">    flowA.combine(flowB) &#123; a, b -&gt; &quot;$a and $b&quot; &#125;</span><br><span class="line">        .collect &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1 and one</span><br><span class="line">2 and one</span><br><span class="line">3 and one</span><br><span class="line">3 and two</span><br><span class="line">4 and two</span><br><span class="line">5 and two</span><br><span class="line">5 and three</span><br><span class="line">5 and four</span><br><span class="line">5 and five</span><br></pre></td></tr></table></figure></p>
<h3 id="flattenMerge"><a href="#flattenMerge" class="headerlink" title="flattenMerge"></a>flattenMerge</h3><p>其实，flattenMerge 不会组合多个 flow ，<strong>而是将它们作为单个流执行</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val flowA = (1..5).asFlow()</span><br><span class="line">    val flowB = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;,&quot;five&quot;)</span><br><span class="line"></span><br><span class="line">    flowOf(flowA,flowB)</span><br><span class="line">        .flattenConcat()</span><br><span class="line">        .collect&#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br></pre></td></tr></table></figure></p>
<p>为了能更清楚地看到 flowA、flowB 作为单个流的执行，对他们稍作改动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    val flowA = (1..5).asFlow().onEach &#123; delay(100) &#125;</span><br><span class="line">    val flowB = flowOf(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;,&quot;five&quot;).onEach &#123; delay(200) &#125;</span><br><span class="line"></span><br><span class="line">    flowOf(flowA,flowB)</span><br><span class="line">        .flattenMerge(2)</span><br><span class="line">        .collect&#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1</span><br><span class="line">one</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">two</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br></pre></td></tr></table></figure></p>
<h3 id="flatMapConcat"><a href="#flatMapConcat" class="headerlink" title="flatMapConcat"></a>flatMapConcat</h3><p>flatMapConcat 由 map、flattenConcat 操作符实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@FlowPreview</span><br><span class="line">public fun &lt;T, R&gt; Flow&lt;T&gt;.flatMapConcat(transform: suspend (value: T) -&gt; Flow&lt;R&gt;): Flow&lt;R&gt; =</span><br><span class="line">    map(transform).flattenConcat()</span><br></pre></td></tr></table></figure></p>
<p>在调用 flatMapConcat 后，collect 函数在收集新值之前会<strong>等待</strong> flatMapConcat 内部的 flow 完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fun currTime() = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">var start: Long = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    (1..5).asFlow()</span><br><span class="line">        .onStart &#123; start = currTime() &#125;</span><br><span class="line">        .onEach &#123; delay(100) &#125;</span><br><span class="line">        .flatMapConcat &#123;</span><br><span class="line">            flow &#123;</span><br><span class="line">                emit(&quot;$it: First&quot;)</span><br><span class="line">                delay(500)</span><br><span class="line">                emit(&quot;$it: Second&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(&quot;$it at $&#123;System.currentTimeMillis() - start&#125; ms from start&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1: First at 114 ms from start</span><br><span class="line">1: Second at 619 ms from start</span><br><span class="line">2: First at 719 ms from start</span><br><span class="line">2: Second at 1224 ms from start</span><br><span class="line">3: First at 1330 ms from start</span><br><span class="line">3: Second at 1830 ms from start</span><br><span class="line">4: First at 1932 ms from start</span><br><span class="line">4: Second at 2433 ms from start</span><br><span class="line">5: First at 2538 ms from start</span><br><span class="line">5: Second at 3041 ms from start</span><br></pre></td></tr></table></figure></p>
<h3 id="flatMapMerge"><a href="#flatMapMerge" class="headerlink" title="flatMapMerge"></a>flatMapMerge</h3><p>flatMapMerge 由 map、flattenMerge 操作符实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FlowPreview</span><br><span class="line">public fun &lt;T, R&gt; Flow&lt;T&gt;.flatMapMerge(</span><br><span class="line">    concurrency: Int = DEFAULT_CONCURRENCY,</span><br><span class="line">    transform: suspend (value: T) -&gt; Flow&lt;R&gt;</span><br><span class="line">): Flow&lt;R&gt; = map(transform).flattenMerge(concurrency)</span><br></pre></td></tr></table></figure></p>
<p>flatMapMerge 是顺序调用内部代码块，并且<strong>并行</strong>地执行 collect 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fun currTime() = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">var start: Long = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    (1..5).asFlow()</span><br><span class="line">        .onStart &#123; start = currTime() &#125;</span><br><span class="line">        .onEach &#123; delay(100) &#125;</span><br><span class="line">        .flatMapMerge &#123;</span><br><span class="line">            flow &#123;</span><br><span class="line">                emit(&quot;$it: First&quot;)</span><br><span class="line">                delay(500)</span><br><span class="line">                emit(&quot;$it: Second&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(&quot;$it at $&#123;System.currentTimeMillis() - start&#125; ms from start&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1: First at 116 ms from start</span><br><span class="line">2: First at 216 ms from start</span><br><span class="line">3: First at 319 ms from start</span><br><span class="line">4: First at 422 ms from start</span><br><span class="line">5: First at 525 ms from start</span><br><span class="line">1: Second at 618 ms from start</span><br><span class="line">2: Second at 719 ms from start</span><br><span class="line">3: Second at 822 ms from start</span><br><span class="line">4: Second at 924 ms from start</span><br><span class="line">5: Second at 1030 ms from start</span><br></pre></td></tr></table></figure></p>
<p>flatMapMerge 操作符有一个参数 concurrency ，它默认使用DEFAULT_CONCURRENCY，如果想更直观地了解 flatMapMerge 的并行，可以对这个参数进行修改。例如改成2，就会发现不一样的执行结果。</p>
<h3 id="flatMapLatest"><a href="#flatMapLatest" class="headerlink" title="flatMapLatest"></a>flatMapLatest</h3><p>当<strong>发射了新值之后，上个 flow 就会被取消</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fun currTime() = System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">var start: Long = 0</span><br><span class="line"></span><br><span class="line">fun main() = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    (1..5).asFlow()</span><br><span class="line">        .onStart &#123; start = currTime() &#125;</span><br><span class="line">        .onEach &#123; delay(100) &#125;</span><br><span class="line">        .flatMapLatest &#123;</span><br><span class="line">            flow &#123;</span><br><span class="line">                emit(&quot;$it: First&quot;)</span><br><span class="line">                delay(500)</span><br><span class="line">                emit(&quot;$it: Second&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .collect &#123;</span><br><span class="line">            println(&quot;$it at $&#123;System.currentTimeMillis() - start&#125; ms from start&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">1: First at 114 ms from start</span><br><span class="line">2: First at 220 ms from start</span><br><span class="line">3: First at 321 ms from start</span><br><span class="line">4: First at 422 ms from start</span><br><span class="line">5: First at 524 ms from start</span><br><span class="line">5: Second at 1024 ms from start</span><br></pre></td></tr></table></figure></p>
<h2 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h2><p>Flow 仍然属于响应式范畴。开发者通过 kotlinx-coroutines-reactive 模块中 Flow.asPublisher() 和 Publisher.asFlow() ，可以方便地将 Flow 跟 Reactive Streams 进行互操作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/d672744ad3e0" target="_blank" rel="noopener">https://www.jianshu.com/p/d672744ad3e0</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/19/app-launch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/19/app-launch/" itemprop="url">Android Application启动流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-19T09:58:32+08:00">
                2020-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Android Application与其他移动平台有两个重大不同点:</p>
<ul>
<li>每个Android App都在一个独立空间里, 意味着其运行在一个单独的进程中, 拥有自己的VM, 被系统分配一个唯一的user ID.</li>
<li>Android App由很多不同组件组成, 这些组件还可以启动其他App的组件. 因此, Android App并没有一个类似程序入口的main()方法.</li>
</ul>
<p>Android Application组件包括:</p>
<ul>
<li>Activities: 前台界面, 直接面向User, 提供UI和操作.</li>
<li>Services: 后台任务.</li>
<li>Broadcast Receivers: 广播接收者.</li>
<li>Contexnt Providers: 数据提供者.</li>
</ul>
<p>Android进程与Linux进程一样. 默认情况下, 每个apk运行在自己的Linux进程中. 另外, 默认一个进程里面只有一个线程—主线程. 这个主线程中有一个Looper实例, 通过调用Looper.loop()从Message队列里面取出Message来做相应的处理.</p>
<h2 id="启动App流程"><a href="#启动App流程" class="headerlink" title="启动App流程"></a>启动App流程</h2><p>用户点击Home上的一个App图标, 启动一个应用时:</p>
<p><img src="/2020/08/19/app-launch/app-launch.webp" alt></p>
<p>Click事件会调用startActivity(Intent), 会通过Binder IPC机制, 最终调用到<strong>ActivityManagerService</strong>. 该Service会执行如下操作:</p>
<ul>
<li>第一步通过PackageManager的resolveIntent()收集这个intent对象的指向信息.</li>
<li>指向信息被存储在一个intent对象中.</li>
<li>下面重要的一步是通过grantUriPermissionLocked()方法来验证用户是否有足够的权限去调用该intent对象指向的Activity.</li>
<li>如果有权限, ActivityManagerService会检查并在新的task中启动目标activity.</li>
<li>现在, 是时候检查这个进程的ProcessRecord是否存在了.</li>
</ul>
<p>如果ProcessRecord是null, ActivityManagerService会创建新的进程来实例化目标activity.</p>
<h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>ActivityManagerService调用startProcessLocked()方法来创建新的进程, 该方法会通过前面讲到的socket通道传递参数给Zygote进程. <strong>Zygote孵化自身, 并调用ZygoteInit.main()方法来实例化ActivityThread对象并最终返回新进程的pid</strong>.</p>
<p><strong>ActivityThread</strong>随后依次调用Looper.prepareLoop()和Looper.loop()来<strong>开启消息循环</strong>.</p>
<p>流程图如下:</p>
<p><img src="/2020/08/19/app-launch/process-create.webp" alt></p>
<h2 id="绑定Application"><a href="#绑定Application" class="headerlink" title="绑定Application"></a>绑定Application</h2><p>接下来要做的就是将进程和指定的Application绑定起来. 这个是通过上节的<strong>ActivityThread对象中调用bindApplication()方法</strong>完成的. 该方法发送一个<strong>BIND_APPLICATION</strong>的消息到消息队列中, 最终通过handleBindApplication()方法处理该消息. 然后调用makeApplication()方法来加载App的classes到内存中.</p>
<p>流程如下:</p>
<p><img src="/2020/08/19/app-launch/bind-application.webp" alt></p>
<h2 id="启动Activity"><a href="#启动Activity" class="headerlink" title="启动Activity"></a>启动Activity</h2><p>经过前两个步骤之后, 系统已经拥有了该application的进程. 后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了.</p>
<p>实际调用方法是realStartActivity(), 它会调用application线程对象中的sheduleLaunchActivity()<strong>发送一个LAUNCH_ACTIVITY消息到消息队列中</strong>, 通过 handleLaunchActivity()来处理该消息.</p>
<p>假设点击的是一个视频浏览的App, 其流程如下:</p>
<p><img src="/2020/08/19/app-launch/start-activity.webp" alt></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/a5532ecc8377" target="_blank" rel="noopener">[译]Android Application启动流程分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/db-store-procedure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/16/db-store-procedure/" itemprop="url">MySQL 存储过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-16T14:53:26+08:00">
                2020-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。存储过程思想上很简单，就是<strong>数据库 SQL 语言层面的代码封装与重用</strong>。</p>
<p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p>
<p>MySQL 5.0 版本开始支持存储过程。</p>
<ul>
<li>优点<br>存储过程可封装，并隐藏复杂的商业逻辑。<br>存储过程可以回传值，并可以接受参数。<br>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。<br>存储过程可以用在数据检验，强制实行商业逻辑等。</li>
<li>缺点<br>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。<br>存储过程的性能调校与撰写，受限于各种数据库系统。</li>
</ul>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>MySQL中，创建存储过程的基本形式如下：</p>
<blockquote>
<p><strong>CREATE PROCEDURE sp_name ([proc_parameter[,…]]) [characteristic …] routine_body </strong></p>
</blockquote>
<p>其中，sp_name参数是存储过程的名称；proc_parameter表示存储过程的参数列表； characteristic参数指定存储过程的特性；routine_body参数是SQL代码的内容，可以用BEGIN…END来标志SQL代码的开始和结束。</p>
<h3 id="proc-parameter"><a href="#proc-parameter" class="headerlink" title="proc_parameter"></a>proc_parameter</h3><p>proc_parameter中的每个参数由3部分组成。这3部分分别是输入输出类型、参数名称和参数类型。其形式如下：</p>
<p>[ IN | OUT | INOUT ] param_name type </p>
<p>其中，IN表示输入参数；OUT表示输出参数； INOUT表示既可以是输入，也可以是输出； param_name参数是存储过程的参数名称；type参数指定存储过程的参数类型，该类型可以是MySQL数据库的任意数据类型。</p>
<h3 id="characteristic"><a href="#characteristic" class="headerlink" title="characteristic"></a>characteristic</h3><p>characteristic参数有多个取值。其取值说明如下：</p>
<p>LANGUAGE SQL：说明routine_body部分是由SQL语言的语句组成，这也是数据库系统默认的语言。</p>
<p>[NOT] DETERMINISTIC：指明存储过程的执行结果是否是确定的。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是非确定的，相同的输入可能得到不同的输出。默认情况下，结果是非确定的。</p>
<p>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：指明子程序使用SQL语句的限制。CONTAINS SQL表示子程序包含SQL语句，但不包含读或写数据的语句；NO SQL表示子程序中不包含SQL语句；READS SQL DATA表示子程序中包含读数据的语句；MODIFIES SQL DATA表示子程序中包含写数据的语句。默认情况下，系统会指定为CONTAINS SQL。</p>
<p>SQL SECURITY { DEFINER | INVOKER }：指明谁有权限来执行。DEFINER表示只有定义者自己才能够执行；INVOKER表示调用者可以执行。默认情况下，系统指定的权限是DEFINER。</p>
<p>COMMENT ‘string’：注释信息。</p>
<p>技巧：创建存储过程时，系统默认指定CONTAINS SQL，表示存储过程中使用了SQL语句。但是，如果存储过程中没有使用SQL语句，最好设置为NO SQL。而且，存储过程中最好在COMMENT部分对存储过程进行简单的注释，以便以后在阅读存储过程的代码时更加方便。</p>
<p>【示例1】 下面创建一个名为num_from_employee的存储过程。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE  PROCEDURE  num_from_employee (IN emp_id INT, OUT count_num INT )  </span><br><span class="line">          READS SQL DATA  </span><br><span class="line">          BEGIN  </span><br><span class="line">              SELECT  COUNT(*)  INTO  count_num  </span><br><span class="line">              FROM  employee  </span><br><span class="line">              WHERE  d_id=emp_id ;  </span><br><span class="line">          END</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，存储过程名称为num_from_employee；输入变量为emp_id；输出变量为count_num。SELECT语句从employee表查询d_id值等于emp_id的记录，并用COUNT(*)计算d_id值相同的记录的条数，最后将计算结果存入count_num中。</p>
<p>说明：MySQL中默认的语句结束符为分号（;）。存储过程中的SQL语句需要分号来结束。<strong>为了避免冲突，首先用”DELIMITER &amp;&amp;”将MySQL的结束符设置为&amp;&amp;。最后再用”DELIMITER ;”来将结束符恢复成分号</strong>。这与创建触发器时是一样的。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">DROP PROCEDURE IF EXISTS `TEST`.`getRecord` $$</span><br><span class="line">CREATE PROCEDURE `TEST`.`getRecord` (</span><br><span class="line">IN in_id INTEGER,</span><br><span class="line">OUT out_name VARCHAR(20),</span><br><span class="line">OUT out_age  INTEGER)</span><br><span class="line">BEGIN</span><br><span class="line">   SELECT name, age</span><br><span class="line">   INTO out_name, out_age</span><br><span class="line">   FROM Student where id = in_id;</span><br><span class="line">END $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在MySQL中，创建存储函数的基本形式如下：</p>
<blockquote>
<p><strong>CREATE FUNCTION sp_name ([func_parameter[,…]]) RETURNS type  [characteristic …] routine_body </strong></p>
</blockquote>
<p>其中，sp_name参数是存储函数的名称；func_parameter表示存储函数的参数列表；RETURNS type指定返回值的类型；characteristic参数指定存储函数的特性，该参数的取值与存储过程中的取值是一样的；routine_body参数是SQL代码的内容，可以用BEGIN…END来标志SQL代码的开始和结束。</p>
<p>func_parameter可以由多个参数组成，其中每个参数由参数名称和参数类型组成，其形式如下：param_name type</p>
<p>其中，param_name参数是存储函数的参数名称；type参数指定存储函数的参数类型，该类型可以是MySQL数据库的任意数据类型。</p>
<p>【示例2】 下面创建一个名为name_from_employee的存储函数。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE  FUNCTION  name_from_employee (emp_id INT )  </span><br><span class="line">          RETURNS VARCHAR(20)  </span><br><span class="line">          BEGIN  </span><br><span class="line">              RETURN  (SELECT  name  </span><br><span class="line">              FROM  employee  </span><br><span class="line">              WHERE  num=emp_id );  </span><br><span class="line">          END</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，存储函数的名称为name_from_employee；该函数的参数为emp_id；返回值是VARCHAR类型。SELECT语句从employee表查询num值等于emp_id的记录，并将该记录的name字段的值返回。</p>
<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><p>在存储过程和函数中，可以定义和使用变量。用户可以使用DECLARE关键字来定义变量。然后可以为变量赋值。这些变量的作用范围是BEGIN…END程序段中。本小节将讲解如何定义变量和为变量赋值。</p>
<h3 id="1．定义变量"><a href="#1．定义变量" class="headerlink" title="1．定义变量"></a>1．定义变量</h3><p>MySQL中可以使用DECLARE关键字来定义变量。定义变量的基本语法如下：</p>
<blockquote>
<p><strong>DECLARE  var_name[,…]  type  [DEFAULT value] </strong></p>
</blockquote>
<p>其中， DECLARE关键字是用来声明变量的；var_name参数是变量的名称，这里可以同时定义多个变量；type参数用来指定变量的类型；DEFAULT value子句将变量默认值设置为value，没有使用DEFAULT子句时，默认值为NULL。</p>
<p>【示例3】 下面定义变量my_sql，数据类型为INT型，默认值为10。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  my_sql  INT  DEFAULT 10 ;</span><br></pre></td></tr></table></figure></p>
<h3 id="2．为变量赋值"><a href="#2．为变量赋值" class="headerlink" title="2．为变量赋值"></a>2．为变量赋值</h3><p>MySQL中可以使用SET关键字来为变量赋值。SET语句的基本语法如下：</p>
<blockquote>
<p><strong>SET  var_name = expr [, var_name = expr] … </strong></p>
</blockquote>
<p>其中，SET关键字是用来为变量赋值的；var_name参数是变量的名称；expr参数是赋值表达式。一个SET语句可以同时为多个变量赋值，各个变量的赋值语句之间用逗号隔开。</p>
<p>【示例4】 下面为变量my_sql赋值为30。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET  my_sql = 30 ;</span><br></pre></td></tr></table></figure></p>
<p>MySQL中还可以使用SELECT…INTO语句为变量赋值。其基本语法如下：</p>
<blockquote>
<p><strong>SELECT  col_name[,…]  INTO  var_name[,…] FROM  table_name  WEHRE  condition </strong></p>
</blockquote>
<p>其中，col_name参数表示查询的字段名称；var_name参数是变量的名称；table_name参数指表的名称；condition参数指查询条件。</p>
<p>【示例5】 下面从employee表中查询id为2的记录，将该记录的d_id值赋给变量my_sql。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  d_id  INTO  my_sql  FROM  employee  WEHRE  id=2 ;</span><br></pre></td></tr></table></figure></p>
<h2 id="定义条件和处理程序"><a href="#定义条件和处理程序" class="headerlink" title="定义条件和处理程序"></a>定义条件和处理程序</h2><p>定义条件和处理程序是事先定义程序执行过程中可能遇到的问题。并且可以在处理程序中定义解决这些问题的办法。这种方式可以提前预测可能出现的问题，并提出解决办法。这样可以增强程序处理问题的能力，避免程序异常停止。MySQL中都是通过DECLARE关键字来定义条件和处理程序。</p>
<h3 id="定义条件"><a href="#定义条件" class="headerlink" title="定义条件"></a>定义条件</h3><p>MySQL中可以使用DECLARE关键字来定义条件。其基本语法如下：</p>
<blockquote>
<p><strong>DECLARE  condition_name  CONDITION  FOR  condition_value</strong><br>condition_value:<br>      SQLSTATE [VALUE] sqlstate_value | mysql_error_code </p>
</blockquote>
<p>其中，condition_name参数表示条件的名称；condition_value参数表示条件的类型；sqlstate_value参数和mysql_error_code参数都可以表示MySQL的错误。例如ERROR 1146 (42S02)中，sqlstate_value值是42S02，mysql_error_code值是1146。</p>
<p>【示例6】 下面定义”ERROR 1146 (42S02)”这个错误，名称为can_not_find。可以用两种不同的方法来定义，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方法一：使用sqlstate_value  </span><br><span class="line">DECLARE  can_not_find  CONDITION  FOR  SQLSTATE  &apos;42S02&apos; ;  </span><br><span class="line">//方法二：使用mysql_error_code  </span><br><span class="line">DECLARE  can_not_find  CONDITION  FOR  1146 ;</span><br></pre></td></tr></table></figure></p>
<h3 id="定义处理程序"><a href="#定义处理程序" class="headerlink" title="定义处理程序"></a>定义处理程序</h3><p>MySQL中可以使用DECLARE关键字来定义处理程序。其基本语法如下：</p>
<blockquote>
<p><strong>DECLARE handler_type HANDLER FOR condition_value[,…] sp_statement  </strong><br>handler_type:<br>    CONTINUE | EXIT | UNDO<br>condition_value:<br>    SQLSTATE [VALUE] sqlstate_value | condition_name  | SQLWARNING  | NOT FOUND  | SQLEXCEPTION  | mysql_error_code </p>
</blockquote>
<p>其中，handler_type参数指明错误的处理方式，该参数有3个取值。这3个取值分别是CONTINUE、EXIT和UNDO。CONTINUE表示遇到错误不进行处理，继续向下执行；EXIT表示遇到错误后马上退出；UNDO表示遇到错误后撤回之前的操作，MySQL中暂时还不支持这种处理方式。</p>
<p>注意：通常情况下，执行过程中遇到错误应该立刻停止执行下面的语句，并且撤回前面的操作。但是，MySQL中现在还不能支持UNDO操作。因此，遇到错误时最好执行EXIT操作。如果事先能够预测错误类型，并且进行相应的处理，那么可以执行CONTINUE操作。</p>
<p>condition_value参数指明错误类型，该参数有6个取值。sqlstate_value和mysql_error_code与条件定义中的是同一个意思。condition_name是DECLARE定义的条件名称。SQLWARNING表示所有以01开头的sqlstate_value值。NOT FOUND表示所有以02开头的sqlstate_value值。SQLEXCEPTION表示所有没有被SQLWARNING或NOT FOUND捕获的sqlstate_value值。sp_statement表示一些存储过程或函数的执行语句。</p>
<p>【示例7】 下面是定义处理程序的几种方式。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//方法一：捕获sqlstate_value  </span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;42S02&apos; SET @info=&apos;CAN NOT FIND&apos;;  </span><br><span class="line">//方法二：捕获mysql_error_code  </span><br><span class="line">DECLARE CONTINUE HANDLER FOR 1146 SET @info=&apos;CAN NOT FIND&apos;;  </span><br><span class="line">//方法三：先定义条件，然后调用  </span><br><span class="line">DECLARE  can_not_find  CONDITION  FOR  1146 ;  </span><br><span class="line">DECLARE CONTINUE HANDLER FOR can_not_find SET @info=&apos;CAN NOT FIND&apos;;  </span><br><span class="line">//方法四：使用SQLWARNING  </span><br><span class="line">DECLARE EXIT HANDLER FOR SQLWARNING SET @info=&apos;ERROR&apos;;  </span><br><span class="line">//方法五：使用NOT FOUND  </span><br><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND SET @info=&apos;CAN NOT FIND&apos;;  </span><br><span class="line">//方法六：使用SQLEXCEPTION  </span><br><span class="line">DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info=&apos;ERROR&apos;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码是6种定义处理程序的方法。</p>
<p>第一种方法是捕获sqlstate_value值。如果遇到sqlstate_value值为42S02，执行CONTINUE操作，并且输出”CAN NOT FIND”信息。</p>
<p>第二种方法是捕获mysql_error_code值。如果遇到mysql_error_code值为1146，执行CONTINUE操作，并且输出”CAN NOT FIND”信息。</p>
<p>第三种方法是先定义条件，然后再调用条件。这里先定义can_not_find条件，遇到1146错误就执行CONTINUE操作。</p>
<p>第四种方法是使用SQLWARNING。SQLWARNING捕获所有以01开头的sqlstate_value值，然后执行EXIT操作，并且输出”ERROR”信息。</p>
<p>第五种方法是使用NOT FOUND。NOT FOUND捕获所有以02开头的sqlstate_value值，然后执行EXIT操作，并且输出”CAN NOT FIND”信息。</p>
<p>第六种方法是使用SQLEXCEPTION。SQLEXCEPTION捕获所有没有被SQLWARNING或NOT FOUND捕获的sqlstate_value值，然后执行EXIT操作，并且输出”ERROR”信息。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/mark5/p/11170577.html" target="_blank" rel="noopener">https://www.cnblogs.com/mark5/p/11170577.html</a><br><a href="https://www.runoob.com/w3cnote/mysql-stored-procedure.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/mysql-stored-procedure.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/09/java-spring-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/09/java-spring-basics/" itemprop="url">Spring 知识点笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-09T11:26:23+08:00">
                2020-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/" itemprop="url" rel="index">
                    <span itemprop="name">Java Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Spring 有可能成为所有企业应用程序的一站式服务点，然而，Spring 是模块化的，允许你挑选和选择适用于你的模块，不必要把剩余部分也引入。Spring 框架提供约 20 个模块，可以根据应用程序的要求来使用。</p>
<p><img src="/2020/07/09/java-spring-basics/spring-framework.png" alt></p>
<h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><p>核心容器由spring-core，spring-beans，spring-context，spring-context-support和spring-expression（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下：</p>
<ul>
<li><p>spring-core模块提供了框架的基本组成部分，包括 IoC 和依赖注入功能。</p>
</li>
<li><p>spring-beans 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</p>
</li>
<li><p>context模块建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。ApplicationContext接口是Context模块的焦点。spring-context-support提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</p>
</li>
<li><p>spring-expression模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。</p>
</li>
</ul>
<p>它们的完整依赖关系如下图所示：</p>
<p><img src="/2020/07/09/java-spring-basics/spring-core.png" alt></p>
<h3 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h3><p>数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下：注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service）</p>
<ul>
<li><p>JDBC 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。</p>
</li>
<li><p>ORM 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。</p>
</li>
<li><p>OXM 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。</p>
</li>
<li><p>JMS 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。</p>
</li>
</ul>
<p>事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细）</p>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：</p>
<ul>
<li><p>Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。</p>
</li>
<li><p>Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。</p>
</li>
<li><p>Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。</p>
</li>
<li><p>Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下：</p>
<ul>
<li><p>AOP 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。</p>
</li>
<li><p>Aspects 模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。</p>
</li>
<li><p>Instrumentation 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。</p>
</li>
<li><p>Messaging 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。</p>
</li>
<li><p>测试模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。</p>
</li>
</ul>
<h2 id="Spring-IoC-容器"><a href="#Spring-IoC-容器" class="headerlink" title="Spring IoC 容器"></a>Spring IoC 容器</h2><p>Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用<strong>依赖注入（DI）</strong>来管理组成一个应用程序的组件。这些对象被称为 <strong>Spring Beans</strong>。</p>
<p>IOC 容器具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而<strong>“控制反转”</strong>是指new实例工作不由程序员来做而是交给Spring容器来做。Spring 提供了以下两种不同类型的容器:</p>
<p><img src="/2020/07/09/java-spring-basics/spring-ioc.png" alt></p>
<p><strong>ApplicationContext 容器包括 BeanFactory 容器的所有功能</strong>，所以通常建议超过 BeanFactory。BeanFactory 仍然可以用于轻量级的应用程序，如移动设备或基于 applet 的应用程序，其中它的数据量和速度是显著。</p>
<h3 id="Spring-的-BeanFactory-容器-忽略"><a href="#Spring-的-BeanFactory-容器-忽略" class="headerlink" title="Spring 的 BeanFactory 容器(忽略)"></a>Spring 的 BeanFactory 容器(忽略)</h3><p>这是一个最简单的容器，它主要的功能是为依赖注入 （DI） 提供支持，这个容器接口在 org.springframework.beans.factory.BeanFactor 中被定义。BeanFactory 和相关的接口，比如BeanFactoryAware、DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。</p>
<p>在 Spring 中，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。</p>
<h3 id="Spring-ApplicationContext-容器"><a href="#Spring-ApplicationContext-容器" class="headerlink" title="Spring ApplicationContext 容器"></a>Spring ApplicationContext 容器</h3><p>Application Context 是 BeanFactory 的子接口，也被成为 Spring 上下文。 这个容器在 org.springframework.context.ApplicationContext interface 接口中定义。</p>
<p>最常被使用的 ApplicationContext 接口实现：</p>
<ul>
<li><p>FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径。</p>
</li>
<li><p>ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</p>
</li>
<li><p>WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</p>
</li>
</ul>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSpringSingleton &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;/res/applicationContext.xml&quot;);</span><br><span class="line">        HelloWorld objA = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        objA.setName(&quot;I&apos;m object A&quot;);</span><br><span class="line">        objA.sqyHello();</span><br><span class="line">        HelloWorld objB = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        objB.sqyHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.out.println(&quot;Bean is going through init.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void destroy()&#123;</span><br><span class="line">        System.out.println(&quot;Bean will destroy now.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /res/applicationContext.xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;helloWorld&quot; class=&quot;com.zsm.test.HelloWorld&quot;</span><br><span class="line">          scope=&quot;singleton&quot;&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;helloWorld1&quot; class=&quot;com.zsm.test.HelloWorld&quot;</span><br><span class="line">          init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring-Bean-定义"><a href="#Spring-Bean-定义" class="headerlink" title="Spring Bean 定义"></a>Spring Bean 定义</h3><p>被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的。</p>
<p>bean 定义包含称为配置元数据的信息，下述容器也需要知道配置元数据：</p>
<ul>
<li><p>如何创建一个 bean</p>
</li>
<li><p>bean 的生命周期的详细信息</p>
</li>
<li><p>bean 的依赖关系</p>
</li>
</ul>
<p><img src="/2020/07/09/java-spring-basics/bean.jpg" alt title="Bean 与 Spring 容器的关系"></p>
<p>Spring IoC 容器完全由实际编写的配置元数据的格式解耦。有下面三个重要的方法把配置元数据提供给 Spring 容器：</p>
<ul>
<li><p>基于 XML 的配置文件</p>
</li>
<li><p>基于注解的配置</p>
</li>
<li><p>基于 Java 的配置</p>
</li>
</ul>
<h3 id="Spring-Bean-作用域"><a href="#Spring-Bean-作用域" class="headerlink" title="Spring Bean 作用域"></a>Spring Bean 作用域</h3><p><img src="/2020/07/09/java-spring-basics/spring-scope.png" alt></p>
<h3 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h3><p>为了定义安装和拆卸一个 bean，我们只要声明带有 <strong>init-method 或 destroy-method</strong> 参数的 。init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。</p>
<p>Bean的生命周期可以表达为：Bean的定义——Bean的初始化——Bean的使用——Bean的销毁。</p>
<h4 id="初始化及销毁回调"><a href="#初始化及销毁回调" class="headerlink" title="初始化及销毁回调"></a>初始化及销毁回调</h4><p>org.springframework.beans.factory.InitializingBean 接口指定一个单一的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void afterPropertiesSet() throws Exception;</span><br></pre></td></tr></table></figure></p>
<p>因此，你可以简单地实现上述接口和初始化工作可以在 afterPropertiesSet() 方法中执行，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean implements InitializingBean &#123;</span><br><span class="line">   public void afterPropertiesSet() &#123;</span><br><span class="line">      // do some initialization work</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在基于 XML 的配置元数据的情况下，你可以使用 init-method 属性来指定带有 void 无参数方法的名称。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面是类的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line">   public void init() &#123;</span><br><span class="line">      // do some initialization work</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>销毁回调 org.springframework.beans.factory.DisposableBean 与上述初始化回调类似。</p>
<p>main方法中，你需要注册一个在 AbstractApplicationContext 类中声明的关闭 hook 的 <strong>registerShutdownHook()</strong> 方法。它将确保正常关闭，并且调用相关的 destroy 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line">   HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">   obj.getMessage();</span><br><span class="line">   context.registerShutdownHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>建议不要使用 InitializingBean 或者 DisposableBean 的回调方法，因为 XML 配置在命名方法上提供了极大的灵活性。</strong></p>
<h4 id="默认的初始化和销毁方法"><a href="#默认的初始化和销毁方法" class="headerlink" title="默认的初始化和销毁方法"></a>默认的初始化和销毁方法</h4><p>如果你有太多具有相同名称的初始化或者销毁方法的 Bean，那么你不需要在每一个 bean 上声明初始化方法和销毁方法。框架使用 元素中的 default-init-method 和 default-destroy-method 属性提供了灵活地配置这种情况，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span><br><span class="line">    default-init-method=&quot;init&quot; </span><br><span class="line">    default-destroy-method=&quot;destroy&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">       &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring——Bean-后置处理器"><a href="#Spring——Bean-后置处理器" class="headerlink" title="Spring——Bean 后置处理器"></a>Spring——Bean 后置处理器</h3><p>Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。</p>
<p>BeanPostProcessor 接口定义回调方法，你可以实现该方法来提供自己的实例化逻辑，依赖解析逻辑等。你可以配置多个 BeanPostProcessor 接口，通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。</p>
<p>ApplicationContext <strong>会自动检测由 BeanPostProcessor 接口的实现定义的 bean</strong>，注册这些 bean 为后置处理器，然后通过在容器中创建 bean，在适当的时候调用它。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class InitHelloWorld implements BeanPostProcessor &#123;</span><br><span class="line">   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">      System.out.println(&quot;BeforeInitialization : &quot; + beanName);</span><br><span class="line">      return bean;  // you can return any other object as well</span><br><span class="line">   &#125;</span><br><span class="line">   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">      System.out.println(&quot;AfterInitialization : &quot; + beanName);</span><br><span class="line">      return bean;  // you can return any other object as well</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean class=&quot;com.zsm.test.InitHelloWorld&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Bean-定义继承"><a href="#Bean-定义继承" class="headerlink" title="Bean 定义继承"></a>Bean 定义继承</h3><p>Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;message1&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;message2&quot; value=&quot;Hello Second World!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;helloIndia&quot; class=&quot;com.tutorialspoint.HelloIndia&quot; parent=&quot;helloWorld&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;message1&quot; value=&quot;Hello India!&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring-依赖注入"><a href="#Spring-依赖注入" class="headerlink" title="Spring 依赖注入"></a>Spring 依赖注入</h2><h3 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h3><p>几种写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for textEditor bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;textEditor&quot; class=&quot;com.zsm.test.di.TextEditor&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;spellChecker&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for spellChecker bean --&gt;</span><br><span class="line">    &lt;!--&lt;bean id=&quot;spellChecker&quot; class=&quot;com.zsm.test.di.SpellChecker&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;spellChecker&quot; class=&quot;com.zsm.test.di.SpellChecker&quot;&gt;</span><br><span class="line">        &lt;!--存在不止一个参数时，构造函数的参数在 bean 定义中的顺序就是把这些参数提供给适当的构造函数的顺序就可以了。考虑下面的类:--&gt;</span><br><span class="line">        &lt;!--&lt;constructor-arg ref=&quot;helloWorld&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;helloWorld2&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--如果你使用 type 属性显式的指定了构造函数参数的类型，容器也可以使用与简单类型匹配的类型。例如：--&gt;</span><br><span class="line">        &lt;!--&lt;constructor-arg type=&quot;int&quot; value=&quot;2001&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;Zara&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--最后并且也是最好的传递构造函数参数的方式，使用 index 属性来显式的指定构造函数参数的索引。下面是基于索引为 0 的例子，如下所示：--&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot; value=&quot;2001&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;1&quot; value=&quot;Zara&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;helloWorld&quot; class=&quot;com.zsm.test.HelloWorld&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;helloWorld2&quot; class=&quot;com.zsm.test.HelloWorld2&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name2&quot; value=&quot;Hello World2!&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    public SpellChecker() &#123;</span><br><span class="line">        System.out.println(&quot;Inside SpellChecker constructor.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public SpellChecker(int num, String desc) &#123;</span><br><span class="line">      System.out.println(&quot;Inside SpellChecker constructor:&quot; + num + &quot;;&quot; + desc);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public SpellChecker(HelloWorld num, HelloWorld2 desc) &#123;</span><br><span class="line">      System.out.println(&quot;Inside SpellChecker constructor:&quot; + num.getName() + &quot;;&quot; + desc.getName2());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void checkSpelling() &#123;</span><br><span class="line">        System.out.println(&quot;Inside checkSpelling.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line">      TextEditor te = (TextEditor) context.getBean(&quot;textEditor&quot;);</span><br><span class="line">      te.spellCheck();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于设值函数的依赖注入"><a href="#基于设值函数的依赖注入" class="headerlink" title="基于设值函数的依赖注入"></a>基于设值函数的依赖注入</h3><p>和构造函数注入唯一的区别就是在基于构造函数注入中，我们使用的是〈bean〉标签中的〈constructor-arg〉元素，而在基于设值函数的注入中，我们使用的是〈bean〉标签中的<strong>〈property〉</strong>元素。</p>
<p>第二个需要注意的点是，如果你要把一个引用传递给一个对象，那么你需要使用 标签的 ref 属性，而如果你要直接传递一个值，那么你应该使用 value 属性。</p>
<p>如果你有许多的设值函数方法，那么在 XML 配置文件中使用 <strong>p-namespace</strong> 是非常方便的（ref则须加后缀-ref）。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//上述 XML 配置文件可以使用 p-namespace 以一种更简洁的方式重写，如下所示：</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;john-classic&quot; class=&quot;com.example.Person&quot;</span><br><span class="line">      p:name=&quot;John Doe&quot;</span><br><span class="line">      p:spouse-ref=&quot;jane&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;</span><br><span class="line">      p:name=&quot;John Doe&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="注入内部-Beans"><a href="#注入内部-Beans" class="headerlink" title="注入内部 Beans"></a>注入内部 Beans</h3><p>正如你所知道的 Java 内部类是在其他类的范围内被定义的，同理，inner beans 是在其他 bean 的范围内定义的 bean。定义入下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;outerBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">         &lt;bean id=&quot;innerBean&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;textEditor&quot; class=&quot;com.zsm.test.interclass.TextEditor&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;spellChecker&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;com.zsm.test.interclass.SpellChecker&quot;/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="注入集合"><a href="#注入集合" class="headerlink" title="注入集合"></a>注入集合</h3><p>现在如果你想传递多个值，如 Java Collection 类型 List、Set、Map 和 Properties，应该怎么做呢。为了处理这种情况，Spring 提供了四种类型的集合的配置元素，如下所示：</p>
<p><img src="/2020/07/09/java-spring-basics/spring-collection.png" alt></p>
<p>示例入下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- Definition for javaCollection --&gt;</span><br><span class="line">   &lt;bean id=&quot;javaCollection&quot; class=&quot;com.tutorialspoint.JavaCollection&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressList(java.util.List) call --&gt;</span><br><span class="line">      &lt;property name=&quot;addressList&quot;&gt;</span><br><span class="line">         &lt;list&gt;</span><br><span class="line">            &lt;value&gt;INDIA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">         &lt;/list&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressSet(java.util.Set) call --&gt;</span><br><span class="line">      &lt;property name=&quot;addressSet&quot;&gt;</span><br><span class="line">         &lt;set&gt;</span><br><span class="line">            &lt;value&gt;INDIA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressMap(java.util.Map) call --&gt;</span><br><span class="line">      &lt;property name=&quot;addressMap&quot;&gt;</span><br><span class="line">         &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;1&quot; value=&quot;INDIA&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;2&quot; value=&quot;Pakistan&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;3&quot; value=&quot;USA&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;4&quot; value=&quot;USA&quot;/&gt;</span><br><span class="line">         &lt;/map&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressProp(java.util.Properties) call --&gt;</span><br><span class="line">      &lt;property name=&quot;addressProp&quot;&gt;</span><br><span class="line">         &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;one&quot;&gt;INDIA&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;two&quot;&gt;Pakistan&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;three&quot;&gt;USA&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;four&quot;&gt;USA&lt;/prop&gt;</span><br><span class="line">         &lt;/props&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>也<strong>可以将引用和值混合在一起</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Passing bean reference  for java.util.Set --&gt;</span><br><span class="line">&lt;property name=&quot;addressSet&quot;&gt;</span><br><span class="line">   &lt;set&gt;</span><br><span class="line">      &lt;ref bean=&quot;address1&quot;/&gt;</span><br><span class="line">      &lt;ref bean=&quot;address2&quot;/&gt;</span><br><span class="line">      &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">   &lt;/set&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Passing bean reference  for java.util.Map --&gt;</span><br><span class="line">&lt;property name=&quot;addressMap&quot;&gt;</span><br><span class="line">   &lt;map&gt;</span><br><span class="line">      &lt;entry key=&quot;one&quot; value=&quot;INDIA&quot;/&gt;</span><br><span class="line">      &lt;entry key =&quot;two&quot; value-ref=&quot;address1&quot;/&gt;</span><br><span class="line">      &lt;entry key =&quot;three&quot; value-ref=&quot;address2&quot;/&gt;</span><br><span class="line">   &lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="注入-null-和空字符串的值"><a href="#注入-null-和空字符串的值" class="headerlink" title="注入 null 和空字符串的值"></a>注入 null 和空字符串的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;...&quot; class=&quot;exampleBean&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>相当于：exampleBean.setEmail(“”)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;...&quot; class=&quot;exampleBean&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;email&quot;&gt;&lt;null/&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>相当于：exampleBean.setEmail(null)。</p>
<h2 id="Beans-自动装配"><a href="#Beans-自动装配" class="headerlink" title="Beans 自动装配"></a>Beans 自动装配</h2><p>Spring 容器可以在不使用&lt;constructor-arg&gt;和&lt;property&gt; 元素的情况下自动装配相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。</p>
<p>你可以使用&lt;bean&gt;元素的 <strong>autowire</strong> 属性为一个 bean 定义指定自动装配模式：</p>
<p><img src="/2020/07/09/java-spring-basics/beans-auto.png" alt></p>
<p>可以使用 byType 或者 constructor 自动装配模式来连接数组和其他类型的集合。</p>
<h3 id="自动装配的局限性"><a href="#自动装配的局限性" class="headerlink" title="自动装配的局限性"></a>自动装配的局限性</h3><p>当<strong>自动装配始终在同一个项目中使用时，它的效果最好</strong>。如果通常不使用自动装配，它<strong>可能会使开发人员混淆的使用它来连接只有一个或两个 bean 定义</strong>。不过，自动装配可以显著减少需要指定的属性或构造器参数，但你应该在使用它们之前考虑到自动装配的局限性和缺点。</p>
<p><img src="/2020/07/09/java-spring-basics/beans-auto-limit.png" alt></p>
<h3 id="自动装配-‘byName’"><a href="#自动装配-‘byName’" class="headerlink" title="自动装配 ‘byName’"></a>自动装配 ‘byName’</h3><p>这种模式由属性名称指定自动装配。</p>
<p>例如，在配置文件中，如果一个 bean 定义设置为自动装配 byName，并且它包含 spellChecker 属性（即，它有一个 setSpellChecker(…) 方法），那么 Spring 就会查找定义名为 spellChecker 的 bean，并且用它来设置这个属性。你<strong>仍然可以使用 <property> 标签连接其余的属性</property></strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--&lt;bean id=&quot;textEditor&quot; class=&quot;com.zsm.test.interclass.TextEditor&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;spellChecker&quot; ref=&quot;spellChecker&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;Generic Text Editor&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;--&gt;</span><br><span class="line"></span><br><span class="line">//使用autowire后</span><br><span class="line">&lt;bean id=&quot;textEditor&quot; class=&quot;com.tutorialspoint.TextEditor&quot; </span><br><span class="line">  autowire=&quot;byName&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;name&quot; value=&quot;Generic Text Editor&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;spellChecker&quot; class=&quot;com.tutorialspoint.SpellChecker&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="自动装配-‘byType’"><a href="#自动装配-‘byType’" class="headerlink" title="自动装配 ‘byType’"></a>自动装配 ‘byType’</h3><p>这种模式由属性类型指定自动装配。</p>
<h3 id="由构造函数自动装配"><a href="#由构造函数自动装配" class="headerlink" title="由构造函数自动装配"></a>由构造函数自动装配</h3><p>这种模式与 byType 非常相似，但它应用于构造器参数。</p>
<h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h2><p>从 Spring 2.5 开始就可以使用注解来配置依赖注入，而不是采用 XML 来描述一个 bean 连线。在 XML 注入之前进行注解注入，因此后者的配置将通过两种方式的<strong>属性连线</strong>被前者重写。</p>
<p>注解连线在默认情况下在 Spring 容器中不打开。启用配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br></pre></td></tr></table></figure></p>
<p>让我们来看看几个重要的注解，并且了解它们是如何工作的：</p>
<p><img src="/2020/07/09/java-spring-basics/annotation.png" alt></p>
<h3 id="Required-注释"><a href="#Required-注释" class="headerlink" title="@Required 注释"></a>@Required 注释</h3><p>@Required 注释应用于 bean 属性的 setter 方法，<strong>它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中</strong>，否则容器就会抛出一个 BeanInitializationException 异常。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">   private Integer age;</span><br><span class="line">   private String name;</span><br><span class="line">   @Required</span><br><span class="line">   public void setAge(Integer age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   public Integer getAge() &#123;</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line">   @Required</span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getName() &#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;student&quot; class=&quot;com.tutorialspoint.Student&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;name&quot;  value=&quot;Zara&quot; /&gt;</span><br><span class="line">      &lt;property name=&quot;age&quot;  value=&quot;11&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Autowired-注释"><a href="#Autowired-注释" class="headerlink" title="@Autowired 注释"></a>@Autowired 注释</h3><p>@Autowired 注释对在哪里和如何完成自动连接提供了更多的细微的控制</p>
<p>1.Setter 方法中的 @Autowired<br>你可以在 XML 文件中的 setter 方法中使用 @Autowired 注释来除去 元素。当 Spring遇到一个在 setter 方法中使用的 @Autowired 注释，它会在方法中视图执行 byType 自动连接。</p>
<p>2.构造函数中的 @Autowired<br>你也可以在构造函数中使用 @Autowired。一个构造函数 @Autowired 说明当创建 bean 时，即使在 XML 文件中没有使用 元素配置 bean ，构造函数也会被自动连接。</p>
<p>3.属性中的 @Autowired<br>你可以在属性中使用 @Autowired 注释来除去 setter 方法。当时使用 为自动连接属性传递的时候，Spring 会将这些传递过来的值或者引用自动分配给那些属性。</p>
<p>4.@Autowired 的（required=false）选项<br>默认情况下，@Autowired 注释意味着依赖是必须的，它类似于 @Required 注释，然而，你可以使用 @Autowired 的 （required=false） 选项关闭默认行为。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TextEditor &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private SpellChecker spellChecker;</span><br><span class="line">   public TextEditor() &#123;</span><br><span class="line">      System.out.println(&quot;Inside TextEditor constructor.&quot; );</span><br><span class="line">   &#125;  </span><br><span class="line">   public SpellChecker getSpellChecker( )&#123;</span><br><span class="line">      return spellChecker;</span><br><span class="line">   &#125;  </span><br><span class="line">   public void spellCheck()&#123;</span><br><span class="line">      spellChecker.checkSpelling();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for textEditor bean --&gt;</span><br><span class="line">&lt;bean id=&quot;textEditor&quot; class=&quot;com.tutorialspoint.TextEditor&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for spellChecker bean --&gt;</span><br><span class="line">&lt;bean id=&quot;spellChecker&quot; class=&quot;com.tutorialspoint.SpellChecker&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Qualifier-注释"><a href="#Qualifier-注释" class="headerlink" title="@Qualifier 注释"></a>@Qualifier 注释</h3><p>当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。相当于<strong>别名</strong>。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Profile &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   @Qualifier(&quot;student1&quot;)</span><br><span class="line">   private Student student;</span><br><span class="line">   public Profile()&#123;</span><br><span class="line">      System.out.println(&quot;Inside Profile constructor.&quot; );</span><br><span class="line">   &#125;</span><br><span class="line">   public void printAge() &#123;</span><br><span class="line">      System.out.println(&quot;Age : &quot; + student.getAge() );</span><br><span class="line">   &#125;</span><br><span class="line">   public void printName() &#123;</span><br><span class="line">      System.out.println(&quot;Name : &quot; + student.getName() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for profile bean --&gt;</span><br><span class="line">&lt;bean id=&quot;profile&quot; class=&quot;com.tutorialspoint.Profile&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for student1 bean --&gt;</span><br><span class="line">&lt;bean id=&quot;student1&quot; class=&quot;com.tutorialspoint.Student&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;name&quot;  value=&quot;Zara&quot; /&gt;</span><br><span class="line">  &lt;property name=&quot;age&quot;  value=&quot;11&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for student2 bean --&gt;</span><br><span class="line">&lt;bean id=&quot;student2&quot; class=&quot;com.tutorialspoint.Student&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;name&quot;  value=&quot;Nuha&quot; /&gt;</span><br><span class="line">  &lt;property name=&quot;age&quot;  value=&quot;2&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring-JSR-250-注释"><a href="#Spring-JSR-250-注释" class="headerlink" title="Spring JSR-250 注释"></a>Spring JSR-250 注释</h3><p>Spring还使用基于 JSR-250 注释，它包括 @PostConstruct， @PreDestroy 和 @Resource 注释。这些注释并不是必需的，只是一个<strong>替代方案</strong>。</p>
<p>为了定义一个 bean 的安装和卸载，我们使用 init-method 和/或 destroy-method 参数简单的声明一下 。init-method 属性指定了一个方法，该方法在 bean 的实例化阶段会立即被调用。同样地，destroy-method 指定了一个方法，该方法只在一个 bean 从容器中删除之前被调用。你<strong>可以使用 @PostConstruct 注释作为初始化回调函数的一个替代，@PreDestroy 注释作为销毁回调函数的一个替代</strong>。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class TextEditor &#123;</span><br><span class="line">   private SpellChecker spellChecker;</span><br><span class="line">   @Resource(name= &quot;spellChecker&quot;)</span><br><span class="line">   public void setSpellChecker( SpellChecker spellChecker )&#123;</span><br><span class="line">      this.spellChecker = spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">   public SpellChecker getSpellChecker()&#123;</span><br><span class="line">      return spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">   public void spellCheck()&#123;</span><br><span class="line">      spellChecker.checkSpelling();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">   private String message;</span><br><span class="line">   public void setMessage(String message)&#123;</span><br><span class="line">      this.message  = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getMessage()&#123;</span><br><span class="line">      System.out.println(&quot;Your Message : &quot; + message);</span><br><span class="line">      return message;</span><br><span class="line">   &#125;</span><br><span class="line">   @PostConstruct</span><br><span class="line">   public void init()&#123;</span><br><span class="line">      System.out.println(&quot;Bean is going through init.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   @PreDestroy</span><br><span class="line">   public void destroy()&#123;</span><br><span class="line">      System.out.println(&quot;Bean will destroy now.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;helloWorld&quot; </span><br><span class="line">   class=&quot;com.tutorialspoint.HelloWorld&quot;</span><br><span class="line">   init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于-Java-的配置"><a href="#基于-Java-的配置" class="headerlink" title="基于 Java 的配置"></a>基于 Java 的配置</h3><p>带有 @Configuration 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。@Bean 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。最简单可行的 @Configuration 类如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class HelloWorldConfig &#123;</span><br><span class="line">   @Bean </span><br><span class="line">   public HelloWorld helloWorld()&#123;</span><br><span class="line">      return new HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面的代码将等同于下面的 XML 配置：</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，带有 @Bean 注解的方法名称作为 bean 的 ID，它创建并返回实际的 bean。你的配置类可以声明多个 @Bean。一旦定义了配置类，你就可以使用 AnnotationConfigApplicationContext 来加载并把他们提供给 Spring 容器，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfig.class); </span><br><span class="line">   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);</span><br><span class="line">   helloWorld.setMessage(&quot;Hello World!&quot;);</span><br><span class="line">   helloWorld.getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//你可以加载各种配置类，如下所示：</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">   ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">   ctx.register(AdditionalConfig.class);</span><br><span class="line">   ctx.refresh();</span><br><span class="line">   MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">   myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h4><p>@import 注解允许<strong>从另一个配置类中加载 @Bean 定义</strong>。考虑 ConfigA 类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ConfigA &#123;</span><br><span class="line">   @Bean</span><br><span class="line">   public A a() &#123;</span><br><span class="line">      return new A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//你可以在另一个 Bean 声明中导入上述 Bean 声明，如下所示：</span><br><span class="line">@Configuration</span><br><span class="line">@Import(ConfigA.class)</span><br><span class="line">public class ConfigB &#123;</span><br><span class="line">   @Bean</span><br><span class="line">   public B a() &#123;</span><br><span class="line">      return new A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当实例化上下文时，不需要同时指定 ConfigA.class 和 ConfigB.class，只有 ConfigB 类需要提供，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   ApplicationContext ctx = </span><br><span class="line">   new AnnotationConfigApplicationContext(ConfigB.class);</span><br><span class="line">   // now both beans A and B will be available...</span><br><span class="line">   A a = ctx.getBean(A.class);</span><br><span class="line">   B b = ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h4><p>@Bean 注解支持指定任意的初始化和销毁的回调方法，就像在 bean 元素中 Spring 的 XML 的初始化方法和销毁方法的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">   public void init() &#123;</span><br><span class="line">      // initialization logic</span><br><span class="line">   &#125;</span><br><span class="line">   public void cleanup() &#123;</span><br><span class="line">      // destruction logic</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">   @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;cleanup&quot; )</span><br><span class="line">   public Foo foo() &#123;</span><br><span class="line">      return new Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定 Bean 的范围。<strong>默认范围是单实例，但是你可以重写带有 @Scope 注解的该方法</strong>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">   @Bean</span><br><span class="line">   @Scope(&quot;prototype&quot;)</span><br><span class="line">   public Foo foo() &#123;</span><br><span class="line">      return new Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>Spring 的核心是 ApplicationContext，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。例如，当上下文启动时，ContextStartedEvent 发布，当上下文停止时，ContextStoppedEvent 发布。</p>
<p>Spring 提供了以下的标准事件：</p>
<p><img src="/2020/07/09/java-spring-basics/event.png" alt></p>
<p>由于 <strong>Spring 的事件处理是单线程的</strong>，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被<strong>阻塞</strong>并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.ApplicationEvent;</span><br><span class="line">public class CustomEvent extends ApplicationEvent&#123; </span><br><span class="line">   public CustomEvent(Object source) &#123;</span><br><span class="line">      super(source);</span><br><span class="line">   &#125;</span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return &quot;My Custom Event&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是 CustomEventPublisher.java 文件的内容：</span><br><span class="line">import org.springframework.context.ApplicationEventPublisher;</span><br><span class="line">import org.springframework.context.ApplicationEventPublisherAware;</span><br><span class="line">public class CustomEventPublisher implements ApplicationEventPublisherAware &#123;</span><br><span class="line">   private ApplicationEventPublisher publisher;</span><br><span class="line">   public void setApplicationEventPublisher(ApplicationEventPublisher publisher)&#123;</span><br><span class="line">      this.publisher = publisher;</span><br><span class="line">   &#125;</span><br><span class="line">   public void publish() &#123;</span><br><span class="line">      CustomEvent ce = new CustomEvent(this);</span><br><span class="line">      publisher.publishEvent(ce);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是 CustomEventHandler.java 文件的内容：</span><br><span class="line">import org.springframework.context.ApplicationListener;</span><br><span class="line">public class CustomEventHandler implements ApplicationListener&lt;CustomEvent&gt;&#123;</span><br><span class="line">   public void onApplicationEvent(CustomEvent event) &#123;</span><br><span class="line">      System.out.println(event.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是 MainApp.java 文件的内容：</span><br><span class="line">import org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ConfigurableApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);    </span><br><span class="line">      CustomEventPublisher cvp = (CustomEventPublisher) context.getBean(&quot;customEventPublisher&quot;);</span><br><span class="line">      cvp.publish();  </span><br><span class="line">      cvp.publish();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是配置文件 Beans.xml：</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;customEventHandler&quot; </span><br><span class="line">      class=&quot;com.tutorialspoint.CustomEventHandler&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;customEventPublisher&quot; </span><br><span class="line">      class=&quot;com.tutorialspoint.CustomEventPublisher&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//输出以下信息：</span><br><span class="line">My Custom Event</span><br><span class="line">My Custom Event</span><br></pre></td></tr></table></figure>
<h2 id="Spring-框架的-AOP"><a href="#Spring-框架的-AOP" class="headerlink" title="Spring 框架的 AOP"></a>Spring 框架的 AOP</h2><p>Spring 框架的一个关键组件是<strong>面向方面的编程(AOP)</strong>框架。面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。跨一个应用程序的多个点的功能被称为<strong>横切关注点</strong>，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。</p>
<p>Spring AOP 模块提供拦截器来拦截一个应用程序，例如，当执行一个方法时，你可以在方法执行之前或之后添加额外的功能。</p>
<h3 id="AOP-术语"><a href="#AOP-术语" class="headerlink" title="AOP 术语"></a>AOP 术语</h3><p><img src="/2020/07/09/java-spring-basics/aop.png" alt></p>
<h3 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h3><p>Spring 方面可以使用下面提到的五种通知工作：</p>
<p><img src="/2020/07/09/java-spring-basics/aop-type.png" alt></p>
<h3 id="基于-AOP-的-XML架构"><a href="#基于-AOP-的-XML架构" class="headerlink" title="基于 AOP 的 XML架构"></a>基于 AOP 的 XML架构</h3><h4 id="声明一个-aspect"><a href="#声明一个-aspect" class="headerlink" title="声明一个 aspect"></a>声明一个 aspect</h4><p>一个 aspect 是使用 元素声明的，支持的 bean 是使用 ref 属性引用的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明一个切入点"><a href="#声明一个切入点" class="headerlink" title="声明一个切入点"></a>声明一个切入点</h4><p>一个切入点有助于确定使用不同建议执行的感兴趣的连接点（即方法）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;</span><br><span class="line">   &lt;aop:pointcut id=&quot;businessService&quot;</span><br><span class="line">      expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明建议"><a href="#声明建议" class="headerlink" title="声明建议"></a>声明建议</h4><p>你可以使用 &lt;aop:{ADVICE NAME}&gt; 元素在一个 中声明五个建议中的任何一个，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;</span><br><span class="line">      &lt;aop:pointcut id=&quot;businessService&quot;</span><br><span class="line">         expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;</span><br><span class="line">      &lt;!-- a before advice definition --&gt;</span><br><span class="line">      &lt;aop:before pointcut-ref=&quot;businessService&quot; </span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">      &lt;!-- an after advice definition --&gt;</span><br><span class="line">      &lt;aop:after pointcut-ref=&quot;businessService&quot; </span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">      &lt;!-- an after-returning advice definition --&gt;</span><br><span class="line">      &lt;!--The doRequiredTask method must have parameter named retVal --&gt;</span><br><span class="line">      &lt;aop:after-returning pointcut-ref=&quot;businessService&quot;</span><br><span class="line">         returning=&quot;retVal&quot;</span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">      &lt;!-- an after-throwing advice definition --&gt;</span><br><span class="line">      &lt;!--The doRequiredTask method must have parameter named ex --&gt;</span><br><span class="line">      &lt;aop:after-throwing pointcut-ref=&quot;businessService&quot;</span><br><span class="line">         throwing=&quot;ex&quot;</span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">      &lt;!-- an around advice definition --&gt;</span><br><span class="line">      &lt;aop:around pointcut-ref=&quot;businessService&quot; </span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">public class Logging &#123;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * before a selected method execution.</span><br><span class="line">    */</span><br><span class="line">   public void beforeAdvice()&#123;</span><br><span class="line">      System.out.println(&quot;Going to setup student profile.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * after a selected method execution.</span><br><span class="line">    */</span><br><span class="line">   public void afterAdvice()&#123;</span><br><span class="line">      System.out.println(&quot;Student profile has been setup.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * when any method returns.</span><br><span class="line">    */</span><br><span class="line">   public void afterReturningAdvice(Object retVal)&#123;</span><br><span class="line">      System.out.println(&quot;Returning:&quot; + retVal.toString() );</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * if there is an exception raised.</span><br><span class="line">    */</span><br><span class="line">   public void AfterThrowingAdvice(IllegalArgumentException ex)&#123;</span><br><span class="line">      System.out.println(&quot;There has been an exception: &quot; + ex.toString());   </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">   private Integer age;</span><br><span class="line">   private String name;</span><br><span class="line">   public void setAge(Integer age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   public Integer getAge() &#123;</span><br><span class="line">      System.out.println(&quot;Age : &quot; + age );</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getName() &#123;</span><br><span class="line">      System.out.println(&quot;Name : &quot; + name );</span><br><span class="line">      return name;</span><br><span class="line">   &#125;  </span><br><span class="line">   public void printThrowException()&#123;</span><br><span class="line">       System.out.println(&quot;Exception raised&quot;);</span><br><span class="line">       throw new IllegalArgumentException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext context =</span><br><span class="line">             new ClassPathXmlApplicationContext(&quot;BeansAop.xml&quot;);</span><br><span class="line">      Student student = (Student) context.getBean(&quot;student&quot;);</span><br><span class="line">      student.getName();</span><br><span class="line">      student.getAge();      </span><br><span class="line">      student.printThrowException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">    http://www.springframework.org/schema/aop</span><br><span class="line">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;log&quot; ref=&quot;logging&quot;&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;selectAll&quot;</span><br><span class="line">                          expression=&quot;execution(* com.zsm.test.aop.*.*(..))&quot;/&gt;</span><br><span class="line">            &lt;aop:before pointcut-ref=&quot;selectAll&quot; method=&quot;beforeAdvice&quot;/&gt;</span><br><span class="line">            &lt;aop:after pointcut-ref=&quot;selectAll&quot; method=&quot;afterAdvice&quot;/&gt;</span><br><span class="line">            &lt;aop:after-returning pointcut-ref=&quot;selectAll&quot;</span><br><span class="line">                                 returning=&quot;retVal&quot;</span><br><span class="line">                                 method=&quot;afterReturningAdvice&quot;/&gt;</span><br><span class="line">            &lt;aop:after-throwing pointcut-ref=&quot;selectAll&quot;</span><br><span class="line">                                throwing=&quot;ex&quot;</span><br><span class="line">                                method=&quot;AfterThrowingAdvice&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--&lt;aop:config&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;log&quot; ref=&quot;logging&quot;&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;selectAll&quot;</span><br><span class="line">                          expression=&quot;execution(* com.zsm.test.aop.Student.getName(..))&quot;/&gt;</span><br><span class="line">            &lt;aop:before pointcut-ref=&quot;selectAll&quot; method=&quot;beforeAdvice&quot;/&gt;</span><br><span class="line">            &lt;aop:after pointcut-ref=&quot;selectAll&quot; method=&quot;afterAdvice&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for student bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;com.zsm.test.aop.Student&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot;  value=&quot;Zara&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot;  value=&quot;11&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for logging aspect --&gt;</span><br><span class="line">    &lt;bean id=&quot;logging&quot; class=&quot;com.zsm.test.aop.Logging&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">Going to setup student profile.</span><br><span class="line">Name : Zara</span><br><span class="line">Student profile has been setup.</span><br><span class="line">Returning:Zara</span><br><span class="line">Going to setup student profile.</span><br><span class="line">Age : 11</span><br><span class="line">Student profile has been setup.</span><br><span class="line">Returning:11</span><br><span class="line">Going to setup student profile.</span><br><span class="line">Exception raised</span><br><span class="line">Student profile has been setup.</span><br><span class="line">There has been an exception: java.lang.IllegalArgumentException</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">	at com.zsm.test.aop.Student.printThrowException(Student.java:22)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h3 id="基于-AOP-的-AspectJ"><a href="#基于-AOP-的-AspectJ" class="headerlink" title="基于 AOP 的 @AspectJ"></a>基于 AOP 的 @AspectJ</h3><p>@AspectJ 作为通过 Java 5 注释注释的普通的 Java 类，它指的是声明 aspects 的一种风格。通过在你的基于架构的 XML 配置文件中包含以下元素，@AspectJ 支持是可用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意：aspectjrt.jar，aspectjweaver.jar添加到lib</p>
<h4 id="声明一个-aspect-1"><a href="#声明一个-aspect-1" class="headerlink" title="声明一个 aspect"></a>声明一个 aspect</h4><p>Aspects 类和其他任何正常的 bean 一样，除了它们将会用 @AspectJ 注释之外，它和其他类一样可能有方法和字段，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AspectModule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明一个切入点-1"><a href="#声明一个切入点-1" class="headerlink" title="声明一个切入点"></a>声明一个切入点</h4><p>一个切入点有助于确定使用不同建议执行的感兴趣的连接点（即方法）。在处理基于配置的 XML 架构时，切入点的声明有两个部分：</p>
<ul>
<li><p>一个切入点表达式决定了我们感兴趣的哪个方法会真正被执行。</p>
</li>
<li><p>一个切入点标签包含一个名称和任意数量的参数。方法的真正内容是不相干的，并且实际上它应该是空的。</p>
</li>
</ul>
<p>下面的示例中定义了一个名为 ‘businessService’ 的切入点，该切入点将与 com.xyz.myapp.service 包下的类中可用的每一个方法相匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;) // expression </span><br><span class="line">private void businessService() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明建议-1"><a href="#声明建议-1" class="headerlink" title="声明建议"></a>声明建议</h4><p>你可以使用 @{ADVICE-NAME} 注释声明五个建议中的任意一个，如下所示。这假设你已经定义了一个切入点标签方法 businessService()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Before(&quot;businessService()&quot;)</span><br><span class="line">public void doBeforeTask()&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">@After(&quot;businessService()&quot;)</span><br><span class="line">public void doAfterTask()&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">@AfterReturning(pointcut = &quot;businessService()&quot;, returning=&quot;retVal&quot;)</span><br><span class="line">public void doAfterReturnningTask(Object retVal)&#123;</span><br><span class="line">  // you can intercept retVal here.</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">@AfterThrowing(pointcut = &quot;businessService()&quot;, throwing=&quot;ex&quot;)</span><br><span class="line">public void doAfterThrowingTask(Exception ex)&#123;</span><br><span class="line">  // you can intercept thrown exception here.</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">@Around(&quot;businessService()&quot;)</span><br><span class="line">public void doAroundTask()&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以为任意一个建议定义你的切入点内联。下面是在建议之前定义内联切入点的一个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Before(&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;)</span><br><span class="line">public doBeforeTask()&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class Logging &#123;</span><br><span class="line">   /** Following is the definition for a pointcut to select</span><br><span class="line">    *  all the methods available. So advice will be called</span><br><span class="line">    *  for all the methods.</span><br><span class="line">    */</span><br><span class="line">   @Pointcut(&quot;execution(* com.zsm.test.aop.anno.*.*(..))&quot;)</span><br><span class="line">   private void selectAll()&#123;&#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * before a selected method execution.</span><br><span class="line">    */</span><br><span class="line">   @Before(&quot;selectAll()&quot;)</span><br><span class="line">   public void beforeAdvice()&#123;</span><br><span class="line">      System.out.println(&quot;Going to setup student profile.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * after a selected method execution.</span><br><span class="line">    */</span><br><span class="line">   @After(&quot;selectAll()&quot;)</span><br><span class="line">   public void afterAdvice()&#123;</span><br><span class="line">      System.out.println(&quot;Student profile has been setup.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * when any method returns.</span><br><span class="line">    */</span><br><span class="line">   @AfterReturning(pointcut = &quot;selectAll()&quot;, returning=&quot;retVal&quot;)</span><br><span class="line">   public void afterReturningAdvice(Object retVal)&#123;</span><br><span class="line">      System.out.println(&quot;Returning:&quot; + retVal.toString() );</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * if there is an exception raised by any method.</span><br><span class="line">    */</span><br><span class="line">   @AfterThrowing(pointcut = &quot;selectAll()&quot;, throwing = &quot;ex&quot;)</span><br><span class="line">   public void AfterThrowingAdvice(IllegalArgumentException ex)&#123;</span><br><span class="line">      System.out.println(&quot;There has been an exception: &quot; + ex.toString());   </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">    http://www.springframework.org/schema/aop</span><br><span class="line">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for student bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;com.zsm.test.aop.anno.Student&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot;  value=&quot;Zara&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot;  value=&quot;11&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for logging aspect --&gt;</span><br><span class="line">    &lt;bean id=&quot;logging&quot; class=&quot;com.zsm.test.aop.anno.Logging&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-JDBC-框架"><a href="#Spring-JDBC-框架" class="headerlink" title="Spring JDBC 框架"></a>Spring JDBC 框架</h2><p>Spring JDBC 提供几种方法和数据库中相应的不同的类与接口。我将给出使用 JdbcTemplate 类框架的经典和最受欢迎的方法。这是管理所有数据库通信和异常处理的中央框架类。</p>
<h3 id="JdbcTemplate-类"><a href="#JdbcTemplate-类" class="headerlink" title="JdbcTemplate 类"></a>JdbcTemplate 类</h3><p>JdbcTemplate 类执行 SQL 查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。它也捕获 JDBC 异常并转换它们到 org.springframework.dao 包中定义的通用类、更多的信息、异常层次结构。</p>
<p>JdbcTemplate 类的实例是<strong>线程安全</strong>配置的。所以你可以配置 JdbcTemplate 的单个实例，然后将这个共享的引用安全地注入到多个 DAOs 中。</p>
<p>使用 JdbcTemplate 类时常见的做法是在你的 Spring 配置文件中配置数据源，然后共享数据源 bean 依赖注入到 DAO 类中，并在数据源的设值函数中创建了 JdbcTemplate。</p>
<h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>我们在数据库 TEST 中创建一个数据库表 Student。假设你正在使用 MySQL 数据库，如果你使用其他数据库，那么你可以改变你的 DDL 和相应的 SQL 查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student(</span><br><span class="line">   ID   INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">   NAME VARCHAR(20) NOT NULL,</span><br><span class="line">   AGE  INT NOT NULL,</span><br><span class="line">   PRIMARY KEY (ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>现在，我们需要提供一个数据源到 JdbcTemplate 中，所以它可以配置本身来获得数据库访问。你可以在 XML 文件中配置数据源，其中一段代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dataSource&quot;</span><br><span class="line">class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/TEST&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意点：<br>1.Could not load JDBC driver class [com.mysql.jdbc.Driver]异常： mysql-connector-java-5.1.8.jar<br>2.MySQL在高版本需要指明是否进行SSL连接,在mysql连接字符串url中加入ssl=true或者false即可，如:url=jdbc:mysql://127.0.0.1:3306/framework?useSSL=true</p>
<h3 id="执行-SQL-语句"><a href="#执行-SQL-语句" class="headerlink" title="执行 SQL 语句"></a>执行 SQL 语句</h3><p>我们看看如何使用 SQL 和 jdbcTemplate 对象在数据库表中执行 CRUD(创建、读取、更新和删除)操作。</p>
<p>查询一个整数类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select count(*) from Student&quot;;</span><br><span class="line">int rowCount = jdbcTemplateObject.queryForInt( SQL );</span><br></pre></td></tr></table></figure></p>
<p>查询一个 long 类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select count(*) from Student&quot;;</span><br><span class="line">long rowCount = jdbcTemplateObject.queryForLong( SQL );</span><br></pre></td></tr></table></figure></p>
<p>一个使用绑定变量的简单查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select age from Student where id = ?&quot;;</span><br><span class="line">int age = jdbcTemplateObject.queryForInt(SQL, new Object[]&#123;10&#125;);</span><br></pre></td></tr></table></figure></p>
<p>查询字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select name from Student where id = ?&quot;;</span><br><span class="line">String name = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;10&#125;, String.class);</span><br></pre></td></tr></table></figure></p>
<p>查询并返回一个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select * from Student where id = ?&quot;;</span><br><span class="line">Student student = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;10&#125;, new StudentMapper());</span><br><span class="line">public class StudentMapper implements RowMapper&lt;Student&gt; &#123;</span><br><span class="line">   public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">      Student student = new Student();</span><br><span class="line">      student.setID(rs.getInt(&quot;id&quot;));</span><br><span class="line">      student.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">      student.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查询并返回多个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select * from Student&quot;;</span><br><span class="line">List&lt;Student&gt; students = jdbcTemplateObject.query(SQL, new StudentMapper());</span><br><span class="line">public class StudentMapper implements RowMapper&lt;Student&gt; &#123;</span><br><span class="line">   public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">      Student student = new Student();</span><br><span class="line">      student.setID(rs.getInt(&quot;id&quot;));</span><br><span class="line">      student.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">      student.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在表中插入一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;insert into Student (name, age) values (?, ?)&quot;;</span><br><span class="line">jdbcTemplateObject.update( SQL, new Object[]&#123;&quot;Zara&quot;, 11&#125; );</span><br></pre></td></tr></table></figure></p>
<p>更新表中的一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;update Student set name = ? where id = ?&quot;;</span><br><span class="line">jdbcTemplateObject.update( SQL, new Object[]&#123;&quot;Zara&quot;, 10&#125; );</span><br></pre></td></tr></table></figure></p>
<p>从表中删除一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;delete Student where id = ?&quot;;</span><br><span class="line">jdbcTemplateObject.update( SQL, new Object[]&#123;20&#125; );</span><br></pre></td></tr></table></figure></p>
<h3 id="执行-DDL-语句"><a href="#执行-DDL-语句" class="headerlink" title="执行 DDL 语句"></a>执行 DDL 语句</h3><p>你可以使用 jdbcTemplate 中的 execute(..) 方法来执行任何 SQL 语句或 DDL 语句。下面是一个使用 CREATE 语句创建一个表的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;CREATE TABLE Student( &quot; +</span><br><span class="line">   &quot;ID   INT NOT NULL AUTO_INCREMENT, &quot; +</span><br><span class="line">   &quot;NAME VARCHAR(20) NOT NULL, &quot; +</span><br><span class="line">   &quot;AGE  INT NOT NULL, &quot; +</span><br><span class="line">   &quot;PRIMARY KEY (ID));&quot;</span><br><span class="line">jdbcTemplateObject.execute( SQL );</span><br></pre></td></tr></table></figure></p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public class StudentJDBCTemplate implements StudentDAO &#123;</span><br><span class="line">   private DataSource dataSource;</span><br><span class="line">   private JdbcTemplate jdbcTemplateObject; </span><br><span class="line">   public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">      this.dataSource = dataSource;</span><br><span class="line">      this.jdbcTemplateObject = new JdbcTemplate(dataSource);</span><br><span class="line">   &#125;</span><br><span class="line">   public void create(String name, Integer age) &#123;</span><br><span class="line">      String SQL = &quot;insert into Student (name, age) values (?, ?)&quot;;     </span><br><span class="line">      jdbcTemplateObject.update( SQL, name, age);</span><br><span class="line">      System.out.println(&quot;Created Record Name = &quot; + name + &quot; Age = &quot; + age);</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   public Student getStudent(Integer id) &#123;</span><br><span class="line">      String SQL = &quot;select * from Student where id = ?&quot;;</span><br><span class="line">      Student student = jdbcTemplateObject.queryForObject(SQL, </span><br><span class="line">                        new Object[]&#123;id&#125;, new StudentMapper());</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">   public List&lt;Student&gt; listStudents() &#123;</span><br><span class="line">      String SQL = &quot;select * from Student&quot;;</span><br><span class="line">      List &lt;Student&gt; students = jdbcTemplateObject.query(SQL, </span><br><span class="line">                                new StudentMapper());</span><br><span class="line">      return students;</span><br><span class="line">   &#125;</span><br><span class="line">   public void delete(Integer id)&#123;</span><br><span class="line">      String SQL = &quot;delete from Student where id = ?&quot;;</span><br><span class="line">      jdbcTemplateObject.update(SQL, id);</span><br><span class="line">      System.out.println(&quot;Deleted Record with ID = &quot; + id );</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   public void update(Integer id, Integer age)&#123;</span><br><span class="line">      String SQL = &quot;update Student set age = ? where id = ?&quot;;</span><br><span class="line">      jdbcTemplateObject.update(SQL, age, id);</span><br><span class="line">      System.out.println(&quot;Updated Record with ID = &quot; + id );</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StudentMapper implements RowMapper&lt;Student&gt; &#123;</span><br><span class="line">   public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">      Student student = new Student();</span><br><span class="line">      student.setId(rs.getInt(&quot;id&quot;));</span><br><span class="line">      student.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">      student.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;BeansJdbc.xml&quot;);</span><br><span class="line">      StudentJDBCTemplate studentJDBCTemplate = (StudentJDBCTemplate)context.getBean(&quot;studentJDBCTemplate&quot;);</span><br><span class="line">      System.out.println(&quot;------Records Creation--------&quot; );</span><br><span class="line">      studentJDBCTemplate.create(&quot;Zara&quot;, 11);</span><br><span class="line">      studentJDBCTemplate.create(&quot;Nuha&quot;, 2);</span><br><span class="line">      studentJDBCTemplate.create(&quot;Ayan&quot;, 15);</span><br><span class="line">      System.out.println(&quot;------Listing Multiple Records--------&quot; );</span><br><span class="line">      List&lt;Student&gt; students = studentJDBCTemplate.listStudents();</span><br><span class="line">      for (Student record : students) &#123;</span><br><span class="line">         System.out.print(&quot;ID : &quot; + record.getId() );</span><br><span class="line">         System.out.print(&quot;, Name : &quot; + record.getName() );</span><br><span class="line">         System.out.println(&quot;, Age : &quot; + record.getAge());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;----Updating Record with ID = 2 -----&quot; );</span><br><span class="line">      studentJDBCTemplate.update(2, 20);</span><br><span class="line">      System.out.println(&quot;----Listing Record with ID = 2 -----&quot; );</span><br><span class="line">      Student student = studentJDBCTemplate.getStudent(2);</span><br><span class="line">      System.out.print(&quot;ID : &quot; + student.getId() );</span><br><span class="line">      System.out.print(&quot;, Name : &quot; + student.getName() );</span><br><span class="line">      System.out.println(&quot;, Age : &quot; + student.getAge());      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for data source --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for studentJDBCTemplate bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;studentJDBCTemplate&quot; class=&quot;com.zsm.test.jdbc.StudentJDBCTemplate&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="SQL-的存储过程"><a href="#SQL-的存储过程" class="headerlink" title="SQL 的存储过程"></a>SQL 的存储过程</h3><p><strong>SimpleJdbcCall 类可以被用于调用一个包含 IN 和 OUT 参数的存储过程</strong>。你可以在处理任何一个 RDBMS 时使用这个方法，就像 Apache Derby， DB2， MySQL， Microsoft SQL Server， Oracle，和 Sybase。</p>
<p>为了了解这个方法，我们使用 Student 表，它可以在 MySQL TEST 数据库中使用下面的 DDL 进行创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student(</span><br><span class="line">   ID   INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">   NAME VARCHAR(20) NOT NULL,</span><br><span class="line">   AGE  INT NOT NULL,</span><br><span class="line">   PRIMARY KEY (ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>下一步，考虑接下来的 MySQL 存储过程，该过程使用 学生 Id 并且使用 OUT 参数返回相应的学生的姓名和年龄。所以让我们在你的 TEST 数据库中使用 MySQL 命令提示符创建这个存储过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">DROP PROCEDURE IF EXISTS `TEST`.`getRecord` $$</span><br><span class="line">CREATE PROCEDURE `TEST`.`getRecord` (</span><br><span class="line">IN in_id INTEGER,</span><br><span class="line">OUT out_name VARCHAR(20),</span><br><span class="line">OUT out_age  INTEGER)</span><br><span class="line">BEGIN</span><br><span class="line">   SELECT name, age</span><br><span class="line">   INTO out_name, out_age</span><br><span class="line">   FROM Student where id = in_id;</span><br><span class="line">END $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class StudentJDBCTemplate implements StudentDAO &#123;</span><br><span class="line">   private DataSource dataSource;</span><br><span class="line">   private SimpleJdbcCall jdbcCall;</span><br><span class="line">   public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">      this.dataSource = dataSource;</span><br><span class="line">      this.jdbcCall =  new SimpleJdbcCall(dataSource).withProcedureName(&quot;getRecord&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   public void create(String name, Integer age) &#123;</span><br><span class="line">      JdbcTemplate jdbcTemplateObject = new JdbcTemplate(dataSource);</span><br><span class="line">      String SQL = &quot;insert into Student (name, age) values (?, ?)&quot;;</span><br><span class="line">      jdbcTemplateObject.update( SQL, name, age);</span><br><span class="line">      System.out.println(&quot;Created Record Name = &quot; + name + &quot; Age = &quot; + age);</span><br><span class="line">   &#125;</span><br><span class="line">   public Student1 getStudent(Integer id) &#123;</span><br><span class="line">      SqlParameterSource in = new MapSqlParameterSource().addValue(&quot;in_id&quot;, id);</span><br><span class="line">      Map&lt;String, Object&gt; out = jdbcCall.execute(in);</span><br><span class="line">      Student1 student = new Student1();</span><br><span class="line">      student.setId(id);</span><br><span class="line">      student.setName((String) out.get(&quot;out_name&quot;));</span><br><span class="line">      student.setAge((Integer) out.get(&quot;out_age&quot;));</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>一个数据库事务是一个被视为单一的工作单元的操作序列。这些操作应该要么完整地执行，要么完全不执行。事务管理是一个重要组成部分，RDBMS 面向企业应用程序，以确保数据完整性和一致性。事务的概念可以描述为具有以下四个关键属性说成是 ACID：</p>
<ul>
<li><p>原子性(Atomicity)：事务应该当作一个单独单元的操作，这意味着整个序列操作要么是成功，要么是失败的。</p>
</li>
<li><p>一致性(Consistency)：这表示数据库的引用完整性的一致性，表中唯一的主键等。</p>
</li>
<li><p>隔离性(Isolation)：可能同时处理很多有相同的数据集的事务，每个事务应该与其他事务隔离，以防止数据损坏。</p>
</li>
<li><p>持久性(Durability)：一个事务一旦完成全部操作后，这个事务的结果必须是永久性的，不能因系统故障而从数据库中删除。</p>
</li>
</ul>
<p>一个真正的 RDBMS 数据库系统将为每个事务保证所有的四个属性。使用 SQL 发布到数据库中的事务的简单视图如下：</p>
<ul>
<li><p>使用 begin transaction 命令开始事务。</p>
</li>
<li><p>使用 SQL 查询语句执行各种删除、更新或插入操作。</p>
</li>
</ul>
<p>如果所有的操作都成功，则执行提交操作，否则回滚所有操作。</p>
<p>Spring 框架在不同的底层事务管理 APIs 的顶部提供了一个抽象层。Spring 的事务支持旨在通过添加事务能力到 POJOs 来提供给 EJB 事务一个选择方案。Spring 支持编程式和声明式事务管理。EJBs 需要一个应用程序服务器，但 Spring 事务管理可以在不需要应用程序服务器的情况下实现。</p>
<h3 id="编程式-vs-声明式"><a href="#编程式-vs-声明式" class="headerlink" title="编程式 vs. 声明式"></a>编程式 vs. 声明式</h3><p>Spring 支持两种类型的事务管理:</p>
<ul>
<li><p>编程式事务管理 ：这意味着你在编程的帮助下有管理事务。这给了你极大的灵活性，但却很难维护。</p>
</li>
<li><p>声明式事务管理 ：这意味着你从业务代码中分离事务管理。你仅仅使用注释或 XML 配置来管理事务。</p>
</li>
</ul>
<p><strong>声明式事务管理比编程式事务管理更可取</strong>，尽管它不如编程式事务管理灵活，但它允许你通过代码控制事务。但作为一种横切关注点，声明式事务管理可以使用 AOP 方法进行模块化。Spring 支持使用 Spring AOP 框架的声明式事务管理。</p>
<h3 id="事务抽象"><a href="#事务抽象" class="headerlink" title="事务抽象"></a>事务抽象</h3><p>Spring事务管理的五大属性：<strong>隔离级别、传播行为、是否只读、事务超时、回滚规则</strong></p>
<p>Spring 事务抽象的关键是由 org.springframework.transaction.PlatformTransactionManager 接口定义，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line">   //根据指定的传播行为，该方法返回当前活动事务或创建一个新的事务。</span><br><span class="line">   TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;</span><br><span class="line">   //该方法提交给定的事务和关于它的状态。</span><br><span class="line">   void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">   //该方法执行一个给定事务的回滚。</span><br><span class="line">   void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TransactionDefinition 是在 Spring 中事务支持的核心接口，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line">   //该方法返回传播行为。Spring 提供了与 EJB CMT 类似的所有的事务传播选项。</span><br><span class="line">   int getPropagationBehavior();</span><br><span class="line">   //该方法返回该事务独立于其他事务的工作的程度。</span><br><span class="line">   int getIsolationLevel();</span><br><span class="line">   //该方法返回该事务的名称。</span><br><span class="line">   String getName();</span><br><span class="line">   //该方法返回以秒为单位的时间间隔，事务必须在该时间间隔内完成。</span><br><span class="line">   int getTimeout();</span><br><span class="line">   //该方法返回该事务是否是只读的。</span><br><span class="line">   boolean isReadOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TransactionStatus 接口为事务代码提供了一个简单的方法来控制事务的执行和查询事务状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager &#123;</span><br><span class="line">   //在当前事务时新的情况下，该方法返回 true。</span><br><span class="line">   boolean isNewTransaction();</span><br><span class="line">   //该方法返回该事务内部是否有一个保存点，也就是说，基于一个保存点已经创建了嵌套事务。</span><br><span class="line">   boolean hasSavepoint();</span><br><span class="line">   //该方法设置该事务为 rollback-only 标记。</span><br><span class="line">   void setRollbackOnly();</span><br><span class="line">   //该方法返回该事务是否已标记为 rollback-only。</span><br><span class="line">   boolean isRollbackOnly();</span><br><span class="line">   //该方法返回该事务是否完成，也就是说，它是否已经提交或回滚。</span><br><span class="line">   boolean isCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>我们可以直接使用 PlatformTransactionManager 来实现编程式方法从而实现事务。要开始一个新事务，你需要有一个带有适当的 transaction 属性的 TransactionDefinition 的实例。当 TransactionDefinition 创建后，你可以通过调用 <strong>getTransaction() 方法来开始你的事务</strong>，该方法会返回 TransactionStatus 的一个实例。 TransactionStatus 对象帮助追踪当前的事务状态，并且最终，如果一切运行顺利，你可以使用 PlatformTransactionManager 的 commit() 方法来提交这个事务，否则的话，你可以使用 rollback() 方法来回滚整个操作。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public void create(String name, Integer age, Integer marks, Integer year)&#123;</span><br><span class="line">  TransactionDefinition def = new DefaultTransactionDefinition();</span><br><span class="line">  TransactionStatus status = transactionManager.getTransaction(def);//开始事务</span><br><span class="line">  try &#123;</span><br><span class="line">     String SQL1 = &quot;insert into Student (name, age) values (?, ?)&quot;;</span><br><span class="line">     jdbcTemplateObject.update( SQL1, name, age);</span><br><span class="line">     // Get the latest student id to be used in Marks table</span><br><span class="line">     String SQL2 = &quot;select max(id) from Student&quot;;</span><br><span class="line">     int sid = jdbcTemplateObject.queryForObject( SQL2, Integer.class );</span><br><span class="line">     String SQL3 = &quot;insert into Marks(sid, marks, year) &quot; + </span><br><span class="line">                   &quot;values (?, ?, ?)&quot;;</span><br><span class="line">     jdbcTemplateObject.update( SQL3, sid, marks, year);</span><br><span class="line">     System.out.println(&quot;Created Name = &quot; + name + &quot;, Age = &quot; + age);</span><br><span class="line">     transactionManager.commit(status);//提交事务</span><br><span class="line">  &#125; catch (DataAccessException e) &#123;</span><br><span class="line">     System.out.println(&quot;Error in creating record, rolling back&quot;);</span><br><span class="line">     transactionManager.rollback(status);</span><br><span class="line">     throw e;</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for data source --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot;</span><br><span class="line">          class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for TransactionManager --&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for studentJDBCTemplate bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;studentJDBCTemplate&quot; class=&quot;com.zsm.test.transaction.StudentJDBCTemplate&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;transactionManager&quot;  ref=&quot;transactionManager&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h3><p>声明式事务管理方法允许你在配置的帮助下而不是源代码硬编程来管理事务。这意味着你可以将事务管理从事务代码中隔离出来。 bean 配置会指定事务型方法。下面是与声明式事务相关的步骤：</p>
<ul>
<li><p>我们使用标签，它创建一个事务处理的建议，同时，我们定义一个匹配所有方法的切入点，我们希望这些方法是事务型的并且会引用事务型的建议。</p>
</li>
<li><p>如果在事务型配置中包含了一个方法的名称，那么创建的建议在调用方法之前就会在事务中开始进行。</p>
</li>
<li><p>目标方法会在 try / catch 块中执行。</p>
</li>
<li><p>如果方法正常结束，AOP 建议会成功的提交事务，否则它执行回滚操作。</p>
</li>
</ul>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">    http://www.springframework.org/schema/tx</span><br><span class="line">    http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for data source --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot;</span><br><span class="line">          class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;create&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;createOperation&quot; expression=&quot;execution(* com.zsm.test.transac.StudentJDBCTemplate.create(..))&quot;/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;createOperation&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for TransactionManager --&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for studentJDBCTemplate bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;studentJDBCTemplate&quot; class=&quot;com.zsm.test.transac.StudentJDBCTemplate&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">public class StudentJDBCTemplate implements StudentDAO&#123;</span><br><span class="line">   private JdbcTemplate jdbcTemplateObject;</span><br><span class="line">   public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">      this.jdbcTemplateObject = new JdbcTemplate(dataSource);</span><br><span class="line">   &#125;</span><br><span class="line">   public void create(String name, Integer age, Integer marks, Integer year)&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         String SQL1 = &quot;insert into Student (name, age) values (?, ?)&quot;;</span><br><span class="line">         jdbcTemplateObject.update( SQL1, name, age);</span><br><span class="line">         // Get the latest student id to be used in Marks table</span><br><span class="line">         String SQL2 = &quot;select max(id) from Student&quot;;</span><br><span class="line">         int sid = jdbcTemplateObject.queryForObject( SQL2, Integer.class );</span><br><span class="line">         String SQL3 = &quot;insert into Marks(sid, marks, year) &quot; +  &quot;values (?, ?, ?)&quot;;</span><br><span class="line">         jdbcTemplateObject.update( SQL3, sid, marks, year);</span><br><span class="line">         System.out.println(&quot;Created Name = &quot; + name + &quot;, Age = &quot; + age);</span><br><span class="line">         // to simulate the exception.</span><br><span class="line">         throw new RuntimeException(&quot;simulate Error condition&quot;) ;</span><br><span class="line">      &#125; catch (DataAccessException e) &#123;</span><br><span class="line">         System.out.println(&quot;Error in creating record, rolling back&quot;);</span><br><span class="line">         throw e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public List&lt;StudentMarks&gt; listStudents() &#123;</span><br><span class="line">      String SQL = &quot;select * from Student, Marks where Student.id=Marks.sid&quot;;</span><br><span class="line">      List &lt;StudentMarks&gt; studentMarks=jdbcTemplateObject.query(SQL, </span><br><span class="line">      new StudentMarksMapper());</span><br><span class="line">      return studentMarks;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//会输出如下所示的异常。在这种情况下，事务会回滚并且在数据库表中不会创建任何记录。</span><br><span class="line">Created Name = Zara, Age = 11</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: simulate Error condition</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring-Web-MVC-框架"><a href="#Spring-Web-MVC-框架" class="headerlink" title="Spring Web MVC 框架"></a>Spring Web MVC 框架</h2><p>Spring web MVC 框架提供了模型-视图-控制的体系结构和可以用来开发灵活、松散耦合的 web 应用程序的组件。</p>
<p>Spring Web 模型-视图-控制（MVC）框架是围绕 DispatcherServlet 设计的，DispatcherServlet 用来处理所有的 HTTP 请求和响应。Spring Web MVC DispatcherServlet 的请求处理的工作流程如下图所示：</p>
<p><img src="/2020/07/09/java-spring-basics/mvc.png" alt></p>
<p>下面是对应于 DispatcherServlet 传入 HTTP 请求的事件序列：</p>
<ul>
<li><p>收到一个 HTTP 请求后，DispatcherServlet 根据 HandlerMapping 来选择并且调用适当的控制器。</p>
</li>
<li><p>控制器接受请求，并基于使用的 GET 或 POST 方法来调用适当的 service 方法。Service 方法将设置基于定义的业务逻辑的模型数据，并返回视图名称到 DispatcherServlet 中。</p>
</li>
<li><p>DispatcherServlet 会从 ViewResolver 获取帮助，为请求检取定义视图。</p>
</li>
<li><p>一旦确定视图，DispatcherServlet 将把模型数据传递给视图，最后呈现在浏览器中。</p>
</li>
</ul>
<p>上面所提到的所有组件，即 HandlerMapping、Controller 和 ViewResolver 是 WebApplicationContext 的一部分，而 WebApplicationContext 是带有一些对 web 应用程序必要的额外特性的 ApplicationContext 的扩展。</p>
<h3 id="需求的配置"><a href="#需求的配置" class="headerlink" title="需求的配置"></a>需求的配置</h3><p>你需要映射你想让 DispatcherServlet 处理的请求，通过使用在 web.xml 文件中的一个 URL 映射。</p>
<p>web.xml 文件将被保留在你的应用程序的 <strong>WebContent/WEB-INF</strong> 目录下。好的，在初始化 HelloWeb DispatcherServlet 时，该框架将尝试加载位于该应用程序的 WebContent/WEB-INF 目录中文件名为 <strong>[servlet-name]-servlet.xml </strong>的应用程序内容。</p>
<p>如果你不想使用默认文件名 [servlet-name]-servlet.xml 和默认位置 WebContent/WEB-INF，你可以通过在 web.xml 文件中添加 servlet 监听器 <strong>ContextLoaderListener 自定义该文件的名称和位置</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app...&gt;</span><br><span class="line">	....</span><br><span class="line">	&lt;context-param&gt;</span><br><span class="line">	   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">	   &lt;param-value&gt;/WEB-INF/HelloWeb-servlet.xml&lt;/param-value&gt;</span><br><span class="line">	&lt;/context-param&gt;</span><br><span class="line">	&lt;listener&gt;</span><br><span class="line">	   &lt;listener-class&gt;</span><br><span class="line">	      org.springframework.web.context.ContextLoaderListener</span><br><span class="line">	   &lt;/listener-class&gt;</span><br><span class="line">	&lt;/listener&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在，检查 HelloWeb-servlet.xml 文件的请求配置，该文件位于 web 应用程序的 WebContent/WEB-INF 目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;</span><br><span class="line">   http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">   http://www.springframework.org/schema/context </span><br><span class="line">   http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;context:component-scan base-package=&quot;com.tutorialspoint&quot; /&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">      &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>以下是关于 HelloWeb-servlet.xml 文件的一些要点：</p>
<ul>
<li><p>[servlet-name]-servlet.xml 文件将用于创建 bean 定义，重新定义在全局范围内具有相同名称的任何已定义的 bean。</p>
</li>
<li><p>context:component-scan标签将用于激活 Spring MVC 注释扫描功能，该功能允许使用注释，如 @Controller 和 @RequestMapping 等等。</p>
</li>
<li><p>InternalResourceViewResolver 将使用定义的规则来解决视图名称。按照上述定义的规则，一个名称为 hello 的逻辑视图将发送给位于 /WEB-INF/jsp/hello.jsp 中实现的视图。</p>
</li>
</ul>
<h3 id="定义控制器"><a href="#定义控制器" class="headerlink" title="定义控制器"></a>定义控制器</h3><p>DispatcherServlet 发送请求到控制器中执行特定的功能。@Controller 注释表明一个特定类是一个控制器的作用。@RequestMapping 注释用于映射 URL 到整个类或一个特定的处理方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public class HelloController&#123;</span><br><span class="line">   @RequestMapping(method = RequestMethod.GET)</span><br><span class="line">   public String printHello(ModelMap model) &#123;</span><br><span class="line">      model.addAttribute(&quot;message&quot;, &quot;Hello Spring MVC Framework!&quot;);</span><br><span class="line">      return &quot;hello&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@Controller 注释定义该类作为一个 Spring MVC 控制器。在这里，第一次使用的 @RequestMapping 表明在该控制器中处理的所有方法都是相对于 /hello 路径的。下一个注释 @RequestMapping(method = RequestMethod.GET) 用于声明 printHello() 方法作为控制器的默认 service 方法来处理 HTTP GET 请求。你可以在相同的 URL 中定义其他方法来处理任何 POST 请求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/15/android-kotlin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/15/android-kotlin/" itemprop="url">Kotlin知识点总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-15T09:41:35+08:00">
                2020-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言 ，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。</p>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>创建<strong>一种兼容Java的语言</strong></p>
<p>让它比Java更<strong>安全</strong>，能够静态检测常见的陷阱。如：引用空指针</p>
<p>让它比Java更<strong>简洁</strong>，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。</p>
<p>Kotlin，类似 Xtend 一样，<strong>旨在提供一种更好的 Java</strong> 而非重建整个新平台。这两种语言都向下编译为字节码（虽然 Xtend 是首先转换成相应的 Java 代码，再让 Java 编译器完成繁重的工作），而且两者都引入了函数和扩展函数（在某个有限范围内静态地增加一个新方法到某个已有类型的能力）。Xtend 是基于 Eclipse 的，而 Kotlin 是基于 IntelliJ 的，两者都提供无界面构建。</p>
<h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>调用某个方法实际上将程序执行顺序转移到该方法所存放在内存中某个地址，将方法的程序内容执行完后，再返回到转去执行该方法前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。也就是通常说的压栈和出栈。因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大。 因此<strong>对于这种内容较短却又反复使用的方法我们可以通过使用内联函数来提升运行效率</strong>。</p>
<p>java中final关键字只是告诉编译器，在编译的时候考虑性能的提升，可以将final函数视为内联函数。但最后编译器会怎么处理，编译器会分析将final函数处理为内联和不处理为内联的性能比较了。（和垃圾处理机制类似，<strong>程序员只有建议权而没有决定权</strong>）</p>
<p>inline 的工作原理就是<strong>将内联函数的函数体复制到调用处实现内联</strong>。</p>
<p>inline 修饰符<strong>影响函数本身和传给它的 lambda 表达式：所有这些都将内联到调用处</strong>。</p>
<p>内联可能导致生成的代码增加；不过如果我们使用得当（即避免内联过大函数），性能上会有所提升，尤其是在循环中的“超多态（megamorphic）”调用处。</p>
<p>reified: 普通函数（非内联函数），不能包含具体化类型参数；若一个类型没有运行时表示（run-time representation）（如非具体化类型参数（non-reified type parameter）或虚拟类型，比如“Nothing”）不能作为一个具体化类型参数的实参。</p>
<p>公有 API 内联函数体内不允许使用非公有声明。</p>
<p><img src="/2020/04/15/android-kotlin/kotlin_inline.png" alt></p>
<p>在Kotlin中对Java中的一些的接口的回调做了一些优化，可以使用一个lambda函数来代替。可以简化写一些不必要的嵌套回调方法。但是需要注意:在lambda表达式，只支持单抽象方法模型，也就是说设计的接口里面只有一个抽象的方法，才符合lambda表达式的规则，多个回调方法不支持。</p>
<h3 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</p>
</blockquote>
<p>let函数适用的场景<br>场景一: 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。<br>场景二: 然后就是需要去明确一个变量所处特定的作用域范围内可以使用</p>
<h3 id="With"><a href="#With" class="headerlink" title="With"></a>With</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</p>
</blockquote>
<p>with函数的适用的场景<br>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//java实现</span><br><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class="line">    ArticleSnippet item = getItem(position);</span><br><span class="line">    if (item == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    holder.tvNewsTitle.setText(StringUtils.trimToEmpty(item.titleEn));</span><br><span class="line">    holder.tvNewsSummary.setText(StringUtils.trimToEmpty(item.summary));</span><br><span class="line">    String gradeInfo = &quot;难度：&quot; + item.gradeInfo;</span><br><span class="line">    String wordCount = &quot;单词数：&quot; + item.length;</span><br><span class="line">    String reviewNum = &quot;读后感：&quot; + item.numReviews;</span><br><span class="line">    String extraInfo = gradeInfo + &quot; | &quot; + wordCount + &quot; | &quot; + reviewNum;</span><br><span class="line">    holder.tvExtraInfo.setText(extraInfo);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//kotlin实现</span><br><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: return</span><br><span class="line"> </span><br><span class="line">   with(item)&#123;</span><br><span class="line">       holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf.text = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</p>
</blockquote>
<p>适用于let,with函数任何场景。因为run函数是let,with两个函数结合体，准确来说它弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样可以省略，直接访问实例的公有属性和方法，另一方面它弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//借助上个例子kotlin代码,使用run函数后的优化</span><br><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line"> </span><br><span class="line">  getItem(position)?.run&#123;</span><br><span class="line">       holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>public inline fun <t> T.apply(block: T.() -&gt; Unit): T { block(); return this }</t></p>
</blockquote>
<p>从结构上来看apply函数和run函数很像，唯一不同点就是它们各自返回的值不一样，<strong>run函数是以闭包形式返回最后一行代码的值，而apply函数的返回的是传入对象的本身</strong>。apply一般用于一个对象实例初始化的时候，需要对对象中的属性进行赋值。或者动态inflate出一个XML的View的时候需要给View绑定数据也会用到，这种情景非常常见。特别是在我们开发中会有一些数据model向View model转化实例化的过程中需要用到。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null).apply&#123;</span><br><span class="line">   course_comment_tv_label.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_score.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_cancel.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_confirm.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_seek_bar.max = 10</span><br><span class="line">   course_comment_seek_bar.progress = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多层级判空示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mSectionMetaData?.apply&#123;</span><br><span class="line"> </span><br><span class="line">	//mSectionMetaData不为空的时候操作mSectionMetaData</span><br><span class="line"> </span><br><span class="line">&#125;?.questionnaire?.apply&#123;</span><br><span class="line"> </span><br><span class="line">	//questionnaire不为空的时候操作questionnaire</span><br><span class="line"> </span><br><span class="line">&#125;?.section?.apply&#123;</span><br><span class="line"> </span><br><span class="line">	//section不为空的时候操作section</span><br><span class="line"> </span><br><span class="line">&#125;?.sectionArticle?.apply&#123;</span><br><span class="line"> </span><br><span class="line">	//sectionArticle不为空的时候操作sectionArticle</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Also"><a href="#Also" class="headerlink" title="Also"></a>Also</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>@SinceKotlin(“1.1”)<br>public inline fun <t> T.also(block: (T) -&gt; Unit): T { block(this); return this }</t></p>
</blockquote>
<p>适用于let函数的任何场景，also函数和let很像，只是唯一的不同点就是<strong>let函数最后的返回值是最后一行的返回值，而also函数的返回值是返回当前的这个对象</strong>。一般可用于多个扩展函数链式调用</p>
<h2 id="协程Coroutine"><a href="#协程Coroutine" class="headerlink" title="协程Coroutine"></a>协程Coroutine</h2><p>协程就像非常轻量级的线程，<strong>是运行在单线程中的并发程序</strong>。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<p>线程是由系统调度的，线程切换或线程阻塞的开销都比较大（涉及到同步锁；涉及到线程阻塞状态和可运行状态之间的切换；涉及到线程的创建及上下文的切换）。而<strong>协程依赖于线程，但协程挂起时不需要阻塞线程，几乎是无代价的，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）</strong>。因此，协程的开销远远小于线程的开销。</p>
<p><img src="/2020/04/15/android-kotlin/coroutines.jpeg" alt></p>
<blockquote>
<p>对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。协程能保留上一次调用时的状态，不需要像线程一样用回调函数，所以性能上会有提升。<strong>缺点是本质是个单线程，不能利用到单个CPU的多个核。</strong></p>
</blockquote>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><p>因为在同一个线程里，协程之间的切换不涉及线程上下文的切换和线程状态的改变，不存在资源、数据并发，所以不用加锁，只需要判断状态就OK，所以执行效率比多线程高很多</p>
</li>
<li><p>协程是非阻塞式的(也有阻塞API)，一个协程在进入阻塞后不会阻塞当前线程，当前线程会去执行其他协程任务</p>
</li>
</ul>
<p>协程的切换，是通过yield API 让协程在空闲时（比如等待io，网络数据未到达）放弃执行权，然后在合适的时机再通过resume API 唤醒协程继续运行。协程一旦开始运行就不会结束，直到遇到yield交出执行权。Yield、resume 这一对 API 可以非常便捷的实现异步，这可是目前所有高级语法孜孜不倦追求的</p>
<h3 id="suspend-关键字"><a href="#suspend-关键字" class="headerlink" title="suspend 关键字"></a>suspend 关键字</h3><p>协程天然亲近方法，协程表现为标记、切换方法、代码段，协程里使用 suspend 关键字修饰方法，既该方法可以被协程挂起，<strong>没用suspend修饰的方法不能参与协程任务</strong>，suspend修饰的方法只能在协程中只能与另一个suspend修饰的方法交流</p>
<p>一个协程内有多个 suspend 修饰的方法顺序书写时，代码也是顺序运行的，为什么，suspend 函数会将整个协程挂起，而不仅仅是这个 suspend 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">suspend fun requestToken(): Token &#123; ... &#125;   // 挂起函数</span><br><span class="line">suspend fun createPost(token: Token, item: Item): Post &#123; ... &#125;  // 挂起函数</span><br><span class="line"></span><br><span class="line">fun postItem(item: Item) &#123;</span><br><span class="line">    GlobalScope.launch &#123; // 创建一个新协程</span><br><span class="line">        val token = requestToken()</span><br><span class="line">        val post = createPost(token, item)</span><br><span class="line">        processPost(post)</span><br><span class="line">        // 需要异常处理，直接加上 try/catch 语句即可</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h3><p>kotlin 中 GlobalScope 类提供了几个构造函数：</p>
<ul>
<li>launch - 创建协程</li>
<li>async - 创建带返回值的协程，返回的是 Deferred 类</li>
<li>withContext - 不创建新的协程，在指定协程上运行代码块</li>
<li>runBlocking - 不是 GlobalScope 的 API，可以独立使用，区别是 runBlocking 里面的 delay 会阻塞线程，而 launch 创建的不会</li>
</ul>
<p>kotlin 在 1.3 之后要求协程必须由 CoroutineScope 创建，CoroutineScope 不阻塞当前线程，在后台创建一个新协程，也可以指定协程调度器。CoroutineScope 并不运行协程，它只是确保您不会失去对协程的追踪。<strong>CoroutineScope 会跟踪所有协程，并且可以取消由它所启动的所有协程</strong>。比如 CoroutineScope.launch{} 可以看成 new Coroutine</p>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><p>launch 函数定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public fun CoroutineScope.launch(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">): Job</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">GlobalScope.launch(Dispatchers.Unconfined) &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要关心的是 launch 的3个参数和返回值 Job：</p>
<p>1.<strong>CoroutineContext</strong> - 可以理解为协程的上下文，在这里我们可以设置 CoroutineDispatcher 协程运行的线程调度器，有 4种线程模式：</p>
<blockquote>
<p>Dispatchers.Default - 使用共享的后台线程池<br>Dispatchers.IO - 用于IO操作的协程<br>Dispatchers.Main - 主线程<br>Dispatchers.Unconfined - 没指定，就是在当前线程(用于不消耗CPU时间的任务以及不更新UI的协程)<br>用newSingleThreadContext创建的调度器：为协和的运行启动了一个线程（一个专用的纯种是一种非常昂贵的资源）</p>
</blockquote>
<p>不写的话就是 Dispatchers.Default 模式的，或者我们可以自己创建协程上下文，也就是线程池，newSingleThreadContext 单线程，newFixedThreadPoolContext 线程池，具体的可以点进去看看，这2个都是方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val singleThreadContext = newSingleThreadContext(&quot;aa&quot;)</span><br><span class="line">GlobalScope.launch(singleThreadContext) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>CoroutineStart</strong> - 启动模式，默认是DEAFAULT，也就是创建就启动；还有一个是LAZY，意思是等你需要它的时候，再调用启动</p>
<blockquote>
<p>DEAFAULT - 模式模式，不写就是默认<br>ATOMIC -<br>UNDISPATCHED<br>LAZY - 懒加载模式，你需要它的时候，再调用启动，看这个例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var job:Job = GlobalScope.launch( start = CoroutineStart.LAZY )&#123;</span><br><span class="line">    Log.d(&quot;AA&quot;, &quot;协程开始运行，时间: &quot; + System.currentTimeMillis())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep( 1000L )</span><br><span class="line">// 手动启动协程</span><br><span class="line">job.start()</span><br></pre></td></tr></table></figure>
<p>3.<strong>block</strong> - 闭包方法体，定义协程内需要执行的操作</p>
<blockquote>
<p>Job - 协程构建函数的返回值，可以把 Job 看成协程对象本身，协程的操作方法都在 Job 身上了<br>job.start() - 启动协程，除了 lazy 模式，协程都不需要手动启动<br>job.join() - 等待协程执行完毕<br>job.cancel() - 取消一个协程<br>job.cancelAndJoin() - 等待协程执行完毕然后再取消</p>
</blockquote>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async 同 launch 唯一的区别就是 async 是有返回值的，看下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">  val deferred = GlobalScope.async&#123;</span><br><span class="line">  delay(1000L)</span><br><span class="line">  Log.d(&quot;AA&quot;,&quot;This is async &quot;)</span><br><span class="line">  return@async &quot;taonce&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log.d(&quot;AA&quot;,&quot;协程 other start&quot;)</span><br><span class="line">  val result = deferred.await()</span><br><span class="line">  Log.d(&quot;AA&quot;,&quot;async result is $result&quot;)</span><br><span class="line">  Log.d(&quot;AA&quot;,&quot;协程 other end &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log.d(&quot;AA&quot;, &quot;主线程位于协程之后的代码执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">This is async</span><br><span class="line">协程 other start</span><br><span class="line">主线程位于协程之后的代码执行，时间: 1553866185250</span><br><span class="line">async result is taonce</span><br><span class="line">协程 other end</span><br></pre></td></tr></table></figure></p>
<p>async 返回的是 Deferred 类型，Deferred 继承自 Job 接口，Job有的它都有，增加了一个方法 <strong>await</strong> ，这个方法接收的是 async 闭包中返回的值，async 的特点是不会阻塞当前线程，但会阻塞所在协程，也就是挂起。</p>
<p>但是注意啊，<strong>async 并不会阻塞线程，只是阻塞锁调用的协程</strong></p>
<h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><p>runBlocking 和 launch 区别的地方就是 runBlocking 的 delay 方法是可以阻塞当前的线程的，和Thread.sleep() 一样，看下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">  runBlocking &#123;</span><br><span class="line">    // 阻塞1s</span><br><span class="line">    delay(1000L)</span><br><span class="line">    println(&quot;This is a coroutines $&#123;TimeUtil.getTimeDetail()&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 阻塞2s</span><br><span class="line">  Thread.sleep(2000L)</span><br><span class="line">  println(&quot;main end $&#123;TimeUtil.getTimeDetail()&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~log~~~~~~~~~~~~~~~~</span><br><span class="line">This is a coroutines 11:00:51</span><br><span class="line">main end 11:00:53</span><br></pre></td></tr></table></figure></p>
<p>runBlocking 通常的用法是用来桥接普通阻塞代码和挂起风格的非阻塞代码，在 runBlocking 闭包里面可以启动另外的协程，协程里面是可以嵌套启动别的协程的。</p>
<h3 id="协程的挂起和恢复"><a href="#协程的挂起和恢复" class="headerlink" title="协程的挂起和恢复"></a>协程的挂起和恢复</h3><p>1.<strong>协程执行时， 协程和协程，协程和线程内代码是顺序运行的</strong><br>最简单的协程运行模式，不涉及挂起时，谁写在前面谁先运行，后面的等前面的协程运行完之后再运行。涉及到挂起时，前面的协程挂起了，那么线程不会空闲，而是继续运行下一个协程，而前面挂起的那个协程在挂起结速后不会马上运行，而是等待当前正在运行的协程运行完毕后再去执行</p>
<p>2.<strong>协程挂起时，就不会执行了，而是等待挂起完成且线程空闲时才能继续执行</strong><br>一个协程内有多个 suspend 修饰的方法顺序书写时，代码也是顺序运行的，为什么，suspend 函数会将整个协程挂起，而不仅仅是这个 suspend 函数。</p>
<p>suspend 修饰的方法挂起的是协程本身，而非该方法，注意这点，看下面的代码体会下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">suspend fun getToken(): String &#123;</span><br><span class="line">  delay(300)</span><br><span class="line">  Log.d(&quot;AA&quot;, &quot;getToken 开始执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line">  return &quot;ask&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun getResponse(token: String): String &#123;</span><br><span class="line">  delay(100)</span><br><span class="line">  Log.d(&quot;AA&quot;, &quot;getResponse 开始执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line">  return &quot;response&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun setText(response: String) &#123;</span><br><span class="line">  Log.d(&quot;AA&quot;, &quot;setText 执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行代码</span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">  Log.d(&quot;AA&quot;, &quot;协程 开始执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line">  val token = getToken()</span><br><span class="line">  val response = getResponse(token)</span><br><span class="line">  setText(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">协程 开始执行，时间: 1553848676780</span><br><span class="line">getToken 开始执行，时间: 1553848676781</span><br><span class="line">getResponse 开始执行，时间: 1553848677088</span><br><span class="line">setText 执行，时间: 1553848677190</span><br></pre></td></tr></table></figure></p>
<p>在 getToken 方法将协程挂起时，getResponse 函数永远不会运行，只有等 getToken 挂起结速将协程恢复时才会运行。</p>
<p>多协程间 suspend 函数运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Unconfined)&#123;</span><br><span class="line">  var token = GlobalScope.async(Dispatchers.Unconfined) &#123;</span><br><span class="line">    return@async getToken()</span><br><span class="line">   &#125;.await()</span><br><span class="line"></span><br><span class="line">  var response = GlobalScope.async(Dispatchers.Unconfined) &#123;</span><br><span class="line">    return@async getResponse(token)</span><br><span class="line">  &#125;.await()</span><br><span class="line"></span><br><span class="line">  setText(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">getToken 开始执行，时间: 1553848676781</span><br><span class="line">getResponse 开始执行，时间: 1553848677088</span><br><span class="line">setText 执行，时间: 1553848677190</span><br></pre></td></tr></table></figure></p>
<p>注意我外面要包裹一层 GlobalScope.launch，要不运行不了。这里我们搞了2个协程出来，但是我们在这里使用了await，这样就会阻塞外部协程，所以代码还是按顺序执行的。这样适用于多个同级 IO 操作的情况，这样写比 rxjava 要省事不少。</p>
<p>协程挂起后再恢复时在哪个线程运行：<br>哪个线程恢复的协程，协程就运行在哪个线程中。<br>注意协程内部，若是在前面有代码切换了线程，后面的代码若是没有指定线程，那么就是运行在这个切换到的线程上的。<br>我们最好给异步任务在外面套一个协程，这样我们可以挂起整个异步任务，然后给每段代码指定运行线程调度器，这样省的因为协程内部挂起恢复变更线程而带来的问题。<br>非 Dispatchers.Main 调度器的协程，会在协程挂起后把协程当做一个任务 DelayedResumeTask 放到默认线程池 DefaultExecutor 队列的最后，在延迟的时间到达才会执行恢复协程任务。虽然多个协程之间可能不是在同一个线程上运行的，但是协程内部的机制可以保证我们书写的协程是按照我们指定的顺序或者逻辑自行。</p>
<h3 id="delay、yield-区别"><a href="#delay、yield-区别" class="headerlink" title="delay、yield 区别"></a>delay、yield 区别</h3><p>delay 和 yield 方法是协程内部的操作，可以挂起协程，区别是 delay 是挂起协程并经过执行时间恢复协程，当线程空闲时就会运行协程；yield 是挂起协程，让协程放弃本次 cpu 执行机会让给别的协程，当线程空闲时再次运行协程。我们只要使用 kotlin 提供的协程上下文类型，线程池是有多个线程的，再次执行的机会很快就会有的。</p>
<p>除了 main 类型，协程在挂起后都会封装成任务放到协程默认线程池的任务队列里去，有延迟时间的在时间过后会放到队列里去，没有延迟时间的直接放到队列里去</p>
<h3 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h3><p>我们在创建协程过后可以接受一个 Job 类型的返回值，我们操作 job 可以取消协程任务，job.cancel 就可以了。</p>
<p>协程的取消有些特质，因为协程内部可以在创建协程的，这样的协程组织关系可以称为父协程，子协程：</p>
<ul>
<li>父协程手动调用 cancel() 或者异常结束，会立即取消它的所有子协程（而抛出CancellationException却会当作正常的协程结束不会取消其父协程）</li>
<li>父协程必须等待所有子协程完成（处于完成或者取消状态）才能完成</li>
<li>子协程抛出未捕获的异常时，默认情况下会取消其父协程</li>
</ul>
<p>现在问题来了，在 Thread 中我们想关闭线程有时候也不是掉个方法就行的，需要我们自行在线程中判断线程是不是已经结束了。在协程中一样，cancel 方法只是修改了协程的状态，在协程自身的方法比如 realy，yield 等中会判断协程的状态从而结束协程，但是若是在协程我们没有用这几个方法怎么办，比如都是逻辑代码，这时就要我们自己手动判断了，使用 job.isActive ，isActive 是个标记，用来检查协程状态</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每一个挂起点和初始挂起点对应的 Continuation 都会转化为一种状态，协程恢复只是跳转到下一种状态中。挂起函数将执行过程分为多个 Continuation 片段，并且利用状态机的方式保证各个片段是顺序执行的。</p>
<p><img src="/2020/04/15/android-kotlin/suspend.webp" alt></p>
<p>await()挂起函数恢复协程的原理是，将 launch 协程封装为 ResumeAwaitOnCompletion 作为 handler 节点添加到 aynsc 协程的 state.list，然后在 async 协程完成时会通知 handler 节点调用 launch 协程的 resume(result) 方法将结果传给 launch 协程，并恢复 launch 协程继续执行 await 挂起点之后的逻辑。</p>
<p>协程其实有三层包装。常用的launch和async返回的Job、Deferred，里面封装了协程状态，提供了取消协程接口，而它们的实例都是继承自AbstractCoroutine，它是协程的第一层包装。第二层包装是编译器生成的SuspendLambda的子类，封装了协程的真正运算逻辑，继承自BaseContinuationImpl，其中completion属性就是协程的第一层包装。第三层包装是线程调度时的DispatchedContinuation，封装了线程调度逻辑，包含了协程的第二层包装。三层包装都实现了Continuation接口，通过代理模式将协程的各层包装组合在一起，每层负责不同的功能。</p>
<p>下面是协程运行的流程图：</p>
<p><img src="/2020/04/15/android-kotlin/flow.webp" alt></p>
<p>总结：协程就是一段可以挂起和恢复执行的运算逻辑，而协程的挂起是通过挂起函数实现的，挂起函数用状态机的方式用挂起点将协程的运算逻辑拆分为不同的片段，每次运行协程执行的不同的逻辑片段。所以协程有两个很大的好处：一是简化异步编程，支持异步返回；而是挂起不阻塞线程，提供线程利用率。</p>
<h3 id="协程的并发"><a href="#协程的并发" class="headerlink" title="协程的并发"></a>协程的并发</h3><p>协程就是可以挂起和恢复执行的运算逻辑，挂起函数用状态机的方式用挂起点将协程的运算逻辑拆分为不同的片段，每次运行协程执行的不同的逻辑片段。所以协程在运行时只是线程中的一块代码，线程的并发处理方式都可以用在协程上。不过协程还提供两种特有的方式，一是不阻塞线程的互斥锁Mutex，一是通过 ThreadLocal 实现的协程局部数据。</p>
<h4 id="Mutex-协程互斥锁"><a href="#Mutex-协程互斥锁" class="headerlink" title="Mutex 协程互斥锁"></a>Mutex 协程互斥锁</h4><p>线程中锁都是阻塞式，在没有获取锁时无法执行其他逻辑，而协程可以通过挂起函数解决这个，没有获取锁就挂起协程，获取后再恢复协程，协程挂起时线程并没有阻塞可以执行其他逻辑。这种互斥锁就是 Mutex，它与 synchronized 关键字有些类似，还提供了 withLock 扩展函数，替代常用的 mutex.lock; try {…} finally { mutex.unlock() }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val mutex = Mutex()</span><br><span class="line">    var counter = 0</span><br><span class="line">    repeat(10000) &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            mutex.withLock &#123;</span><br><span class="line">                counter ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;The final count is $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Mutex的使用比较简单，不过需要注意的是多个协程竞争的应该是同一个Mutex互斥锁。</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>线程中可以使用ThreadLocal作为线程局部数据，每个线程中的数据都是独立的。协程中可以通过<strong>ThreadLocal.asContextElement()扩展函数实现协程局部数据，每次协程切换会恢复之前的值</strong>。先看下面的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val threadLocal = ThreadLocal&lt;String&gt;().apply &#123; set(&quot;Init&quot;) &#125;</span><br><span class="line">    printlnValue(threadLocal)</span><br><span class="line">    val job = GlobalScope.launch(threadLocal.asContextElement(&quot;launch&quot;)) &#123;</span><br><span class="line">        printlnValue(threadLocal)</span><br><span class="line">        threadLocal.set(&quot;launch changed&quot;)</span><br><span class="line">        printlnValue(threadLocal)</span><br><span class="line">        yield()</span><br><span class="line">        printlnValue(threadLocal)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    printlnValue(threadLocal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private fun printlnValue(threadLocal: ThreadLocal&lt;String&gt;) &#123;</span><br><span class="line">    println(&quot;$&#123;Thread.currentThread()&#125; thread local value: $&#123;threadLocal.get()&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出如下：</span><br><span class="line">Thread[main,5,main] thread local value: Init</span><br><span class="line">Thread[DefaultDispatcher-worker-1,5,main] thread local value: launch</span><br><span class="line">Thread[DefaultDispatcher-worker-1,5,main] thread local value: launch changed</span><br><span class="line">Thread[DefaultDispatcher-worker-2,5,main] thread local value: launch</span><br><span class="line">Thread[main,5,main] thread local value: Init</span><br></pre></td></tr></table></figure></p>
<p>上面的输出有个疑问的地方，为什么执行yield()挂起函数后 threadLocal 的值不是launch changed而变回了launch?<br>最重要的牢记它的原理：<strong>启动和恢复时保存ThreadLocal在当前线程的值，并修改为 value，挂起和结束时修改当前线程ThreadLocal的值为之前保存的值。</strong></p>
<h2 id="委托by"><a href="#委托by" class="headerlink" title="委托by"></a>委托by</h2><p>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。</p>
<h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p>
<p>以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建接口</span><br><span class="line">interface Base &#123;   </span><br><span class="line">    fun print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现此接口的被委托的类</span><br><span class="line">class BaseImpl(val x: Int) : Base &#123;</span><br><span class="line">    override fun print() &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过关键字 by 建立委托类</span><br><span class="line">class Derived(b: Base) : Base by b</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val b = BaseImpl(10)</span><br><span class="line">    Derived(b).print() // 输出 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p>
<h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。</p>
<p>属性委托语法格式：</p>
<blockquote>
<p>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</p>
</blockquote>
<ul>
<li>var/val：属性类型(可变/只读)</li>
<li>属性名：属性名称</li>
<li>类型：属性的数据类型</li>
<li>表达式：委托代理类</li>
</ul>
<p>by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。<strong>属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。</strong></p>
<p>该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，prop 为进行委托的属性的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import kotlin.reflect.KProperty</span><br><span class="line">// 定义包含属性委托的类</span><br><span class="line">class Example &#123;</span><br><span class="line">    var p: String by Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 委托的类</span><br><span class="line">class Delegate &#123;</span><br><span class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</span><br><span class="line">        return &quot;$thisRef, 这里委托了 $&#123;property.name&#125; 属性&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;</span><br><span class="line">        println(&quot;$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val e = Example()</span><br><span class="line">    println(e.p)     // 访问该属性，调用 getValue() 函数</span><br><span class="line"></span><br><span class="line">    e.p = &quot;Runoob&quot;   // 调用 setValue() 函数</span><br><span class="line">    println(e.p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">Example@433c675d, 这里委托了 p 属性</span><br><span class="line">Example@433c675d 的 p 属性赋值为 Runoob</span><br><span class="line">Example@433c675d, 这里委托了 p 属性</span><br></pre></td></tr></table></figure></p>
<h3 id="延迟属性-Lazy"><a href="#延迟属性-Lazy" class="headerlink" title="延迟属性 Lazy"></a>延迟属性 Lazy</h3><p>lazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy <t> 实例的函数，返回的实例可以作为实现延迟属性的委托： <strong>第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val lazyValue: String by lazy &#123;</span><br><span class="line">    println(&quot;computed!&quot;)     // 第一次调用输出，第二次调用不执行</span><br><span class="line">    &quot;Hello&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(lazyValue)   // 第一次执行，执行两次输出表达式</span><br><span class="line">    println(lazyValue)   // 第二次执行，只输出返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行输出结果：</span><br><span class="line">computed!</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></t></p>
<p>你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun example(computeFoo: () -&gt; Foo) &#123;</span><br><span class="line">    val memoizedFoo by lazy(computeFoo)</span><br><span class="line"></span><br><span class="line">    if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;</span><br><span class="line">        memoizedFoo.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。</p>
<h3 id="提供委托provideDelegate"><a href="#提供委托provideDelegate" class="headerlink" title="提供委托provideDelegate"></a>提供委托provideDelegate</h3><p>通过定义 provideDelegate 操作符，<strong>可以扩展创建属性实现所委托对象的逻辑</strong>。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。</p>
<p>provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。</p>
<p>例如，如果要在绑定之前检查属性名称，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123;</span><br><span class="line">    operator fun provideDelegate(</span><br><span class="line">            thisRef: MyUI,</span><br><span class="line">            prop: KProperty&lt;*&gt;</span><br><span class="line">    ): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">        checkProperty(thisRef, prop.name)</span><br><span class="line">        // 创建委托</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">class MyUI &#123;</span><br><span class="line">    val image by bindResource(ResourceID.image_id)</span><br><span class="line">    val text by bindResource(ResourceID.text_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>provideDelegate 的参数与 getValue 相同：</p>
<blockquote>
<p>thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型<br>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。</p>
</blockquote>
<p>在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。</p>
<p>如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 检查属性名称而不使用“provideDelegate”功能</span><br><span class="line">class MyUI &#123;</span><br><span class="line">    val image by bindResource(ResourceID.image_id, &quot;image&quot;)</span><br><span class="line">    val text by bindResource(ResourceID.text_id, &quot;text&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; MyUI.bindResource(</span><br><span class="line">        id: ResourceID&lt;T&gt;,</span><br><span class="line">        propertyName: String</span><br><span class="line">): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">   checkProperty(this, propertyName)</span><br><span class="line">   // 创建委托</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    var prop: Type by MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这段代码是当“provideDelegate”功能可用时</span><br><span class="line">// 由编译器生成的代码：</span><br><span class="line">class C &#123;</span><br><span class="line">    // 调用“provideDelegate”来创建额外的“delegate”属性</span><br><span class="line">    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)</span><br><span class="line">    val prop: Type</span><br><span class="line">        get() = prop$delegate.getValue(this, this::prop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><p>在定义的时候忽略返回值等于是隐式声明函数的返回值是空。在Kotlin中，这种隐式返回的类型称之为：Unit。这个Unit类型的作用类似Java语言中的void类型。Unit是一种只有一个值——Unit的类型。这个值不需要显式返回。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>Kotlin中的闭包是一个功能性自包含模块，可以在代码中被当做参数传递或者直接使用。<strong>函数里面声明函数，函数里面返回函数，就是闭包。</strong></p>
<p>闭包就是一个代码块，<strong>用“{ }”包起来</strong>。Kotlin语言中有三种闭包形式：全局函数、自嵌套函数、匿名函数体。下面举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 执行test闭包的内容</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个比较测试闭包</span><br><span class="line">val test = if (5 &gt; 3) &#123;</span><br><span class="line">    println(&quot;yes&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;no&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原语句等价于 val test = println(&quot;yes&quot;) ,test是一个Unit对象，而Unit是个object，也就是个单例类,所以，上面的代码等价于</span><br><span class="line">val test  = Unit</span><br><span class="line">object Unit &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;yes&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//因为单例对象只会初始化一次，所以不管定义多少次只会打印一次yes。</span><br><span class="line">//实际上，val test = &#123;println(&quot;yes&quot;)&#125; ，大括号包裹的是另外一种，等价于 val test = fun()&#123; println(&quot;yes&quot;) &#125; 这种才是函数的调用形式，使用test()</span><br></pre></td></tr></table></figure></p>
<p>闭包的用途：<strong>能够读取其他函数的内部变量，另一个用处就是让这些变量的值始终保持在内存中(在内存中维持一个变量)。</strong></p>
<p>注意：闭包会使得函数中的变量都被保存在内存中，内存消耗很大.闭包赋值给变量后,待变量销毁,内存释放</p>
<blockquote>
<p>广义上来说，在Kotlin语言之中，函数、条件语句、控制流语句、花括号逻辑块、Lambda表达式都可以称之为闭包，但通常情况下，我们所指的闭包都是在说Lambda表达式。</p>
</blockquote>
<h3 id="双冒号"><a href="#双冒号" class="headerlink" title="双冒号 ::"></a>双冒号 ::</h3><p>Kotlin 中 双冒号操作符 表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。</p>
<p>一般情况，我们调用当前类的方法 this 都是可省略的。为了防止作用域混淆 ，:: 调用的函数如果是类的成员函数或者是扩展函数，必须使用限定符,比如this。</p>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 给一个字符串拼接前缀和后缀</span><br><span class="line"> * 前缀默认值：***</span><br><span class="line"> * 后缀默认值：###</span><br><span class="line"> */</span><br><span class="line">fun catString(myString: String, prefix: String = &quot;***&quot;, suffix: String = &quot;###&quot;): String&#123;</span><br><span class="line">    return prefix + myString + suffix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用的时候，可以忽略带有默认值的参数不传</span><br><span class="line">catString(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="可变个数参数（vararg）"><a href="#可变个数参数（vararg）" class="headerlink" title="可变个数参数（vararg）"></a>可变个数参数（vararg）</h3><p>声明可变个数形参需要用到vararg关键字，当参数传递进入函数体之后，参数在函数体内可以通过集合的形式访问。<strong>函数最多可以有一个可变个数的形参，而且它必须出现在参数列表的最后</strong>。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 求多个数字的和</span><br><span class="line"> */</span><br><span class="line">fun sumNumbers(vararg numbers : Double) : Double&#123;</span><br><span class="line">    var result : Double = 0.0</span><br><span class="line">    for (number in numbers) &#123;</span><br><span class="line">        result += number</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用的时候，则可以传任意多个参数</span><br><span class="line">sumNumbers(1.2,2.56,3.14)</span><br></pre></td></tr></table></figure></p>
<h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><p>在结构化编程盛行的年代，嵌套函数被广泛使用，在一个函数体中定义另外一个函数体就为嵌套函数。<strong>嵌套函数默认对外界是隐藏的，但仍然可以通过它们包裹的函数调用和使用它</strong>，举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 嵌套函数demo</span><br><span class="line"> *</span><br><span class="line"> * 比较数字numberA和数字numberB的二次幂谁大</span><br><span class="line"> */</span><br><span class="line">fun compare(numberA: Int, numberB: Int) : Int&#123;</span><br><span class="line">    var powerB = 0</span><br><span class="line"></span><br><span class="line">    // 嵌套函数，求一个数字的二次幂</span><br><span class="line">    fun power(num : Int) : Int&#123;</span><br><span class="line">        return num * num</span><br><span class="line">    &#125;</span><br><span class="line">    powerB = power(numberB)</span><br><span class="line"></span><br><span class="line">    if (numberA &gt; powerB) &#123;</span><br><span class="line">        return numberA</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return powerB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 报错!!! </span><br><span class="line">    // 无法直接调用内部嵌套的函数</span><br><span class="line">    power()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/Zachary_46/article/details/80446851" target="_blank" rel="noopener">https://blog.csdn.net/Zachary_46/article/details/80446851</a><br><a href="https://www.runoob.com/kotlin/kotlin-delegated.html" target="_blank" rel="noopener">https://www.runoob.com/kotlin/kotlin-delegated.html</a><br><a href="https://www.jianshu.com/p/76d2f47b900d" target="_blank" rel="noopener">Coroutine 协程</a><br><a href="https://www.jianshu.com/p/2857993af646" target="_blank" rel="noopener">Kotlin Coroutines(协程) 完全解析（三）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/09/android-jetpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/09/android-jetpack/" itemprop="url">Android Jetpack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-09T16:19:49+08:00">
                2020-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Google 在2018年推出了 Android Jetpack。Jetpack 是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。</p>
<p>Android Jetpack 组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用 Kotlin 语言功能帮助您提高工作效率。可全部使用，也可混合搭配！Jetpack 也包含了与平台 API 解除捆绑的 androidx.* 软件包库。</p>
<p>特点如下：</p>
<ul>
<li>加速开发：组件可以单独采用（不过这些组件是为协同工作而构建的），同时利用 Kotlin 语言功能帮助您提高工作效率。</li>
<li>消除样板代码：Android Jetpack 可管理繁琐的 Activity（如后台任务、导航和生命周期管理），以便您可以专注于如何让自己的应用出类拔萃。</li>
<li>构建高质量的强大应用：Android Jetpack 组件围绕现代化设计实践构建而成，具有向后兼容性，可以减少崩溃和内存泄漏。</li>
</ul>
<h2 id="JetPack的组成"><a href="#JetPack的组成" class="headerlink" title="JetPack的组成"></a>JetPack的组成</h2><p><img src="/2020/04/09/android-jetpack/jetpack-composition.png" alt></p>
<p>WorkManager很强大，需要的地方可以替代以前的方案。LifeCycles也不错，扩展其他类具有关联生命周期的。还有Room数据库的框架，简单了很多。LiveData和ViewModel的结合基本上就是RxJava和RxAndroid的结合的功能了。</p>
<h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><p>Navigation是一个可简化Android导航的库和插件</p>
<p>Navigation是用来<strong>管理Fragment的切换</strong>，并且可以通过可视化的方式，看见App的交互流程。这完美的契合了Jake Wharton大神<strong>单Activity</strong>的建议。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>处理Fragment的切换（上文已说过）</li>
<li>默认情况下正确处理Fragment的前进和后退</li>
<li>为过渡和动画提供标准化的资源</li>
<li>实现和处理深层连接</li>
<li>可以绑定Toolbar、BottomNavigationView和ActionBar等</li>
<li>SafeArgs（Gradle插件） 数据传递时提供类型安全性</li>
<li>ViewModel支持</li>
</ul>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ol>
<li><p>Navigation Graph(New XML resource)： 这是一个新的资源文件，用户在可视化界面可以看出他能够到达的Destination(用户能够到达的屏幕界面)，以及流程关系。</p>
</li>
<li><p>NavHostFragment(Layout XML view)： 当前Fragment的容器</p>
</li>
<li><p>NavController(Kotlin/Java object)： 导航的控制者</p>
</li>
</ol>
<p>可能我这么解释还是有点抽象，做一个不是那么恰当的比喻，我们可以将Navigation Graph看作一个地图，NavHostFragment看作一个车，以及把NavController看作车中的方向盘，Navigation Graph中可以看出各个地点（Destination）和通往各个地点的路径，NavHostFragment可以到达地图中的各个目的地，但是决定到什么目的地还是方向盘NavController，虽然它取决于开车人（用户）。</p>
<h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>app:startDestination</td>
<td>navigation标签: 默认的起始位置</td>
</tr>
<tr>
<td>app:destination</td>
<td>action标签: 跳转完成到达的fragment的Id</td>
</tr>
<tr>
<td>app:popUpTo</td>
<td>action标签: 将fragment从栈中弹出，直到某个Id的fragment</td>
</tr>
<tr>
<td>app:argType</td>
<td>argument标签: 标签的类型</td>
</tr>
<tr>
<td>android:defaultValue</td>
<td>argument标签: 默认值</td>
</tr>
<tr>
<td>app:navGraph</td>
<td>fragment标签: 存放的是第二步建好导航的资源文件，也就是确定了Navigation Graph</td>
</tr>
<tr>
<td>app:defaultNavHost=”true”</td>
<td>fragment标签: 与系统的返回按钮相关联</td>
</tr>
</tbody>
</table>
<p>导航示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">btnLogin.setOnClickListener &#123;</span><br><span class="line">            // 设置动画参数</span><br><span class="line">            val navOption = navOptions &#123;</span><br><span class="line">                anim &#123;</span><br><span class="line">                    enter = R.anim.slide_in_right</span><br><span class="line">                    exit = R.anim.slide_out_left</span><br><span class="line">                    popEnter = R.anim.slide_in_left</span><br><span class="line">                    popExit = R.anim.slide_out_right</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 参数设置</span><br><span class="line">            val bundle = Bundle()</span><br><span class="line">            bundle.putString(&quot;name&quot;,&quot;TeaOf&quot;)</span><br><span class="line">            findNavController().navigate(R.id.login, bundle,navOption)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不用Safe Args，action可以由Navigation.createNavigateOnClickListener(R.id.next_action, null)方式生成</p>
<h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p><img src="/2020/04/09/android-jetpack/livedata.png" alt></p>
<p>LiveData有个内部类LifecycleBoundObserver，它实现了GenericLifecycleObserver，而GenericLifecycleObserver继承了LifecycleObserver接口。当组件（Fragment、Activity）生命周期变化时会通过onStateChanged()方法回调过来。</p>
<p>LiveData主要涉及到的时序有三个：<br>在Fragment/Activity中通过LiveData.observer()添加观察者（observer()方法中的第二个参数）。<br>根据Fragment/Activity生命周期发生变化时，移除观察者或者通知观察者更新数据。<br>当调用LiveData的setValue()、postValue()方法后，通知观察者更新数据(setValue必须发生在主线程,如果当前线程是子线程可以使用postValue)。</p>
<p>在LiveData.observe()方法中添加了组件（实现了LifecycleOwner接口的Fragment和Activity）生命周期观察者。而这个观察者就是LifecycleBoundObserver对象.</p>
<p><strong>应用及知识点</strong>：</p>
<ol>
<li><p>使用ViewModel在同一个Activity中的Fragment之间共享数据：想要利用ViewModel实现Fragment之间数据共享，前提是Fragment中的FragmentActivity得相同。</p>
</li>
<li><p>map是你将你的函数用于你传参的livedata的数据通过函数体中的逻辑改变，然后将结果传到下游。而switchmap，转换跟map差不多，只不过传到下游的是<strong>livedata类型</strong>。</p>
</li>
<li><p>MediatorLiveData 是 LiveData 的子类，允许您合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。</p>
</li>
<li><p>使用LiveData共享数据：定义一个类然后继承LiveData，并使用单例模式即可。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 登录信息</span><br><span class="line">data class LoginInfo constructor(val account:String, val pwd:String, val email:String)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义单例LiveData</span><br><span class="line"> */</span><br><span class="line">class LoginLiveData:LiveData&lt;LoginInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private lateinit var sInstance: LoginLiveData</span><br><span class="line"></span><br><span class="line">        @MainThread</span><br><span class="line">        fun get(): LoginLiveData &#123;</span><br><span class="line">            sInstance = if (::sInstance.isInitialized) sInstance else LoginLiveData()</span><br><span class="line">            return sInstance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：您可以使用 observeForever(Observer) 方法来注册未关联 LifecycleOwner 对象的观察者。在这种情况下，观察者会被视为始终处于活跃状态，因此它始终会收到关于修改的通知。您可以通过调用 removeObserver(Observer) 方法来移除这些观察者。</p>
<h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel类是被设计用来以可感知生命周期的方式存储和管理 UI 相关数据，ViewModel中数据会一直存活即使 activity configuration发生变化，比如横竖屏切换的时候。</p>
<p>由于 ViewModel 生命周期可能长与 activity 生命周期，所以为了避免内存泄漏 Google 禁止在 ViewModel 中持有 Context 或 activity 或 view 的引用。</p>
<p><img src="/2020/04/09/android-jetpack/viewmodel-lifecycle.webp" alt title="ViewModel生命周期"></p>
<p>viewmodel初始化：</p>
<blockquote>
<p>ViewModelProviders.of(activity，factory).get(MyViewModel.class)</p>
</blockquote>
<p>1、初始化了<strong>ViewModelProvider内部维护了 用于创建 VM 的 Factory，和用户存放 VM 的ViewModelStore</strong>；<br>2、初始化了 用来生成 ViewModel 的 Factory（默认为DefaultFactory）；<br>3、通过ViewModelStores的静态方法实例化了 HolderFragment，并实例化了ViewModelStore<br>4、然后是ViewModelProvider的 get 方法</p>
<p><img src="/2020/04/09/android-jetpack/viewmodel-init.png" alt title="ViewModel初始化"></p>
<h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><p><img src="/2020/04/09/android-jetpack/room.webp" alt></p>
<h2 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h2><p>DataBinding 是google发布的一个数据绑定框架，<strong>用于降低布局和逻辑的耦合性</strong>，使代码逻辑更加清晰。大量减少 Activity 内的代码，数据能够单向或双向绑定到 layout 文件中，<strong>有助于防止内存泄漏</strong>，而且<strong>能自动进行空检测以避免空指针异常</strong>。</p>
<p><img src="/2020/04/09/android-jetpack/data-binding.webp" alt></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>app及对应module添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">   dataBinding &#123;</span><br><span class="line">       enabled = true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.activity中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    val dataBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)</span><br><span class="line">    // 给user初始化值</span><br><span class="line">    dataBinding.user = User(&quot;zhangsan&quot;, &quot;12345&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.在 Fragment 中的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123;</span><br><span class="line">     val blankFragmentBinding: BlankFragmentBinding =</span><br><span class="line">         DataBindingUtil.inflate(inflater, R.layout.blank_fragment, container, false)</span><br><span class="line">     return blankFragmentBinding.root</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>3.在RecyclerView中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerViewHolder 	&#123;</span><br><span class="line">     val itemMvvmBinding = DataBindingUtil.inflate&lt;ViewDataBinding&gt;(</span><br><span class="line">         LayoutInflater.from(parent.context), R.layout.item_mvvm, parent, false)</span><br><span class="line">     itemMvvmBinding.getRoot().setOnClickListener(this)</span><br><span class="line">     return RecyclerViewHolder(itemMvvmBinding)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override fun onBindViewHolder(holder: RecyclerViewHolder, position: Int) &#123;</span><br><span class="line">     val itemMvvmBinding = holder.getBinding()</span><br><span class="line">     val userBean = data.get(position)</span><br><span class="line">     itemMvvmBinding.setUser(userBean)</span><br><span class="line">     itemMvvmBinding.btnUpdate.setOnClickListener(OnBtnClickListener(1, userBean))</span><br><span class="line">     ...</span><br><span class="line">     // 立刻执行绑定</span><br><span class="line">     itemMvvmBinding.executePendingBindings()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="单向绑定"><a href="#单向绑定" class="headerlink" title="单向绑定"></a>单向绑定</h3><p>一个简单的ViewModel 类被更新后，并不会让 UI 自动更新。而数据绑定后，我们自然会希望数据变更后 UI 会即时刷新，Observable 就是为此而生的概念。实现数据变化自动驱动 UI 刷新的方式有三种：BaseObservable、ObservableField、ObservableCollection</p>
<h4 id="BaseObservable"><a href="#BaseObservable" class="headerlink" title="BaseObservable"></a>BaseObservable</h4><p>BaseObservable 提供了 notifyChange() 和 notifyPropertyChanged() 两个方法:</p>
<ul>
<li>notifyChange() 它会刷新所有的值。</li>
<li>notifyPropertyChanged() 它只会根据对应的BR的flag更新，该 BR 的生成通过注释 @Bindable 生成，可以通过 BR notify 特定属性关联的视图。</li>
</ul>
<p>//由于kotlin的属性默认是public修饰，所以可以直接在属性上@Bindable, 如何设置了修饰符且不为public的话，则可使用@get Bindable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class UserInfo : BaseObservable() &#123;</span><br><span class="line">	// 对name进行@Bindable标志，然后会生成BR.name</span><br><span class="line">    @Bindable</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            // 当name,发生改变时只会刷新与name相关控件的值，不会刷新其他的值</span><br><span class="line">            notifyPropertyChanged(BR.name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    @get: Bindable</span><br><span class="line">    var password: String = &quot;&quot;</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            // 当password 发生改变时，也会刷新其他属性相关的控件的值</span><br><span class="line">            notifyChange()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现了 Observable 接口的类允许注册一个监听器OnPropertyChangedCallback，当可观察对象的属性更改时就会通知这个监听器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//当中 propertyId 就用于标识特定的字段</span><br><span class="line">user.addOnPropertyChangedCallback(object : Observable.OnPropertyChangedCallback()&#123;</span><br><span class="line">     override fun onPropertyChanged(sender: Observable, propertyId: Int) &#123;</span><br><span class="line">                </span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="ObservableField"><a href="#ObservableField" class="headerlink" title="ObservableField"></a>ObservableField</h4><p>继承于 Observable 类相对来说限制有点高，且也需要进行notify 操作，因此为了<strong>简单起见可以选择使用 ObservableField</strong>。 可以理解为官方对 BaseObservable 中字段的注解和刷新等操作的封装，官方原生提供了对基本数据类型的封装，例如 ObservableBoolean、ObservableByte、ObservableChar、ObservableShort、ObservableInt、ObservableLong、ObservableFloat、ObservableDouble 以及 ObservableParcelable ，也可通过 ObservableField 泛型来申明其他类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data class ObservableUser(</span><br><span class="line">    var name: ObservableField&lt;String&gt;,</span><br><span class="line">    var password: ObservableField&lt;String&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h4 id="ObservableCollection"><a href="#ObservableCollection" class="headerlink" title="ObservableCollection"></a>ObservableCollection</h4><p>dataBinding 也提供了包装类用于替代原生的 List 和 Map，分别是 ObservableList 和 ObservableMap,当其包含的数据发生变化时，绑定的视图也会随之进行刷新</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>双向绑定的意思即为当数据改变时同时使视图刷新，而视图改变时也可以同时改变数据。绑定变量的方式比单向绑定多了一个等号，如：android:text=”@={user.name}”</p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>严格意义上来说，事件绑定也是一种变量绑定，只不过设置的变量是回调接口而已。</p>
<p>事件绑定包括方法引用和监听绑定：</p>
<ul>
<li>方法引用：参数类型和返回类型要一致，参考et_pwd EditText的android:onTextChanged引用。</li>
<li>监听绑定：相比较于方法引用，监听绑定的要求就没那么高了，我们可以使用自行定义的函数，参考et_account EditText的android:onTextChanged引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">        xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;!--需要的viewModel,通过mBinding.vm=mViewMode注入--&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;model&quot;</span><br><span class="line">            type=&quot;com.joe.jetpackdemo.viewmodel.LoginModel&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;activity&quot;</span><br><span class="line">            type=&quot;androidx.fragment.app.FragmentActivity&quot;/&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/txt_cancel&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;()-&gt; activity.onBackPressed()&#125;&quot;</span><br><span class="line">            /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/txt_title&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">            .../&gt;</span><br><span class="line"></span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:id=&quot;@+id/et_account&quot;</span><br><span class="line">            android:text=&quot;@&#123;model.n.get()&#125;&quot;</span><br><span class="line">            android:onTextChanged=&quot;@&#123;(text, start, before, count)-&gt;model.onNameChanged(text)&#125;&quot;</span><br><span class="line">            ...</span><br><span class="line">            /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:id=&quot;@+id/et_pwd&quot;</span><br><span class="line">            android:text=&quot;@&#123;model.p.get()&#125;&quot;</span><br><span class="line">            android:onTextChanged=&quot;@&#123;model::onPwdChanged&#125;&quot;</span><br><span class="line">            ...</span><br><span class="line">            /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/btn_login&quot;</span><br><span class="line">            android:text=&quot;Sign in&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;() -&gt; model.login()&#125;&quot;</span><br><span class="line">            android:enabled=&quot;@&#123;(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true&#125;&quot;</span><br><span class="line">            .../&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用类方法"><a href="#使用类方法" class="headerlink" title="使用类方法"></a>使用类方法</h3><p>首先定义一个静态方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object StringUtils &#123;</span><br><span class="line"></span><br><span class="line">   fun toUpperCase( str:String):String &#123;</span><br><span class="line">        return str.toUpperCase();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 data 标签中导入该工具类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import type=&quot;com.github.ixiaow.sample.StringUtils&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以像对待一般的函数一样来调用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:layout_width=&quot;match_parent&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">   android:onClick=&quot;@&#123;()-&gt;userPresenter.onUserNameClick(userInfo)&#125;&quot;</span><br><span class="line">   android:text=&quot;@&#123;StringUtils.toUpperCase(userInfo.name)&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ul>
<li>运算符 + - / * %</li>
<li>字符串连接 +</li>
<li>逻辑与或 &amp;&amp; ||</li>
<li>二进制 &amp; | ^</li>
<li>一元 + - ! ~</li>
<li>移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>
<li>比较 == &gt; &lt; &gt;= &lt;= (Note that &lt; needs to be escaped as &lt;)</li>
<li>instanceof</li>
<li>Grouping ()</li>
<li>Literals - character, String, numeric, null</li>
<li>Cast</li>
<li>方法调用</li>
<li>域访问</li>
<li>数组访问</li>
<li>三元操作符</li>
</ul>
<p>除了上述之外，Data Binding新增了<strong>空合并操作符??</strong>，例如android:text=”@{user.displayName ?? user.lastName}”，它等价于android:text=”@{user.displayName != null ? user.displayName : user.lastName}”。</p>
<h3 id="BindingMethod"><a href="#BindingMethod" class="headerlink" title="@BindingMethod"></a>@BindingMethod</h3><p>如果XXXView类有成员变量borderColor，并且XXXView类有setBoderColor(int color)方法，那么在布局中我们就可以借助Data Binding直接使用app:borderColor这个属性。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:scrimColor=&quot;@&#123;@color/scrim&#125;&quot;</span><br><span class="line">    app:drawerListener=&quot;@&#123;fragment.drawerListener&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>还用XXXView为例，它有成员变量borderColor，这次设置borderColor的方法是setBColor(总有程序员乱写方法名~)，强行用app:borderColor显然是行不通的，可以这样用的前提是必须有setBoderColor(int color)方法，显然setBColor不匹配，但我们可以通过BindingMethods注解实现app:borderColor的使用，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@BindingMethods(value = [</span><br><span class="line">    BindingMethod(</span><br><span class="line">        type = 包名.XXXView::class,</span><br><span class="line">        attribute = &quot;app:borderColor&quot;,</span><br><span class="line">        method = &quot;setBColor&quot;)])</span><br></pre></td></tr></table></figure></p>
<h3 id="BindingAdapter"><a href="#BindingAdapter" class="headerlink" title="@BindingAdapter"></a>@BindingAdapter</h3><blockquote>
<ul>
<li>用于标记修饰方法,方法必须为公共静态方法</li>
<li>方法的第一个参数的类型必须为View类型，不然报错</li>
<li>用来自定义view的任意属性</li>
</ul>
</blockquote>
<p>dataBinding 提供了 BindingAdapter 这个注解用于支持自定义属性，或者是修改原有属性。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#123;&quot;url&quot;&#125;)</span><br><span class="line">public static void loadImage(ImageView view, String url) &#123;</span><br><span class="line">	Log.d(TAG, &quot;loadImage url : &quot; + url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在 xml 文件中关联变量值，当中，bind 这个名称可以自定义</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;import type=&quot;com.github.ixiaow.databindingsample.model.Image&quot; /&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;image&quot;</span><br><span class="line">            type=&quot;Image&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;android.support.constraint.ConstraintLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:id=&quot;@+id/image&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">            bind:url=&quot;@&#123;image.url&#125;&quot; /&gt;</span><br><span class="line">    &lt;/android.support.constraint.ConstraintLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>
<p>BindingAdapter 更为强大的一点是可以覆盖 Android 原先的控件属性。例如，可以设定每一个 Button 的文本都要加上后缀：“-Button”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:text&quot;)</span><br><span class="line">public static void setText(Button view, String text) &#123;</span><br><span class="line">	view.setText(text + &quot;-Button&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:onClick=&quot;@&#123;()-&gt;handler.onClick(image)&#125;&quot;</span><br><span class="line">    android:text=&apos;@&#123;&quot;改变图片Url&quot;&#125;&apos;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="InverseBindingAdapter"><a href="#InverseBindingAdapter" class="headerlink" title="@InverseBindingAdapter"></a>@InverseBindingAdapter</h3><blockquote>
<ul>
<li>作用于方法，方法须为公共静态方法。</li>
<li>方法的第一个参数必须为View类型，如TextView等</li>
<li>用于双向绑定</li>
<li>需要与@BindingAdapter配合使用</li>
</ul>
</blockquote>
<p>死循环绑定的解决方式：只处理新旧数据不一样的数据，参考源码中的例子：android.databinding.adapters.TextViewBindingAdapter。</p>
<p>需要注意的是，使用该语法必须要有反向绑定的方法，android原生view都是自带的，所以<strong>使用原生控件无须担心</strong>，但是自定义view的话需要我们通过InverseBindingAdapter注解类实现</p>
<h3 id="BindingConversion"><a href="#BindingConversion" class="headerlink" title="@BindingConversion"></a>@BindingConversion</h3><p>dataBinding 还支持<strong>对数据进行转换</strong>，或者进行<strong>类型转换</strong>。作用于方法，被该注解标记的方法，被视为dataBinding的转换方法。方法必须为公共静态（public static）方法，且有且只能有1个参数。</p>
<p>与 BindingAdapter 类似，以下方法会将布局文件中所有以@{String}方式引用到的String类型变量加上后缀-conversionString<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@BindingConversion</span><br><span class="line">public static String conversionString(String text) &#123;</span><br><span class="line">	return text + &quot;-conversionString&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 BindingConversion 的优先级要高些, 此外，BindingConversion 也可以用于转换属性值的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@BindingConversion</span><br><span class="line">public static Drawable convertStringToDrawable(String str) &#123;</span><br><span class="line">    if (str.equals(&quot;红色&quot;)) &#123;</span><br><span class="line">        return new ColorDrawable(Color.parseColor(&quot;#FF4081&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (str.equals(&quot;蓝色&quot;)) &#123;</span><br><span class="line">        return new ColorDrawable(Color.parseColor(&quot;#3F51B5&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return new ColorDrawable(Color.parseColor(&quot;#344567&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.自定义生成的绑定类的类名</p>
<p>每个数据绑定布局文件都会生成一个绑定类，ViewDataBinding 的实例名是<strong>根据布局文件名来生成，采用驼峰命名法来命名，并省略布局文件名包含的下划线。控件的获取方式类似，但首字母小写。</strong></p>
<p>通过如下方式自定义 ViewDataBinding 的实例名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;data class=&quot;CustomBinding&quot;&gt;&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.alias 别名</p>
<p>如果存在 import 的类名相同的情况，可以使用 alias 指定别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;com.github.ixiaow.sample.model1.User&quot; /&gt;</span><br><span class="line">    &lt;import</span><br><span class="line">       alias=&quot;TempUser&quot;</span><br><span class="line">       type=&quot;com.github.ixiaow.sample.model2.User&quot; /&gt;</span><br><span class="line">    &lt;variable</span><br><span class="line">       name=&quot;user&quot;</span><br><span class="line">       type=&quot;User&quot; /&gt;</span><br><span class="line">    &lt;variable</span><br><span class="line">       name=&quot;tempUserInfo&quot;</span><br><span class="line">       type=&quot;TempUser&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">	//&lt;需要被替换成&amp;lt;</span><br><span class="line">	&lt;variable name=&quot;users&quot; type=&quot;List&amp;lt;User&gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.默认值(默认值将只在预览视图中显示，且默认值不能包含引号)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;userInfo.name,default=defaultValue&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>4.DataBinding的坑<br>官网上的demo很简单，简单到UserInfo中的所有字段都是string，它并没有告诉我们当字段是int时会有什么问题。假设我们没有在layout中对age写String.valueOf方法的话， userAge就是一个int对象，它会在这里被直接setText<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// batch finished</span><br><span class="line">if ((dirtyFlags &amp; 0xdL) != 0) &#123;</span><br><span class="line">    // api target 1</span><br><span class="line">    android.databinding.adapters.TextViewBindingAdapter.setText(this.tvAge, userAge); //&lt;--设置UI的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对setText传一个int值，会被当做Resource索引，然后导致崩溃。如果你是刚接触DataBinding的新手，估计会看到下面这种崩溃原因</p>
<blockquote>
<p>Resource #0x0</p>
</blockquote>
<p>原因就是缺少了String.valueOf调用了。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>DataBinding使用了apt技术，我们build项目时DataBinding会生成多个文件。</p>
<p>DataBinding通过布局中的tag将控件查找出来，然后根据生成的配置文件将V与M进行对应的同步操作，设置一个全局的布局变化监听来实时更新，M通过他的set方法进行同步。</p>
<p>数据绑定框架的目标就是免除开发者繁琐的操作UI，它帮我们做这些事情就好了。 所以它通过注解在编译期生成了ActivityMainBinding类，就是下面这里:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    ....</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);</span><br><span class="line">        mUser = new UserInfo();</span><br><span class="line">        binding.setUser(mUser);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ActivityMainBinding可以理解为观察者，它的父类是ViewDataBinding, 它有个抽象方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">protected abstract void executeBindings();</span><br></pre></td></tr></table></figure></p>
<p>所有的layout都会生成一个Binding类，这个类继承ViewDataBinding，然后实现了execute*方法。 理解DataBinding框架的关键代码就在这里，其他可以选择性忽略，我们看代码的时候是这样的，先抽脉络，细枝末节的处理可以在理解了框架之后再慢慢体会。 下面是这个抽象方法的具体实现逻辑，这些代码都是DataBinding帮我们生成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void executeBindings() &#123;</span><br><span class="line">    long dirtyFlags = 0;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        dirtyFlags = mDirtyFlags;</span><br><span class="line">        mDirtyFlags = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    java.lang.String userName = null;</span><br><span class="line">    java.lang.String stringValueOfUserAge = null;</span><br><span class="line">    int userAge = 0;</span><br><span class="line">    com.phoenix.databindingdemo.UserInfo user = mUser; //&lt;--我们传入的对象</span><br><span class="line"></span><br><span class="line">    if ((dirtyFlags &amp; 0xfL) != 0) &#123;</span><br><span class="line">        if ((dirtyFlags &amp; 0xbL) != 0) &#123;</span><br><span class="line">                if (user != null) &#123;</span><br><span class="line">                    // read user.name</span><br><span class="line">                    userName = user.getName();//&lt;--UserInfo类中注解标识的get方法</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((dirtyFlags &amp; 0xdL) != 0) &#123;</span><br><span class="line">                if (user != null) &#123;</span><br><span class="line">                    // read user.age</span><br><span class="line">                    userAge = user.getAge();//&lt;--UserInfo类中注解标识的get方法</span><br><span class="line">                &#125;</span><br><span class="line">                // read String.valueOf(user.age)</span><br><span class="line">                stringValueOfUserAge = java.lang.String.valueOf(userAge);//&lt;--layout中的String.valueOf</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // batch finished</span><br><span class="line">    if ((dirtyFlags &amp; 0xdL) != 0) &#123;</span><br><span class="line">        // api target 1</span><br><span class="line">        android.databinding.adapters.TextViewBindingAdapter.setText(this.tvAge, stringValueOfUserAge); //&lt;--设置UI的操作</span><br><span class="line">    &#125;</span><br><span class="line">    if ((dirtyFlags &amp; 0xbL) != 0) &#123;</span><br><span class="line">        // api target 1</span><br><span class="line">        android.databinding.adapters.TextViewBindingAdapter.setText(this.tvName, userName); //&lt;--设置UI的操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在activity中把 mUser对象传入了binding类，在每次对它进行set操作的时候都会触发notify， 之后DataBinding框架会回调execute方法， 框架通过注解拿到get方法，然后拿到和UI所对应的数据，之后结合layout中对应的标注去更新UI。 整个观察者模式的逻辑基本就是这样。</p>
<h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h2><p>service一直被用来做后台运行的操作，包括一些保活，上传数据之类的，这个后台运行的弊端很多，比如耗电，比如设计用户隐私之类的，谷歌对这些后台行为进行了一些处理，从Android Oreo(API 26) 开始，如果一个应用的目标版本为Android 8.0，当它在某些不被允许创建后台服务的场景下，调用了Service的startService()方法，该方法会抛出IllegalStateException。如果想继续使用service，必须调用Context.startForegroundService()。所以，在不久的将来，service的使用范围会越来越小，取而代之的，是谷歌推出的新的技术：WorkManager。</p>
<p>WorkManager 在工作的触发器 满足时, 运行可推迟的后台工作。WorkManager会根据设备API的情况，自动选用JobScheduler, 或是AlarmManager来实现后台任务，WorkManager里面的任务在应用退出之后还可以继续执行，这个技术适用于在应用退出之后任务还需要继续执行的需求。</p>
<p>WorkManager库的架构图如下所示：</p>
<p><img src="/2020/04/09/android-jetpack/workmanager.jpg" alt></p>
<p>WorkManager可以做很多事情: 取消任务, 组合任务, 构建任务链, 将一个任务的参数合并到另一个任务。大部分的后台任务处理，WorkManager都可以胜任:</p>
<p><img src="/2020/04/09/android-jetpack/work_manager.webp" alt></p>
<h2 id="相关应用架构"><a href="#相关应用架构" class="headerlink" title="相关应用架构"></a>相关应用架构</h2><p><img src="/2020/04/09/android-jetpack/jetpack-architecture.png" alt></p>
<blockquote>
<p>注意：任何应用编写方式都不可能是每种情况的最佳选择。话虽如此，但推荐的这个架构是个不错的起点，适合大多数情况和工作流。如果您已经有编写 Android 应用的好方法（遵循常见的架构原则），则无需更改。</p>
</blockquote>
<h3 id="常见的架构原则"><a href="#常见的架构原则" class="headerlink" title="常见的架构原则"></a>常见的架构原则</h3><p>如果您不应使用应用组件存储应用数据和状态，那么您应该如何设计应用呢？</p>
<p><strong>分离关注点</strong></p>
<p>要遵循的最重要的原则是分离关注点。一种常见的错误是在一个 Activity 或 Fragment 中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。您应尽可能使这些类保持精简，这样可以避免许多与生命周期相关的问题。</p>
<p>请注意，您并非拥有 Activity 和 Fragment 的实现；它们只是表示 Android 操作系统与应用之间关系的粘合类。操作系统可能会根据用户互动或因内存不足等系统条件随时销毁它们。为了提供令人满意的用户体验和更易于管理的应用维护体验，您最好尽量减少对它们的依赖。</p>
<p><strong>通过模型驱动界面</strong></p>
<p>另一个重要原则是您应该通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。它们独立于应用中的 View 对象和应用组件，因此不受应用的生命周期以及相关的关注点的影响。</p>
<p>持久性是理想之选，原因如下：</p>
<ul>
<li>如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据。</li>
<li>当网络连接不稳定或不可用时，应用会继续工作。</li>
</ul>
<p>应用所基于的模型类<strong>应明确定义数据管理职责</strong>，这样将使应用更可测试且更一致。</p>
<h3 id="最佳做法"><a href="#最佳做法" class="headerlink" title="最佳做法"></a>最佳做法</h3><p>编程是一个创造性的领域，构建 Android 应用也不例外。无论是在多个 Activity 或 Fragment 之间传递数据，检索远程数据并将其保留在本地以在离线模式下使用，还是复杂应用遇到的任何其他常见情况，解决问题的方法都会有很多种。</p>
<p>虽然以下建议不是强制性的，但根据我们的经验，从长远来看，遵循这些建议会使您的代码库更强大、可测试性更高且更易维护：</p>
<p><strong>避免将应用的入口点（如 Activity、Service 和广播接收器）指定为数据源。</strong></p>
<p>相反，您应只将其与其他组件协调，以检索与该入口点相关的数据子集。每个应用组件存在的时间都很短暂，具体取决于用户与其设备的交互情况以及系统当前的整体运行状况。</p>
<p><strong>在应用的各个模块之间设定明确定义的职责界限。</strong></p>
<p>例如，请勿在代码库中将从网络加载数据的代码散布到多个类或软件包中。同样，也不要将不相关的职责（如数据缓存和数据绑定）定义到同一个类中。</p>
<p><strong>尽量少公开每个模块中的代码。</strong></p>
<p>请勿试图创建“就是那一个”快捷方式来呈现一个模块的内部实现细节。短期内，您可能会省点时间，但随着代码库的不断发展，您可能会反复陷入技术上的麻烦。</p>
<p><strong>考虑如何使每个模块可独立测试。</strong></p>
<p>例如，如果使用明确定义的 API 从网络获取数据，将会更容易测试在本地数据库中保留该数据的模块。如果您将这两个模块的逻辑混放在一处，或将网络代码分散在整个代码库中，那么即便能够进行测试，难度也会大很多。</p>
<p><strong>专注于应用的独特核心，以使其从其他应用中脱颖而出。</strong></p>
<p>不要一次又一次地编写相同的样板代码，这是在做无用功。相反，您应将时间和精力集中放在能让应用与众不同的方面上，并让 Android 架构组件以及建议的其他库处理重复的样板。</p>
<p><strong>保留尽可能多的相关数据和最新数据。</strong></p>
<p>这样，即使用户的设备处于离线模式，他们也可以使用您应用的功能。请注意，并非所有用户都能享受到稳定的高速连接。</p>
<p><strong>将一个数据源指定为单一可信来源。</strong></p>
<p>每当应用需要访问这部分数据时，这部分数据都应一律源于此单一可信来源。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.google.cn/jetpack?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/jetpack?hl=zh_cn</a><br><a href="https://www.jianshu.com/p/66b93df4b7a6" target="_blank" rel="noopener">即学即用Android Jetpack</a><br><a href="https://www.jianshu.com/p/35d143e84d42" target="_blank" rel="noopener">深入了解架构组件之ViewModel</a><br><a href="https://developer.android.google.cn/jetpack/docs/guide?hl=zh_cn#recommended-app-arch" target="_blank" rel="noopener">应用架构指南</a><br><a href="https://juejin.im/post/5b04d064f265da0b80711759" target="_blank" rel="noopener">从Service到WorkManager</a><br><a href="https://github.com/googlecodelabs/android-navigation" target="_blank" rel="noopener">android-navigation demo</a><br><a href="https://blog.csdn.net/xiaowu_zhu/article/details/91826467" target="_blank" rel="noopener">Android DataBinding 使用</a><br><a href="https://www.jianshu.com/p/9bd2f3069d2e" target="_blank" rel="noopener">DataBinding常用注解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/07/android-plugin-virtualApp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/07/android-plugin-virtualApp/" itemprop="url">VirtualApp沙盒基本原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-07T13:41:44+08:00">
                2020-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android插件化/" itemprop="url" rel="index">
                    <span itemprop="name">Android插件化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>VirtualApp是一款运行于Android系统的沙盒产品，可以理解为轻量级的“Android虚拟机”。是一个开源的Android App虚拟化引擎，允许在其中创建虚拟空间，并在这个虚拟空间中运行其他应用。</p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>Android应用隔离是基于Linux系统的多用户机制实现的，即每个应用在安装时被分配了不同的Linux用户uid/gid。而在VirtualApp中，client应用（通过VirtualApp安装的应用）与host应用（即VirtualApp本身）是<strong>具有相同用户uid</strong>的。</p>
<p>因此，VirtualApp在运行时，包含以下三部分：</p>
<ul>
<li>Main Process，进程名io.virtualapp，主要负责VirtualApp用户界面及应用管理</li>
<li>Server Process，进程名io.virtualapp:x，主要负责系统服务的代理，是通过Content Provider启动的</li>
<li>VApp Process，进程名io.virtualapp:p[0-…]，作为将来运行client应用的进程，当client应用启动后，其进程名会更新为client应用的包名</li>
</ul>
<p>下面是在VirtualApp中运行应用后通过ps命令得到的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generic_x86:/ $ ps |grep u0_a60</span><br><span class="line">u0_a60    2385  1258  996260 54456 SyS_epoll_ 00000000 S io.virtualapp</span><br><span class="line">u0_a60    2412  1258  980940 48272 SyS_epoll_ 00000000 S io.virtualapp:x</span><br><span class="line">u0_a60    3705  1258  993632 54472 SyS_epoll_ 00000000 S org.galaxy.simpleapp</span><br></pre></td></tr></table></figure></p>
<p>可以看到，以上进程，均是以VirtualApp的用户uid运行的。因此，Android应用隔离此时不再适用，我们可以对client应用进行hook而无需root权限。</p>
<h2 id="注入逻辑"><a href="#注入逻辑" class="headerlink" title="注入逻辑"></a>注入逻辑</h2><p>要想实现对一个APP的虚拟化，就是不直接把APP安装进系统，同时又要提供APP运行过程中所需的一切，从而可以让它误以为自己是运行在正常系统中。这里就需要实现系统服务的虚拟化和相关路径的虚拟化。</p>
<p>其中，<strong>系统服务的虚拟化主要靠注入大量framework组件来实现</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@VirtualApp/lib/src/main/java/com/lody/virtual/client/core/InvocationStubManager.java</span><br><span class="line">private void injectInternal() throws Throwable &#123;</span><br><span class="line">  if (VirtualCore.get().isMainProcess()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (VirtualCore.get().isServerProcess()) &#123;</span><br><span class="line">    addInjector(new ActivityManagerStub());</span><br><span class="line">    addInjector(new PackageManagerStub());</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (VirtualCore.get().isVAppProcess()) &#123;</span><br><span class="line">    addInjector(new LibCoreStub());</span><br><span class="line">    addInjector(new ActivityManagerStub());</span><br><span class="line">    addInjector(new PackageManagerStub());</span><br><span class="line">    addInjector(HCallbackStub.getDefault());</span><br><span class="line">    addInjector(new ISmsStub());</span><br><span class="line">    addInjector(new ISubStub());</span><br><span class="line">    addInjector(new DropBoxManagerStub());</span><br><span class="line">    addInjector(new NotificationManagerStub());</span><br><span class="line">    addInjector(new LocationManagerStub());</span><br><span class="line">    addInjector(new WindowManagerStub());</span><br><span class="line">    addInjector(new ClipBoardStub());</span><br><span class="line">    addInjector(new MountServiceStub());</span><br><span class="line">    addInjector(new BackupManagerStub());</span><br><span class="line">    addInjector(new TelephonyStub());</span><br><span class="line">    addInjector(new TelephonyRegistryStub());</span><br><span class="line">    addInjector(new PhoneSubInfoStub());</span><br><span class="line">    addInjector(new PowerManagerStub());</span><br><span class="line">    addInjector(new AppWidgetManagerStub());</span><br><span class="line">    addInjector(new AccountManagerStub());</span><br><span class="line">    addInjector(new AudioManagerStub());</span><br><span class="line">    addInjector(new SearchManagerStub());</span><br><span class="line">    addInjector(new ContentServiceStub());</span><br><span class="line">    addInjector(new ConnectivityStub());</span><br><span class="line"> </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR2) &#123;</span><br><span class="line">      addInjector(new VibratorStub());</span><br><span class="line">      addInjector(new WifiManagerStub());</span><br><span class="line">      addInjector(new BluetoothStub());</span><br><span class="line">      addInjector(new ContextHubServiceStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR1) &#123;</span><br><span class="line">      addInjector(new UserManagerStub());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR1) &#123;</span><br><span class="line">      addInjector(new DisplayStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= LOLLIPOP) &#123;</span><br><span class="line">      addInjector(new PersistentDataBlockServiceStub());</span><br><span class="line">      addInjector(new InputMethodManagerStub());</span><br><span class="line">      addInjector(new MmsStub());</span><br><span class="line">      addInjector(new SessionManagerStub());</span><br><span class="line">      addInjector(new JobServiceStub());</span><br><span class="line">      addInjector(new RestrictionStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= KITKAT) &#123;</span><br><span class="line">      addInjector(new AlarmManagerStub());</span><br><span class="line">      addInjector(new AppOpsManagerStub());</span><br><span class="line">      addInjector(new MediaRouterServiceStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= LOLLIPOP_MR1) &#123;</span><br><span class="line">      addInjector(new GraphicsStatsStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= M) &#123;</span><br><span class="line">      addInjector(new NetworkManagementStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= N) &#123;</span><br><span class="line">              addInjector(new WifiScannerStub());</span><br><span class="line">              addInjector(new ShortcutServiceStub());</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个注入过程是发生在io.virtualapp.VApp.attachBaseContext中，因此，每次启动一个子进程都会执行到这里，这会区分是isMainProcess（io.virtualapp）或者isServerProcess（io.virtualapp:x）或者isVAppProcess（被安装APP）来进行不同的注入，可以看到，注入最多的还是在被安装APP的进程中。</p>
<h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>从启动VirtualApp到运行其中的应用，大致流程如下：</p>
<h3 id="启动host应用"><a href="#启动host应用" class="headerlink" title="启动host应用"></a>启动host应用</h3><p>我们启动VirtualApp，其Application为io.virtualapp.VApp。<strong>在attachBaseContext()</strong>方法中会调用到com.lody.virtual.client.core.PatchManager#injectInternal，但此时为<strong>Main Process</strong>，不进行系统服务的替换。</p>
<h3 id="启动Server-Process"><a href="#启动Server-Process" class="headerlink" title="启动Server Process"></a>启动Server Process</h3><p>host应用会进行一些初始化，其中就包括获取全部已安装应用，这会调用到com.lody.virtual.client.core.VirtualCore#getAllApps。而这一方法最终会访问com.lody.virtual.server.BinderProvider。由AndroidManifest.xml可知，该provider会运行在新进程io.virtualapp:x中，即<strong>Server Process</strong>。</p>
<p>由于在新进程中启动组件，同样会首先创建该应用的Application，因此也会调用到com.lody.virtual.client.core.PatchManager#injectInternal。此时，<strong>会进行相应系统服务(ActivityManager和PackageManager)的代理构造和替换。</strong></p>
<h3 id="启动VApp-Process"><a href="#启动VApp-Process" class="headerlink" title="启动VApp Process"></a>启动VApp Process</h3><p>点击一个已安装应用，此时会通过替换掉的系统服务访问真实的系统服务（主要是ActivityManager），并在新进程中启动组件com.lody.virtual.client.stub.StubActivity.C0。由AndroidManifest.xml可知，该进程具有后缀:p0。</p>
<p>同样的，在该Activity组件启动之前会初始化io.virtualapp.VApp，并在com.lody.virtual.client.core.PatchManager#injectInternal中<strong>完成系统服务的代理构造和替换。</strong></p>
<h3 id="启动client应用"><a href="#启动client应用" class="headerlink" title="启动client应用"></a>启动client应用</h3><p>此时，真正的client应用尚未启动，进程io.virtualapp:p0仅仅是作为一个placeholder。StubActivity会从Intent中获取到client应用的相关信息，并修改自身ActivityThread的handler。随后调用startActivity启动client应用。</p>
<p>由于之前Server Process和VApp Process都已完成了相关系统服务的替换，这里会完成client应用的bindApplication调用、构造client应用的LoadedApk，并通过反射完成真正的Application和Activity的创建。</p>
<p>最终，client应用便运行在了我们的VApp Process中。</p>
<h2 id="系统服务的代理和替换"><a href="#系统服务的代理和替换" class="headerlink" title="系统服务的代理和替换"></a>系统服务的代理和替换</h2><p>VirtualApp之所以能够实现虚拟空间，是因为其对许多系统服务进行了代理和替换。因此，这部分便是整个框架的核心。系统服务运行在system_server中，Android应用调用系统服务，是通过Binder机制进行IPC。因此，<strong>应用所持有的是系统服务的BinderProxy，通过对这些BinderProxer构造代理并替换，便实现了对系统服务的代理和替换。</strong></p>
<p>具体地，我们以com.lody.virtual.client.hook.patchs.am.ActivityManagerPatch为例，这个类实现了对ActivityManager服务的代理和替换。</p>
<h3 id="代理的构造"><a href="#代理的构造" class="headerlink" title="代理的构造"></a>代理的构造</h3><p>可以看到，这个类的注记中包含了大量类名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Patch(&#123;StartActivity.class, StartActivityAsCaller.class,</span><br><span class="line">        StartActivityAndWait.class, StartActivityWithConfig.class, StartActivityIntentSender.class,</span><br><span class="line">        StartNextMatchingActivity.class, StartVoiceActivity.class,</span><br><span class="line">        GetIntentSender.class, RegisterReceiver.class, GetContentProvider.class,</span><br><span class="line">        GetContentProviderExternal.class,</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>而这些列出的每一个类，对应于一个方法的hook，例如，com.lody.virtual.client.hook.patchs.am.StartActivity是ActivityManager服务的startActivity方法的hook。这些类均继承自com.lody.virtual.client.hook.base.Hook，包含了方法beforeCall(), call(), afterCall()，这些方法便是hook的具体内容。</p>
<p>ActivityManagerPatch在创建时，会调用到其父类的方法com.lody.virtual.client.hook.base.PatchDelegate#onBindHooks。这里会检查上述注记中列出的hook，并对符合条件的hook调用addHook()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Class&lt;? extends PatchDelegate&gt; clazz = getClass();</span><br><span class="line">Patch patch = clazz.getAnnotation(Patch.class);</span><br><span class="line">int version = Build.VERSION.SDK_INT;</span><br><span class="line">if (patch != null) &#123;</span><br><span class="line">    Class&lt;?&gt;[] hookTypes = patch.value();</span><br><span class="line">    for (Class&lt;?&gt; hookType : hookTypes) &#123;</span><br><span class="line">        ApiLimit apiLimit = hookType.getAnnotation(ApiLimit.class);</span><br><span class="line">        boolean needToAddHook = true;</span><br><span class="line">        if (apiLimit != null) &#123;</span><br><span class="line">            int apiStart = apiLimit.start();</span><br><span class="line">            int apiEnd = apiLimit.end();</span><br><span class="line">            boolean highThanStart = apiStart == -1 || version &gt; apiStart;</span><br><span class="line">            boolean lowThanEnd = apiEnd == -1 || version &lt; apiEnd;</span><br><span class="line">            if (!highThanStart || !lowThanEnd) &#123;</span><br><span class="line">                needToAddHook = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (needToAddHook) &#123;</span><br><span class="line">            addHook(hookType);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>而addHook()最终会调用到com.lody.virtual.client.hook.base.HookDelegate#addHook，其实质便是将这个hook添加至映射表internalHookTable中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Hook addHook(Hook hook) &#123;</span><br><span class="line">    if (hook != null &amp;&amp; !TextUtils.isEmpty(hook.getName())) &#123;</span><br><span class="line">        if (internalHookTable.containsKey(hook.getName())) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;The Hook(%s, %s) you added has been in existence.&quot;, hook.getName(),</span><br><span class="line">                    hook.getClass().getName());</span><br><span class="line">            return hook;</span><br><span class="line">        &#125;</span><br><span class="line">        internalHookTable.put(hook.getName(), hook);</span><br><span class="line">    &#125;</span><br><span class="line">    return hook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>internalHookTable维护了所有的hook，以hook的名称（一般就是所hook的方法的名称）作为key。随后，在com.lody.virtual.client.hook.base.HookDelegate.HookHandler的invoke()方法中，查找表 internalHookTable中是否包含将要执行的方法名；如果有，则依次执行对应hook的beforeCall(), call(), afterCall()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private class HookHandler implements InvocationHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Hook hook = getHook(method.getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            if (hook != null &amp;&amp; hook.isEnable()) &#123;</span><br><span class="line">                if (hook.beforeCall(mBaseInterface, method, args)) &#123;</span><br><span class="line">                    Object res = hook.call(mBaseInterface, method, args);</span><br><span class="line">                    res = hook.afterCall(mBaseInterface, method, args, res);</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return method.invoke(mBaseInterface, args);</span><br></pre></td></tr></table></figure></p>
<p>而这里的类HookHandler，就是构造的Java代理的Handler：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public HookDelegate(T baseInterface, Class&lt;?&gt;... proxyInterfaces) &#123;</span><br><span class="line">    this.mBaseInterface = baseInterface;</span><br><span class="line">    if (baseInterface != null) &#123;</span><br><span class="line">        if (proxyInterfaces == null) &#123;</span><br><span class="line">            proxyInterfaces = HookUtils.getAllInterface(baseInterface.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        mProxyInterface = (T) Proxy.newProxyInstance(baseInterface.getClass().getClassLoader(), proxyInterfaces, new HookHandler());</span><br></pre></td></tr></table></figure></p>
<p>对于ActivityManagerPatch来说，这里的baseInterface便是原始的BinderProxy: ActivityManagerProxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ActivityManagerPatch() &#123;</span><br><span class="line">    super(new HookDelegate&lt;IInterface&gt;(ActivityManagerNative.getDefault.call()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>综上，我们根据baseInterface，为其构造了代理mProxyInterface。从而访问mProxyInterface时，便会执行HookHandler的invoke()方法，进而查找internalHookTable，对设置了hook的方法执行hook。</p>
<h3 id="系统服务的替换"><a href="#系统服务的替换" class="headerlink" title="系统服务的替换"></a>系统服务的替换</h3><p>如之前所说，对系统服务的替换，是通过对应用所持有的系统服务的BinderProxy进行替换的。以上是构造代理的基本过程，那么如何将应用所持有的BinderProxy替换成我们构造的代理呢？回到ActivityManagerPatch，这个类的inject()方法完成了实际的替换工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void inject() throws Throwable &#123;</span><br><span class="line">    if (ActivityManagerNative.gDefault.type() == IActivityManager.TYPE) &#123;</span><br><span class="line">        ActivityManagerNative.gDefault.set(getHookDelegate().getProxyInterface());</span><br><span class="line"></span><br><span class="line">    &#125; else if (ActivityManagerNative.gDefault.type() == Singleton.TYPE) &#123;</span><br><span class="line">        Object gDefault = ActivityManagerNative.gDefault.get();</span><br><span class="line">        Singleton.mInstance.set(gDefault, getHookDelegate().getProxyInterface());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>ActivityManagerNative.gDefault便是应用所持有的原始ActivityManagerProxy对象，通过Java反射，将替换成为getHookDelegate().getProxyInterface()。而替换的内容，便是我们所构造的代理mProxyInterface。</p>
<p>由此，我们完成了对系统服务进行代理和替换的整个过程。随后，在调用系统服务时，便会执行以下操作：</p>
<ul>
<li>访问BinderProxy的代理，即我们设置了hook的代理</li>
<li>根据hook的具体内容操作，对数据进行处理；需要调用原始系统服务时，访问原始的BinderProxy</li>
<li>真正的系统服务接收到Binder，进行处理并返回</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上介绍可以看到，VirtualApp在原有系统服务之上构造了代理，进而为其中的应用搭建了一套虚拟环境，应用可以无感知地运行在这其中。更进一步，我们可以设置这套虚拟环境，使其实现应用多开、非侵入式应用hook等高级功能。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">https://github.com/asLody/VirtualApp</a><br><a href="http://rk700.github.io/2017/03/15/virtualapp-basic/" target="_blank" rel="noopener">http://rk700.github.io/2017/03/15/virtualapp-basic/</a><br><a href="https://blog.csdn.net/weixin_40581980/article/details/81169266" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40581980/article/details/81169266</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/03/android-plugin-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/03/android-plugin-knowledge/" itemprop="url">Android插件化方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-03T15:20:16+08:00">
                2020-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android插件化/" itemprop="url" rel="index">
                    <span itemprop="name">Android插件化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>插件化技术涉及得非常广泛，其中最核心的就是Android的类加载机制和反射机制。下图载自腾讯bugly：</p>
<p><img src="/2020/04/03/android-plugin-knowledge/plugin_history.jpg" alt title="图1：插件化概要"></p>
<h2 id="插件化发展历史"><a href="#插件化发展历史" class="headerlink" title="插件化发展历史"></a>插件化发展历史</h2><p>插件化技术最初源于免安装运行apk的想法，这个免安装的apk可以理解为插件。支持插件化的app可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展。想要实现插件化，主要是解决下面三个问题：</p>
<ul>
<li>插件中代码的加载和与主工程的互相调用</li>
<li>插件中资源的加载和与主工程的互相访问</li>
<li>四大组件生命周期的管理</li>
</ul>
<p>下面是比较出名的几个开源的插件化框架，按照出现的时间排序。研究它们的实现原理，可以大致看出插件化技术的发展，根据实现原理可以将这几个框架划分成了三代。</p>
<p><img src="/2020/04/03/android-plugin-knowledge/plugin_generate.jpg" alt></p>
<p><strong>第一代</strong>：dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期。该种方式缺点明显，插件中的activity必须继承PluginActivity，开发时要小心处理context。而DroidPlugin通过Hook系统服务的方式启动插件中的Activity，使得开发插件的过程和开发普通的app没有什么区别，但是由于hook过多系统服务，异常复杂且不够稳定。<br><strong>第二代</strong>：为了同时达到<strong>插件开发的低侵入性（像开发普通app一样开发插件）和框架的稳定性</strong>，在实现原理上都是趋近于选择尽量少的hook，并通过在manifest中预埋一些组件实现对四大组件的插件化。另外各个框架根据其设计思想都做了不同程度的扩展，其中Small更是做成了一个跨平台，组件化的开发框架。<br><strong>第三代</strong>：VirtualApp比较厉害，能够完全模拟app的运行环境，能够实现app的免安装运行和双开技术。Atlas是阿里开源出来的一个结合组件化和热修复技术的一个app基础框架，其广泛的应用与阿里系的各个app，其号称是一个容器化框架。</p>
<h2 id="Atlas-VirtualApk-RePlugin对比"><a href="#Atlas-VirtualApk-RePlugin对比" class="headerlink" title="Atlas/VirtualApk/RePlugin对比"></a>Atlas/VirtualApk/RePlugin对比</h2><p>Atlas是伴随着手机淘宝的不断发展而衍生出来的一个运行于Android系统上的一个容器化框架，我们也叫<strong>动态组件化(Dynamic Bundle)框架</strong>。它主要提供了解耦化、组件化、动态性的支持。覆盖了工程师的工程编码期、Apk运行期以及后续运维期的各种问题。</p>
<p>VirtualAPK是滴滴出行自研的一款优秀的插件化框架，功能完备。支持几乎所有的Android特性；四大组件均不需要在宿主manifest中预注册，每个组件都有完整的生命周期，入侵性极低。</p>
<p>RePlugin是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。</p>
<p>Atlas：<a href="https://github.com/alibaba/atlas/tree/master/atlas-docs" target="_blank" rel="noopener">https://github.com/alibaba/atlas/tree/master/atlas-docs</a><br>VirtualAPK：<a href="https://github.com/didi/VirtualAPK/wiki" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK/wiki</a><br>RePlugin：<a href="https://github.com/Qihoo360/RePlugin/wiki" target="_blank" rel="noopener">https://github.com/Qihoo360/RePlugin/wiki</a></p>
<h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>从定义上说，<strong>Atlas定义为组件化，而VirtualAPK和RePlugin则定义为插件化</strong>。这两种还是有一点点不同的，<strong>组件化偏重于编译期，插件化偏重于运行期</strong>。换句话来说，Atlas在编译的时候是需要把bundle放在一起处理的，而后面两个则可以完全独立开，和开发新的一个apk一样，最后打包的时候配置一下就行。</p>
<h3 id="二、接入难度"><a href="#二、接入难度" class="headerlink" title="二、接入难度"></a>二、接入难度</h3><p>初次接入Atlas，那真的会有点懵逼，官方文档已经万年没更新的，GitHub上面的demo和文档上的好多都不一样，就算接入了，也会出现一堆问题，简直想死。VirtualAPK，滴滴这个，接入还算简单的了，文档也比较完善。RePlugin，360这个也挺简单的，宿主和插件分得很清楚。所以接入难度：<strong>RePlugin最快，VirtualAPK其次，Atlas最麻烦。</strong></p>
<h3 id="三、功能"><a href="#三、功能" class="headerlink" title="三、功能"></a>三、功能</h3><p>三者<strong>都有的功能是远程bundle，按需加载</strong>。意思是项目中某个模块，打包的时候不打进apk，等你安装了，需要用到的时候再下载那个模块进行加载显示，从而减少apk的安装体积。<strong>Atlas会把插件打成so的形式，而VirtualAPK和RePlugin会打成apk的形式，都是放在内存卡，然后调用各自的安装加载方法就行</strong>。Atlas安装后，可以把so删掉，但VirtualAPK的apk需要一直在内存卡，否则是打不开的，而RePlugin安装后会自动备份一个apk到缓存目录。除了远程bundle功能，Atlas还有热修复的功能，可以不升级apk就实现宿主和组件的更新。</p>
<h3 id="四、更新插件方式"><a href="#四、更新插件方式" class="headerlink" title="四、更新插件方式"></a>四、更新插件方式</h3><p>Atlas更新插件的话，必须要和宿主一起，打差异补丁才能更新，而VirtualAPK和RePlugin是可以直接通过下载一个新的插件apk，然后调安装方法就能实现插件的更新。</p>
<h3 id="五、插件独立性"><a href="#五、插件独立性" class="headerlink" title="五、插件独立性"></a>五、插件独立性</h3><p>Atlas和宿主的依赖还是挺多，毕竟官方也强调是组件化，不是插件化。<strong>而VirtualAPK，它可以是一个独立的app，但插件里面也定义和宿主的关联，就是说这个插件apk并不能给其他宿主用，只能给插件里面声明的那个宿主使用。RePlugin呢，就比较独立了，里面不用声明和宿主的联系，所以你生成一个插件后，这个插件可以给其他宿主调用。</strong></p>
<h3 id="六、宿主和插件的公共库"><a href="#六、宿主和插件的公共库" class="headerlink" title="六、宿主和插件的公共库"></a>六、宿主和插件的公共库</h3><p>如果宿主和插件都用到一些公共依赖库，比如http库，图片加载库，这个时候怎么处理？Atlas处理就简单了，毕竟是组件化，和宿主的项目都是在一起。可以在项目里面定义一个middleLibrary，这个库里面依赖一些公共的库或者资源，然后宿主和插件都依赖他就行了<strong>。VirtualAPK呢，由于插件里面要声明和宿主的关联，所以他会自动检测，如果插件中依赖的库，在宿主里面也有的话，他会自动去掉一个，不会重复。RePlugin是比较独立的，没有和宿主太多联系，所以目前大家的做法是宿主compile，插件 provided的形式，而共用资源的话，RePlugin是不提倡的了。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你的app需要热更新和插件的功能，推荐使用Atlas；如果你的app仅用到插件，在需要的时候才下载加载的话，你可以选择VirtualAPK和RePlugin；如果你的插件希望其他宿主也能用的话，那就只能RePlugin了，RePlugin就像一个应用市场，你的宿主仅仅是一个壳，然后把需要的插件下载加载使用就行，更新的话也无需更新宿主，直接更新插件就行。</p>
<h2 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h2><p>Atlas是伴随着手机淘宝的不断发展而衍生出来的一个运行于Android系统上的一个容器化框架，我们也叫动态组件化(Dynamic Bundle)框架。它主要提供了解耦化、组件化、动态性的支持。覆盖了工程师的工程编码期、Apk运行期以及后续运维期的各种问题。</p>
<h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><p><img src="/2020/04/03/android-plugin-knowledge/atlas-package.webp" alt title="包结构"></p>
<p>其整体包结构和正常Apk包结构类似。区别在于armeabi中存放大量的so，每个so都是APK转过来的，作为一个单独的bundle。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2020/04/03/android-plugin-knowledge/atlas-layer.webp" alt></p>
<p>这一块是Atlas的整体设计，分为五层：</p>
<ul>
<li>第一层我们称之为Hack层，包括OS  Hack  toolkit &amp; verifier，这里我们对系统能力做一些扩展，然后做一些安全校验。</li>
<li>第二层是Bundle  Franework，就是我们的容器基础框架，提供Bundle管理、加载、生命周期、安全等一些最基本的能力。</li>
<li>第三层是运行期管理层，包括清单，我们会把所有的Bundle和它们的能力列在一个清单上，在调用时方便查找；另外是版本管理，会对所有Bundle的版本进行管理；再就是代理，这里就是和业界一些插件化框架机制类似的地方，我们会代理系统的运行环境，让Bundle运行在我们的容器框架上；然后还有调试和监控工具，是为了方便工程期开发调试。</li>
<li>第四层是业务层了，这里我们向业务方暴露了一些接口，如框架生命周期、配置文件、工具库等等。</li>
<li>最上面一层是应用接入层，就是我们的业务代码了。</li>
</ul>
<h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>1、Manifest与依赖<br>Bundle的Manifest在编译期会进行Merge，Bundle的依赖会单独Merge，因为涉及依赖仲裁最终输出BundleInfoList</p>
<p>2、多ClassLoader<br>为什么要用多ClassLoader，我的猜想是，类卸载。<br>JVM提供的类加载器始终不会释放，因此根据可达性，其加载出来的类，也始终不会释放，但是用户自定义的就可以。<br>这保证了一个组件在使用完以后，不存在任何实例化对象，任何类对象，保证了性能与稳定。</p>
<p><img src="/2020/04/03/android-plugin-knowledge/atlas-path.webp" alt></p>
<p>DelegateClassLoader先查找宿主Bundle的PathClassLoader，然后根据BundleInfoList，查找对应Bundle的BundleClassLoader</p>
<p>3、资源</p>
<p><img src="/2020/04/03/android-plugin-knowledge/atlas-res.webp" alt></p>
<p>用DelegeteResources替换系统的Resource，Bundle的资源在运行期会添加到AssertsPath中<br>并且进行分区，防止资源错乱<br>并且根据ART、Dalvik适配以及机型适配<br>为了防止资源名冲突，在资源名前后添加bundle独有id</p>
<p>4、按需加载</p>
<p>在想用一个组件的时候，到BundleInfoList中查找对应的Bundle，进行加载<br>每个组件都有生命周期管理，这样保证组件在不用的时候资源可以释放</p>
<p>5、动态化</p>
<p>主Bundle基于ClassLoader实现，业务Bundle基于差量Merge<br>可以结合Andfix，它基于Native Hook实现，用于方法的动态修改</p>
<p><img src="/2020/04/03/android-plugin-knowledge/atlas-apk.webp" alt></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>为什么atlas这么好，支付宝却开始弃用了呢？诱因是android p的发布，大家可以看看这篇了解下 <a href="https://blog.csdn.net/tyro_smallnew/article/details/80468034" target="_blank" rel="noopener">https://blog.csdn.net/tyro_smallnew/article/details/80468034</a> （Android P阻止调用非sdk api后，Atlas该何去何从）。</p>
<p>android p开始android开始禁止开发者使用非官方api，也就是禁止反射使用android不想让开发者使用的类和属性，但是atlas的工作原理就是反射这些不让用的api。</p>
<p>然而android p并不是主要原因，主要原因是 Atlas并不是刚需而且有些限制：<br>1、基于动态化加载的方案有许多，前端技术已经开始应用到app开发中，weex rn性能也已经达到开发者预期，前端方案明显是比atlas更有优势，而在支付宝中你会发现大部分都是前端页面<br>2、插件更新其实并不常用，一般大厂的应用都通过严谨的测试，出问题的概率比较小，大部分逻辑都是服务端来实现，可控性很强，所以插件更新在一些公司没有用武之地<br>3、Atlas依赖管理比较复杂，插件之间存在依赖也可能是多级依赖，如果要跨插件依赖需要整理好依赖树，但需求常改，之前的依赖树可能不符合需求需要重整，这个时候非常耗时耗力，而原生开发的依赖管理就方便得多<br>4、兼容问题，Atlas经历了好几代android的兼容：5.0时代的art虚拟机兼容、7.0浏览器资源加载兼容、各个版本的api兼容。。。你会在atlas核心代码中发现很多if else来判断android版本，不过atlas做的不错兼容的也很好，但每次android出版本都要兼容一次确实费时费力</p>
<h3 id="Atlas-support-android-Q"><a href="#Atlas-support-android-Q" class="headerlink" title="Atlas support android Q"></a><a href="https://github.com/alibaba/atlas/releases" target="_blank" rel="noopener">Atlas support android Q</a></h3><p>Atlas 5.1.0.9-rc26 已发布，此次更新较为重大，官方提醒升级请慎重。</p>
<p>主要更新内容如下：</p>
<ul>
<li>支持 Android Q，弃用 atlasupdate 项目</li>
<li>bundle 需要在运行时打包在 maindex 中</li>
<li>未来将不再支持动态部署</li>
<li>dexpatch 仅在 Android P 以下的版本受支持，并且 Atlas 不会在 Android P 及更高版本上加载补丁（新补丁将在稍后提供）</li>
<li>弃用 DelegateClassloader、DelegateResources、BundleClassloader、InstrumentationHook 等</li>
<li>如果想要在使用这个 bundle 之前初始化一个 bundle，可以使用：BundleIniter.initBundle（String bundleName，null）</li>
<li>不支持 bundle 依赖项，因为所有 bundle 都在运行时使用 PathClassloader</li>
<li>之后将不支持远程视图和远程片段，因为所有 bundle 都在运行时使用 PathClassloader</li>
<li>AtlasDemo 已更新</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ceded2da7847" target="_blank" rel="noopener">https://www.jianshu.com/p/ceded2da7847</a><br><a href="https://mp.weixin.qq.com/s/Uwr6Rimc7Gpnq4wMFZSAag?utm_source=androidweekly&amp;utm_medium=website" target="_blank" rel="noopener">《Android插件化技术——原理篇》</a></p>
<p>atlas:<br>1.<a href="https://github.com/alibaba/atlas" target="_blank" rel="noopener">https://github.com/alibaba/atlas</a><br>2.<a href="https://blog.csdn.net/qq_36523667/article/details/99178542" target="_blank" rel="noopener">https://blog.csdn.net/qq_36523667/article/details/99178542</a><br>3.<a href="https://mp.weixin.qq.com/s/G0dsrVYytT8WdJ6U90NPiA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/G0dsrVYytT8WdJ6U90NPiA</a><br>4.<a href="https://www.jianshu.com/p/d3d881a59561" target="_blank" rel="noopener">https://www.jianshu.com/p/d3d881a59561</a><br>5.<a href="https://edu.aliyun.com/course/68/lesson/list?spm=5176.8764728.aliyun-edu-course-tab.2.73736355X6f7Nr&amp;previewAs=guest&amp;accounttraceid=0fc924ae8401453ba825c59f1e55158fzmti" target="_blank" rel="noopener">开源Android容器化框架Atlas开发者指南</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/07/c-plus-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/07/c-plus-language/" itemprop="url">C++ 语言笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-07T13:06:49+08:00">
                2020-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p>
<p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：封装、抽象、继承、多态。</p>
<p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。C++ 是 C 的一个超集，任何合法的 C 程序都是合法的 C++ 程序。</p>
<p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</p>
<p>注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p>
<p>本章只针对和C语言不同处介绍。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。</p>
<h3 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// main() 是程序开始执行的地方</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们讲解一下上面这段程序：</p>
<blockquote>
<ul>
<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <iostream>。</iostream></li>
<li>下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>
<li>下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。</li>
<li>下一行 int main() 是主函数，程序从这里开始执行。</li>
<li>下一行 cout &lt;&lt; “Hello World”; 会在屏幕上显示消息 “Hello World”。</li>
<li>下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。</li>
</ul>
</blockquote>
<h3 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h3><p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。</p>
<h3 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h3><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。<strong>三字符序列总是以两个问号开头</strong>。</p>
<p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。<strong>以前为了表示键盘上没有的字符</strong>，这是必不可少的一种方法。三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p>
<p>g++仍默认支持三字符组，但会给出编译警告。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>bool</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
</tr>
<tr>
<td>浮点型</td>
<td>float</td>
</tr>
<tr>
<td>双浮点型</td>
<td>double</td>
</tr>
<tr>
<td>无类型</td>
<td>void</td>
</tr>
<tr>
<td>宽字符型</td>
<td>wchar_t</td>
</tr>
</tbody>
</table>
<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<blockquote>
<ul>
<li>true 值代表真。</li>
<li>false 值代表假。</li>
</ul>
</blockquote>
<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>
<h3 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h3><p>wchar_t为宽字符型    ，占2 或 4 个字节。其实 wchar_t 是这样来的：</p>
<blockquote>
<p>typedef short int wchar_t;</p>
</blockquote>
<p>所以 wchar_t 实际上的空间是和 short int 一样。</p>
<h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符提供了变量的额外信息。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>const</td>
<td>const 类型的对象在程序执行期间不能被修改改变。</td>
</tr>
<tr>
<td>volatile</td>
<td>修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td>
</tr>
<tr>
<td>restrict</td>
<td>由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
</tbody>
</table>
<h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<blockquote>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
</blockquote>
<p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<h3 id="mutable-存储类"><a href="#mutable-存储类" class="headerlink" title="mutable 存储类"></a>mutable 存储类</h3><p>mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>
<h3 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h3><p>使用 thread_local 说明符声明的变量<strong>仅可在它在其上创建的线程上访问</strong>。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
<p>thread_local 说明符可以与 static 或 extern 合并。</p>
<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>
<p>以下演示了可以被声明为 thread_local 的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread_local int x;  // 命名空间下的全局变量</span><br><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">    static thread_local std::string s; // 类的static成员变量</span><br><span class="line">&#125;;</span><br><span class="line">static thread_local std::string X::s;  // X::s 是需要定义的</span><br><span class="line"> </span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    thread_local std::vector&lt;int&gt; v;  // 本地变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</p>
<p>Cast：强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><p>当您定义一个函数，您<strong>可以为参数列表中后边的每一个参数指定默认值</strong>。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p>
<p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int sum(int a, int b=20)</span><br><span class="line">&#123;</span><br><span class="line">  int result;</span><br><span class="line"> </span><br><span class="line">  result = a + b;</span><br><span class="line">  </span><br><span class="line">  return (result);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   // 局部变量声明</span><br><span class="line">   int a = 100;</span><br><span class="line">   int b = 200;</span><br><span class="line">   int result;</span><br><span class="line"> </span><br><span class="line">   // 调用函数来添加值</span><br><span class="line">   result = sum(a, b);</span><br><span class="line">   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 再次调用函数</span><br><span class="line">   result = sum(a);</span><br><span class="line">   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Total value is :300</span><br><span class="line">Total value is :120</span><br></pre></td></tr></table></figure></p>
<h3 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h3><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>
<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>
<blockquote>
<p>[capture](parameters)-&gt;return-type{body}<br>[capture](parameters){body}</p>
</blockquote>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[](int x, int y)&#123; return x &lt; y ; &#125;</span><br><span class="line"></span><br><span class="line">[]&#123; ++global_x; &#125; </span><br><span class="line"></span><br><span class="line">[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p>
<p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p>
<blockquote>
<p>[]      // 沒有定义任何变量。使用未定义变量会引发错误。<br>[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。<br>[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。<br>[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。<br>[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。<br>[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</p>
</blockquote>
<p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p>
<blockquote>
<p>[this]() { this-&gt;someFunc(); }();</p>
</blockquote>
<h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h2><p>C++ 提供了以下两种类型的字符串表示形式：</p>
<blockquote>
<ul>
<li>C 风格字符串</li>
<li>C++ 引入的 string 类类型</li>
</ul>
</blockquote>
<p>C++ 标准库提供了 string 类类型，支持C 风格字符串所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   string str1 = &quot;Hello&quot;;</span><br><span class="line">   string str2 = &quot;World&quot;;</span><br><span class="line">   string str3;</span><br><span class="line">   int  len ;</span><br><span class="line"> </span><br><span class="line">   // 复制 str1 到 str3</span><br><span class="line">   str3 = str1;</span><br><span class="line">   cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 连接 str1 和 str2</span><br><span class="line">   str3 = str1 + str2;</span><br><span class="line">   cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 连接后，str3 的总长度</span><br><span class="line">   len = str3.size();</span><br><span class="line">   cout &lt;&lt; &quot;str3.size() :  &quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">str3 : Hello</span><br><span class="line">str1 + str2 : HelloWorld</span><br><span class="line">str3.size() :  10</span><br></pre></td></tr></table></figure></p>
<h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++ 引用"></a>C++ 引用</h2><p>引用变量是一个<strong>别名</strong>，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。引用通常用于函数参数列表和函数返回值。</p>
<h3 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h3><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<blockquote>
<ul>
<li><strong>不存在空引用</strong>。引用必须连接到一块合法的内存。</li>
<li><strong>一旦引用被初始化为一个对象，就不能被指向到另一个对象</strong>。指针可以在任何时候指向到另一个对象。</li>
<li><strong>引用必须在创建时被初始化</strong>。指针可以在任何时间被初始化。</li>
</ul>
</blockquote>
<h3 id="C-中创建引用"><a href="#C-中创建引用" class="headerlink" title="C++ 中创建引用"></a>C++ 中创建引用</h3><p>试想<strong>变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签</strong>。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>
<blockquote>
<p>int i = 17;</p>
</blockquote>
<p>我们可以为 i 声明引用变量，如下所示：</p>
<blockquote>
<p>int&amp;  r = i;<br>double&amp; s = d;</p>
</blockquote>
<p>在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   // 声明简单的变量</span><br><span class="line">   int    i;</span><br><span class="line">   double d;</span><br><span class="line"> </span><br><span class="line">   // 声明引用变量</span><br><span class="line">   int&amp;    r = i;</span><br><span class="line">   double&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = 5;</span><br><span class="line">   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = 11.7;</span><br><span class="line">   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of i : 5</span><br><span class="line">Value of i reference : 5</span><br><span class="line">Value of d : 11.7</span><br><span class="line">Value of d reference : 11.7</span><br></pre></td></tr></table></figure>
<h2 id="C-输入输出"><a href="#C-输入输出" class="headerlink" title="C++ 输入输出"></a>C++ 输入输出</h2><h3 id="I-O-库头文件"><a href="#I-O-库头文件" class="headerlink" title="I/O 库头文件"></a>I/O 库头文件</h3><p>下列的头文件在 C++ 编程中很重要：</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>函数和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;iostream></td>
<td>该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>
</tr>
<tr>
<td>&lt;iomanip></td>
<td>该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。</td>
</tr>
<tr>
<td>&lt;fstream></td>
<td>该文件为用户控制的文件处理声明服务。</td>
</tr>
</tbody>
</table>
<h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h3><p>预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char str[] = &quot;Hello C++&quot;;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。</p>
<p>cerr、clog类似。但良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>
<h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h3><p>预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char name[50];</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;请输入您的名称： &quot;;</span><br><span class="line">   cin &gt;&gt; name;</span><br><span class="line">   cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>
<blockquote>
<p>cin &gt;&gt; name &gt;&gt; age;</p>
</blockquote>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<blockquote>
<p>void open(const char *filename, ios::openmode mode);</p>
</blockquote>
<p>在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式:</p>
<p>模式标志     | 描述<br>| - | - |<br>ios::app     | 追加模式。所有写入都追加到文件末尾。<br>ios::ate     | 文件打开后定位到文件末尾。<br>ios::in     | 打开文件用于读取。<br>ios::out     | 打开文件用于写入。<br>ios::trunc     | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</p>
<p>您可以把以上两种或两种以上的模式结合使用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法</span><br><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc );</span><br><span class="line"></span><br><span class="line">//类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</span><br><span class="line">ifstream  afile;</span><br><span class="line">afile.open(&quot;file.dat&quot;, ios::out | ios::in );</span><br></pre></td></tr></table></figure></p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>
<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<blockquote>
<p>void close();</p>
</blockquote>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息或流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 、 fstream  或 ifstream 、 fstream 对象，而不是 cout 对象或 cin 对象。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   char data[100];</span><br><span class="line"> </span><br><span class="line">   // 以写模式打开文件</span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.open(&quot;afile.dat&quot;);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Enter your name: &quot;; </span><br><span class="line">   cin.getline(data, 100);</span><br><span class="line"> </span><br><span class="line">   // 向文件写入用户输入的数据</span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Enter your age: &quot;; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.ignore();</span><br><span class="line">   </span><br><span class="line">   // 再次向文件写入用户输入的数据</span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 关闭打开的文件</span><br><span class="line">   outfile.close();</span><br><span class="line"> </span><br><span class="line">   // 以读模式打开文件</span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.open(&quot;afile.dat&quot;); </span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line"> </span><br><span class="line">   // 在屏幕上写入数据</span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   // 再次从文件读取数据，并显示它</span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   // 关闭打开的文件</span><br><span class="line">   infile.close();</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列输入和输出：</span><br><span class="line">$./a.out</span><br><span class="line">Writing to the file</span><br><span class="line">Enter your name: Zara</span><br><span class="line">Enter your age: 9</span><br><span class="line">Reading from the file</span><br><span class="line">Zara</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p>
<h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><p>istream 和 ostream 都提供了用于<strong>重新定位文件位置指针</strong>的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span><br><span class="line">fileObject.seekg( n );</span><br><span class="line"> </span><br><span class="line">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::cur );</span><br><span class="line"> </span><br><span class="line">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::end );</span><br><span class="line"> </span><br><span class="line">// 定位到 fileObject 的末尾</span><br><span class="line">fileObject.seekg( 0, ios::end );</span><br></pre></td></tr></table></figure></p>
<h2 id="C-类和继承"><a href="#C-类和继承" class="headerlink" title="C++ 类和继承"></a>C++ 类和继承</h2><p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p>
<h3 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h3><p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<p>类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      double length;   // 盒子的长度</span><br><span class="line">      double breadth;  // 盒子的宽度</span><br><span class="line">      double height;   // 盒子的高度</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected。</p>
<h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。继承代表了 is a 关系。</p>
<p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<blockquote>
<p>class derived-class: access-specifier base-class</p>
</blockquote>
<p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<h3 id="继承类型access-specifier"><a href="#继承类型access-specifier" class="headerlink" title="继承类型access-specifier"></a>继承类型access-specifier</h3><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 protected 或 private 继承，<strong>通常使用 public 继承</strong>。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li>公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li>
<li>保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。</li>
<li>私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<blockquote>
<p>Box operator+(const Box&amp;);</p>
</blockquote>
<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>
<blockquote>
<p>Box operator+(const Box&amp;, const Box&amp;);</p>
</blockquote>
<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line"> </span><br><span class="line">      double getVolume(void)</span><br><span class="line">      &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">          length = len;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      void setBreadth( double bre )</span><br><span class="line">      &#123;</span><br><span class="line">          breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      void setHeight( double hei )</span><br><span class="line">      &#123;</span><br><span class="line">          height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      // 重载 + 运算符，用于把两个 Box 对象相加</span><br><span class="line">      Box operator+(const Box&amp; b)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box;</span><br><span class="line">         box.length = this-&gt;length + b.length;</span><br><span class="line">         box.breadth = this-&gt;breadth + b.breadth;</span><br><span class="line">         box.height = this-&gt;height + b.height;</span><br><span class="line">         return box;</span><br><span class="line">      &#125;</span><br><span class="line">   private:</span><br><span class="line">      double length;      // 长度</span><br><span class="line">      double breadth;     // 宽度</span><br><span class="line">      double height;      // 高度</span><br><span class="line">&#125;;</span><br><span class="line">// 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Box Box1;                // 声明 Box1，类型为 Box</span><br><span class="line">   Box Box2;                // 声明 Box2，类型为 Box</span><br><span class="line">   Box Box3;                // 声明 Box3，类型为 Box</span><br><span class="line">   double volume = 0.0;     // 把体积存储在该变量中</span><br><span class="line"> </span><br><span class="line">   // Box1 详述</span><br><span class="line">   Box1.setLength(6.0); </span><br><span class="line">   Box1.setBreadth(7.0); </span><br><span class="line">   Box1.setHeight(5.0);</span><br><span class="line"> </span><br><span class="line">   // Box2 详述</span><br><span class="line">   Box2.setLength(12.0); </span><br><span class="line">   Box2.setBreadth(13.0); </span><br><span class="line">   Box2.setHeight(10.0);</span><br><span class="line"> </span><br><span class="line">   // Box1 的体积</span><br><span class="line">   volume = Box1.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   // Box2 的体积</span><br><span class="line">   volume = Box2.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   // 把两个对象相加，得到 Box3</span><br><span class="line">   Box3 = Box1 + Box2;</span><br><span class="line"> </span><br><span class="line">   // Box3 的体积</span><br><span class="line">   volume = Box3.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Volume of Box1 : 210</span><br><span class="line">Volume of Box2 : 1560</span><br><span class="line">Volume of Box3 : 5400</span><br></pre></td></tr></table></figure></p>
<h3 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h3><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>双目算术运算符</td>
<td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td>
</tr>
<tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&#124;&#124;(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>&#124; (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)`</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=, &#124;=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td>()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标)</td>
</tr>
</tbody>
</table>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li>.：成员访问运算符</li>
<li>.<em>, -&gt;</em>：成员指针访问运算符</li>
<li>::：域运算符</li>
<li>sizeof：长度运算符</li>
<li>?:：条件运算符</li>
<li>#： 预处理符号</li>
</ul>
<h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++ 多态"></a>C++ 多态</h2><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      int area()</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Rectangle: public Shape&#123;</span><br><span class="line">   public:</span><br><span class="line">      Rectangle( int a=0, int b=0):Shape(a, b) &#123; &#125;</span><br><span class="line">      int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Triangle: public Shape&#123;</span><br><span class="line">   public:</span><br><span class="line">      Triangle( int a=0, int b=0):Shape(a, b) &#123; &#125;</span><br><span class="line">      int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         cout &lt;&lt; &quot;Triangle class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return (width * height / 2); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   Rectangle rec(10,7);</span><br><span class="line">   Triangle  tri(10,5);</span><br><span class="line"> </span><br><span class="line">   // 存储矩形的地址</span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   // 调用矩形的求面积函数 area</span><br><span class="line">   shape-&gt;area();</span><br><span class="line"> </span><br><span class="line">   // 存储三角形的地址</span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   // 调用三角形的求面积函数 area</span><br><span class="line">   shape-&gt;area();</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Parent class area</span><br><span class="line">Parent class area</span><br></pre></td></tr></table></figure>
<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态或静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>
<p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      virtual int area()</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">修改后，当编译和执行前面的实例代码时，它会产生以下结果：</span><br><span class="line">Rectangle class area</span><br><span class="line">Triangle class area</span><br></pre></td></tr></table></figure></p>
<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>
<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会<strong>告诉编译器不要静态链接到该函数</strong>。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接或后期绑定</strong>。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>
<p>我们可以把基类中的虚函数 area() 改写如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      // pure virtual function</span><br><span class="line">      virtual int area() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>= 0 告诉编译器，<strong>函数没有主体</strong>，上面的虚函数是纯虚函数。</p>
<h2 id="C-动态内存"><a href="#C-动态内存" class="headerlink" title="C++ 动态内存"></a>C++ 动态内存</h2><p>C++ 程序中的内存分为两个部分：</p>
<blockquote>
<ul>
<li>栈：在函数内部声明的所有变量都将占用栈内存。</li>
<li>堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
</blockquote>
<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>
<p>在 C++ 中，这种运算符即 new 运算符。如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。</p>
<h3 id="new-和-delete-运算符"><a href="#new-和-delete-运算符" class="headerlink" title="new 和 delete 运算符"></a>new 和 delete 运算符</h3><p>通用语法：</p>
<blockquote>
<p>new data-type;<br>delete member; </p>
</blockquote>
<p>在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double* pvalue  = NULL; // 初始化为 null 的指针</span><br><span class="line">pvalue  = new double;   // 为变量请求内存</span><br></pre></td></tr></table></figure></p>
<p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double* pvalue  = NULL;</span><br><span class="line">if( !(pvalue  = new double ))</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;Error: out of memory.&quot; &lt;&lt;endl;</span><br><span class="line">   exit(1);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pvalue = 29494.99;     // 在分配的地址存储值</span><br><span class="line">cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">delete pvalue;        // 释放 pvalue 所指向的内存</span><br></pre></td></tr></table></figure></p>
<p>malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p>
<h2 id="C-命名空间"><a href="#C-命名空间" class="headerlink" title="C++ 命名空间"></a>C++ 命名空间</h2><p>命名空间可作为附加信息来<strong>区分不同库中相同名称的函数、类、变量等</strong>。使用了命名空间即定义了<strong>上下文</strong>。本质上，命名空间就是定义了一个范围。</p>
<h3 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h3><p>命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示：</p>
<blockquote>
<p>namespace namespace_name {<br>   // 代码声明<br>}</p>
</blockquote>
<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p>
<blockquote>
<p>name::code;  // code 可以是变量或函数</p>
</blockquote>
<p>让我们来看看命名空间如何为变量或函数等实体定义范围：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 第一个命名空间</span><br><span class="line">namespace first_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二个命名空间</span><br><span class="line">namespace second_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   // 调用第一个命名空间中的函数</span><br><span class="line">   first_space::func();</span><br><span class="line">   </span><br><span class="line">   // 调用第二个命名空间中的函数</span><br><span class="line">   second_space::func(); </span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Inside first_space</span><br><span class="line">Inside second_space</span><br></pre></td></tr></table></figure></p>
<h3 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h3><p>您可以使用 using namespace 指令，这样在使用命名空间时就<strong>可以不用在前面加上命名空间的名称</strong>。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 第一个命名空间</span><br><span class="line">namespace first_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二个命名空间</span><br><span class="line">namespace second_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">using namespace first_space;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   // 调用第一个命名空间中的函数</span><br><span class="line">   func();</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Inside first_space</span><br></pre></td></tr></table></figure></p>
<p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p>
<blockquote>
<p>using std::cout;</p>
</blockquote>
<p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;std::endl is used with std!&quot; &lt;&lt; std::endl;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">std::endl is used with std!</span><br></pre></td></tr></table></figure></p>
<p>using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p>
<h3 id="不连续的命名空间"><a href="#不连续的命名空间" class="headerlink" title="不连续的命名空间"></a>不连续的命名空间</h3><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。<strong>一个命名空间的各个组成部分可以分散在多个文件中</strong>。</p>
<p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素。</p>
<h3 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h3><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name1 &#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">   namespace namespace_name2 &#123;</span><br><span class="line">      // 代码声明</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 访问 namespace_name2 中的成员</span><br><span class="line">using namespace namespace_name1::namespace_name2;</span><br><span class="line"> </span><br><span class="line">// 访问 namespace:name1 中的成员</span><br><span class="line">using namespace namespace_name1;</span><br></pre></td></tr></table></figure></p>
<p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的</p>
<h2 id="C-模板"><a href="#C-模板" class="headerlink" title="C++ 模板"></a>C++ 模板</h2><p>模板是<strong>泛型</strong>编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>模板函数定义的一般形式如下所示：</p>
<blockquote>
<p>template <class type> ret-type func-name(parameter list)<br>{<br>   // 函数的主体<br>}</class></p>
</blockquote>
<p>在这里，<strong>type 是函数所使用的数据类型的占位符名称</strong>。这个名称可以在函数定义中使用。</p>
<p>下面是函数模板的实例，返回两个数中的最大值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline T const&amp; Max (T const&amp; a, T const&amp; b) </span><br><span class="line">&#123; </span><br><span class="line">    return a &lt; b ? b:a; </span><br><span class="line">&#125; </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    int i = 39;</span><br><span class="line">    int j = 20;</span><br><span class="line">    cout &lt;&lt; &quot;Max(i, j): &quot; &lt;&lt; Max(i, j) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    double f1 = 13.5; </span><br><span class="line">    double f2 = 20.7; </span><br><span class="line">    cout &lt;&lt; &quot;Max(f1, f2): &quot; &lt;&lt; Max(f1, f2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    string s1 = &quot;Hello&quot;; </span><br><span class="line">    string s2 = &quot;World&quot;; </span><br><span class="line">    cout &lt;&lt; &quot;Max(s1, s2): &quot; &lt;&lt; Max(s1, s2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p>
<blockquote>
<p>template <class type> class class-name {<br>.<br>.<br>.<br>}</class></p>
</blockquote>
<p>在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您<strong>可以使用一个逗号分隔的列表来定义多个泛型数据类型</strong>。</p>
<p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Stack &#123; </span><br><span class="line">  private: </span><br><span class="line">    vector&lt;T&gt; elems;     // 元素 </span><br><span class="line"> </span><br><span class="line">  public: </span><br><span class="line">    void push(T const&amp;);  // 入栈</span><br><span class="line">    void pop();               // 出栈</span><br><span class="line">    T top() const;            // 返回栈顶元素</span><br><span class="line">    bool empty() const&#123;       // 如果为空则返回真。</span><br><span class="line">        return elems.empty(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Stack&lt;T&gt;::push (T const&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    // 追加传入元素的副本</span><br><span class="line">    elems.push_back(elem);    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Stack&lt;T&gt;::pop () </span><br><span class="line">&#123; </span><br><span class="line">    if (elems.empty()) &#123; </span><br><span class="line">        throw out_of_range(&quot;Stack&lt;&gt;::pop(): empty stack&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 删除最后一个元素</span><br><span class="line">    elems.pop_back();         </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T Stack&lt;T&gt;::top () const </span><br><span class="line">&#123; </span><br><span class="line">    if (elems.empty()) &#123; </span><br><span class="line">        throw out_of_range(&quot;Stack&lt;&gt;::top(): empty stack&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 返回最后一个元素的副本 </span><br><span class="line">    return elems.back();      </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        Stack&lt;int&gt;         intStack;  // int 类型的栈 </span><br><span class="line">        Stack&lt;string&gt; stringStack;    // string 类型的栈 </span><br><span class="line"> </span><br><span class="line">        // 操作 int 类型的栈 </span><br><span class="line">        intStack.push(7); </span><br><span class="line">        cout &lt;&lt; intStack.top() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        // 操作 string 类型的栈 </span><br><span class="line">        stringStack.push(&quot;hello&quot;); </span><br><span class="line">        cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.pop(); </span><br><span class="line">        stringStack.pop(); </span><br><span class="line">    &#125; </span><br><span class="line">    catch (exception const&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; ex.what() &lt;&lt;endl; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">7</span><br><span class="line">hello</span><br><span class="line">Exception: Stack&lt;&gt;::pop(): empty stack</span><br></pre></td></tr></table></figure></p>
<h2 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h2><p># 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌<strong>转换</strong>为用引号引起来的字符串。</p>
<p>请看下面的宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define MKSTR( x ) #x</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">HELLO C++</span><br></pre></td></tr></table></figure>
<p>## 运算符用于连接两个令牌。下面是一个实例：</p>
<blockquote>
<p>#define CONCAT( x, y )  x ## y</p>
</blockquote>
<p>当 CONCAT 出现在程序中时，它的参数会被<strong>连接</strong>起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define concat(a, b) a ## b</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int xy = 100;</span><br><span class="line">   </span><br><span class="line">   cout &lt;&lt; concat(x, y);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h2 id="C-友元"><a href="#C-友元" class="headerlink" title="C++ 友元"></a>C++ 友元</h2><p>友元机制<strong>允许一个类将对其非公有成员的访问权授予指定的函数或者类</strong>，友元的声明以friend开始，它只能出现在类定义的内部，友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受其声明出现部分的访问控制影响。通常，将友元声明成组地放在类定义的开始或结尾是个好主意。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数是指某些虽然不是类成员函数却能够访问类的所有成员的函数。类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend void set_show(int x, A &amp;a);      //该函数是友元函数的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void set_show(int x, A &amp;a)  //友元函数定义，为了访问类A中的成员</span><br><span class="line">&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line"></span><br><span class="line">    set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。</p>
<p>关于友元类的注意事项：<br>(1) 友元关系不能被继承。<br>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。<br>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend class C;                         //这是友元类的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C             //友元类定义，为了访问类A中的成员</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void set_show(int x, A &amp;a) &#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line">    class C c;</span><br><span class="line"></span><br><span class="line">    c.set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h3><p>使类B中的成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员了。</p>
<p>当用到友元成员函数时，需注意友元声明和友元定义之间的相互依赖，在该例子中，类B必须先定义，否则类A就不能将一个B的函数指定为友元。然而，只有在定义了类A之后，才能定义类B的该成员函数。更一般的讲，必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A;    //当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。这是类A的声明</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void set_show(int x, A &amp;a);             //该函数是类A的友元函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend void B::set_show(int x, A &amp;a);   //该函数是友元成员函数的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">    void show() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void B::set_show(int x, A &amp;a)       //只有在定义类A后才能定义该函数，毕竟，它被设为友元是为了访问类A的成员</span><br><span class="line">&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line">    class B b;</span><br><span class="line"></span><br><span class="line">    b.set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-信号处理"><a href="#C-信号处理" class="headerlink" title="C++ 信号处理"></a>C++ 信号处理</h2><p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。</p>
<p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。</csignal></p>
<table>
<thead>
<tr>
<th>信号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>程序的异常终止，如调用 abort。</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>错误的算术运算，比如除以零或导致溢出的操作。</td>
</tr>
<tr>
<td>SIGILL</td>
<td>检测非法指令。</td>
</tr>
<tr>
<td>SIGINT</td>
<td>接收到交互注意信号。</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>非法访问内存。</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>发送到程序的终止请求。</td>
</tr>
</tbody>
</table>
<h3 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal() 函数"></a>signal() 函数</h3><p>C++ 信号处理库提供了 signal 函数，用来<strong>捕获突发事件</strong>。以下是 signal() 函数的语法：</p>
<blockquote>
<p>void (*signal (int sig, void (*func)(int)))(int); </p>
</blockquote>
<p>这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;csignal&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void signalHandler( int signum )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\n&quot;;</span><br><span class="line"> </span><br><span class="line">    // 清理并关闭</span><br><span class="line">    // 终止程序  </span><br><span class="line"> </span><br><span class="line">   exit(signum);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    // 注册信号 SIGINT 和信号处理程序</span><br><span class="line">    signal(SIGINT, signalHandler);  </span><br><span class="line"> </span><br><span class="line">    while(1)&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;</span><br><span class="line">       sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line"></span><br><span class="line">现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure>
<h3 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise() 函数"></a>raise() 函数</h3><p>您可以使用函数 raise() <strong>生成信号</strong>，该函数带有一个整数信号编号作为参数，语法如下：</p>
<blockquote>
<p>int raise (signal sig);</p>
</blockquote>
<p>在这里，sig 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;csignal&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void signalHandler( int signum )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\n&quot;;</span><br><span class="line"> </span><br><span class="line">    // 清理并关闭</span><br><span class="line">    // 终止程序 </span><br><span class="line"> </span><br><span class="line">   exit(signum);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    // 注册信号 SIGINT 和信号处理程序</span><br><span class="line">    signal(SIGINT, signalHandler);  </span><br><span class="line"> </span><br><span class="line">    while(++i)&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;</span><br><span class="line">       if( i == 3 )&#123;</span><br><span class="line">          raise( SIGINT);</span><br><span class="line">       &#125;</span><br><span class="line">       sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure></p>
<h2 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++ 多线程"></a>C++ 多线程</h2><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。</p>
<h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>pthread_t：线程ID<br>pthread_attr_t：线程属性</p>
<ol>
<li><p>操纵函数<br>pthread_create()：创建一个线程<br>pthread_exit()：终止当前线程<br>pthread_cancel()：中断另外一个线程的运行，Android中没有<br>pthread_join()：阻塞当前的线程，直到另外一个线程运行结束<br>pthread_attr_init()：初始化线程的属性<br>pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）<br>pthread_attr_getdetachstate()：获取脱离状态的属性<br>pthread_attr_destroy()：删除线程的属性<br>pthread_kill()：向线程发送一个信号</p>
</li>
<li><p>同步函数<br>pthread_mutex_init() 初始化互斥锁<br>pthread_mutex_destroy() 删除互斥锁<br>pthread_mutex_lock()：占有互斥锁（阻塞操作）<br>pthread_mutex_trylock()：试图占有互斥锁（不阻塞操作）。即，当互斥锁空闲时，将占有该锁；否则，立即返回。<br>pthread_mutex_unlock(): 释放互斥锁<br>pthread_cond_init()：初始化条件变量<br>pthread_cond_destroy()：销毁条件变量<br>pthread_cond_signal(): 唤醒第一个调用pthread_cond_wait()而进入睡眠的线程<br>pthread_cond_wait(): 等待条件变量的特殊条件发生<br>Thread-local storage（或者以Pthreads术语，称作线程特有数据）：<br>pthread_key_create(): 分配用于标识进程中线程特定数据的键<br>pthread_setspecific(): 为指定线程特定数据键设置线程特定绑定<br>pthread_getspecific(): 获取调用线程的键绑定，并将该绑定存储在 value 指向的位置中<br>pthread_key_delete(): 销毁现有线程特定数据键<br>pthread_attr_getschedparam();获取线程优先级<br>pthread_attr_setschedparam();设置线程优先级</p>
</li>
<li><p>工具函数<br>pthread_equal(): 对两个线程的线程标识号进行比较<br>pthread_detach(): 分离线程<br>pthread_self(): 查询线程自身线程标识号</p>
</li>
</ol>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>
<blockquote>
<p>#include &lt;pthread.h&gt;<br>pthread_create (thread, attr, start_routine, arg) </p>
</blockquote>
<p>在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>thread</td>
<td>指向线程标识符指针。</td>
</tr>
<tr>
<td>attr</td>
<td>一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>
</tr>
<tr>
<td>start_routine</td>
<td>线程运行函数起始地址，一旦线程被创建就会执行。</td>
</tr>
<tr>
<td>arg</td>
<td>运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>
</tr>
</tbody>
</table>
<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>
<blockquote>
<p>#include &lt;pthread.h&gt;<br>pthread_exit (status) </p>
</blockquote>
<p>在这里，pthread_exit 用于显式地退出一个线程。通常情况下，<strong>pthread_exit() 函数是在线程完成工作后无需继续存在时被调用</strong>。</p>
<p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS     5</span><br><span class="line"> </span><br><span class="line">struct thread_data&#123;</span><br><span class="line">   int  thread_id;</span><br><span class="line">   char *message;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void *PrintHello(void *threadarg)</span><br><span class="line">&#123;</span><br><span class="line">   struct thread_data *my_data;</span><br><span class="line"> </span><br><span class="line">   my_data = (struct thread_data *) threadarg;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Thread ID : &quot; &lt;&lt; my_data-&gt;thread_id ;</span><br><span class="line">   cout &lt;&lt; &quot; Message : &quot; &lt;&lt; my_data-&gt;message &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   pthread_t threads[NUM_THREADS];</span><br><span class="line">   struct thread_data td[NUM_THREADS];</span><br><span class="line">   int rc;</span><br><span class="line">   int i;</span><br><span class="line"> </span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt;&quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      td[i].thread_id = i;</span><br><span class="line">      td[i].message = (char*)&quot;This is message&quot;;</span><br><span class="line">      rc = pthread_create(&amp;threads[i], NULL,</span><br><span class="line">                          PrintHello, (void *)&amp;td[i]);</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Wno-write-strings test.cpp -lpthread -o test.o</span><br><span class="line">$ ./test.o</span><br><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">Thread ID : 0 Message : This is message</span><br><span class="line">main() : creating thread, Thread ID : 21</span><br><span class="line"> Message : This is message</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">Thread ID : 2 Message : This is message</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Thread ID : 3 Message : This is message</span><br><span class="line">Thread ID : 4 Message : This is message</span><br></pre></td></tr></table></figure></p>
<h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><p>我们可以使用以下两个函数来连接或分离线程：</p>
<blockquote>
<p>pthread_join (threadid, status)<br>pthread_detach (threadid) </p>
</blockquote>
<p><strong>pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止</strong>。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p>
<p>一个线程默认的状态是joinable，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符。只有当你<strong>调用了pthread_join之后这些资源才会被释放</strong>。</p>
<p>这个实例演示了如何使用 pthread_join() 函数来等待线程的完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS     5</span><br><span class="line"> </span><br><span class="line">void *wait(void *t)</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   long tid;</span><br><span class="line"> </span><br><span class="line">   tid = (long)t;</span><br><span class="line"> </span><br><span class="line">   sleep(1);</span><br><span class="line">   cout &lt;&lt; &quot;Sleeping in thread &quot; &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Thread with id : &quot; &lt;&lt; tid &lt;&lt; &quot;  ...exiting &quot; &lt;&lt; endl;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int rc;</span><br><span class="line">   int i;</span><br><span class="line">   pthread_t threads[NUM_THREADS];</span><br><span class="line">   pthread_attr_t attr;</span><br><span class="line">   void *status;</span><br><span class="line"> </span><br><span class="line">   // 初始化并设置线程为可连接的（joinable）</span><br><span class="line">   pthread_attr_init(&amp;attr);</span><br><span class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"> </span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt; &quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      rc = pthread_create(&amp;threads[i], NULL, wait, (void *)&amp;i );</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // 删除属性，并等待其他线程</span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = pthread_join(threads[i], &amp;status);</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to join,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; &quot;Main: completed thread id :&quot; &lt;&lt; i ;</span><br><span class="line">      cout &lt;&lt; &quot;  exiting with status :&quot; &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Main: program exiting.&quot; &lt;&lt; endl;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">main() : creating thread, 2</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 4  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 3  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 2  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 1  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Main: completed thread id :0  exiting with status :0</span><br><span class="line">Main: completed thread id :1  exiting with status :0</span><br><span class="line">Main: completed thread id :2  exiting with status :0</span><br><span class="line">Main: completed thread id :3  exiting with status :0</span><br><span class="line">Main: completed thread id :4  exiting with status :0</span><br><span class="line">Main: program exiting.</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-tutorial.html</a><br><a href="https://www.jianshu.com/p/34d88df0cfe0" target="_blank" rel="noopener">https://www.jianshu.com/p/34d88df0cfe0</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/03/android-ndk-jni-invoke/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/03/android-ndk-jni-invoke/" itemprop="url">JNI 的调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-03T13:19:25+08:00">
                2020-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-NDK/" itemprop="url" rel="index">
                    <span itemprop="name">Android NDK</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="注册native函数"><a href="#注册native函数" class="headerlink" title="注册native函数"></a>注册native函数</h2><p>JNI有两种注册native方法的途径：</p>
<blockquote>
<ul>
<li>静态注册：<br>先由Java得到本地方法的声明，然后再通过JNI实现该声明方法</li>
<li>动态注册：<br>先通过JNI重载JNI_OnLoad()实现本地方法，然后直接在Java中调用本地方法。</li>
</ul>
</blockquote>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册就是根据函数名来遍历Java和JNI函数之间的关联，而且要求JNI层函数的名字必须遵循特定的格式。具体的实现很简单，首先在Java代码中声明native函数，然后通过javah来生成native函数的具体形式，接下来在JNI代码中实现这些函数即可。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class JniDemo1&#123;</span><br><span class="line">       static &#123;</span><br><span class="line">             System.loadLibrary(&quot;samplelib_jni&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private native void nativeMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接来下通过javah来产生jni代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -d ./jni/ -classpath /Users/YOUR_NAME/Library/Android/sdk/platforms/android-21/android.jar:../../build/intermediates/classes/debug/ com.xxxpackagename.JniDemo1</span><br></pre></td></tr></table></figure></p>
<p>然后就会得到一个JNI的.h文件，里面包含这几个native函数的声明，观察一下文件名以及函数名。JNI方法名的规范：</p>
<blockquote>
<p>返回值 + Java前缀+全路径类名+方法名+参数1JNIEnv+参数2jobject+其他参数</p>
</blockquote>
<p>注意事项：</p>
<blockquote>
<ul>
<li>注意分隔符：<br>Java前缀与类名以及类名之间的包名和方法名之间使用”_”进行分割；</li>
<li>注意静态：<br>如果在Java中声明的方法是”静态的”，则native方法也是static。否则不是。</li>
</ul>
</blockquote>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册，也就是通过RegisterNatives方法把C/C++中的方法映射到Java中的native方法，而无需遵循特定的方法命名格式。</p>
<p>当我们使用System.loadLibarary()方法加载so库的时候，Java虚拟机就会找到这个<strong>JNI_OnLoad</strong>函数并调用该函数，<strong>这个函数的作用是告诉Dalvik虚拟机此C库使用的是哪一个JNI版本</strong>，如果你的库里面没有写明JNI_OnLoad()函数，VM会默认该库使用最老的JNI 1.1版本。由于最新版本的JNI做了很多扩充，也优化了一些内容，如果需要使用JNI新版本的功能，就必须在JNI_OnLoad()函数声明JNI的版本，同时也可以在该函数中做一些初始化的动作。该函数前面也有三个关键字分别是JNIEXPORT，JNICALL ，jint。其中JNIEXPORT和JNICALL是两个宏定义，用于指定该函数时JNI函数。jint是JNI定义的数据类型，因为Java层和C/C++的数据类型或者对象不能直接相互的引用或者使用，JNI层定义了自己的数据类型，用于衔接Java层和JNI层。与JNI_OnLoad()函数相对应的有JNI_OnUnload()函数，当虚拟机释放的该C库的时候，则会调用JNI_OnUnload()函数来进行善后清除工作。</p>
<p>该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义一下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DestroyJavaVM</span><br><span class="line">AttachCurrentThread</span><br><span class="line">DetachCurrentThread</span><br><span class="line">GetEnv</span><br></pre></td></tr></table></figure></p>
<p>举例说明，首先是加载so库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class JniDemo1&#123;</span><br><span class="line">       static &#123;</span><br><span class="line">             System.loadLibrary(&quot;samplelib_jni&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在jni中的实现，并且在这个函数里面去动态的注册native方法，完整的参考代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &quot;Log4Android.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static const char *className = &quot;com/gebilaolitou/jnidemo/JNIDemo2&quot;;</span><br><span class="line"></span><br><span class="line">static void sayHello(JNIEnv *env, jobject, jlong handle) &#123;</span><br><span class="line">    LOGI(&quot;JNI&quot;, &quot;native: say hello ###&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static JNINativeMethod gJni_Methods_table[] = &#123;</span><br><span class="line">    &#123;&quot;sayHello&quot;, &quot;(J)V&quot;, (void*)sayHello&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int jniRegisterNativeMethods(JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;JNI&quot;,&quot;Registering %s natives\n&quot;, className);</span><br><span class="line">    clazz = (env)-&gt;FindClass( className);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;Native registration unable to find class &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    if ((env)-&gt;RegisterNatives(clazz, gJni_Methods_table, numMethods) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;RegisterNatives failed for &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (env)-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jint JNI_OnLoad(JavaVM* vm, void* reserved)&#123;</span><br><span class="line">    LOGI(&quot;JNI&quot;, &quot;enter jni_onload&quot;);</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = NULL;</span><br><span class="line">    jint result = -1;</span><br><span class="line"></span><br><span class="line">    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jniRegisterNativeMethods(env, className, gJni_Methods_table, sizeof(gJni_Methods_table) / sizeof(JNINativeMethod));</span><br><span class="line"></span><br><span class="line">    return JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>我们一个个来说，首先看JNI_OnLoad函数的实现，里面代码很简单，主要就是两个代码块，一个是if语句，一个是jniRegisterNativeMethods函数的实现。那我们一个一个来分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">    return result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了GetEnv函数时为了<strong>获取JNIEnv结构体指针</strong>，其实JNIEnv结构体指向了一个函数表，该函数表指向了对应的JNI函数，我们通过这些JNI函数实现JNI编程。</p>
<p>然后就调用了jniRegisterNativeMethods函数来实现注册，这里面注意一个静态变量gJni_Methods_table。它其实代表了一个native方法的数组，如果你在一个Java类中有一个native方法，这里它的size就是1，如果是两个native方法，它的size就是2，大家看下这个gJni_Methods_table变量的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod gJni_Methods_table[] = &#123;</span><br><span class="line">    &#123;&quot;sayHello&quot;, &quot;(J)V&quot;, (void*)sayHello&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们看到他的类型是JNINativeMethod ，那我们就来研究下JNINativeMethod</p>
<p>JNI允许我们提供一个<strong>函数映射表</strong>，注册给Java虚拟机，这样JVM就可以用函数映射表来调用相应的函数。这样就可以不必通过函数名来查找需要调用的函数了。Java与JNI通过JNINativeMethod的结构来建立联系，它被定义在jni.h中，其结构内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123; </span><br><span class="line">    const char* name; </span><br><span class="line">    const char* signature; </span><br><span class="line">    void* fnPtr; </span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure></p>
<p>这里面有3个变量，那我们就依次来讲解下：<br>第一个变量name，代表的是Java中的函数名<br>第二个变量signature，代表的是Java中的参数和返回值<br>第三个变量fnPtr，代表的是的指向C函数的函数指针</p>
<p>下面我们再来看下jniRegisterNativeMethods函数内部的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int jniRegisterNativeMethods(JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;JNI&quot;,&quot;Registering %s natives\n&quot;, className);</span><br><span class="line">    clazz = (env)-&gt;FindClass( className);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;Native registration unable to find class &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    if ((env)-&gt;RegisterNatives(clazz, gJni_Methods_table, numMethods) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;RegisterNatives failed for &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (env)-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过clazz = (env)-&gt;FindClass( className);找到声明native方法的类<br>然后通过调用<strong>RegisterNatives</strong>函数将注册函数的Java类，以及注册函数的数组，以及个数注册在一起，这样就实现了绑定。</p>
<p>上面在讲解JNINativeMethod结构体的时候，提到一个概念，就是”signature”即签名，我们下面就来讲解下。</p>
<h2 id="JNI中的签名"><a href="#JNI中的签名" class="headerlink" title="JNI中的签名"></a>JNI中的签名</h2><p>Java是支持函数重载的。但如果JNI仅仅是根据函数名，是没有办法找到重载的函数的，所以为了解决这个问题，JNI就衍生了一个概念——“签名”，即<strong>参数类型和返回值类型的组合</strong>。如果拥有一个该函数的签名信息和这个函数的函数名，我们就可以顺序的找到对应的Java层中的函数了。</p>
<h3 id="查看类中的方法的签名"><a href="#查看类中的方法的签名" class="headerlink" title="查看类中的方法的签名"></a>查看类中的方法的签名</h3><p>可以使用 java -p命令(建议使用该命令来对比签名)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">javap -s -p MainActivity.class</span><br><span class="line"></span><br><span class="line">Compiled from &quot;MainActivity.java&quot;</span><br><span class="line">public class com.example.hellojni.MainActivity extends android.app.Activity &#123;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Signature: ()V</span><br><span class="line"></span><br><span class="line">  public com.example.hellojni.MainActivity();</span><br><span class="line">    Signature: ()V</span><br><span class="line"></span><br><span class="line">  protected void onCreate(android.os.Bundle);</span><br><span class="line">    Signature: (Landroid/os/Bundle;)V</span><br><span class="line"></span><br><span class="line">  public boolean onCreateOptionsMenu(android.view.Menu);</span><br><span class="line">    Signature: (Landroid/view/Menu;)Z</span><br><span class="line"></span><br><span class="line">  public native java.lang.String stringFromJNI(); //native 方法</span><br><span class="line">    Signature: ()Ljava/lang/String;  //签名</span><br><span class="line"></span><br><span class="line">  public native int max(int, int); //native 方法</span><br><span class="line">    Signature: (II)I    //签名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到上面有()V ，(Landroid/os/Bundle;)V，(Landroid/view/Menu;)Z，(II)I我们一脸懵逼，这是什么鬼，所以我们要来研究下签名的格式</p>
<h3 id="JNI定义的函数签名信息"><a href="#JNI定义的函数签名信息" class="headerlink" title="JNI定义的函数签名信息"></a>JNI定义的函数签名信息</h3><blockquote>
<p>(参数1类型标示；参数2类型标示；参数3类型标示…)返回值类型标示</p>
</blockquote>
<p>当参数为引用类型的时候，参数类型的标示的根式为”L包名”，其中包名的.(点)要换成”/“，看我上面的例子就差不多，比如String就是Ljava/lang/String，Menu为Landroid/view/Menu。</p>
<p>如果是基本类类型，其签名如下：</p>
<table>
<thead>
<tr>
<th>类型标示</th>
<th>Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
</tr>
</tbody>
</table>
<p>除了boolean和long，其他都是首字母大写。如果返回值是void，对应的签名是<strong>V</strong>。</p>
<p>这里重点说1个特殊的类型，一个是数组及Array:</p>
<table>
<thead>
<tr>
<th>类型标示</th>
<th>Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>[签名</td>
<td>数组</td>
</tr>
<tr>
<td>[i</td>
<td>int[]</td>
</tr>
<tr>
<td>[Ljava/lang/Object</td>
<td>String[]</td>
</tr>
</tbody>
</table>
<h2 id="Native调用Java代码"><a href="#Native调用Java代码" class="headerlink" title="Native调用Java代码"></a>Native调用Java代码</h2><p>上面讲解了如何从JNI中调用Java类中的方法，其实在jni.h中已经定义了一系列函数来实现这一目的，下面我们就以此举例说明：</p>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>为了能够在C/C++中调用Java中的类，jni.h的头文件专门定义了jclass类型表示Java中Class类。JNIEnv中有3个函数可以获取jclass。</p>
<blockquote>
<ul>
<li>jclass FindClass(const char* clsName)：<br>通过类的名称来获取jclass。</li>
<li>jclass GetObjectClass(jobject obj)：<br>通过对象实例来获取jclass，相当于Java中的getClass()函数</li>
<li>jclass getSuperClass(jclass obj)：<br>通过jclass可以获取其父类的jclass对象</li>
</ul>
</blockquote>
<p>通过类的名称获取jclass(类的全名，这时候包名不是用’”.”点号而是用”/“来区分的)。比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取Java中的String对象的class对象</span><br><span class="line">jclass jcl_string=env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br></pre></td></tr></table></figure></p>
<h3 id="获取属性方法"><a href="#获取属性方法" class="headerlink" title="获取属性方法"></a>获取属性方法</h3><p>为了在C/C++获取Java层的属性和方法，JNI在jni.h头文件中定义了jfieldID和jmethodID这两种类型来分别代表Java端的属性和方法。</p>
<p>常见的调用Java层的方法如下，一般是使用JNIEnv来进行操作：</p>
<blockquote>
<p>GetFieldID/GetMethodID：获取某个属性/某个方法<br>GetStaticFieldID/GetStaticMethodID：获取某个静态属性/静态方法</p>
</blockquote>
<p>方法的具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jfieldID GetFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jfieldID GetStaticFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jmethodID GetStaticMethodID(JNIEnv *env, jclass clazz,const char *name, const char *sig);</span><br></pre></td></tr></table></figure></p>
<p>他们都是4个入参，并且都一样。JNIEnv代表一个JNI环境接口，jclass上面也说了代表Java层中的”类”，name则代表方法名或者属性名，那最后一个char *sig代表签名。</p>
<h3 id="构造一个对象"><a href="#构造一个对象" class="headerlink" title="构造一个对象"></a>构造一个对象</h3><p>常用的JNI中创建对象的方法如下：</p>
<blockquote>
<p>jobject NewObject(jclass clazz, jmethodID methodID, …)</p>
</blockquote>
<p>比如有我们知道Java类中可能有多个构造函数，当我们要指定调用某个构造函数的时候，会调用下面这个方法，即把指定的构造函数传入进去即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">obj = (*env)-&gt;NewObject(env, cls, mid);</span><br></pre></td></tr></table></figure></p>
<p>现在我们来看下他上面的二个主要参数</p>
<blockquote>
<p>clazz：是需要创建的Java对象的Class对象<br>methodID：是传递一个方法ID，想一想Java对象创建的时候，需要执行什么操作？就是执行构造函数。</p>
</blockquote>
<p>有人会说这要走两行代码，有没有一行代码的，是有的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobject NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);</span><br></pre></td></tr></table></figure></p>
<p>这里多了一个参数，即jvalue *args，这里是args代表的是对应构造函数的所有参数的，我们可以应将传递给构造函数的所有参数放在jvalues类型的数组args中，该数组紧跟着放在methodID参数的后面。NewObject()收到数组中的这些参数后，将把它们传给所要调用的Java方法。</p>
<p>上面说到，参数是个数组，如果参数不是数组怎么处理，jni.h同样也提供了一个方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobject NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);</span><br></pre></td></tr></table></figure></p>
<p>这个方法和上面不同在于，这里将构造函数的所有参数放到在va_list类型的参数args中，该参数紧跟着放在methodID参数的后面。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>JNI获取类的成员变量的ID调用GetFieldID获取，通过Set[类型]Field修改变量值。</li>
<li>JNI获取类的静态变量的ID调用GetStaticFieldID获取，通过SetStatic[类型]Field修改变量值。</li>
<li>JNI获取类的方法的ID调用GetMethodID获取，通过Call[类型]Method调用方法。</li>
<li>JNI获取类的静态方法的ID调用GetStaticMethodID获取，通过CallStatic[类型]Method调用方法。</li>
<li>JNI获取类的构造方法的ID调用GetMethodID获取，通过NewObject构造，构造函数名为”<init>“。</init></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/b71aeb4ed13d" target="_blank" rel="noopener">https://www.jianshu.com/p/b71aeb4ed13d</a><br><a href="https://www.jianshu.com/p/0f34c097028a" target="_blank" rel="noopener">JNI学习Demo</a><br><a href="https://www.jianshu.com/p/83f3ec4f3ac1" target="_blank" rel="noopener">JNI访问Java变量和方法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Shuming Zhao">
            
              <p class="site-author-name" itemprop="name">Shuming Zhao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuming Zhao</span>

  
</div>

<div class="powered-by"><i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人，
<span id="busuanzi_container_site_pv">访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
</span>
</div>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
