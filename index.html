<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="1ilOhMWnNE">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/07/android-plugin-virtualApp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/07/android-plugin-virtualApp/" itemprop="url">VirtualApp沙盒基本原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-07T13:41:44+08:00">
                2020-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android插件化/" itemprop="url" rel="index">
                    <span itemprop="name">Android插件化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>VirtualApp是一款运行于Android系统的沙盒产品，可以理解为轻量级的“Android虚拟机”。是一个开源的Android App虚拟化引擎，允许在其中创建虚拟空间，并在这个虚拟空间中运行其他应用。</p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>Android应用隔离是基于Linux系统的多用户机制实现的，即每个应用在安装时被分配了不同的Linux用户uid/gid。而在VirtualApp中，client应用（通过VirtualApp安装的应用）与host应用（即VirtualApp本身）是<strong>具有相同用户uid</strong>的。</p>
<p>因此，VirtualApp在运行时，包含以下三部分：</p>
<ul>
<li>Main Process，进程名io.virtualapp，主要负责VirtualApp用户界面及应用管理</li>
<li>Server Process，进程名io.virtualapp:x，主要负责系统服务的代理，是通过Content Provider启动的</li>
<li>VApp Process，进程名io.virtualapp:p[0-…]，作为将来运行client应用的进程，当client应用启动后，其进程名会更新为client应用的包名</li>
</ul>
<p>下面是在VirtualApp中运行应用后通过ps命令得到的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generic_x86:/ $ ps |grep u0_a60</span><br><span class="line">u0_a60    2385  1258  996260 54456 SyS_epoll_ 00000000 S io.virtualapp</span><br><span class="line">u0_a60    2412  1258  980940 48272 SyS_epoll_ 00000000 S io.virtualapp:x</span><br><span class="line">u0_a60    3705  1258  993632 54472 SyS_epoll_ 00000000 S org.galaxy.simpleapp</span><br></pre></td></tr></table></figure></p>
<p>可以看到，以上进程，均是以VirtualApp的用户uid运行的。因此，Android应用隔离此时不再适用，我们可以对client应用进行hook而无需root权限。</p>
<h2 id="注入逻辑"><a href="#注入逻辑" class="headerlink" title="注入逻辑"></a>注入逻辑</h2><p>要想实现对一个APP的虚拟化，就是不直接把APP安装进系统，同时又要提供APP运行过程中所需的一切，从而可以让它误以为自己是运行在正常系统中。这里就需要实现系统服务的虚拟化和相关路径的虚拟化。</p>
<p>其中，<strong>系统服务的虚拟化主要靠注入大量framework组件来实现</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@VirtualApp/lib/src/main/java/com/lody/virtual/client/core/InvocationStubManager.java</span><br><span class="line">private void injectInternal() throws Throwable &#123;</span><br><span class="line">  if (VirtualCore.get().isMainProcess()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (VirtualCore.get().isServerProcess()) &#123;</span><br><span class="line">    addInjector(new ActivityManagerStub());</span><br><span class="line">    addInjector(new PackageManagerStub());</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (VirtualCore.get().isVAppProcess()) &#123;</span><br><span class="line">    addInjector(new LibCoreStub());</span><br><span class="line">    addInjector(new ActivityManagerStub());</span><br><span class="line">    addInjector(new PackageManagerStub());</span><br><span class="line">    addInjector(HCallbackStub.getDefault());</span><br><span class="line">    addInjector(new ISmsStub());</span><br><span class="line">    addInjector(new ISubStub());</span><br><span class="line">    addInjector(new DropBoxManagerStub());</span><br><span class="line">    addInjector(new NotificationManagerStub());</span><br><span class="line">    addInjector(new LocationManagerStub());</span><br><span class="line">    addInjector(new WindowManagerStub());</span><br><span class="line">    addInjector(new ClipBoardStub());</span><br><span class="line">    addInjector(new MountServiceStub());</span><br><span class="line">    addInjector(new BackupManagerStub());</span><br><span class="line">    addInjector(new TelephonyStub());</span><br><span class="line">    addInjector(new TelephonyRegistryStub());</span><br><span class="line">    addInjector(new PhoneSubInfoStub());</span><br><span class="line">    addInjector(new PowerManagerStub());</span><br><span class="line">    addInjector(new AppWidgetManagerStub());</span><br><span class="line">    addInjector(new AccountManagerStub());</span><br><span class="line">    addInjector(new AudioManagerStub());</span><br><span class="line">    addInjector(new SearchManagerStub());</span><br><span class="line">    addInjector(new ContentServiceStub());</span><br><span class="line">    addInjector(new ConnectivityStub());</span><br><span class="line"> </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR2) &#123;</span><br><span class="line">      addInjector(new VibratorStub());</span><br><span class="line">      addInjector(new WifiManagerStub());</span><br><span class="line">      addInjector(new BluetoothStub());</span><br><span class="line">      addInjector(new ContextHubServiceStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR1) &#123;</span><br><span class="line">      addInjector(new UserManagerStub());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR1) &#123;</span><br><span class="line">      addInjector(new DisplayStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= LOLLIPOP) &#123;</span><br><span class="line">      addInjector(new PersistentDataBlockServiceStub());</span><br><span class="line">      addInjector(new InputMethodManagerStub());</span><br><span class="line">      addInjector(new MmsStub());</span><br><span class="line">      addInjector(new SessionManagerStub());</span><br><span class="line">      addInjector(new JobServiceStub());</span><br><span class="line">      addInjector(new RestrictionStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= KITKAT) &#123;</span><br><span class="line">      addInjector(new AlarmManagerStub());</span><br><span class="line">      addInjector(new AppOpsManagerStub());</span><br><span class="line">      addInjector(new MediaRouterServiceStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= LOLLIPOP_MR1) &#123;</span><br><span class="line">      addInjector(new GraphicsStatsStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= M) &#123;</span><br><span class="line">      addInjector(new NetworkManagementStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= N) &#123;</span><br><span class="line">              addInjector(new WifiScannerStub());</span><br><span class="line">              addInjector(new ShortcutServiceStub());</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个注入过程是发生在io.virtualapp.VApp.attachBaseContext中，因此，每次启动一个子进程都会执行到这里，这会区分是isMainProcess（io.virtualapp）或者isServerProcess（io.virtualapp:x）或者isVAppProcess（被安装APP）来进行不同的注入，可以看到，注入最多的还是在被安装APP的进程中。</p>
<h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>从启动VirtualApp到运行其中的应用，大致流程如下：</p>
<h3 id="启动host应用"><a href="#启动host应用" class="headerlink" title="启动host应用"></a>启动host应用</h3><p>我们启动VirtualApp，其Application为io.virtualapp.VApp。<strong>在attachBaseContext()</strong>方法中会调用到com.lody.virtual.client.core.PatchManager#injectInternal，但此时为<strong>Main Process</strong>，不进行系统服务的替换。</p>
<h3 id="启动Server-Process"><a href="#启动Server-Process" class="headerlink" title="启动Server Process"></a>启动Server Process</h3><p>host应用会进行一些初始化，其中就包括获取全部已安装应用，这会调用到com.lody.virtual.client.core.VirtualCore#getAllApps。而这一方法最终会访问com.lody.virtual.server.BinderProvider。由AndroidManifest.xml可知，该provider会运行在新进程io.virtualapp:x中，即<strong>Server Process</strong>。</p>
<p>由于在新进程中启动组件，同样会首先创建该应用的Application，因此也会调用到com.lody.virtual.client.core.PatchManager#injectInternal。此时，<strong>会进行相应系统服务(ActivityManager和PackageManager)的代理构造和替换。</strong></p>
<h3 id="启动VApp-Process"><a href="#启动VApp-Process" class="headerlink" title="启动VApp Process"></a>启动VApp Process</h3><p>点击一个已安装应用，此时会通过替换掉的系统服务访问真实的系统服务（主要是ActivityManager），并在新进程中启动组件com.lody.virtual.client.stub.StubActivity.C0。由AndroidManifest.xml可知，该进程具有后缀:p0。</p>
<p>同样的，在该Activity组件启动之前会初始化io.virtualapp.VApp，并在com.lody.virtual.client.core.PatchManager#injectInternal中<strong>完成系统服务的代理构造和替换。</strong></p>
<h3 id="启动client应用"><a href="#启动client应用" class="headerlink" title="启动client应用"></a>启动client应用</h3><p>此时，真正的client应用尚未启动，进程io.virtualapp:p0仅仅是作为一个placeholder。StubActivity会从Intent中获取到client应用的相关信息，并修改自身ActivityThread的handler。随后调用startActivity启动client应用。</p>
<p>由于之前Server Process和VApp Process都已完成了相关系统服务的替换，这里会完成client应用的bindApplication调用、构造client应用的LoadedApk，并通过反射完成真正的Application和Activity的创建。</p>
<p>最终，client应用便运行在了我们的VApp Process中。</p>
<h2 id="系统服务的代理和替换"><a href="#系统服务的代理和替换" class="headerlink" title="系统服务的代理和替换"></a>系统服务的代理和替换</h2><p>VirtualApp之所以能够实现虚拟空间，是因为其对许多系统服务进行了代理和替换。因此，这部分便是整个框架的核心。系统服务运行在system_server中，Android应用调用系统服务，是通过Binder机制进行IPC。因此，<strong>应用所持有的是系统服务的BinderProxy，通过对这些BinderProxer构造代理并替换，便实现了对系统服务的代理和替换。</strong></p>
<p>具体地，我们以com.lody.virtual.client.hook.patchs.am.ActivityManagerPatch为例，这个类实现了对ActivityManager服务的代理和替换。</p>
<h3 id="代理的构造"><a href="#代理的构造" class="headerlink" title="代理的构造"></a>代理的构造</h3><p>可以看到，这个类的注记中包含了大量类名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Patch(&#123;StartActivity.class, StartActivityAsCaller.class,</span><br><span class="line">        StartActivityAndWait.class, StartActivityWithConfig.class, StartActivityIntentSender.class,</span><br><span class="line">        StartNextMatchingActivity.class, StartVoiceActivity.class,</span><br><span class="line">        GetIntentSender.class, RegisterReceiver.class, GetContentProvider.class,</span><br><span class="line">        GetContentProviderExternal.class,</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>而这些列出的每一个类，对应于一个方法的hook，例如，com.lody.virtual.client.hook.patchs.am.StartActivity是ActivityManager服务的startActivity方法的hook。这些类均继承自com.lody.virtual.client.hook.base.Hook，包含了方法beforeCall(), call(), afterCall()，这些方法便是hook的具体内容。</p>
<p>ActivityManagerPatch在创建时，会调用到其父类的方法com.lody.virtual.client.hook.base.PatchDelegate#onBindHooks。这里会检查上述注记中列出的hook，并对符合条件的hook调用addHook()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Class&lt;? extends PatchDelegate&gt; clazz = getClass();</span><br><span class="line">Patch patch = clazz.getAnnotation(Patch.class);</span><br><span class="line">int version = Build.VERSION.SDK_INT;</span><br><span class="line">if (patch != null) &#123;</span><br><span class="line">    Class&lt;?&gt;[] hookTypes = patch.value();</span><br><span class="line">    for (Class&lt;?&gt; hookType : hookTypes) &#123;</span><br><span class="line">        ApiLimit apiLimit = hookType.getAnnotation(ApiLimit.class);</span><br><span class="line">        boolean needToAddHook = true;</span><br><span class="line">        if (apiLimit != null) &#123;</span><br><span class="line">            int apiStart = apiLimit.start();</span><br><span class="line">            int apiEnd = apiLimit.end();</span><br><span class="line">            boolean highThanStart = apiStart == -1 || version &gt; apiStart;</span><br><span class="line">            boolean lowThanEnd = apiEnd == -1 || version &lt; apiEnd;</span><br><span class="line">            if (!highThanStart || !lowThanEnd) &#123;</span><br><span class="line">                needToAddHook = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (needToAddHook) &#123;</span><br><span class="line">            addHook(hookType);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>而addHook()最终会调用到com.lody.virtual.client.hook.base.HookDelegate#addHook，其实质便是将这个hook添加至映射表internalHookTable中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Hook addHook(Hook hook) &#123;</span><br><span class="line">    if (hook != null &amp;&amp; !TextUtils.isEmpty(hook.getName())) &#123;</span><br><span class="line">        if (internalHookTable.containsKey(hook.getName())) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;The Hook(%s, %s) you added has been in existence.&quot;, hook.getName(),</span><br><span class="line">                    hook.getClass().getName());</span><br><span class="line">            return hook;</span><br><span class="line">        &#125;</span><br><span class="line">        internalHookTable.put(hook.getName(), hook);</span><br><span class="line">    &#125;</span><br><span class="line">    return hook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>internalHookTable维护了所有的hook，以hook的名称（一般就是所hook的方法的名称）作为key。随后，在com.lody.virtual.client.hook.base.HookDelegate.HookHandler的invoke()方法中，查找表 internalHookTable中是否包含将要执行的方法名；如果有，则依次执行对应hook的beforeCall(), call(), afterCall()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private class HookHandler implements InvocationHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Hook hook = getHook(method.getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            if (hook != null &amp;&amp; hook.isEnable()) &#123;</span><br><span class="line">                if (hook.beforeCall(mBaseInterface, method, args)) &#123;</span><br><span class="line">                    Object res = hook.call(mBaseInterface, method, args);</span><br><span class="line">                    res = hook.afterCall(mBaseInterface, method, args, res);</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return method.invoke(mBaseInterface, args);</span><br></pre></td></tr></table></figure></p>
<p>而这里的类HookHandler，就是构造的Java代理的Handler：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public HookDelegate(T baseInterface, Class&lt;?&gt;... proxyInterfaces) &#123;</span><br><span class="line">    this.mBaseInterface = baseInterface;</span><br><span class="line">    if (baseInterface != null) &#123;</span><br><span class="line">        if (proxyInterfaces == null) &#123;</span><br><span class="line">            proxyInterfaces = HookUtils.getAllInterface(baseInterface.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        mProxyInterface = (T) Proxy.newProxyInstance(baseInterface.getClass().getClassLoader(), proxyInterfaces, new HookHandler());</span><br></pre></td></tr></table></figure></p>
<p>对于ActivityManagerPatch来说，这里的baseInterface便是原始的BinderProxy: ActivityManagerProxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ActivityManagerPatch() &#123;</span><br><span class="line">    super(new HookDelegate&lt;IInterface&gt;(ActivityManagerNative.getDefault.call()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>综上，我们根据baseInterface，为其构造了代理mProxyInterface。从而访问mProxyInterface时，便会执行HookHandler的invoke()方法，进而查找internalHookTable，对设置了hook的方法执行hook。</p>
<h3 id="系统服务的替换"><a href="#系统服务的替换" class="headerlink" title="系统服务的替换"></a>系统服务的替换</h3><p>如之前所说，对系统服务的替换，是通过对应用所持有的系统服务的BinderProxy进行替换的。以上是构造代理的基本过程，那么如何将应用所持有的BinderProxy替换成我们构造的代理呢？回到ActivityManagerPatch，这个类的inject()方法完成了实际的替换工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void inject() throws Throwable &#123;</span><br><span class="line">    if (ActivityManagerNative.gDefault.type() == IActivityManager.TYPE) &#123;</span><br><span class="line">        ActivityManagerNative.gDefault.set(getHookDelegate().getProxyInterface());</span><br><span class="line"></span><br><span class="line">    &#125; else if (ActivityManagerNative.gDefault.type() == Singleton.TYPE) &#123;</span><br><span class="line">        Object gDefault = ActivityManagerNative.gDefault.get();</span><br><span class="line">        Singleton.mInstance.set(gDefault, getHookDelegate().getProxyInterface());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>ActivityManagerNative.gDefault便是应用所持有的原始ActivityManagerProxy对象，通过Java反射，将替换成为getHookDelegate().getProxyInterface()。而替换的内容，便是我们所构造的代理mProxyInterface。</p>
<p>由此，我们完成了对系统服务进行代理和替换的整个过程。随后，在调用系统服务时，便会执行以下操作：</p>
<ul>
<li>访问BinderProxy的代理，即我们设置了hook的代理</li>
<li>根据hook的具体内容操作，对数据进行处理；需要调用原始系统服务时，访问原始的BinderProxy</li>
<li>真正的系统服务接收到Binder，进行处理并返回</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上介绍可以看到，VirtualApp在原有系统服务之上构造了代理，进而为其中的应用搭建了一套虚拟环境，应用可以无感知地运行在这其中。更进一步，我们可以设置这套虚拟环境，使其实现应用多开、非侵入式应用hook等高级功能。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">https://github.com/asLody/VirtualApp</a><br><a href="http://rk700.github.io/2017/03/15/virtualapp-basic/" target="_blank" rel="noopener">http://rk700.github.io/2017/03/15/virtualapp-basic/</a><br><a href="https://blog.csdn.net/weixin_40581980/article/details/81169266" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40581980/article/details/81169266</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/03/android-plugin-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/03/android-plugin-knowledge/" itemprop="url">Android插件化方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-03T15:20:16+08:00">
                2020-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android插件化/" itemprop="url" rel="index">
                    <span itemprop="name">Android插件化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>插件化技术涉及得非常广泛，其中最核心的就是Android的类加载机制和反射机制。下图载自腾讯bugly：</p>
<p><img src="/2020/04/03/android-plugin-knowledge/plugin_history.jpg" alt title="图1：插件化概要"></p>
<h2 id="插件化发展历史"><a href="#插件化发展历史" class="headerlink" title="插件化发展历史"></a>插件化发展历史</h2><p>插件化技术最初源于免安装运行apk的想法，这个免安装的apk可以理解为插件。支持插件化的app可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展。想要实现插件化，主要是解决下面三个问题：</p>
<ul>
<li>插件中代码的加载和与主工程的互相调用</li>
<li>插件中资源的加载和与主工程的互相访问</li>
<li>四大组件生命周期的管理</li>
</ul>
<p>下面是比较出名的几个开源的插件化框架，按照出现的时间排序。研究它们的实现原理，可以大致看出插件化技术的发展，根据实现原理可以将这几个框架划分成了三代。</p>
<p><img src="/2020/04/03/android-plugin-knowledge/plugin_generate.jpg" alt></p>
<p><strong>第一代</strong>：dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期。该种方式缺点明显，插件中的activity必须继承PluginActivity，开发时要小心处理context。而DroidPlugin通过Hook系统服务的方式启动插件中的Activity，使得开发插件的过程和开发普通的app没有什么区别，但是由于hook过多系统服务，异常复杂且不够稳定。<br><strong>第二代</strong>：为了同时达到插件开发的低侵入性（像开发普通app一样开发插件）和框架的稳定性，在实现原理上都是趋近于选择尽量少的hook，并通过在manifest中预埋一些组件实现对四大组件的插件化。另外各个框架根据其设计思想都做了不同程度的扩展，其中Small更是做成了一个跨平台，组件化的开发框架。<br><strong>第三代</strong>：VirtualApp比较厉害，能够完全模拟app的运行环境，能够实现app的免安装运行和双开技术。Atlas是阿里开源出来的一个结合组件化和热修复技术的一个app基础框架，其广泛的应用与阿里系的各个app，其号称是一个容器化框架。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/07/c-plus-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/07/c-plus-language/" itemprop="url">C++ 语言笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-07T13:06:49+08:00">
                2020-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p>
<p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：封装、抽象、继承、多态。</p>
<p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。C++ 是 C 的一个超集，任何合法的 C 程序都是合法的 C++ 程序。</p>
<p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</p>
<p>注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p>
<p>本章只针对和C语言不同处介绍。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。</p>
<h3 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// main() 是程序开始执行的地方</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们讲解一下上面这段程序：</p>
<blockquote>
<ul>
<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <iostream>。</iostream></li>
<li>下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>
<li>下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。</li>
<li>下一行 int main() 是主函数，程序从这里开始执行。</li>
<li>下一行 cout &lt;&lt; “Hello World”; 会在屏幕上显示消息 “Hello World”。</li>
<li>下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。</li>
</ul>
</blockquote>
<h3 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h3><p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。</p>
<h3 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h3><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。<strong>三字符序列总是以两个问号开头</strong>。</p>
<p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。<strong>以前为了表示键盘上没有的字符</strong>，这是必不可少的一种方法。三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p>
<p>g++仍默认支持三字符组，但会给出编译警告。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>bool</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
</tr>
<tr>
<td>浮点型</td>
<td>float</td>
</tr>
<tr>
<td>双浮点型</td>
<td>double</td>
</tr>
<tr>
<td>无类型</td>
<td>void</td>
</tr>
<tr>
<td>宽字符型</td>
<td>wchar_t</td>
</tr>
</tbody>
</table>
<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<blockquote>
<ul>
<li>true 值代表真。</li>
<li>false 值代表假。</li>
</ul>
</blockquote>
<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>
<h3 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h3><p>wchar_t为宽字符型    ，占2 或 4 个字节。其实 wchar_t 是这样来的：</p>
<blockquote>
<p>typedef short int wchar_t;</p>
</blockquote>
<p>所以 wchar_t 实际上的空间是和 short int 一样。</p>
<h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符提供了变量的额外信息。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>const</td>
<td>const 类型的对象在程序执行期间不能被修改改变。</td>
</tr>
<tr>
<td>volatile</td>
<td>修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td>
</tr>
<tr>
<td>restrict</td>
<td>由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
</tbody>
</table>
<h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<blockquote>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
</blockquote>
<p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<h3 id="mutable-存储类"><a href="#mutable-存储类" class="headerlink" title="mutable 存储类"></a>mutable 存储类</h3><p>mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>
<h3 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h3><p>使用 thread_local 说明符声明的变量<strong>仅可在它在其上创建的线程上访问</strong>。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
<p>thread_local 说明符可以与 static 或 extern 合并。</p>
<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>
<p>以下演示了可以被声明为 thread_local 的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread_local int x;  // 命名空间下的全局变量</span><br><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">    static thread_local std::string s; // 类的static成员变量</span><br><span class="line">&#125;;</span><br><span class="line">static thread_local std::string X::s;  // X::s 是需要定义的</span><br><span class="line"> </span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    thread_local std::vector&lt;int&gt; v;  // 本地变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</p>
<p>Cast：强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><p>当您定义一个函数，您<strong>可以为参数列表中后边的每一个参数指定默认值</strong>。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p>
<p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int sum(int a, int b=20)</span><br><span class="line">&#123;</span><br><span class="line">  int result;</span><br><span class="line"> </span><br><span class="line">  result = a + b;</span><br><span class="line">  </span><br><span class="line">  return (result);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   // 局部变量声明</span><br><span class="line">   int a = 100;</span><br><span class="line">   int b = 200;</span><br><span class="line">   int result;</span><br><span class="line"> </span><br><span class="line">   // 调用函数来添加值</span><br><span class="line">   result = sum(a, b);</span><br><span class="line">   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 再次调用函数</span><br><span class="line">   result = sum(a);</span><br><span class="line">   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Total value is :300</span><br><span class="line">Total value is :120</span><br></pre></td></tr></table></figure></p>
<h3 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h3><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>
<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>
<blockquote>
<p>[capture](parameters)-&gt;return-type{body}<br>[capture](parameters){body}</p>
</blockquote>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[](int x, int y)&#123; return x &lt; y ; &#125;</span><br><span class="line"></span><br><span class="line">[]&#123; ++global_x; &#125; </span><br><span class="line"></span><br><span class="line">[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p>
<p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p>
<blockquote>
<p>[]      // 沒有定义任何变量。使用未定义变量会引发错误。<br>[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。<br>[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。<br>[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。<br>[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。<br>[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</p>
</blockquote>
<p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p>
<blockquote>
<p>[this]() { this-&gt;someFunc(); }();</p>
</blockquote>
<h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h2><p>C++ 提供了以下两种类型的字符串表示形式：</p>
<blockquote>
<ul>
<li>C 风格字符串</li>
<li>C++ 引入的 string 类类型</li>
</ul>
</blockquote>
<p>C++ 标准库提供了 string 类类型，支持C 风格字符串所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   string str1 = &quot;Hello&quot;;</span><br><span class="line">   string str2 = &quot;World&quot;;</span><br><span class="line">   string str3;</span><br><span class="line">   int  len ;</span><br><span class="line"> </span><br><span class="line">   // 复制 str1 到 str3</span><br><span class="line">   str3 = str1;</span><br><span class="line">   cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 连接 str1 和 str2</span><br><span class="line">   str3 = str1 + str2;</span><br><span class="line">   cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 连接后，str3 的总长度</span><br><span class="line">   len = str3.size();</span><br><span class="line">   cout &lt;&lt; &quot;str3.size() :  &quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">str3 : Hello</span><br><span class="line">str1 + str2 : HelloWorld</span><br><span class="line">str3.size() :  10</span><br></pre></td></tr></table></figure></p>
<h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++ 引用"></a>C++ 引用</h2><p>引用变量是一个<strong>别名</strong>，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。引用通常用于函数参数列表和函数返回值。</p>
<h3 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h3><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<blockquote>
<ul>
<li><strong>不存在空引用</strong>。引用必须连接到一块合法的内存。</li>
<li><strong>一旦引用被初始化为一个对象，就不能被指向到另一个对象</strong>。指针可以在任何时候指向到另一个对象。</li>
<li><strong>引用必须在创建时被初始化</strong>。指针可以在任何时间被初始化。</li>
</ul>
</blockquote>
<h3 id="C-中创建引用"><a href="#C-中创建引用" class="headerlink" title="C++ 中创建引用"></a>C++ 中创建引用</h3><p>试想<strong>变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签</strong>。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>
<blockquote>
<p>int i = 17;</p>
</blockquote>
<p>我们可以为 i 声明引用变量，如下所示：</p>
<blockquote>
<p>int&amp;  r = i;<br>double&amp; s = d;</p>
</blockquote>
<p>在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   // 声明简单的变量</span><br><span class="line">   int    i;</span><br><span class="line">   double d;</span><br><span class="line"> </span><br><span class="line">   // 声明引用变量</span><br><span class="line">   int&amp;    r = i;</span><br><span class="line">   double&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = 5;</span><br><span class="line">   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = 11.7;</span><br><span class="line">   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of i : 5</span><br><span class="line">Value of i reference : 5</span><br><span class="line">Value of d : 11.7</span><br><span class="line">Value of d reference : 11.7</span><br></pre></td></tr></table></figure>
<h2 id="C-输入输出"><a href="#C-输入输出" class="headerlink" title="C++ 输入输出"></a>C++ 输入输出</h2><h3 id="I-O-库头文件"><a href="#I-O-库头文件" class="headerlink" title="I/O 库头文件"></a>I/O 库头文件</h3><p>下列的头文件在 C++ 编程中很重要：</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>函数和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;iostream></td>
<td>该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>
</tr>
<tr>
<td>&lt;iomanip></td>
<td>该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。</td>
</tr>
<tr>
<td>&lt;fstream></td>
<td>该文件为用户控制的文件处理声明服务。</td>
</tr>
</tbody>
</table>
<h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h3><p>预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char str[] = &quot;Hello C++&quot;;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。</p>
<p>cerr、clog类似。但良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>
<h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h3><p>预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char name[50];</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;请输入您的名称： &quot;;</span><br><span class="line">   cin &gt;&gt; name;</span><br><span class="line">   cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>
<blockquote>
<p>cin &gt;&gt; name &gt;&gt; age;</p>
</blockquote>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<blockquote>
<p>void open(const char *filename, ios::openmode mode);</p>
</blockquote>
<p>在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式:</p>
<p>模式标志     | 描述<br>| - | - |<br>ios::app     | 追加模式。所有写入都追加到文件末尾。<br>ios::ate     | 文件打开后定位到文件末尾。<br>ios::in     | 打开文件用于读取。<br>ios::out     | 打开文件用于写入。<br>ios::trunc     | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</p>
<p>您可以把以上两种或两种以上的模式结合使用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法</span><br><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc );</span><br><span class="line"></span><br><span class="line">//类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</span><br><span class="line">ifstream  afile;</span><br><span class="line">afile.open(&quot;file.dat&quot;, ios::out | ios::in );</span><br></pre></td></tr></table></figure></p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>
<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<blockquote>
<p>void close();</p>
</blockquote>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息或流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 、 fstream  或 ifstream 、 fstream 对象，而不是 cout 对象或 cin 对象。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   char data[100];</span><br><span class="line"> </span><br><span class="line">   // 以写模式打开文件</span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.open(&quot;afile.dat&quot;);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Enter your name: &quot;; </span><br><span class="line">   cin.getline(data, 100);</span><br><span class="line"> </span><br><span class="line">   // 向文件写入用户输入的数据</span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Enter your age: &quot;; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.ignore();</span><br><span class="line">   </span><br><span class="line">   // 再次向文件写入用户输入的数据</span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 关闭打开的文件</span><br><span class="line">   outfile.close();</span><br><span class="line"> </span><br><span class="line">   // 以读模式打开文件</span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.open(&quot;afile.dat&quot;); </span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line"> </span><br><span class="line">   // 在屏幕上写入数据</span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   // 再次从文件读取数据，并显示它</span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   // 关闭打开的文件</span><br><span class="line">   infile.close();</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列输入和输出：</span><br><span class="line">$./a.out</span><br><span class="line">Writing to the file</span><br><span class="line">Enter your name: Zara</span><br><span class="line">Enter your age: 9</span><br><span class="line">Reading from the file</span><br><span class="line">Zara</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p>
<h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><p>istream 和 ostream 都提供了用于<strong>重新定位文件位置指针</strong>的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span><br><span class="line">fileObject.seekg( n );</span><br><span class="line"> </span><br><span class="line">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::cur );</span><br><span class="line"> </span><br><span class="line">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::end );</span><br><span class="line"> </span><br><span class="line">// 定位到 fileObject 的末尾</span><br><span class="line">fileObject.seekg( 0, ios::end );</span><br></pre></td></tr></table></figure></p>
<h2 id="C-类和继承"><a href="#C-类和继承" class="headerlink" title="C++ 类和继承"></a>C++ 类和继承</h2><p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p>
<h3 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h3><p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<p>类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      double length;   // 盒子的长度</span><br><span class="line">      double breadth;  // 盒子的宽度</span><br><span class="line">      double height;   // 盒子的高度</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected。</p>
<h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。继承代表了 is a 关系。</p>
<p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<blockquote>
<p>class derived-class: access-specifier base-class</p>
</blockquote>
<p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<h3 id="继承类型access-specifier"><a href="#继承类型access-specifier" class="headerlink" title="继承类型access-specifier"></a>继承类型access-specifier</h3><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 protected 或 private 继承，<strong>通常使用 public 继承</strong>。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li>公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li>
<li>保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。</li>
<li>私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<blockquote>
<p>Box operator+(const Box&amp;);</p>
</blockquote>
<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>
<blockquote>
<p>Box operator+(const Box&amp;, const Box&amp;);</p>
</blockquote>
<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line"> </span><br><span class="line">      double getVolume(void)</span><br><span class="line">      &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">          length = len;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      void setBreadth( double bre )</span><br><span class="line">      &#123;</span><br><span class="line">          breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      void setHeight( double hei )</span><br><span class="line">      &#123;</span><br><span class="line">          height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      // 重载 + 运算符，用于把两个 Box 对象相加</span><br><span class="line">      Box operator+(const Box&amp; b)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box;</span><br><span class="line">         box.length = this-&gt;length + b.length;</span><br><span class="line">         box.breadth = this-&gt;breadth + b.breadth;</span><br><span class="line">         box.height = this-&gt;height + b.height;</span><br><span class="line">         return box;</span><br><span class="line">      &#125;</span><br><span class="line">   private:</span><br><span class="line">      double length;      // 长度</span><br><span class="line">      double breadth;     // 宽度</span><br><span class="line">      double height;      // 高度</span><br><span class="line">&#125;;</span><br><span class="line">// 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Box Box1;                // 声明 Box1，类型为 Box</span><br><span class="line">   Box Box2;                // 声明 Box2，类型为 Box</span><br><span class="line">   Box Box3;                // 声明 Box3，类型为 Box</span><br><span class="line">   double volume = 0.0;     // 把体积存储在该变量中</span><br><span class="line"> </span><br><span class="line">   // Box1 详述</span><br><span class="line">   Box1.setLength(6.0); </span><br><span class="line">   Box1.setBreadth(7.0); </span><br><span class="line">   Box1.setHeight(5.0);</span><br><span class="line"> </span><br><span class="line">   // Box2 详述</span><br><span class="line">   Box2.setLength(12.0); </span><br><span class="line">   Box2.setBreadth(13.0); </span><br><span class="line">   Box2.setHeight(10.0);</span><br><span class="line"> </span><br><span class="line">   // Box1 的体积</span><br><span class="line">   volume = Box1.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   // Box2 的体积</span><br><span class="line">   volume = Box2.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   // 把两个对象相加，得到 Box3</span><br><span class="line">   Box3 = Box1 + Box2;</span><br><span class="line"> </span><br><span class="line">   // Box3 的体积</span><br><span class="line">   volume = Box3.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Volume of Box1 : 210</span><br><span class="line">Volume of Box2 : 1560</span><br><span class="line">Volume of Box3 : 5400</span><br></pre></td></tr></table></figure></p>
<h3 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h3><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>双目算术运算符</td>
<td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td>
</tr>
<tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&#124;&#124;(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>&#124; (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)`</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=, &#124;=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td>()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标)</td>
</tr>
</tbody>
</table>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li>.：成员访问运算符</li>
<li>.<em>, -&gt;</em>：成员指针访问运算符</li>
<li>::：域运算符</li>
<li>sizeof：长度运算符</li>
<li>?:：条件运算符</li>
<li>#： 预处理符号</li>
</ul>
<h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++ 多态"></a>C++ 多态</h2><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      int area()</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Rectangle: public Shape&#123;</span><br><span class="line">   public:</span><br><span class="line">      Rectangle( int a=0, int b=0):Shape(a, b) &#123; &#125;</span><br><span class="line">      int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Triangle: public Shape&#123;</span><br><span class="line">   public:</span><br><span class="line">      Triangle( int a=0, int b=0):Shape(a, b) &#123; &#125;</span><br><span class="line">      int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         cout &lt;&lt; &quot;Triangle class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return (width * height / 2); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   Rectangle rec(10,7);</span><br><span class="line">   Triangle  tri(10,5);</span><br><span class="line"> </span><br><span class="line">   // 存储矩形的地址</span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   // 调用矩形的求面积函数 area</span><br><span class="line">   shape-&gt;area();</span><br><span class="line"> </span><br><span class="line">   // 存储三角形的地址</span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   // 调用三角形的求面积函数 area</span><br><span class="line">   shape-&gt;area();</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Parent class area</span><br><span class="line">Parent class area</span><br></pre></td></tr></table></figure>
<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态或静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>
<p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      virtual int area()</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">修改后，当编译和执行前面的实例代码时，它会产生以下结果：</span><br><span class="line">Rectangle class area</span><br><span class="line">Triangle class area</span><br></pre></td></tr></table></figure></p>
<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>
<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会<strong>告诉编译器不要静态链接到该函数</strong>。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接或后期绑定</strong>。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>
<p>我们可以把基类中的虚函数 area() 改写如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      // pure virtual function</span><br><span class="line">      virtual int area() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>= 0 告诉编译器，<strong>函数没有主体</strong>，上面的虚函数是纯虚函数。</p>
<h2 id="C-动态内存"><a href="#C-动态内存" class="headerlink" title="C++ 动态内存"></a>C++ 动态内存</h2><p>C++ 程序中的内存分为两个部分：</p>
<blockquote>
<ul>
<li>栈：在函数内部声明的所有变量都将占用栈内存。</li>
<li>堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
</blockquote>
<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>
<p>在 C++ 中，这种运算符即 new 运算符。如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。</p>
<h3 id="new-和-delete-运算符"><a href="#new-和-delete-运算符" class="headerlink" title="new 和 delete 运算符"></a>new 和 delete 运算符</h3><p>通用语法：</p>
<blockquote>
<p>new data-type;<br>delete member; </p>
</blockquote>
<p>在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double* pvalue  = NULL; // 初始化为 null 的指针</span><br><span class="line">pvalue  = new double;   // 为变量请求内存</span><br></pre></td></tr></table></figure></p>
<p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double* pvalue  = NULL;</span><br><span class="line">if( !(pvalue  = new double ))</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;Error: out of memory.&quot; &lt;&lt;endl;</span><br><span class="line">   exit(1);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pvalue = 29494.99;     // 在分配的地址存储值</span><br><span class="line">cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">delete pvalue;        // 释放 pvalue 所指向的内存</span><br></pre></td></tr></table></figure></p>
<p>malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p>
<h2 id="C-命名空间"><a href="#C-命名空间" class="headerlink" title="C++ 命名空间"></a>C++ 命名空间</h2><p>命名空间可作为附加信息来<strong>区分不同库中相同名称的函数、类、变量等</strong>。使用了命名空间即定义了<strong>上下文</strong>。本质上，命名空间就是定义了一个范围。</p>
<h3 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h3><p>命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示：</p>
<blockquote>
<p>namespace namespace_name {<br>   // 代码声明<br>}</p>
</blockquote>
<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p>
<blockquote>
<p>name::code;  // code 可以是变量或函数</p>
</blockquote>
<p>让我们来看看命名空间如何为变量或函数等实体定义范围：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 第一个命名空间</span><br><span class="line">namespace first_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二个命名空间</span><br><span class="line">namespace second_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   // 调用第一个命名空间中的函数</span><br><span class="line">   first_space::func();</span><br><span class="line">   </span><br><span class="line">   // 调用第二个命名空间中的函数</span><br><span class="line">   second_space::func(); </span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Inside first_space</span><br><span class="line">Inside second_space</span><br></pre></td></tr></table></figure></p>
<h3 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h3><p>您可以使用 using namespace 指令，这样在使用命名空间时就<strong>可以不用在前面加上命名空间的名称</strong>。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 第一个命名空间</span><br><span class="line">namespace first_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二个命名空间</span><br><span class="line">namespace second_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">using namespace first_space;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   // 调用第一个命名空间中的函数</span><br><span class="line">   func();</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Inside first_space</span><br></pre></td></tr></table></figure></p>
<p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p>
<blockquote>
<p>using std::cout;</p>
</blockquote>
<p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;std::endl is used with std!&quot; &lt;&lt; std::endl;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">std::endl is used with std!</span><br></pre></td></tr></table></figure></p>
<p>using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p>
<h3 id="不连续的命名空间"><a href="#不连续的命名空间" class="headerlink" title="不连续的命名空间"></a>不连续的命名空间</h3><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。<strong>一个命名空间的各个组成部分可以分散在多个文件中</strong>。</p>
<p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素。</p>
<h3 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h3><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name1 &#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">   namespace namespace_name2 &#123;</span><br><span class="line">      // 代码声明</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 访问 namespace_name2 中的成员</span><br><span class="line">using namespace namespace_name1::namespace_name2;</span><br><span class="line"> </span><br><span class="line">// 访问 namespace:name1 中的成员</span><br><span class="line">using namespace namespace_name1;</span><br></pre></td></tr></table></figure></p>
<p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的</p>
<h2 id="C-模板"><a href="#C-模板" class="headerlink" title="C++ 模板"></a>C++ 模板</h2><p>模板是<strong>泛型</strong>编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>模板函数定义的一般形式如下所示：</p>
<blockquote>
<p>template <class type> ret-type func-name(parameter list)<br>{<br>   // 函数的主体<br>}</class></p>
</blockquote>
<p>在这里，<strong>type 是函数所使用的数据类型的占位符名称</strong>。这个名称可以在函数定义中使用。</p>
<p>下面是函数模板的实例，返回两个数中的最大值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline T const&amp; Max (T const&amp; a, T const&amp; b) </span><br><span class="line">&#123; </span><br><span class="line">    return a &lt; b ? b:a; </span><br><span class="line">&#125; </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    int i = 39;</span><br><span class="line">    int j = 20;</span><br><span class="line">    cout &lt;&lt; &quot;Max(i, j): &quot; &lt;&lt; Max(i, j) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    double f1 = 13.5; </span><br><span class="line">    double f2 = 20.7; </span><br><span class="line">    cout &lt;&lt; &quot;Max(f1, f2): &quot; &lt;&lt; Max(f1, f2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    string s1 = &quot;Hello&quot;; </span><br><span class="line">    string s2 = &quot;World&quot;; </span><br><span class="line">    cout &lt;&lt; &quot;Max(s1, s2): &quot; &lt;&lt; Max(s1, s2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p>
<blockquote>
<p>template <class type> class class-name {<br>.<br>.<br>.<br>}</class></p>
</blockquote>
<p>在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您<strong>可以使用一个逗号分隔的列表来定义多个泛型数据类型</strong>。</p>
<p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Stack &#123; </span><br><span class="line">  private: </span><br><span class="line">    vector&lt;T&gt; elems;     // 元素 </span><br><span class="line"> </span><br><span class="line">  public: </span><br><span class="line">    void push(T const&amp;);  // 入栈</span><br><span class="line">    void pop();               // 出栈</span><br><span class="line">    T top() const;            // 返回栈顶元素</span><br><span class="line">    bool empty() const&#123;       // 如果为空则返回真。</span><br><span class="line">        return elems.empty(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Stack&lt;T&gt;::push (T const&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    // 追加传入元素的副本</span><br><span class="line">    elems.push_back(elem);    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Stack&lt;T&gt;::pop () </span><br><span class="line">&#123; </span><br><span class="line">    if (elems.empty()) &#123; </span><br><span class="line">        throw out_of_range(&quot;Stack&lt;&gt;::pop(): empty stack&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 删除最后一个元素</span><br><span class="line">    elems.pop_back();         </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T Stack&lt;T&gt;::top () const </span><br><span class="line">&#123; </span><br><span class="line">    if (elems.empty()) &#123; </span><br><span class="line">        throw out_of_range(&quot;Stack&lt;&gt;::top(): empty stack&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 返回最后一个元素的副本 </span><br><span class="line">    return elems.back();      </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        Stack&lt;int&gt;         intStack;  // int 类型的栈 </span><br><span class="line">        Stack&lt;string&gt; stringStack;    // string 类型的栈 </span><br><span class="line"> </span><br><span class="line">        // 操作 int 类型的栈 </span><br><span class="line">        intStack.push(7); </span><br><span class="line">        cout &lt;&lt; intStack.top() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        // 操作 string 类型的栈 </span><br><span class="line">        stringStack.push(&quot;hello&quot;); </span><br><span class="line">        cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.pop(); </span><br><span class="line">        stringStack.pop(); </span><br><span class="line">    &#125; </span><br><span class="line">    catch (exception const&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; ex.what() &lt;&lt;endl; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">7</span><br><span class="line">hello</span><br><span class="line">Exception: Stack&lt;&gt;::pop(): empty stack</span><br></pre></td></tr></table></figure></p>
<h2 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h2><p># 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌<strong>转换</strong>为用引号引起来的字符串。</p>
<p>请看下面的宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define MKSTR( x ) #x</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">HELLO C++</span><br></pre></td></tr></table></figure>
<p>## 运算符用于连接两个令牌。下面是一个实例：</p>
<blockquote>
<p>#define CONCAT( x, y )  x ## y</p>
</blockquote>
<p>当 CONCAT 出现在程序中时，它的参数会被<strong>连接</strong>起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define concat(a, b) a ## b</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int xy = 100;</span><br><span class="line">   </span><br><span class="line">   cout &lt;&lt; concat(x, y);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h2 id="C-友元"><a href="#C-友元" class="headerlink" title="C++ 友元"></a>C++ 友元</h2><p>友元机制<strong>允许一个类将对其非公有成员的访问权授予指定的函数或者类</strong>，友元的声明以friend开始，它只能出现在类定义的内部，友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受其声明出现部分的访问控制影响。通常，将友元声明成组地放在类定义的开始或结尾是个好主意。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数是指某些虽然不是类成员函数却能够访问类的所有成员的函数。类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend void set_show(int x, A &amp;a);      //该函数是友元函数的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void set_show(int x, A &amp;a)  //友元函数定义，为了访问类A中的成员</span><br><span class="line">&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line"></span><br><span class="line">    set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。</p>
<p>关于友元类的注意事项：<br>(1) 友元关系不能被继承。<br>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。<br>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend class C;                         //这是友元类的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C             //友元类定义，为了访问类A中的成员</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void set_show(int x, A &amp;a) &#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line">    class C c;</span><br><span class="line"></span><br><span class="line">    c.set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h3><p>使类B中的成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员了。</p>
<p>当用到友元成员函数时，需注意友元声明和友元定义之间的相互依赖，在该例子中，类B必须先定义，否则类A就不能将一个B的函数指定为友元。然而，只有在定义了类A之后，才能定义类B的该成员函数。更一般的讲，必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A;    //当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。这是类A的声明</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void set_show(int x, A &amp;a);             //该函数是类A的友元函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend void B::set_show(int x, A &amp;a);   //该函数是友元成员函数的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">    void show() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void B::set_show(int x, A &amp;a)       //只有在定义类A后才能定义该函数，毕竟，它被设为友元是为了访问类A的成员</span><br><span class="line">&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line">    class B b;</span><br><span class="line"></span><br><span class="line">    b.set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-信号处理"><a href="#C-信号处理" class="headerlink" title="C++ 信号处理"></a>C++ 信号处理</h2><p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。</p>
<p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。</csignal></p>
<table>
<thead>
<tr>
<th>信号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>程序的异常终止，如调用 abort。</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>错误的算术运算，比如除以零或导致溢出的操作。</td>
</tr>
<tr>
<td>SIGILL</td>
<td>检测非法指令。</td>
</tr>
<tr>
<td>SIGINT</td>
<td>接收到交互注意信号。</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>非法访问内存。</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>发送到程序的终止请求。</td>
</tr>
</tbody>
</table>
<h3 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal() 函数"></a>signal() 函数</h3><p>C++ 信号处理库提供了 signal 函数，用来<strong>捕获突发事件</strong>。以下是 signal() 函数的语法：</p>
<blockquote>
<p>void (*signal (int sig, void (*func)(int)))(int); </p>
</blockquote>
<p>这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;csignal&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void signalHandler( int signum )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\n&quot;;</span><br><span class="line"> </span><br><span class="line">    // 清理并关闭</span><br><span class="line">    // 终止程序  </span><br><span class="line"> </span><br><span class="line">   exit(signum);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    // 注册信号 SIGINT 和信号处理程序</span><br><span class="line">    signal(SIGINT, signalHandler);  </span><br><span class="line"> </span><br><span class="line">    while(1)&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;</span><br><span class="line">       sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line"></span><br><span class="line">现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure>
<h3 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise() 函数"></a>raise() 函数</h3><p>您可以使用函数 raise() <strong>生成信号</strong>，该函数带有一个整数信号编号作为参数，语法如下：</p>
<blockquote>
<p>int raise (signal sig);</p>
</blockquote>
<p>在这里，sig 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;csignal&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void signalHandler( int signum )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\n&quot;;</span><br><span class="line"> </span><br><span class="line">    // 清理并关闭</span><br><span class="line">    // 终止程序 </span><br><span class="line"> </span><br><span class="line">   exit(signum);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    // 注册信号 SIGINT 和信号处理程序</span><br><span class="line">    signal(SIGINT, signalHandler);  </span><br><span class="line"> </span><br><span class="line">    while(++i)&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;</span><br><span class="line">       if( i == 3 )&#123;</span><br><span class="line">          raise( SIGINT);</span><br><span class="line">       &#125;</span><br><span class="line">       sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure></p>
<h2 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++ 多线程"></a>C++ 多线程</h2><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。</p>
<h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>pthread_t：线程ID<br>pthread_attr_t：线程属性</p>
<ol>
<li><p>操纵函数<br>pthread_create()：创建一个线程<br>pthread_exit()：终止当前线程<br>pthread_cancel()：中断另外一个线程的运行，Android中没有<br>pthread_join()：阻塞当前的线程，直到另外一个线程运行结束<br>pthread_attr_init()：初始化线程的属性<br>pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）<br>pthread_attr_getdetachstate()：获取脱离状态的属性<br>pthread_attr_destroy()：删除线程的属性<br>pthread_kill()：向线程发送一个信号</p>
</li>
<li><p>同步函数<br>pthread_mutex_init() 初始化互斥锁<br>pthread_mutex_destroy() 删除互斥锁<br>pthread_mutex_lock()：占有互斥锁（阻塞操作）<br>pthread_mutex_trylock()：试图占有互斥锁（不阻塞操作）。即，当互斥锁空闲时，将占有该锁；否则，立即返回。<br>pthread_mutex_unlock(): 释放互斥锁<br>pthread_cond_init()：初始化条件变量<br>pthread_cond_destroy()：销毁条件变量<br>pthread_cond_signal(): 唤醒第一个调用pthread_cond_wait()而进入睡眠的线程<br>pthread_cond_wait(): 等待条件变量的特殊条件发生<br>Thread-local storage（或者以Pthreads术语，称作线程特有数据）：<br>pthread_key_create(): 分配用于标识进程中线程特定数据的键<br>pthread_setspecific(): 为指定线程特定数据键设置线程特定绑定<br>pthread_getspecific(): 获取调用线程的键绑定，并将该绑定存储在 value 指向的位置中<br>pthread_key_delete(): 销毁现有线程特定数据键<br>pthread_attr_getschedparam();获取线程优先级<br>pthread_attr_setschedparam();设置线程优先级</p>
</li>
<li><p>工具函数<br>pthread_equal(): 对两个线程的线程标识号进行比较<br>pthread_detach(): 分离线程<br>pthread_self(): 查询线程自身线程标识号</p>
</li>
</ol>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>
<blockquote>
<p>#include &lt;pthread.h&gt;<br>pthread_create (thread, attr, start_routine, arg) </p>
</blockquote>
<p>在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>thread</td>
<td>指向线程标识符指针。</td>
</tr>
<tr>
<td>attr</td>
<td>一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>
</tr>
<tr>
<td>start_routine</td>
<td>线程运行函数起始地址，一旦线程被创建就会执行。</td>
</tr>
<tr>
<td>arg</td>
<td>运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>
</tr>
</tbody>
</table>
<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>
<blockquote>
<p>#include &lt;pthread.h&gt;<br>pthread_exit (status) </p>
</blockquote>
<p>在这里，pthread_exit 用于显式地退出一个线程。通常情况下，<strong>pthread_exit() 函数是在线程完成工作后无需继续存在时被调用</strong>。</p>
<p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS     5</span><br><span class="line"> </span><br><span class="line">struct thread_data&#123;</span><br><span class="line">   int  thread_id;</span><br><span class="line">   char *message;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void *PrintHello(void *threadarg)</span><br><span class="line">&#123;</span><br><span class="line">   struct thread_data *my_data;</span><br><span class="line"> </span><br><span class="line">   my_data = (struct thread_data *) threadarg;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Thread ID : &quot; &lt;&lt; my_data-&gt;thread_id ;</span><br><span class="line">   cout &lt;&lt; &quot; Message : &quot; &lt;&lt; my_data-&gt;message &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   pthread_t threads[NUM_THREADS];</span><br><span class="line">   struct thread_data td[NUM_THREADS];</span><br><span class="line">   int rc;</span><br><span class="line">   int i;</span><br><span class="line"> </span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt;&quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      td[i].thread_id = i;</span><br><span class="line">      td[i].message = (char*)&quot;This is message&quot;;</span><br><span class="line">      rc = pthread_create(&amp;threads[i], NULL,</span><br><span class="line">                          PrintHello, (void *)&amp;td[i]);</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Wno-write-strings test.cpp -lpthread -o test.o</span><br><span class="line">$ ./test.o</span><br><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">Thread ID : 0 Message : This is message</span><br><span class="line">main() : creating thread, Thread ID : 21</span><br><span class="line"> Message : This is message</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">Thread ID : 2 Message : This is message</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Thread ID : 3 Message : This is message</span><br><span class="line">Thread ID : 4 Message : This is message</span><br></pre></td></tr></table></figure></p>
<h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><p>我们可以使用以下两个函数来连接或分离线程：</p>
<blockquote>
<p>pthread_join (threadid, status)<br>pthread_detach (threadid) </p>
</blockquote>
<p><strong>pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止</strong>。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p>
<p>一个线程默认的状态是joinable，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符。只有当你<strong>调用了pthread_join之后这些资源才会被释放</strong>。</p>
<p>这个实例演示了如何使用 pthread_join() 函数来等待线程的完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS     5</span><br><span class="line"> </span><br><span class="line">void *wait(void *t)</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   long tid;</span><br><span class="line"> </span><br><span class="line">   tid = (long)t;</span><br><span class="line"> </span><br><span class="line">   sleep(1);</span><br><span class="line">   cout &lt;&lt; &quot;Sleeping in thread &quot; &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Thread with id : &quot; &lt;&lt; tid &lt;&lt; &quot;  ...exiting &quot; &lt;&lt; endl;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int rc;</span><br><span class="line">   int i;</span><br><span class="line">   pthread_t threads[NUM_THREADS];</span><br><span class="line">   pthread_attr_t attr;</span><br><span class="line">   void *status;</span><br><span class="line"> </span><br><span class="line">   // 初始化并设置线程为可连接的（joinable）</span><br><span class="line">   pthread_attr_init(&amp;attr);</span><br><span class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"> </span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt; &quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      rc = pthread_create(&amp;threads[i], NULL, wait, (void *)&amp;i );</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // 删除属性，并等待其他线程</span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = pthread_join(threads[i], &amp;status);</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to join,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; &quot;Main: completed thread id :&quot; &lt;&lt; i ;</span><br><span class="line">      cout &lt;&lt; &quot;  exiting with status :&quot; &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Main: program exiting.&quot; &lt;&lt; endl;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">main() : creating thread, 2</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 4  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 3  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 2  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 1  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Main: completed thread id :0  exiting with status :0</span><br><span class="line">Main: completed thread id :1  exiting with status :0</span><br><span class="line">Main: completed thread id :2  exiting with status :0</span><br><span class="line">Main: completed thread id :3  exiting with status :0</span><br><span class="line">Main: completed thread id :4  exiting with status :0</span><br><span class="line">Main: program exiting.</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-tutorial.html</a><br><a href="https://www.jianshu.com/p/34d88df0cfe0" target="_blank" rel="noopener">https://www.jianshu.com/p/34d88df0cfe0</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/03/android-ndk-jni-invoke/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/03/android-ndk-jni-invoke/" itemprop="url">JNI 的调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-03T13:19:25+08:00">
                2020-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-NDK/" itemprop="url" rel="index">
                    <span itemprop="name">Android NDK</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="注册native函数"><a href="#注册native函数" class="headerlink" title="注册native函数"></a>注册native函数</h2><p>JNI有两种注册native方法的途径：</p>
<blockquote>
<ul>
<li>静态注册：<br>先由Java得到本地方法的声明，然后再通过JNI实现该声明方法</li>
<li>动态注册：<br>先通过JNI重载JNI_OnLoad()实现本地方法，然后直接在Java中调用本地方法。</li>
</ul>
</blockquote>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册就是根据函数名来遍历Java和JNI函数之间的关联，而且要求JNI层函数的名字必须遵循特定的格式。具体的实现很简单，首先在Java代码中声明native函数，然后通过javah来生成native函数的具体形式，接下来在JNI代码中实现这些函数即可。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class JniDemo1&#123;</span><br><span class="line">       static &#123;</span><br><span class="line">             System.loadLibrary(&quot;samplelib_jni&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private native void nativeMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接来下通过javah来产生jni代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -d ./jni/ -classpath /Users/YOUR_NAME/Library/Android/sdk/platforms/android-21/android.jar:../../build/intermediates/classes/debug/ com.xxxpackagename.JniDemo1</span><br></pre></td></tr></table></figure></p>
<p>然后就会得到一个JNI的.h文件，里面包含这几个native函数的声明，观察一下文件名以及函数名。JNI方法名的规范：</p>
<blockquote>
<p>返回值 + Java前缀+全路径类名+方法名+参数1JNIEnv+参数2jobject+其他参数</p>
</blockquote>
<p>注意事项：</p>
<blockquote>
<ul>
<li>注意分隔符：<br>Java前缀与类名以及类名之间的包名和方法名之间使用”_”进行分割；</li>
<li>注意静态：<br>如果在Java中声明的方法是”静态的”，则native方法也是static。否则不是。</li>
</ul>
</blockquote>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册，也就是通过RegisterNatives方法把C/C++中的方法映射到Java中的native方法，而无需遵循特定的方法命名格式。</p>
<p>当我们使用System.loadLibarary()方法加载so库的时候，Java虚拟机就会找到这个<strong>JNI_OnLoad</strong>函数并调用该函数，<strong>这个函数的作用是告诉Dalvik虚拟机此C库使用的是哪一个JNI版本</strong>，如果你的库里面没有写明JNI_OnLoad()函数，VM会默认该库使用最老的JNI 1.1版本。由于最新版本的JNI做了很多扩充，也优化了一些内容，如果需要使用JNI新版本的功能，就必须在JNI_OnLoad()函数声明JNI的版本，同时也可以在该函数中做一些初始化的动作。该函数前面也有三个关键字分别是JNIEXPORT，JNICALL ，jint。其中JNIEXPORT和JNICALL是两个宏定义，用于指定该函数时JNI函数。jint是JNI定义的数据类型，因为Java层和C/C++的数据类型或者对象不能直接相互的引用或者使用，JNI层定义了自己的数据类型，用于衔接Java层和JNI层。与JNI_OnLoad()函数相对应的有JNI_OnUnload()函数，当虚拟机释放的该C库的时候，则会调用JNI_OnUnload()函数来进行善后清除工作。</p>
<p>该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义一下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DestroyJavaVM</span><br><span class="line">AttachCurrentThread</span><br><span class="line">DetachCurrentThread</span><br><span class="line">GetEnv</span><br></pre></td></tr></table></figure></p>
<p>举例说明，首先是加载so库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class JniDemo1&#123;</span><br><span class="line">       static &#123;</span><br><span class="line">             System.loadLibrary(&quot;samplelib_jni&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在jni中的实现，并且在这个函数里面去动态的注册native方法，完整的参考代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &quot;Log4Android.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static const char *className = &quot;com/gebilaolitou/jnidemo/JNIDemo2&quot;;</span><br><span class="line"></span><br><span class="line">static void sayHello(JNIEnv *env, jobject, jlong handle) &#123;</span><br><span class="line">    LOGI(&quot;JNI&quot;, &quot;native: say hello ###&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static JNINativeMethod gJni_Methods_table[] = &#123;</span><br><span class="line">    &#123;&quot;sayHello&quot;, &quot;(J)V&quot;, (void*)sayHello&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int jniRegisterNativeMethods(JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;JNI&quot;,&quot;Registering %s natives\n&quot;, className);</span><br><span class="line">    clazz = (env)-&gt;FindClass( className);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;Native registration unable to find class &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    if ((env)-&gt;RegisterNatives(clazz, gJni_Methods_table, numMethods) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;RegisterNatives failed for &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (env)-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jint JNI_OnLoad(JavaVM* vm, void* reserved)&#123;</span><br><span class="line">    LOGI(&quot;JNI&quot;, &quot;enter jni_onload&quot;);</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = NULL;</span><br><span class="line">    jint result = -1;</span><br><span class="line"></span><br><span class="line">    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jniRegisterNativeMethods(env, className, gJni_Methods_table, sizeof(gJni_Methods_table) / sizeof(JNINativeMethod));</span><br><span class="line"></span><br><span class="line">    return JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>我们一个个来说，首先看JNI_OnLoad函数的实现，里面代码很简单，主要就是两个代码块，一个是if语句，一个是jniRegisterNativeMethods函数的实现。那我们一个一个来分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">    return result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了GetEnv函数时为了<strong>获取JNIEnv结构体指针</strong>，其实JNIEnv结构体指向了一个函数表，该函数表指向了对应的JNI函数，我们通过这些JNI函数实现JNI编程。</p>
<p>然后就调用了jniRegisterNativeMethods函数来实现注册，这里面注意一个静态变量gJni_Methods_table。它其实代表了一个native方法的数组，如果你在一个Java类中有一个native方法，这里它的size就是1，如果是两个native方法，它的size就是2，大家看下这个gJni_Methods_table变量的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod gJni_Methods_table[] = &#123;</span><br><span class="line">    &#123;&quot;sayHello&quot;, &quot;(J)V&quot;, (void*)sayHello&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们看到他的类型是JNINativeMethod ，那我们就来研究下JNINativeMethod</p>
<p>JNI允许我们提供一个<strong>函数映射表</strong>，注册给Java虚拟机，这样JVM就可以用函数映射表来调用相应的函数。这样就可以不必通过函数名来查找需要调用的函数了。Java与JNI通过JNINativeMethod的结构来建立联系，它被定义在jni.h中，其结构内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123; </span><br><span class="line">    const char* name; </span><br><span class="line">    const char* signature; </span><br><span class="line">    void* fnPtr; </span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure></p>
<p>这里面有3个变量，那我们就依次来讲解下：<br>第一个变量name，代表的是Java中的函数名<br>第二个变量signature，代表的是Java中的参数和返回值<br>第三个变量fnPtr，代表的是的指向C函数的函数指针</p>
<p>下面我们再来看下jniRegisterNativeMethods函数内部的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int jniRegisterNativeMethods(JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;JNI&quot;,&quot;Registering %s natives\n&quot;, className);</span><br><span class="line">    clazz = (env)-&gt;FindClass( className);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;Native registration unable to find class &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    if ((env)-&gt;RegisterNatives(clazz, gJni_Methods_table, numMethods) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;RegisterNatives failed for &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (env)-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过clazz = (env)-&gt;FindClass( className);找到声明native方法的类<br>然后通过调用<strong>RegisterNatives</strong>函数将注册函数的Java类，以及注册函数的数组，以及个数注册在一起，这样就实现了绑定。</p>
<p>上面在讲解JNINativeMethod结构体的时候，提到一个概念，就是”signature”即签名，我们下面就来讲解下。</p>
<h2 id="JNI中的签名"><a href="#JNI中的签名" class="headerlink" title="JNI中的签名"></a>JNI中的签名</h2><p>Java是支持函数重载的。但如果JNI仅仅是根据函数名，是没有办法找到重载的函数的，所以为了解决这个问题，JNI就衍生了一个概念——“签名”，即<strong>参数类型和返回值类型的组合</strong>。如果拥有一个该函数的签名信息和这个函数的函数名，我们就可以顺序的找到对应的Java层中的函数了。</p>
<h3 id="查看类中的方法的签名"><a href="#查看类中的方法的签名" class="headerlink" title="查看类中的方法的签名"></a>查看类中的方法的签名</h3><p>可以使用 java -p命令(建议使用该命令来对比签名)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">javap -s -p MainActivity.class</span><br><span class="line"></span><br><span class="line">Compiled from &quot;MainActivity.java&quot;</span><br><span class="line">public class com.example.hellojni.MainActivity extends android.app.Activity &#123;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Signature: ()V</span><br><span class="line"></span><br><span class="line">  public com.example.hellojni.MainActivity();</span><br><span class="line">    Signature: ()V</span><br><span class="line"></span><br><span class="line">  protected void onCreate(android.os.Bundle);</span><br><span class="line">    Signature: (Landroid/os/Bundle;)V</span><br><span class="line"></span><br><span class="line">  public boolean onCreateOptionsMenu(android.view.Menu);</span><br><span class="line">    Signature: (Landroid/view/Menu;)Z</span><br><span class="line"></span><br><span class="line">  public native java.lang.String stringFromJNI(); //native 方法</span><br><span class="line">    Signature: ()Ljava/lang/String;  //签名</span><br><span class="line"></span><br><span class="line">  public native int max(int, int); //native 方法</span><br><span class="line">    Signature: (II)I    //签名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到上面有()V ，(Landroid/os/Bundle;)V，(Landroid/view/Menu;)Z，(II)I我们一脸懵逼，这是什么鬼，所以我们要来研究下签名的格式</p>
<h3 id="JNI定义的函数签名信息"><a href="#JNI定义的函数签名信息" class="headerlink" title="JNI定义的函数签名信息"></a>JNI定义的函数签名信息</h3><blockquote>
<p>(参数1类型标示；参数2类型标示；参数3类型标示…)返回值类型标示</p>
</blockquote>
<p>当参数为引用类型的时候，参数类型的标示的根式为”L包名”，其中包名的.(点)要换成”/“，看我上面的例子就差不多，比如String就是Ljava/lang/String，Menu为Landroid/view/Menu。</p>
<p>如果是基本类类型，其签名如下：</p>
<table>
<thead>
<tr>
<th>类型标示</th>
<th>Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
</tr>
</tbody>
</table>
<p>除了boolean和long，其他都是首字母大写。如果返回值是void，对应的签名是<strong>V</strong>。</p>
<p>这里重点说1个特殊的类型，一个是数组及Array:</p>
<table>
<thead>
<tr>
<th>类型标示</th>
<th>Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>[签名</td>
<td>数组</td>
</tr>
<tr>
<td>[i</td>
<td>int[]</td>
</tr>
<tr>
<td>[Ljava/lang/Object</td>
<td>String[]</td>
</tr>
</tbody>
</table>
<h2 id="Native调用Java代码"><a href="#Native调用Java代码" class="headerlink" title="Native调用Java代码"></a>Native调用Java代码</h2><p>上面讲解了如何从JNI中调用Java类中的方法，其实在jni.h中已经定义了一系列函数来实现这一目的，下面我们就以此举例说明：</p>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>为了能够在C/C++中调用Java中的类，jni.h的头文件专门定义了jclass类型表示Java中Class类。JNIEnv中有3个函数可以获取jclass。</p>
<blockquote>
<ul>
<li>jclass FindClass(const char* clsName)：<br>通过类的名称来获取jclass。</li>
<li>jclass GetObjectClass(jobject obj)：<br>通过对象实例来获取jclass，相当于Java中的getClass()函数</li>
<li>jclass getSuperClass(jclass obj)：<br>通过jclass可以获取其父类的jclass对象</li>
</ul>
</blockquote>
<p>通过类的名称获取jclass(类的全名，这时候包名不是用’”.”点号而是用”/“来区分的)。比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取Java中的String对象的class对象</span><br><span class="line">jclass jcl_string=env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br></pre></td></tr></table></figure></p>
<h3 id="获取属性方法"><a href="#获取属性方法" class="headerlink" title="获取属性方法"></a>获取属性方法</h3><p>为了在C/C++获取Java层的属性和方法，JNI在jni.h头文件中定义了jfieldID和jmethodID这两种类型来分别代表Java端的属性和方法。</p>
<p>常见的调用Java层的方法如下，一般是使用JNIEnv来进行操作：</p>
<blockquote>
<p>GetFieldID/GetMethodID：获取某个属性/某个方法<br>GetStaticFieldID/GetStaticMethodID：获取某个静态属性/静态方法</p>
</blockquote>
<p>方法的具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jfieldID GetFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jfieldID GetStaticFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jmethodID GetStaticMethodID(JNIEnv *env, jclass clazz,const char *name, const char *sig);</span><br></pre></td></tr></table></figure></p>
<p>他们都是4个入参，并且都一样。JNIEnv代表一个JNI环境接口，jclass上面也说了代表Java层中的”类”，name则代表方法名或者属性名，那最后一个char *sig代表签名。</p>
<h3 id="构造一个对象"><a href="#构造一个对象" class="headerlink" title="构造一个对象"></a>构造一个对象</h3><p>常用的JNI中创建对象的方法如下：</p>
<blockquote>
<p>jobject NewObject(jclass clazz, jmethodID methodID, …)</p>
</blockquote>
<p>比如有我们知道Java类中可能有多个构造函数，当我们要指定调用某个构造函数的时候，会调用下面这个方法，即把指定的构造函数传入进去即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">obj = (*env)-&gt;NewObject(env, cls, mid);</span><br></pre></td></tr></table></figure></p>
<p>现在我们来看下他上面的二个主要参数</p>
<blockquote>
<p>clazz：是需要创建的Java对象的Class对象<br>methodID：是传递一个方法ID，想一想Java对象创建的时候，需要执行什么操作？就是执行构造函数。</p>
</blockquote>
<p>有人会说这要走两行代码，有没有一行代码的，是有的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobject NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);</span><br></pre></td></tr></table></figure></p>
<p>这里多了一个参数，即jvalue *args，这里是args代表的是对应构造函数的所有参数的，我们可以应将传递给构造函数的所有参数放在jvalues类型的数组args中，该数组紧跟着放在methodID参数的后面。NewObject()收到数组中的这些参数后，将把它们传给所要调用的Java方法。</p>
<p>上面说到，参数是个数组，如果参数不是数组怎么处理，jni.h同样也提供了一个方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobject NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);</span><br></pre></td></tr></table></figure></p>
<p>这个方法和上面不同在于，这里将构造函数的所有参数放到在va_list类型的参数args中，该参数紧跟着放在methodID参数的后面。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>JNI获取类的成员变量的ID调用GetFieldID获取，通过Set[类型]Field修改变量值。</li>
<li>JNI获取类的静态变量的ID调用GetStaticFieldID获取，通过SetStatic[类型]Field修改变量值。</li>
<li>JNI获取类的方法的ID调用GetMethodID获取，通过Call[类型]Method调用方法。</li>
<li>JNI获取类的静态方法的ID调用GetStaticMethodID获取，通过CallStatic[类型]Method调用方法。</li>
<li>JNI获取类的构造方法的ID调用GetMethodID获取，通过NewObject构造，构造函数名为”<init>“。</init></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/b71aeb4ed13d" target="_blank" rel="noopener">https://www.jianshu.com/p/b71aeb4ed13d</a><br><a href="https://www.jianshu.com/p/0f34c097028a" target="_blank" rel="noopener">JNI学习Demo</a><br><a href="https://www.jianshu.com/p/83f3ec4f3ac1" target="_blank" rel="noopener">JNI访问Java变量和方法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/02/android-ndk-jni/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/02/android-ndk-jni/" itemprop="url">JNI 详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-02T10:40:44+08:00">
                2020-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-NDK/" itemprop="url" rel="index">
                    <span itemprop="name">Android NDK</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JNI，全称为Java Native Interface，即Java本地接口，JNI是Java调用Native 语言的一种特性。通过JNI可以使得Java与C/C++机型交互。即可以在Java代码中调用C/C++等语言的代码或者在C/C++代码中调用Java代码。由于JNI是JVM规范的一部分，因此可以将我们写的JNI的程序在任何实现了JNI规范的Java虚拟机中运行。</p>
<p>JNI的主要竞争优势在于：它在设计之初就确保了二进制的兼容性，JNI编写的应用程序兼容性以及其在某些具体平台上的Java虚拟机兼容性(当谈及JNI时，这里并不特比针对Davik虚拟机，JNI适用于所有JVM虚拟机)。这就是为什么C/C++编译后的代码无论在任何平台上都能执行。不过，一些早期版本并不支持二进制兼容。二进制兼容性是一种程序兼容性类型，允许一个程序在不改变其可执行文件的条件下在不同的编译环境中工作。</p>
<p>JNI下一共涉及到三个角色：C/C++代码、本地方法接口类、Java层中具体业务类。</p>
<h2 id="JNI的命名规则"><a href="#JNI的命名规则" class="headerlink" title="JNI的命名规则"></a>JNI的命名规则</h2><p>举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNIExport jstring JNICALL Java_com_example_hellojni_MainActivity_stringFromJNI( JNIEnv* env,jobject thiz )</span><br></pre></td></tr></table></figure></p>
<p>jstring 是返回值类型<br>Java_com_example_hellojni 是包名<br>MainActivity 是类名<br>stringFromJNI 是方法名</p>
<p>其中JNIExport和JNICALL是不固定保留的关键字不要修改</p>
<h2 id="如何实现JNI"><a href="#如何实现JNI" class="headerlink" title="如何实现JNI"></a>如何实现JNI</h2><p>JNI开发流程的步骤：</p>
<blockquote>
<ul>
<li>第1步：在Java中先声明一个native方法</li>
<li>第2步：编译Java源文件javac得到.class文件</li>
<li>第3步：通过javah -jni命令导出JNI的.h头文件</li>
<li>第4步：使用Java需要交互的本地代码，实现在Java中声明的Native方法（如果Java需要与C++交互，那么就用C++实现Java的Native方法。）</li>
<li>第5步：将本地代码编译成动态库(Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib)</li>
<li>第6步：通过Java命令执行Java程序，最终实现Java调用本地代码。</li>
</ul>
</blockquote>
<p>PS：javah 是JDK自带的一个命令，-jni参数表示将class 中用到native 声明的函数生成JNI 规则的函数</p>
<p><img src="/2020/01/02/android-ndk-jni/jni-flow.webp" alt title="JNI开发流程"></p>
<h2 id="JNI结构"><a href="#JNI结构" class="headerlink" title="JNI结构"></a>JNI结构</h2><p><img src="/2020/01/02/android-ndk-jni/jni-struct.webp" alt title="JNI结构"><br>这张JNI函数表的组成就像C++的虚函数表。虚拟机可以运行多张函数表，举例来说，一张调试函数表，另一张是调用函数表。JNI接口指针仅在当前线程中起作用。这意味着指针不能从一个线程进入另一个线程。然而，可以在不同的线程中调用本地方法。</p>
<p><img src="/2020/01/02/android-ndk-jni/jni-interface.webp" alt title="JNI接口"></p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (JNIEnv *env, jobject obj, jint i, jstring s)</span><br><span class="line">&#123;</span><br><span class="line">     const char *str = (*env)-&gt;GetStringUTFChars(env, s, 0); </span><br><span class="line">     (*env)-&gt;ReleaseStringUTFChars(env, s, str); </span><br><span class="line">     return 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面的方法有三个入参，我们就依次来看下：</p>
<blockquote>
<ul>
<li>*env：一个接口指针</li>
<li>obj：在本地方法中声明的对象引用</li>
<li>i和s：用于传递的参数</li>
</ul>
</blockquote>
<p>关于obj、i和s的类型大家可以参考下面的JNI数据类型，JNI有自己的原始数据类型和数据引用类型如下：</p>
<p><img src="/2020/01/02/android-ndk-jni/jni-type.webp" alt></p>
<h2 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h2><p>Java语言的执行环境是Java虚拟机(JVM)，JVM其实是主机环境中的一个进程，每个JVM虚拟机都在本地环境中有一个JavaVM结构体，该结构体在创建Java虚拟机时被返回，在JNI环境中创建JVM的函数为JNI_CreateJavaVM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNI_CreateJavaVM(JavaVM **pvm, void **penv, void*args);</span><br></pre></td></tr></table></figure></p>
<h3 id="JavaVM"><a href="#JavaVM" class="headerlink" title="JavaVM"></a>JavaVM</h3><p>JavaVM是Java虚拟机在JNI层的代表，<strong>JNI全局仅仅有一个JavaVM结构中封装了一些函数指针（或叫函数表结构）</strong>，JavaVM中封装的这些函数指针主要是对JVM操作接口。另外，在C和C++中的JavaVM的定义有所不同，在C中JavaVM是JNIInvokeInterface_类型指针，而在C++中有对JNIInvokeInterface_进行了一次封装，比C中少了一个参数，这也是为什么JNI代码更推荐使用C++来编写的原因。</p>
<h3 id="JNIEnv"><a href="#JNIEnv" class="headerlink" title="JNIEnv"></a>JNIEnv</h3><p>JNIEnv是一个线程相关的结构体，该结构体代表了Java在本线程的执行环境。该 JNIEnv 将用于线程本地存储。因此，您<strong>无法在线程之间共享 JNIEnv</strong>。</p>
<p>一个JVM对应一个JavaVM结构，而一个JVM中可能创建多个Java线程，每个线程对应一个JNIEnv结构，它们保存在线程本地存储TLS中。因此，不同的线程的JNIEnv是不同，也不能相互共享使用。JNIEnv结构也是一个函数表，在本地代码中通过JNIEnv的函数表来操作Java数据或者调用Java方法。也就是说，只要在本地代码中拿到了JNIEnv结构，就可以在本地代码中调用Java代码。</p>
<h4 id="JNIEnv的作用"><a href="#JNIEnv的作用" class="headerlink" title="JNIEnv的作用"></a>JNIEnv的作用</h4><ul>
<li>调用Java 函数：JNIEnv代表了Java执行环境，能够使用JNIEnv调用Java中的代码</li>
<li>操作Java代码：Java对象传入JNI层就是jobject对象，需要使用JNIEnv来操作这个Java对象</li>
</ul>
<h4 id="JNIEnv的创建"><a href="#JNIEnv的创建" class="headerlink" title="JNIEnv的创建"></a>JNIEnv的创建</h4><p>JNIEnv 创建与释放：从JavaVM获得，这里面又分为C与C++，我们就依次来看下：</p>
<ul>
<li>C 中——JNIInvokeInterface：JNIInvokeInterface是C语言环境中的JavaVM结构体，调用 (*AttachCurrentThread)(JavaVM*, JNIEnv*, void) 方法，能够获得JNIEnv结构体</li>
<li>C++中 ——_JavaVM：_JavaVM是C++中JavaVM结构体，调用jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) 方法，能够获取JNIEnv结构体；</li>
</ul>
<h4 id="JNIEnv的释放"><a href="#JNIEnv的释放" class="headerlink" title="JNIEnv的释放"></a>JNIEnv的释放</h4><ul>
<li>C 中释放：调用JavaVM结构体JNIInvokeInterface中的(*DetachCurrentThread)(JavaVM*)方法，能够释放本线程的JNIEnv</li>
<li>C++ 中释放：调用JavaVM结构体_JavaVM中的jint DetachCurrentThread(){ return functions-&gt;DetachCurrentThread(this); } 方法，就可以释放 本线程的JNIEnv</li>
</ul>
<h4 id="JNIEnv与线程"><a href="#JNIEnv与线程" class="headerlink" title="JNIEnv与线程"></a>JNIEnv与线程</h4><p>JNIEnv是线程相关的，即在每一个线程中都有一个JNIEnv指针，每个JNIEnv都是线程专有的，其他线程不能使用本线程中的JNIEnv，即线程A不能调用线程B的JNIEnv。所以JNIEnv不能跨线程。</p>
<h4 id="JNIEnv结构"><a href="#JNIEnv结构" class="headerlink" title="JNIEnv结构"></a>JNIEnv结构</h4><p>JNIEnv是一个指针，指向一个线程相关的结构，线程相关结构指向JNI函数指针数组，这个数组中存放了大量的JNI函数指针，这些指针指向了详细的JNI函数：</p>
<p><img src="/2020/01/02/android-ndk-jni/jnienv-struct.webp" alt title="JNIEnv结构图"></p>
<h4 id="与JNIEnv相关的常用函数"><a href="#与JNIEnv相关的常用函数" class="headerlink" title="与JNIEnv相关的常用函数"></a>与JNIEnv相关的常用函数</h4><h5 id="创建Java中的对象"><a href="#创建Java中的对象" class="headerlink" title="创建Java中的对象"></a>创建Java中的对象</h5><blockquote>
<ul>
<li>jobject NewObject(JNIEnv *env, jclass clazz,jmethodID methodID, …)：</li>
<li>jobject NewObjectA(JNIEnv *env, jclass clazz,jmethodID methodID, const jvalue *args)：</li>
<li>jobject NewObjectV(JNIEnv *env, jclass clazz,jmethodID methodID, va_list args)：</li>
</ul>
</blockquote>
<p>第一个参数jclass class 代表的你要创建哪个类的对象，第二个参数,jmethodID methodID代表你要使用那个构造方法ID来创建这个对象。只要有jclass和jmethodID，我们就可以在本地方法创建这个Java类的对象。</p>
<h5 id="创建Java类中的String对象"><a href="#创建Java类中的String对象" class="headerlink" title="创建Java类中的String对象"></a>创建Java类中的String对象</h5><blockquote>
<p>jstring NewString(JNIEnv *env, const jchar *unicodeChars, jsize len)：</p>
</blockquote>
<p>通过Unicode字符的数组来创建一个新的String对象。<br>env是JNI接口指针；unicodeChars是指向Unicode字符串的指针；len是Unicode字符串的长度。返回值是Java字符串对象，如果无法构造该字符串，则为null。</p>
<p>那有没有一个直接直接new一个utf-8的字符串的方法呢？答案是有的，就是jstring NewStringUTF(JNIEnv *env, const char *bytes)这个方法就是直接new一个编码为utf-8的字符串。</p>
<h5 id="创建类型为基本类型PrimitiveType的数组"><a href="#创建类型为基本类型PrimitiveType的数组" class="headerlink" title="创建类型为基本类型PrimitiveType的数组"></a>创建类型为基本类型PrimitiveType的数组</h5><blockquote>
<p>ArrayType New<primitivetype>Array(JNIEnv *env, jsize length)</primitivetype></p>
</blockquote>
<p>指定一个长度然后返回相应的Java基本类型的数组。用于构造一个新的数组对象，类型是原始类型。基本的原始类型如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>New<primitivetype>Array Routines</primitivetype></td>
<td>Array Type</td>
</tr>
<tr>
<td>NewBooleanArray()</td>
<td>jbooleanArray</td>
</tr>
<tr>
<td>NewByteArray()</td>
<td>jbyteArray</td>
</tr>
<tr>
<td>NewCharArray()</td>
<td>jcharArray</td>
</tr>
<tr>
<td>NewShortArray()</td>
<td>jshortArray</td>
</tr>
<tr>
<td>NewIntArray()</td>
<td>jintArray</td>
</tr>
<tr>
<td>NewLongArray()</td>
<td>jlongArray</td>
</tr>
<tr>
<td>NewFloatArray()</td>
<td>jfloatArray</td>
</tr>
<tr>
<td>NewDoubleArray()</td>
<td>jdoubleArray</td>
</tr>
</tbody>
</table>
<h5 id="创建类型为elementClass的数组"><a href="#创建类型为elementClass的数组" class="headerlink" title="创建类型为elementClass的数组"></a>创建类型为elementClass的数组</h5><blockquote>
<p>jobjectArray NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement);</p>
</blockquote>
<p>造一个新的数据组，类型是elementClass，所有类型都被初始化为initialElement。</p>
<h5 id="获取数组中某个位置的元素"><a href="#获取数组中某个位置的元素" class="headerlink" title="获取数组中某个位置的元素"></a>获取数组中某个位置的元素</h5><blockquote>
<p>jobject GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index);</p>
</blockquote>
<p>返回Object数组的一个元素</p>
<h5 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h5><blockquote>
<p>jsize GetArrayLength(JNIEnv *env, jarray array);</p>
</blockquote>
<p>获取array数组的长度.</p>
<h5 id="GetArrayElements"><a href="#GetArrayElements" class="headerlink" title="GetArrayElements"></a>GetArrayElements</h5><blockquote>
<p>NativeType *Get<primitivetype>ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy);</primitivetype></p>
</blockquote>
<p>返回指向数组元素的指针，如果操作失败则返回NULL。</p>
<p>这是用来<strong>返回原生数据类型数组体的家族函数</strong>。函数返回的指针在调用对应的ReleaseArrayElements()函数之前都是有效的（就是指针指向的区域没有被释放，是可以使用的）。因为这个函数返回的数组可能是Java数组的一份拷贝，所以直到调用ReleaseArrayElements()方法，对返回的数组所做的修改才会反映到原始数组中。</p>
<p>GetArrayElements()函数的返回值是和JVM相关的，如果JVM的GC支持pin操作，那么返回值就是指向原始数组的指针；否则返回的就是原始数组的一份拷贝的首地址。</p>
<p>如果isCopy不为NULL，如果进行了复制，则*isCopy设置为JNI_TRUE; 如果没有复制，则设置为JNI_FALSE。</p>
<p>下表描述了特定的原始数组元素访问器。您应该进行以下替换：</p>
<blockquote>
<ul>
<li>将GetArrayElements替换为下表中的一个实际原始元素访问器例程名称。</li>
<li>将ArrayType替换为相应的数组类型。</li>
<li>将NativeType替换为该例程的相应本地类型。</li>
</ul>
</blockquote>
<p>无论如何在JVM中表示布尔数组，GetBooleanArrayElements()始终返回指向jbooleans的指针，每个字节表示一个元素（解包表示）。其他类型的所有数组都保证在内存中是连续的。</p>
<table>
<thead>
<tr>
<th>GetArrayElements例程</th>
<th>数组类型</th>
<th>本地类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetBooleanArrayElements()</td>
<td>jbooleanArray</td>
<td>jboolean</td>
</tr>
<tr>
<td>GetByteArrayElements()</td>
<td>jbyteArray</td>
<td>jbyte</td>
</tr>
<tr>
<td>GetCharArrayElements()    jcharArray</td>
<td>jchar</td>
</tr>
<tr>
<td>GetShortArrayElements()</td>
<td>jshortArray</td>
<td>jshort</td>
</tr>
<tr>
<td>GetIntArrayElements()</td>
<td>jintArray</td>
<td>jint</td>
</tr>
<tr>
<td>GetLongArrayElements()</td>
<td>jlongArray</td>
<td>jlong</td>
</tr>
<tr>
<td>GetFloatArrayElements()</td>
<td>jfloatArray</td>
<td>jfloat</td>
</tr>
<tr>
<td>GetDoubleArrayElements()</td>
<td>jdoubleArray</td>
<td>jdouble</td>
</tr>
</tbody>
</table>
<h5 id="ReleaseArrayElements"><a href="#ReleaseArrayElements" class="headerlink" title="ReleaseArrayElements"></a>ReleaseArrayElements</h5><blockquote>
<p>void Release<primitivetype>ArrayElements(JNIEnv *env, ArrayType array, NativeType *elems, jint mode);</primitivetype></p>
</blockquote>
<p>一系列函数，通知VM本地代码不再需要访问elems。elems参数是使用相应的GetArrayElements()函数从数组派生的指针。<strong>如有必要，此函数会将对elems所做的所有更改复制回原始数组</strong>。</p>
<p>mode参数提供有关如何释放数组缓冲区的信息。如果elems不是数组中元素的副本，则mode无效。否则，模式会产生以下影响，如下表所示：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>复制回内容并释放elems缓冲区</td>
</tr>
<tr>
<td>JNI_COMMIT</td>
<td>复制回内容，但不释放elems缓冲区</td>
</tr>
<tr>
<td>JNI_ABORT</td>
<td>释放缓冲区而不复制回可能的更改</td>
</tr>
</tbody>
</table>
<p>在大多数情况下，程序员<strong>将“0”传递给mode参数，以确保固定和复制数组的一致行为</strong>。其他选项使程序员可以更好地控制内存管理，并且应该非常谨慎地使用。</p>
<p>关于更多JNI的常用方法，文档可以参考 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp9502" target="_blank" rel="noopener">JNI Functions</a></p>
<h2 id="JNI的引用"><a href="#JNI的引用" class="headerlink" title="JNI的引用"></a>JNI的引用</h2><p>在JNI规范中定义了三种引用：局部引用（Local Reference）、全局引用（Global Reference）、弱全局引用（Weak Global Reference）。</p>
<h3 id="局部引用-Local-Reference"><a href="#局部引用-Local-Reference" class="headerlink" title="局部引用(Local Reference)"></a>局部引用(Local Reference)</h3><p>局部引用，也成本地引用，通常是在函数中创建并使用。会阻止GC回收所有引用对象。</p>
<p>最常见的引用类型，基本上通过JNI返回来的引用都是局部引用，例如使用NewObject，就会返回创建出来的实例的局部引用，局部引用值在该native函数有效，所有在该函数中产生的局部引用，都会<strong>在函数返回的时候自动释放(freed)，也可以使用DeleteLocalRef函数手动释放该应用</strong>。之所以使用DeleteLocalRef函数：实际上局部引用存在，就会防止其指向对象被垃圾回收期回收，尤其是当一个局部变量引用指向一个很庞大的对象，或是在一个循环中生成一个局部引用，最好的做法就是在使用完该对象后，或在该循环尾部把这个引用是释放掉，以确保在垃圾回收器被触发的时候被回收。在局部引用的有效期中，可以传递到别的本地函数中，要强调的是它的有效期仍然只是在第一次的Java本地函数调用中，所以千万不能用C++全部变量保存它或是把它定义为C++静态局部变量。</p>
<h3 id="全局引用-Global-Reference"><a href="#全局引用-Global-Reference" class="headerlink" title="全局引用(Global Reference)"></a>全局引用(Global Reference)</h3><p>全局引用可以跨方法、跨线程使用，直到被开发者<strong>显式释放</strong>。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。能创建全部引用的函数只有NewGlobalRef，而释放它需要使用ReleaseGlobalRef函数</p>
<h3 id="弱全局引用-Weak-Global-Reference"><a href="#弱全局引用-Weak-Global-Reference" class="headerlink" title="弱全局引用(Weak Global Reference)"></a>弱全局引用(Weak Global Reference)</h3><p>与全局引用类似，创建跟删除都需要由编程人员来进行，不一样的是，弱引用将不会阻止垃圾回收期回收这个引用所指向的对象，所以在使用时需要多加小心，它所引用的对象可能是不存在的或者已经被回收。</p>
<p>通过使用NewWeakGlobalRef、ReleaseWeakGlobalRef来产生和解除引用。</p>
<h3 id="引用比较"><a href="#引用比较" class="headerlink" title="引用比较"></a>引用比较</h3><p>在给定两个引用，不管是什么引用，我们只需要调用IsSameObject函数来判断他们是否是指向相同的对象。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*env)-&gt;IsSameObject(env, obj1, obj2)</span><br></pre></td></tr></table></figure></p>
<p>如果obj1和obj2指向相同的对象，则返回JNI_TRUE(或者1)，否则返回JNI_FALSE(或者0),</p>
<p>PS：有一个特殊的引用需要注意：NULL，JNI中的NULL引用指向JVM中的null对象，如果obj是一个全局或者局部引用，使用(*env)-&gt;IsSameObject(env, obj, NULL)或者obj == NULL用来判断obj是否指向一个null对象即可。但是需要注意的是，IsSameObject用于弱全局引用与NULL比较时，返回值的意义是不同于局部引用和全局引用的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobject local_obj_ref = (*env)-&gt;NewObject(env, xxx_cls,xxx_mid);</span><br><span class="line">jobject g_obj_ref = (*env)-&gt;NewWeakGlobalRef(env, local_ref);</span><br><span class="line">// ... 业务逻辑处理</span><br><span class="line">jboolean isEqual = (*env)-&gt;IsSameObject(env, g_obj_ref, NULL);</span><br></pre></td></tr></table></figure></p>
<h2 id="UTF-8-和-UTF-16-字符串"><a href="#UTF-8-和-UTF-16-字符串" class="headerlink" title="UTF-8 和 UTF-16 字符串"></a>UTF-8 和 UTF-16 字符串</h2><p>Java 编程语言使用的是 UTF-16。为方便起见，JNI 还提供了使用修改后的 UTF-8 的方法。修改后的编码对 C 代码非常有用，因为它将 \u0000 编码为 0xc0 0x80，而不是 0x00。这样做的好处是，您可以依靠以零终止的 C 样式字符串，非常适合与标准 libc 字符串函数配合使用。但缺点是，您<strong>无法将任意 UTF-8 数据传递给 JNI 并期望它能够正常工作</strong>。</p>
<p>如果可能，使用 UTF-16 字符串执行操作通常会更快。Android 目前不需要 GetStringChars 的副本，而 GetStringUTFChars 需要分配和转换为 UTF-8。请注意，UTF-16 字符串不是以零终止的，并且允许使用 \u0000，因此您需要保留字符串长度和 jchar 指针。</p>
<p><strong>不要忘记 Release 您 Get 的字符串</strong>。字符串函数会返回 jchar* 或 jbyte*，它们是指向原始数据而非局部引用的 C 样式指针。这些指针在调用 Release 之前保证有效，这意味着在原生方法返回时不会释放这些指针。</p>
<p><strong>传递给 NewStringUTF 的数据必须采用修改后的 UTF-8 格式</strong>。一种常见的错误就是从文件或网络数据流中读取字符数据，并在未过滤的情况下将其传递给 NewStringUTF。除非您确定数据是有效的 MUTF-8（或 7 位 ASCII，这是一个兼容子集），否则您需要剔除无效字符或将它们转换为适当的修改后的 UTF-8 格式。如果不这样做，UTF-16 转换可能会产生意外的结果。CheckJNI 默认状态下为模拟器启用，它会扫描字符串并且在收到无效输入时会中止虚拟机。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/87ce6f565d37" target="_blank" rel="noopener">https://www.jianshu.com/p/87ce6f565d37</a><br><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp9502" target="_blank" rel="noopener">JNI Functions</a><br><a href="https://www.jianshu.com/p/67081d9b0a9c" target="_blank" rel="noopener">JNI的常用方法的中文API</a><br><a href="https://developer.android.google.cn/training/articles/perf-jni#%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">JNI 提示</a><br><a href="https://blog.csdn.net/afei__/article/details/81290711" target="_blank" rel="noopener">Android NDK 从入门到精通（汇总篇）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/24/c-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/c-language/" itemprop="url">C 语言笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T14:30:18+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p>
<p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p>
<ul>
<li>易于学习。</li>
<li>结构化语言。</li>
<li>它产生高效率的程序。</li>
<li>它可以处理底层的活动。</li>
<li>它可以在多种计算机平台上编译。</li>
</ul>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>C 程序主要包括以下部分：<br>1、预处理器指令<br>2、函数<br>3、变量<br>4、语句 &amp; 表达式<br>5、注释</p>
<p>让我们看一段简单的代码，可以输出单词 “Hello World”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   /* 我的第一个 C 程序 */</span><br><span class="line">   printf(&quot;Hello, World! \n&quot;);</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译 &amp; 执行 C 程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure></p>
<p>a.out 为可执行文件，如果是多个 c 代码的源码文件，编译方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test1.c test2.c -o main.out</span><br><span class="line">$ ./main.out</span><br></pre></td></tr></table></figure></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="C-的令牌（Tokens）"><a href="#C-的令牌（Tokens）" class="headerlink" title="C 的令牌（Tokens）"></a>C 的令牌（Tokens）</h3><p>C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Hello, World! \n&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这五个令牌分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf</span><br><span class="line">(</span><br><span class="line">&quot;Hello, World! \n&quot;</span><br><span class="line">)</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是<strong>区分大小写</strong>的编程语言。因此，在 C 中，Manpower 和 manpower 是两个不同的标识符。下面列出几个有效的标识符：</p>
<blockquote>
<p>mohd       zara    abc   move_name  a_123<br>myname50   _temp   j     a23b9      retVal</p>
</blockquote>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>声明自动变量</td>
</tr>
<tr>
<td>break</td>
<td>跳出当前循环</td>
</tr>
<tr>
<td>case</td>
<td>开关语句分支</td>
</tr>
<tr>
<td>char</td>
<td>声明字符型变量或函数返回值类型</td>
</tr>
<tr>
<td>const</td>
<td>声明只读变量</td>
</tr>
<tr>
<td>continue</td>
<td>结束当前循环，开始下一轮循环</td>
</tr>
<tr>
<td>default</td>
<td>开关语句中的”其它”分支</td>
</tr>
<tr>
<td>do</td>
<td>循环语句的循环体</td>
</tr>
<tr>
<td>double</td>
<td>声明双精度浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td>else</td>
<td>条件语句否定分支（与 if 连用）</td>
</tr>
<tr>
<td>enum</td>
<td>声明枚举类型</td>
</tr>
<tr>
<td>extern</td>
<td>声明变量或函数是在其它文件或本文件的其他位置定义</td>
</tr>
<tr>
<td>float</td>
<td>声明浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td>for</td>
<td>一种循环语句</td>
</tr>
<tr>
<td>goto</td>
<td>无条件跳转语句</td>
</tr>
<tr>
<td>if</td>
<td>条件语句</td>
</tr>
<tr>
<td>int</td>
<td>声明整型变量或函数</td>
</tr>
<tr>
<td>long</td>
<td>声明长整型变量或函数返回值类型</td>
</tr>
<tr>
<td>register</td>
<td>声明寄存器变量</td>
</tr>
<tr>
<td>return</td>
<td>子程序返回语句（可以带参数，也可不带参数）</td>
</tr>
<tr>
<td>short</td>
<td>声明短整型变量或函数</td>
</tr>
<tr>
<td>signed</td>
<td>声明有符号类型变量或函数</td>
</tr>
<tr>
<td>sizeof</td>
<td>计算数据类型或变量长度（即所占字节数）</td>
</tr>
<tr>
<td>static</td>
<td>声明静态变量</td>
</tr>
<tr>
<td>struct</td>
<td>声明结构体类型</td>
</tr>
<tr>
<td>switch</td>
<td>用于开关语句</td>
</tr>
<tr>
<td>typedef</td>
<td>用以给数据类型取别名</td>
</tr>
<tr>
<td>unsigned</td>
<td>声明无符号类型变量或函数</td>
</tr>
<tr>
<td>union</td>
<td>声明共用体类型</td>
</tr>
<tr>
<td>void</td>
<td>声明函数无返回值或无参数，声明无类型指针</td>
</tr>
<tr>
<td>volatile</td>
<td>说明变量在程序执行中可被隐含地改变</td>
</tr>
<tr>
<td>while</td>
<td>循环语句的循环条件</td>
</tr>
</tbody>
</table>
<p>C99 新增关键字：<br>_Bool    _Complex    _Imaginary    inline    restrict</p>
<p>C11 新增关键字：<br>_Alignas    _Alignof    _Atomic    _Generic    _Noreturn<br>_Static_assert    _Thread_local          </p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p>
<p>C 中的类型可分为以下几种：</p>
<style>
table th:nth-of-type(1) {
    width: 100px;
}
</style>

<table>
<thead>
<tr>
<th>序号</th>
<th>类型与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。</td>
</tr>
<tr>
<td>2</td>
<td>枚举类型：它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td>
</tr>
<tr>
<td>3</td>
<td>void 类型：类型说明符 void 表明没有可用的值。</td>
</tr>
<tr>
<td>4</td>
<td>派生类型：它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td>
</tr>
</tbody>
</table>
<p>数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。     </p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>1 字节</td>
<td>-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 字节</td>
<td>0 到 255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 字节</td>
<td>-128 到 127</td>
</tr>
<tr>
<td>int</td>
<td>2 或 4 字节</td>
<td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>2 或 4 字节</td>
<td>0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
<td>-32,768 到 32,767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2 字节</td>
<td>0 到 65,535</td>
</tr>
<tr>
<td>long</td>
<td>4 字节</td>
<td>-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4 字节</td>
<td>0 到 4,294,967,295</td>
</tr>
</tbody>
</table>
<p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。</p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>值范围</th>
<th>精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4 字节</td>
<td>1.2E-38 到 3.4E+38</td>
<td>6 位小数</td>
</tr>
<tr>
<td>double</td>
<td>8 字节</td>
<td>2.3E-308 到 1.7E+308</td>
<td>15 位小数</td>
</tr>
<tr>
<td>long double</td>
<td>16 字节</td>
<td>3.4E-4932 到 1.1E+4932</td>
<td>19 位小数</td>
</tr>
</tbody>
</table>
<h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>类型与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>函数返回为空：C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);</td>
</tr>
<tr>
<td>2</td>
<td>函数参数为空：C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);</td>
</tr>
<tr>
<td>3</td>
<td>指针指向 void：类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。</td>
</tr>
</tbody>
</table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>
<blockquote>
<p>type variable_list;</p>
</blockquote>
<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>变量的声明有两种情况：<br>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。<br>2、另一种是<strong>不需要建立存储空间</strong>的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</p>
<p>除非有extern关键字，否则都是变量的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i; //声明，不是定义</span><br><span class="line">int i; //声明，也是定义</span><br></pre></td></tr></table></figure></p>
<p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
<p>以下是各种类型的整数常量的实例：</p>
<pre><code>85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
</code></pre><h3 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h3><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<p>下面列举几个浮点常量的实例：</p>
<pre><code>3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */
</code></pre><h3 id="字符常量-字符串常量"><a href="#字符常量-字符串常量" class="headerlink" title="字符常量/字符串常量"></a>字符常量/字符串常量</h3><p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p>
<p>在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。</p>
<p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>
<h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>在 C 中，有两种简单的定义常量的方式：<br>1、使用 #define 预处理器。<br>2、使用 const 关键字。</p>
<p><strong>#define 预处理器</strong><br>下面是使用 #define 预处理器定义常量的形式：</p>
<blockquote>
<p>#define identifier value</p>
</blockquote>
<p><strong>const 关键字</strong><br>您可以使用 const 前缀声明指定类型的常量，如下所示：</p>
<blockquote>
<p>const type variable = value;</p>
</blockquote>
<h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
</ul>
<h3 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h3><p>auto 存储类是所有局部变量默认的存储类。</p>
<pre><code>{
   int mount;
   auto int month;
}
</code></pre><p>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</p>
<h3 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h3><p>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<pre><code>{
   register int  miles;
}
</code></pre><p><strong>寄存器只用于需要快速访问的变量，比如计数器</strong>。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着<strong>变量可能存储在寄存器中</strong>，这取决于硬件和实现的限制。</p>
<h3 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h3><p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
<p>以下实例演示了 static 修饰全局变量和局部变量的应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void func1(void);</span><br><span class="line"> </span><br><span class="line">static int count=10;        /* 全局变量 - static 是默认的 */</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  while (count--) &#123;</span><br><span class="line">      func1();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void func1(void)</span><br><span class="line">&#123;</span><br><span class="line">/* &apos;thingy&apos; 是 &apos;func1&apos; 的局部变量 - 只初始化一次</span><br><span class="line"> * 每次调用函数 &apos;func1&apos; &apos;thingy&apos; 值不会被重置。</span><br><span class="line"> */                </span><br><span class="line">  static int thingy=5;</span><br><span class="line">  thingy++;</span><br><span class="line">  printf(&quot; thingy 为 %d ， count 为 %d\n&quot;, thingy, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"> thingy 为 6 ， count 为 9</span><br><span class="line"> thingy 为 7 ， count 为 8</span><br><span class="line"> thingy 为 8 ， count 为 7</span><br><span class="line"> thingy 为 9 ， count 为 6</span><br><span class="line"> thingy 为 10 ， count 为 5</span><br><span class="line"> thingy 为 11 ， count 为 4</span><br><span class="line"> thingy 为 12 ， count 为 3</span><br><span class="line"> thingy 为 13 ， count 为 2</span><br><span class="line"> thingy 为 14 ， count 为 1</span><br><span class="line"> thingy 为 15 ， count 为 0</span><br></pre></td></tr></table></figure></p>
<h3 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h3><p>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有<strong>多个文件</strong>且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，<strong>extern 是用来在另一个文件中声明一个全局变量或函数。</strong></p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//第一个文件：main.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count = 5;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二个文件：support.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">extern int count;</span><br><span class="line"> </span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;count is %d\n&quot;, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：</span><br><span class="line"> $ gcc main.c support.c</span><br><span class="line">//这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：</span><br><span class="line">count is 5</span><br></pre></td></tr></table></figure></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>if…else 语句<br>switch 语句<br>? : 运算符(三元运算符)</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>while 循环<br>do…while 循环<br>for 循环</p>
<p>控制语句包括：break 语句、continue 语句、goto 语句    </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C 语言中的函数定义的一般形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name( parameter list )</span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数声明包括以下几个部分：</p>
<blockquote>
<p>return_type function_name( parameter list );</p>
</blockquote>
<p>针对上面定义的函数 max()，以下是函数声明：</p>
<blockquote>
<p>int max(int num1, int num2);</p>
</blockquote>
<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>
<blockquote>
<p>int max(int, int);</p>
</blockquote>
<p>当您<strong>在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的</strong>。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量，这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th>调用类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>传值调用</td>
<td>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td>
</tr>
<tr>
<td>引用调用</td>
<td>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td>
</tr>
</tbody>
</table>
<p><strong>默认情况下，C 使用传值调用来传递参数</strong>。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>全局变量与局部变量在内存中的区别：<br>1、全局变量保存在内存的全局存储区中，占用静态的存储单元；<br>2、局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
<p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化。</p>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
<p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<blockquote>
<p>type arrayName [ arraySize ];</p>
</blockquote>
<h2 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h2><p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的。</p>
<p>枚举语法定义格式为：</p>
<blockquote>
<p>enum　枚举名　{枚举元素1,枚举元素2,……};</p>
</blockquote>
<p>使用枚举的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
<p>可以在定义枚举类型时改变枚举元素的值：</p>
<blockquote>
<p>enum season {spring, summer=3, autumn, winter};</p>
</blockquote>
<p>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p>
<h3 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h3><p>前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。</p>
<p>我们可以通过以下三种方式来定义枚举变量</p>
<p>1、先定义枚举类型，再定义枚举变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line">enum DAY day;</span><br></pre></td></tr></table></figure></p>
<p>2、定义枚举类型的同时定义枚举变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure></p>
<p>3、省略枚举名称，直接定义枚举变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>按照 C 语言规范是没有办法遍历枚举类型的。不过在一些特殊的情况下，枚举类型<strong>必须连续</strong>是可以实现有条件的遍历。</p>
<p>也可以将整数转换为枚举。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。</p>
<p>请看下面的实例，它将输出定义的变量地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int  var1;</span><br><span class="line">   char var2[10];</span><br><span class="line"> </span><br><span class="line">   printf(&quot;var1 变量的地址： %p\n&quot;, &amp;var1  );</span><br><span class="line">   printf(&quot;var2 变量的地址： %p\n&quot;, &amp;var2  );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">var1 变量的地址： 0x7fff5cc109d4</span><br><span class="line">var2 变量的地址： 0x7fff5cc109de</span><br></pre></td></tr></table></figure></p>
<h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><p>指针<strong>是一个变量，其值为另一个变量的地址，即内存位置的直接地址</strong>。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<blockquote>
<p>type *var-name;</p>
</blockquote>
<p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应<strong>指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数</strong>。</p>
<p>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<h3 id="如何使用指针？"><a href="#如何使用指针？" class="headerlink" title="如何使用指针？"></a>如何使用指针？</h3><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int  var = 20;   /* 实际变量的声明 */</span><br><span class="line">   int  *ip;        /* 指针变量的声明 */</span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */</span><br><span class="line"> </span><br><span class="line">   printf(&quot;Address of var variable: %p\n&quot;, &amp;var  );</span><br><span class="line"> </span><br><span class="line">   /* 在指针变量中存储的地址 */</span><br><span class="line">   printf(&quot;Address stored in ip variable: %p\n&quot;, ip );</span><br><span class="line"> </span><br><span class="line">   /* 使用指针访问值 */</span><br><span class="line">   printf(&quot;Value of *ip variable: %d\n&quot;, *ip );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Address of var variable: bffd8b3c</span><br><span class="line">Address stored in ip variable: bffd8b3c</span><br><span class="line">Value of *ip variable: 20</span><br></pre></td></tr></table></figure></p>
<h3 id="C-中的-NULL-指针"><a href="#C-中的-NULL-指针" class="headerlink" title="C 中的 NULL 指针"></a>C 中的 NULL 指针</h3><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。</p>
<p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int  *ptr = NULL;</span><br><span class="line"> </span><br><span class="line">   printf(&quot;ptr 的地址是 %p\n&quot;, ptr  );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">ptr 的地址是 0x0</span><br></pre></td></tr></table></figure></p>
<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p>
<p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p>
<pre><code>if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */
</code></pre><h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
<p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：</p>
<blockquote>
<p>int **var;</p>
</blockquote>
<h2 id="函数指针与回调函数"><a href="#函数指针与回调函数" class="headerlink" title="函数指针与回调函数"></a>函数指针与回调函数</h2><p>函数指针是指向函数的指针变量。</p>
<p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参数。</p>
<p>函数指针变量的声明：</p>
<blockquote>
<p>typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型</p>
</blockquote>
<p>以下实例声明了函数指针变量 p，指向函数 max：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* p 是函数指针 */</span><br><span class="line">    int (* p)(int, int) = &amp; max; // &amp;可以省略</span><br><span class="line">    int a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;请输入三个数字:&quot;);</span><br><span class="line">    scanf(&quot;%d %d %d&quot;, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    /* 与直接调用函数等价，d = max(max(a, b), c) */</span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    printf(&quot;最大的数字是: %d\n&quot;, d);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">请输入三个数字:1 2 3</span><br><span class="line">最大的数字是: 3</span><br></pre></td></tr></table></figure></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数指针作为某个函数的参数，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<p>实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">// 回调函数</span><br><span class="line">void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i=0; i&lt;arraySize; i++)</span><br><span class="line">        array[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 获取随机值</span><br><span class="line">int getNextRandomValue(void)</span><br><span class="line">&#123;</span><br><span class="line">    return rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int myarray[10];</span><br><span class="line">    populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line">    for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709</span><br></pre></td></tr></table></figure></p>
<h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h2><p>在 C 语言中，<strong>字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组</strong>。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p>
<blockquote>
<p>char greeting[6] = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘\0’};</p>
</blockquote>
<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<blockquote>
<p>char greeting[] = “Hello”;</p>
</blockquote>
<p>其实，您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。</p>
<p>C 中有大量操作字符串的函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>strcpy(s1, s2)</td>
<td>复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td>strcat(s1, s2)</td>
<td>连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td>strlen(s1)</td>
<td>返回字符串 s1 的长度。</td>
</tr>
<tr>
<td>strcmp(s1, s2)</td>
<td>如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。</s2></td>
</tr>
<tr>
<td>strchr(s1, ch)</td>
<td>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td>strstr(s1, s2)</td>
<td>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody>
</table>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构是 C 编程中一种用户自定义的可用的数据类型，它允许您<strong>存储不同类型的数据项</strong>。</p>
<p>为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct tag &#123; </span><br><span class="line">    member-list</span><br><span class="line">    member-list </span><br><span class="line">    member-list  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-list ;</span><br></pre></td></tr></table></figure></p>
<p>tag 是结构体标签。<br>member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。<br>variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125; book;</span><br></pre></td></tr></table></figure></p>
<p>在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//同时又声明了结构体变量s1</span><br><span class="line">//这个结构体并没有标明其标签</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125; s1;</span><br><span class="line"> </span><br><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//结构体的标签被命名为SIMPLE,没有声明变量</span><br><span class="line">struct SIMPLE</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125;;</span><br><span class="line">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span><br><span class="line">struct SIMPLE t1, t2[20], *t3;</span><br><span class="line"> </span><br><span class="line">//也可以用typedef创建新类型</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line">//现在可以用Simple2作为类型声明新的结构体变量</span><br><span class="line">Simple2 u1, u2[20], *u3;</span><br></pre></td></tr></table></figure></p>
<p>在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&amp;s1，则是非法的。</p>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//此结构体的声明包含了其他的结构体</span><br><span class="line">struct COMPLEX</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct SIMPLE a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//此结构体的声明包含了指向自己类型的指针</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct NODE *next_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果<strong>两个结构体互相包含，则需要对其中一个结构体进行不完整声明</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct B;    //对结构体B进行不完整声明</span><br><span class="line"> </span><br><span class="line">//结构体A中包含指向结构体B的指针</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    struct B *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span><br><span class="line">struct B</span><br><span class="line">&#123;</span><br><span class="line">    struct A *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h3><p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125; book = &#123;&quot;C 语言&quot;, &quot;RUNOOB&quot;, &quot;编程语言&quot;, 123456&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行输出结果为：</span><br><span class="line">title : C 语言</span><br><span class="line">author: RUNOOB</span><br><span class="line">subject: 编程语言</span><br><span class="line">book_id: 123456</span><br></pre></td></tr></table></figure></p>
<h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<blockquote>
<p>struct Books *struct_pointer;</p>
</blockquote>
<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<blockquote>
<p>struct_pointer = &Book1;</p>
</blockquote>
<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<blockquote>
<p>struct_pointer-&gt;title;</p>
</blockquote>
<p>实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void printBook( struct Books *book );</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   struct Books Book1;        /* 声明 Book1，类型为 Books */</span><br><span class="line">   struct Books Book2;        /* 声明 Book2，类型为 Books */</span><br><span class="line"> </span><br><span class="line">   /* Book1 详述 */</span><br><span class="line">   strcpy( Book1.title, &quot;C Programming&quot;);</span><br><span class="line">   strcpy( Book1.author, &quot;Nuha Ali&quot;); </span><br><span class="line">   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);</span><br><span class="line">   Book1.book_id = 6495407;</span><br><span class="line"> </span><br><span class="line">   /* Book2 详述 */</span><br><span class="line">   strcpy( Book2.title, &quot;Telecom Billing&quot;);</span><br><span class="line">   strcpy( Book2.author, &quot;Zara Ali&quot;);</span><br><span class="line">   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);</span><br><span class="line">   Book2.book_id = 6495700;</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book1 的地址来输出 Book1 信息 */</span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book2 的地址来输出 Book2 信息 */</span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">void printBook( struct Books *book )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;Book title : %s\n&quot;, book-&gt;title);</span><br><span class="line">   printf( &quot;Book author : %s\n&quot;, book-&gt;author);</span><br><span class="line">   printf( &quot;Book subject : %s\n&quot;, book-&gt;subject);</span><br><span class="line">   printf( &quot;Book book_id : %d\n&quot;, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>有些信息在存储时，<strong>并不需要占用一个完整的字节，而只需占几个或一个二进制位</strong>。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。</p>
<p>所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>典型的实例：<br>1、用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。<br>2、读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</p>
<p>位域定义与结构定义相仿，其形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  type [member_name] : width ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>type：只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。<br>member_name：位域的名称。<br>width：位域中位的数量。宽度必须小于或等于指定类型的位宽度。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</span><br><span class="line">struct bs&#123;</span><br><span class="line">    int a:8;</span><br><span class="line">    int b:2;</span><br><span class="line">    int c:6;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure></p>
<h3 id="位域说明"><a href="#位域说明" class="headerlink" title="位域说明"></a>位域说明</h3><p>1、一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</span><br><span class="line">struct bs&#123;</span><br><span class="line">    unsigned a:4;</span><br><span class="line">    unsigned  :4;    /* 空域 */</span><br><span class="line">    unsigned b:4;    /* 从下一单元开始存放 */</span><br><span class="line">    unsigned c:4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、由于<strong>位域不允许跨两个字节</strong>，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。</p>
<p>3、位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct k&#123;</span><br><span class="line">    int a:1;</span><br><span class="line">    int  :2;    /* 该 2 位不能使用 */</span><br><span class="line">    int b:3;</span><br><span class="line">    int c:2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从以上分析可以看出，<strong>位域在本质上就是一种结构类型，不过其成员是按二进位分配的</strong>。</p>
<h3 id="位域的使用"><a href="#位域的使用" class="headerlink" title="位域的使用"></a>位域的使用</h3><p>位域的使用和结构成员的使用相同，其一般形式为：</p>
<blockquote>
<p>位域变量名.位域名<br>位域变量名-&gt;位域名</p>
</blockquote>
<p>位域允许用各种格式输出。</p>
<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体是一种特殊的数据类型，<strong>允许您在相同的内存位置存储不同的数据类型，但任何时候只能有一个成员带有值</strong>。共用体提供了一种使用相同的内存位置的有效方式。</p>
<p>共用体占用的内存应足够存储共用体中最大的成员。</p>
<p>为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union [union tag]</span><br><span class="line">&#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one or more union variables];</span><br></pre></td></tr></table></figure></p>
<p>union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。</p>
<p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">union Data</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char  str[20];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   union Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = 10;</span><br><span class="line">   data.f = 220.5;</span><br><span class="line">   strcpy( data.str, &quot;C Programming&quot;);</span><br><span class="line"> </span><br><span class="line">   printf( &quot;data.i : %d\n&quot;, data.i);</span><br><span class="line">   printf( &quot;data.f : %f\n&quot;, data.f);</span><br><span class="line">   printf( &quot;data.str : %s\n&quot;, data.str);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">data.i : 1917853763</span><br><span class="line">data.f : 4122360580327794860452759994368.000000</span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">union Data</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char  str[20];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   union Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = 10;</span><br><span class="line">   printf( &quot;data.i : %d\n&quot;, data.i);</span><br><span class="line">   </span><br><span class="line">   data.f = 220.5;</span><br><span class="line">   printf( &quot;data.f : %f\n&quot;, data.f);</span><br><span class="line">   </span><br><span class="line">   strcpy( data.str, &quot;C Programming&quot;);</span><br><span class="line">   printf( &quot;data.str : %s\n&quot;, data.str);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">data.i : 10</span><br><span class="line">data.f : 220.500000</span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure></p>
<p>在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。</p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>C 语言提供了 typedef 关键字，您可以使用它来<strong>为类型取一个新的名字</strong>。下面的实例为单字节数字定义了一个术语 BYTE(按照惯例定义时会大写字母，但也可以使用小写字母)：</p>
<blockquote>
<p>typedef unsigned char BYTE;</p>
</blockquote>
<p>在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：</p>
<blockquote>
<p>BYTE  b1, b2;</p>
</blockquote>
<p>也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">typedef struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125; Book;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Book book;</span><br><span class="line"> </span><br><span class="line">   strcpy( book.title, &quot;C 教程&quot;);</span><br><span class="line">   strcpy( book.author, &quot;Runoob&quot;); </span><br><span class="line">   strcpy( book.subject, &quot;编程语言&quot;);</span><br><span class="line">   book.book_id = 12345;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;书标题 : %s\n&quot;, book.title);</span><br><span class="line">   printf( &quot;书作者 : %s\n&quot;, book.author);</span><br><span class="line">   printf( &quot;书类目 : %s\n&quot;, book.subject);</span><br><span class="line">   printf( &quot;书 ID : %d\n&quot;, book.book_id);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="typedef-vs-define"><a href="#typedef-vs-define" class="headerlink" title="typedef vs #define"></a>typedef vs #define</h3><p>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p>
<ul>
<li>typedef 仅限于为类型定义符号名称，<strong>#define 不仅可以为类型定义别名，也能为数值定义别名</strong>，比如您可以定义 1 为 ONE。</li>
<li>typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。</li>
</ul>
<p>下面是 #define 的最简单的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">#define TRUE  1</span><br><span class="line">#define FALSE 0</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;TRUE 的值: %d\n&quot;, TRUE);</span><br><span class="line">   printf( &quot;FALSE 的值: %d\n&quot;, FALSE);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">TRUE 的值: 1</span><br><span class="line">FALSE 的值: 0</span><br></pre></td></tr></table></figure></p>
<h2 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数(inline)"></a>内联函数(inline)</h2><p>在c/c++中，<strong>为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题</strong>，特别的引入了inline修饰符，表示为内联函数。</p>
<p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p>
<p>在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p>
<p>下面我们来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//函数定义为inline即:内联函数</span><br><span class="line">inline char* dbtest(int a) &#123;</span><br><span class="line">    return (i % 2 &gt; 0) ? &quot;奇&quot; : &quot;偶&quot;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int i = 0;</span><br><span class="line">   for (i=1; i &lt; 100; i++) &#123;</span><br><span class="line">       printf(&quot;i:%d    奇偶性:%s /n&quot;, i, dbtest(i));    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个for<strong>循环的内部任何调用dbtest(i)的地方都换成了(i%2&gt;0)?”奇”:”偶”</strong>，这样就<strong>避免了频繁调用函数对栈内存重复开辟所带来的消耗</strong>。</p>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>inline的使用是有所限制的，inline<strong>只适合函数体内代码简单的涵数使用</strong>，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。</p>
<h3 id="对编译器的建议"><a href="#对编译器的建议" class="headerlink" title="对编译器的建议"></a>对编译器的建议</h3><p>inline函数仅仅是一个<strong>对编译器的建议</strong>，所以最后<strong>能否真正内联要看编译器的意思</strong>，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p>
<h3 id="类中的成员函数与inline"><a href="#类中的成员函数与inline" class="headerlink" title="类中的成员函数与inline"></a>类中的成员函数与inline</h3><p><strong>定义在类中的成员函数缺省都是内联的</strong>，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public:void Foo(int x, int y) &#123;  &#125; // 自动地成为内联函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 头文件</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    void Foo(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义文件</span><br><span class="line">inline void A::Foo(int x, int y)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="inline-是一种“用于实现的关键字”"><a href="#inline-是一种“用于实现的关键字”" class="headerlink" title="inline 是一种“用于实现的关键字”"></a>inline 是一种“用于实现的关键字”</h3><p>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。</p>
<p>如下风格的函数Foo 不能成为内联函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline void Foo(int x, int y); // inline 仅与函数声明放在一起</span><br><span class="line"></span><br><span class="line">void Foo(int x, int y)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>而如下风格的函数Foo 则成为内联函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void Foo(int x, int y);</span><br><span class="line"></span><br><span class="line">inline void Foo(int x, int y) &#123;&#125; // inline 与函数定义体放在一起</span><br></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.建议：inline函数的定义放在头文件中<br>2.慎用inline：内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。<br>3.最令人烦恼的还是当编译器拒绝内联的时候。如果内联函数不能增强性能，就避免使用它！</p>
<h2 id="输入-amp-输出"><a href="#输入-amp-输出" class="headerlink" title="输入 &amp; 输出"></a>输入 &amp; 输出</h2><p>C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p>
<table>
<thead>
<tr>
<th>标准文件</th>
<th>文件指针</th>
<th>设备</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准输入</td>
<td>stdin</td>
<td>键盘</td>
</tr>
<tr>
<td>标准输出</td>
<td>stdout</td>
<td>屏幕</td>
</tr>
<tr>
<td>标准错误</td>
<td>stderr</td>
<td>屏幕</td>
</tr>
</tbody>
</table>
<h3 id="getchar-amp-putchar-函数"><a href="#getchar-amp-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h3><p>int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p>
<p>int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p>
<p>请看下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   int c;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;Enter a value :&quot;);</span><br><span class="line">   c = getchar( );</span><br><span class="line"> </span><br><span class="line">   printf( &quot;\nYou entered: &quot;);</span><br><span class="line">   putchar( c );</span><br><span class="line">   printf( &quot;\n&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：</span><br><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: r</span><br></pre></td></tr></table></figure></p>
<h3 id="gets-amp-puts-函数"><a href="#gets-amp-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h3><p>char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。</p>
<p>int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char str[100];</span><br><span class="line"> </span><br><span class="line">   printf( &quot;Enter a value :&quot;);</span><br><span class="line">   gets( str );</span><br><span class="line"> </span><br><span class="line">   printf( &quot;\nYou entered: &quot;);</span><br><span class="line">   puts( str );</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</span><br><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: runoob</span><br></pre></td></tr></table></figure>
<h3 id="scanf-和-printf-函数"><a href="#scanf-和-printf-函数" class="headerlink" title="scanf() 和 printf() 函数"></a>scanf() 和 printf() 函数</h3><p>int scanf(const char *format, …) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。</p>
<p>int printf(const char *format, …) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。</p>
<p>format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p>
<p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main( ) &#123;</span><br><span class="line"> </span><br><span class="line">   char str[100];</span><br><span class="line">   int i;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;Enter a value :&quot;);</span><br><span class="line">   scanf(&quot;%s %d&quot;, str, &amp;i);</span><br><span class="line"> </span><br><span class="line">   printf( &quot;\nYou entered: %s %d &quot;, str, i);</span><br><span class="line">   printf(&quot;\n&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：</span><br><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob 123</span><br><span class="line"></span><br><span class="line">You entered: runoob 123</span><br></pre></td></tr></table></figure></p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。原型为：</p>
<blockquote>
<p>FILE *fopen( const char * filename, const char * mode );</p>
</blockquote>
<p>在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>打开一个已有的文本文件，允许读取文件。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody>
</table>
<p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p>
<blockquote>
<p>“rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b”</p>
</blockquote>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：</p>
<blockquote>
<p>int fclose( FILE *fp );</p>
</blockquote>
<p>如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。</p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。下面是把字符写入到流中的最简单的函数：</p>
<blockquote>
<p>int fputc( int c, FILE *fp );</p>
</blockquote>
<p>函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：</p>
<blockquote>
<p>int fputs( const char *s, FILE *fp );</p>
</blockquote>
<p>您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中。尝试下面的实例：</p>
<p>注意：请确保您有可用的 tmp 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。/tmp 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: C:\tmp、D:\tmp等。</p>
<p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line">   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">   fprintf(fp, &quot;This is testing for fprintf...\n&quot;);</span><br><span class="line">   fputs(&quot;This is testing for fputs...\n&quot;, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。下面是从文件读取单个字符的最简单的函数：</p>
<blockquote>
<p>int fgetc( FILE * fp );</p>
</blockquote>
<p>函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。下面的函数允许您从流中读取一个字符串：</p>
<blockquote>
<p>char *fgets( char *buf, int n, FILE *fp );</p>
</blockquote>
<p>您也可以使用 int fscanf(FILE *fp, const char *format, …) 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line">   char buff[255];</span><br><span class="line"> </span><br><span class="line">   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;r&quot;);</span><br><span class="line">   fscanf(fp, &quot;%s&quot;, buff);</span><br><span class="line">   printf(&quot;1: %s\n&quot;, buff );</span><br><span class="line"> </span><br><span class="line">   fgets(buff, 255, (FILE*)fp);</span><br><span class="line">   printf(&quot;2: %s\n&quot;, buff );</span><br><span class="line">   </span><br><span class="line">   fgets(buff, 255, (FILE*)fp);</span><br><span class="line">   printf(&quot;3: %s\n&quot;, buff );</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：</span><br><span class="line">1: This</span><br><span class="line">2: is testing for fprintf...</span><br><span class="line"></span><br><span class="line">3: This is testing for fputs...</span><br></pre></td></tr></table></figure>
<p>首先，fscanf() 方法只读取了 This，因为它在后边遇到了一个空格。其次，调用 fgets() 读取剩余的部分，直到行尾。最后，调用 fgets() 完整地读取第二行。</p>
<h3 id="二进制-I-O-函数"><a href="#二进制-I-O-函数" class="headerlink" title="二进制 I/O 函数"></a>二进制 I/O 函数</h3><p>下面两个函数用于二进制输入和输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size_of_elements, </span><br><span class="line">             size_t number_of_elements, FILE *a_file);</span><br><span class="line">              </span><br><span class="line">size_t fwrite(const void *ptr, size_t size_of_elements, </span><br><span class="line">             size_t number_of_elements, FILE *a_file);</span><br></pre></td></tr></table></figure></p>
<p>这两个函数都是用于存储块的读写 - 通常是数组或结构体。</p>
<h2 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h2><p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>
<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>#define</td>
<td>定义宏</td>
</tr>
<tr>
<td>#include</td>
<td>包含一个源代码文件</td>
</tr>
<tr>
<td>#undef</td>
<td>取消已定义的宏</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果宏已经定义，则返回真</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果宏没有定义，则返回真</td>
</tr>
<tr>
<td>#if</td>
<td>如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#else</td>
<td>#if 的替代方案</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#endif</td>
<td>结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td>#error</td>
<td>当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td>#pragma</td>
<td>使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody>
</table>
<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__DATE__</td>
<td>当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td>
</tr>
<tr>
<td>__TIME__</td>
<td>当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td>
</tr>
<tr>
<td>__FILE__</td>
<td>这会包含当前文件名，一个字符串常量。</td>
</tr>
<tr>
<td>__LINE__</td>
<td>这会包含当前行号，一个十进制常量。</td>
</tr>
<tr>
<td>__STDC__</td>
<td>当编译器以 ANSI 标准编译时，则定义为 1。</td>
</tr>
</tbody>
</table>
<h3 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h3><p>C 预处理器提供了下列的运算符来帮助您创建宏：</p>
<h4 id="宏延续运算符（-）"><a href="#宏延续运算符（-）" class="headerlink" title="宏延续运算符（\）"></a>宏延续运算符（\）</h4><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define  message_for(a, b)  \</span><br><span class="line">    printf(#a &quot; and &quot; #b &quot;: We love you!\n&quot;)</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串常量化运算符（-）"><a href="#字符串常量化运算符（-）" class="headerlink" title="字符串常量化运算符（#）"></a>字符串常量化运算符（#）</h4><p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define  message_for(a, b)  \</span><br><span class="line">    printf(#a &quot; and &quot; #b &quot;: We love you!\n&quot;)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   message_for(Carole, Debra);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Carole and Debra: We love you!</span><br></pre></td></tr></table></figure></p>
<h4 id="标记粘贴运算符（-）"><a href="#标记粘贴运算符（-）" class="headerlink" title="标记粘贴运算符（##）"></a>标记粘贴运算符（##）</h4><p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define tokenpaster(n) printf (&quot;token&quot; #n &quot; = %d&quot;, token##n)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int token34 = 40;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(34);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">token34 = 40</span><br></pre></td></tr></table></figure></p>
<p>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p>
<blockquote>
<p>printf (“token34 = %d”, token34);</p>
</blockquote>
<p>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。</p>
<h4 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined() 运算符"></a>defined() 运算符</h4><p>预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#if !defined (MESSAGE)</span><br><span class="line">   #define MESSAGE &quot;You wish!&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Here is the message: %s\n&quot;, MESSAGE);  </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Here is the message: You wish!</span><br></pre></td></tr></table></figure></p>
<h3 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h3><p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，计算一个数的平方，我们可以使用宏重写上面的代码，如下：</p>
<blockquote>
<p>#define square(x) ((x) * (x))</p>
</blockquote>
<p>在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Max between 20 and 10 is %d\n&quot;, MAX(10, 20));  </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Max between 20 and 10 is 20</span><br></pre></td></tr></table></figure></p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：编译器自带的头文件和程序员编写的头文件（如下）。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<blockquote>
<p>#include &lt;file></p>
<p>#include “file”</p>
</blockquote>
<p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
<h3 id="只引用一次头文件"><a href="#只引用一次头文件" class="headerlink" title="只引用一次头文件"></a>只引用一次头文件</h3><p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HEADER_FILE</span><br><span class="line">#define HEADER_FILE</span><br><span class="line"></span><br><span class="line">the entire header file file</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。</p>
<h3 id="有条件引用"><a href="#有条件引用" class="headerlink" title="有条件引用"></a>有条件引用</h3><p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if SYSTEM_1</span><br><span class="line">   # include &quot;system_1.h&quot;</span><br><span class="line">#elif SYSTEM_2</span><br><span class="line">   # include &quot;system_2.h&quot;</span><br><span class="line">#elif SYSTEM_3</span><br><span class="line">   ...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SYSTEM_H &quot;system_1.h&quot;</span><br><span class="line">...</span><br><span class="line">#include SYSTEM_H</span><br></pre></td></tr></table></figure></p>
<p>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换是把变量从一种类型转换为另一种数据类型。您可以使用强制类型转换运算符来把值显式地从一种类型转换为另一种类型，如下所示：</p>
<blockquote>
<p>(type_name) expression</p>
</blockquote>
<p>在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</p>
<h3 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h3><p>整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。请看下面的实例，在 int 中添加一个字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int  i = 17;</span><br><span class="line">   char c = &apos;c&apos;; /* ascii 值是 99 */</span><br><span class="line">   int sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   printf(&quot;Value of sum : %d\n&quot;, sum );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of sum : 116</span><br></pre></td></tr></table></figure></p>
<p>在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 ‘c’ 的值转换为对应的 ascii 值。</p>
<h3 id="常用的算术转换"><a href="#常用的算术转换" class="headerlink" title="常用的算术转换"></a>常用的算术转换</h3><p>常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：</p>
<p><img src="/2019/12/24/c-language/usual_arithmetic_conversion.png" alt><br>让我们看看下面的实例来理解这个概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int  i = 17;</span><br><span class="line">   char c = &apos;c&apos;; /* ascii 值是 99 */</span><br><span class="line">   float sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   printf(&quot;Value of sum : %f\n&quot;, sum );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of sum : 116.000000</span><br></pre></td></tr></table></figure></p>
<p>在这里，c 首先被转换为整数，但是由于最后的值是 float 型的，所以会应用常用的算术转换，编译器会把 i 和 c 转换为浮点型，并把它们相加得到一个浮点数。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>C 语言<strong>不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据</strong>。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p>
<p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p>
<h3 id="errno、perror-和-strerror"><a href="#errno、perror-和-strerror" class="headerlink" title="errno、perror() 和 strerror()"></a>errno、perror() 和 strerror()</h3><p>C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。</p>
<ul>
<li>perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li>
<li>strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li>
</ul>
<p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">extern int errno ;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   FILE * pf;</span><br><span class="line">   int errnum;</span><br><span class="line">   pf = fopen (&quot;unexist.txt&quot;, &quot;rb&quot;);</span><br><span class="line">   if (pf == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      errnum = errno;</span><br><span class="line">      fprintf(stderr, &quot;错误号: %d\n&quot;, errno);</span><br><span class="line">      perror(&quot;通过 perror 输出错误&quot;);</span><br><span class="line">      fprintf(stderr, &quot;打开文件错误: %s\n&quot;, strerror( errnum ));</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      fclose (pf);</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">错误号: 2</span><br><span class="line">通过 perror 输出错误: No such file or directory</span><br><span class="line">打开文件错误: No such file or directory</span><br></pre></td></tr></table></figure></p>
<h3 id="程序退出状态"><a href="#程序退出状态" class="headerlink" title="程序退出状态"></a>程序退出状态</h3><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p>
<p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   int dividend = 20;</span><br><span class="line">   int divisor = 5;</span><br><span class="line">   int quotient;</span><br><span class="line"> </span><br><span class="line">   // 在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。</span><br><span class="line">   if( divisor == 0)&#123;</span><br><span class="line">      fprintf(stderr, &quot;除数为 0 退出运行...\n&quot;);</span><br><span class="line">      exit(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   quotient = dividend / divisor;</span><br><span class="line">   fprintf(stderr, &quot;quotient 变量的值为: %d\n&quot;, quotient );</span><br><span class="line"> </span><br><span class="line">   exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">quotient 变量的值为 : 4</span><br></pre></td></tr></table></figure></p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int func(int, ... ) </span><br><span class="line">&#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   func(2, 2, 3);</span><br><span class="line">   func(3, 2, 3, 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，函数 func() 最后一个参数写成省略号，即三个点号（…），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li>
<li>使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。</li>
<li>使用宏 va_end 来清理赋予 va_list 变量的内存。</li>
</ul>
<p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"> </span><br><span class="line">double average(int num,...)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    double sum = 0.0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    /* 为 num 个参数初始化 valist */</span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    /* 访问所有赋给 valist 的参数 */</span><br><span class="line">    for (i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, int);</span><br><span class="line">    &#125;</span><br><span class="line">    /* 清理为 valist 保留的内存 */</span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    return sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Average of 2, 3, 4, 5 = %f\n&quot;, average(4, 2,3,4,5));</span><br><span class="line">   printf(&quot;Average of 5, 10, 15 = %f\n&quot;, average(3, 5,10,15));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Average of 2, 3, 4, 5 = 3.500000</span><br><span class="line">Average of 5, 10, 15 = 10.000000</span><br></pre></td></tr></table></figure></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>语言为内存的分配和管理提供了几个函数。这些函数可以在 &lt;stdlib.h&gt; 头文件中找到。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>函数和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>void *calloc(int num, int size)  <br>在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td>
</tr>
<tr>
<td>2</td>
<td>void free(void *address) <br> 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td>
</tr>
<tr>
<td>3</td>
<td>void *malloc(int num) <br> 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td>
</tr>
<tr>
<td>4</td>
<td>void *realloc(void *address, int newsize) <br> 该函数重新分配内存，把内存扩展到 newsize。</td>
</tr>
</tbody>
</table>
<p>注意：void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<h3 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h3><p>如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要<strong>定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 200 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student in class 10th</span><br></pre></td></tr></table></figure></p>
<p>上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>
<blockquote>
<p>calloc(200, sizeof(char));</p>
</blockquote>
<p>当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些<strong>预先定义了大小的数组，一旦定义则无法改变大小</strong>。</p>
<h3 id="重新调整内存的大小和释放内存"><a href="#重新调整内存的大小和释放内存" class="headerlink" title="重新调整内存的大小和释放内存"></a>重新调整内存的大小和释放内存</h3><p>当程序退出时，<strong>操作系统会自动释放所有分配给程序的内存</strong>，但是，<strong>建议您在不需要内存时，都应该调用函数 free() 来释放内存</strong>。</p>
<p>或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 30 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /* 假设您想要存储更大的描述信息 */</span><br><span class="line">   description = (char *) realloc( description, 100 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcat( description, &quot;She is in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line"> </span><br><span class="line">   /* 使用 free() 函数释放内存 */</span><br><span class="line">   free(description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student.She is in class 10th</span><br></pre></td></tr></table></figure></p>
<p>您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main( int argc, char *argv[] )  </span><br><span class="line">&#123;</span><br><span class="line">   if( argc == 2 )</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;The argument supplied is %s\n&quot;, argv[1]);</span><br><span class="line">   &#125;</span><br><span class="line">   else if( argc &gt; 2 )</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;Too many arguments supplied.\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;One argument expected.\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用一个参数，编译并执行上面的代码，它会产生下列结果：</span><br><span class="line">$./a.out testing</span><br><span class="line">The argument supplied is testing</span><br><span class="line"></span><br><span class="line">使用两个参数，编译并执行上面的代码，它会产生下列结果：</span><br><span class="line">$./a.out testing1 testing2</span><br><span class="line">Too many arguments supplied.</span><br><span class="line"></span><br><span class="line">不传任何参数，编译并执行上面的代码，它会产生下列结果：</span><br><span class="line">$./a.out</span><br><span class="line">One argument expected</span><br></pre></td></tr></table></figure></p>
<p>应当指出的是，<strong>argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针</strong>，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。</p>
<p>多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 “” 或单引号 ‘’ 内部。</p>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><h3 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h3><p>C 库函数 int printf(const char *format, …) 发送格式化输出到标准输出 stdout。</p>
<p>规定符:</p>
<ul>
<li>%d 十进制有符号整数</li>
<li>%u 十进制无符号整数</li>
<li>%f 浮点数</li>
<li>%s 字符串</li>
<li>%c 单个字符</li>
<li>%p 指针的值</li>
<li>%e 指数形式的浮点数</li>
<li>%x, %X 无符号以十六进制表示的整数</li>
<li>%o 无符号以八进制表示的整数</li>
<li>%g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出</li>
<li>%p 输出地址符</li>
<li>%lu 32位无符号整数</li>
<li>%llu 64位无符号整数</li>
</ul>
<h2 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h2><p>C11（也被称为C1X）指ISO标准ISO/IEC 9899:2011，是当前最新的C语言标准。在它之前的C语言标准为C99。</p>
<p>新特性：</p>
<ul>
<li><p>对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及&lt;stdalign.h&gt;头文件）。</p>
</li>
<li><p>_Noreturn 函数标记，类似于 gcc 的 <strong>attribute</strong>((noreturn))。</p>
</li>
<li><p>_Generic 关键字。</p>
</li>
<li><p>多线程（Multithreading）支持，包括：<br>_Thread_local存储类型标识符，&lt;threads.h&gt;头文件，里面包含了线程的创建和管理函数。<br>_Atomic类型修饰符和&lt;stdatomic.h&gt;头文件。</p>
</li>
<li><p>增强的Unicode的支持。基于C Unicode技术报告ISO/IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16/UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件&lt;uchar.h&gt;。</p>
</li>
<li><p>删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。</p>
</li>
<li><p>增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。</p>
</li>
<li><p>增加了更多浮点处理宏(宏)。</p>
</li>
<li><p>匿名结构体/联合体支持。这个在gcc早已存在，C11将其引入标准。</p>
</li>
<li><p>静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。</p>
</li>
<li><p>新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。</p>
</li>
<li><p>新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。</p>
</li>
</ul>
<h2 id="重入函数"><a href="#重入函数" class="headerlink" title="重入函数"></a>重入函数</h2><p>在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。所谓<strong>可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会 出错</strong>。不可重入函数在实时系统设计中被视为不安全函数。</p>
<p>可重入函数可以被一个以上的任务调用，而不必担心数据被破坏。可重入函数任何时候都可以被中断，一段时间以后又可以运行，而相应的数据不会丢失。可重入函数或者只使用局部变量，即保存在CPU寄存器中或堆栈中；或者使用全局变量，则要对全局变量予以保护。而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等等，所以他如果被中断的话，可能出现问题，所以这类函数是 不能运行在多任务环境下的。</p>
<p>满足下列条件的函数多数是不可重入的：<br>（1）函数体内使用了静态的数据结构；<br>（2）函数体内调用了malloc()或者free()函数；<br>（3）函数体内调用了标准I/O函数。</p>
<p>如何写出可重入的函数？<br>在函数体内不访问那些全局变量，不使用静态局部变量，坚持只使用缺省态（auto）局部变量，写出的函数就将是可重入的。如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断。</p>
<p>把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写他。只要遵守以下几条很容易理解的规则：<br>第一，不要使用全局变量。因为别的代码很可能覆盖这些变量值。<br>第二，在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”或者用OS_ENTER_KERNAL/OS_EXIT_KERNAL来描述。<br>第三，不能调用任何不可重入的函数。<br>第四，谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL。<br>还有一些规则，都是很好理解的，总之，时刻记住一句话：<strong>保证中断是安全的</strong>！<br>通俗的来讲吧：由于中断是可能随时发生的，断点位置也是无法预期的。所以必须保证每个函数都具有不被中断发生，压栈，转向ISR，弹栈后继续执行影响的稳定性。也就是说具有不会被中断影响的能力。既然有这个要求，你提供和编写的每个函数就不能拿公共的资源或者是变量来使用，因为该函数使用的同时，ISR（中断服务程序）也可那会去修改或者是获取这个资源，从而有可能使中断返回之后，这部分公用的资源已经面目全非。</p>
<p>案例：<br>相信很多人都看过下面这个面试题<br>中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 <strong>interrupt。下面的代码就使用了</strong>interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__interrupt double compute_area (double radius) </span><br><span class="line">&#123;</span><br><span class="line">    double area = PI * radius * radius;</span><br><span class="line">    printf(&quot;\nArea = %f&quot;, area);</span><br><span class="line">    return area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数有太多的错误了，以至让人不知从何说起了：<br>1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。<br>2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。<br>3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。<br>4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/cprogramming/c-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-tutorial.html</a><br><a href="https://www.cnblogs.com/AlwaysOnLines/p/3912680.html" target="_blank" rel="noopener">C语言之可重入函数 &amp;&amp; 不可重入函数</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/28/design-pattern-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/28/design-pattern-summary/" itemprop="url">GoF 的 23 种设计模式总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-28T09:09:46+08:00">
                2019-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p>
<p>1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）一书，在本教程中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）匿名著称。</p>
<p>直到今天，狭义的设计模式还是 GoF 的 23 种经典设计模式。</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点：<br>1、可以提高程序员的思维能力、编程能力和设计能力。<br>2、使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。<br>3、使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</p>
<p>当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，可能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。</p>
<p>1、根据作用范围来分</p>
<p>根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种：</p>
<ul>
<li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</li>
<li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</li>
</ul>
<p>2、根据目的来分</p>
<p>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种：</p>
<ul>
<li>创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li>
<li>结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li>
<li>行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</li>
</ul>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的主要关注点是“<strong>怎样创建对象？</strong>”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<p>创建型模式分为以下几种：</p>
<ul>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式<strong>描述如何将类或对象按某种布局组成更大的结构</strong>。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ul>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ul>
<p>以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式。</p>
<h2 id="行为性模式"><a href="#行为性模式" class="headerlink" title="行为性模式"></a>行为性模式</h2><p>行为型模式用于描述程序在运行时复杂的流程控制，即<strong>描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务</strong>，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式：</p>
<ul>
<li>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ul>
<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/27/design-pattern-bridge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/27/design-pattern-bridge/" itemprop="url">桥接模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-27T16:29:28+08:00">
                2019-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是<strong>用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度</strong>。</p>
<p>桥接模式的优点是：<br>1、由于抽象与实现分离，所以扩展能力强；<br>2、其实现细节对客户透明。</p>
<p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。<br>2、当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。<br>3、当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</p>
<h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。</p>
<p><img src="/2019/11/27/design-pattern-bridge/bridge.jpg" alt></p>
<p>桥接（Bridge）模式包含以下主要角色：<br>1、抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。<br>2、扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。<br>3、实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。<br>4、具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</p>
<p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//实现化角色</span><br><span class="line">interface Implementor</span><br><span class="line">&#123;</span><br><span class="line">    public void OperationImpl();</span><br><span class="line">&#125;</span><br><span class="line">//具体实现化角色</span><br><span class="line">class ConcreteImplementorA implements Implementor</span><br><span class="line">&#123;</span><br><span class="line">    public void OperationImpl()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体实现化(Concrete Implementor)角色被访问&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象化角色</span><br><span class="line">abstract class Abstraction</span><br><span class="line">&#123;</span><br><span class="line">   protected Implementor imple;</span><br><span class="line">   protected Abstraction(Implementor imple)</span><br><span class="line">   &#123;</span><br><span class="line">       this.imple=imple;</span><br><span class="line">   &#125;</span><br><span class="line">   public abstract void Operation();   </span><br><span class="line">&#125;</span><br><span class="line">//扩展抽象化角色</span><br><span class="line">class RefinedAbstraction extends Abstraction</span><br><span class="line">&#123;</span><br><span class="line">   protected RefinedAbstraction(Implementor imple)</span><br><span class="line">   &#123;</span><br><span class="line">       super(imple);</span><br><span class="line">   &#125;</span><br><span class="line">   public void Operation()</span><br><span class="line">   &#123;</span><br><span class="line">       System.out.println(&quot;扩展抽象化(Refined Abstraction)角色被访问&quot; );</span><br><span class="line">       imple.OperationImpl();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class BridgeTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Implementor imple=new ConcreteImplementorA();</span><br><span class="line">        Abstraction abs=new RefinedAbstraction(imple);</span><br><span class="line">        abs.Operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果如下：</span><br><span class="line">扩展抽象化(Refined Abstraction)角色被访问</span><br><span class="line">具体实现化(Concrete Implementor)角色被访问</span><br></pre></td></tr></table></figure></p>
<h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>在软件开发中，有时桥接（Bridge）模式可与适配器模式联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来，其具体结构图如下：</p>
<p><img src="/2019/11/27/design-pattern-bridge/bridge-adaptee.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/27/design-pattern-facade/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/27/design-pattern-facade/" itemprop="url">外观模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-27T15:50:48+08:00">
                2019-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点：<br>1、降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。<br>2、对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。<br>3、降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</p>
<p>外观（Facade）模式的主要缺点如下：<br>1、不能很好地限制客户使用子系统类。<br>2、增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。<br>2、当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。<br>3、当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</p>
<h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。</p>
<p><img src="/2019/11/27/design-pattern-facade/facade.jpg" alt></p>
<p>外观（Facade）模式包含以下主要角色:<br>1、外观（Facade）角色：为多个子系统对外提供一个共同的接口。<br>2、子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。<br>3、客户（Client）角色：通过一个外观角色访问各个子系统的功能。</p>
<p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//外观角色</span><br><span class="line">class Facade</span><br><span class="line">&#123;</span><br><span class="line">    private SubSystem01 obj1=new SubSystem01();</span><br><span class="line">    private SubSystem02 obj2=new SubSystem02();</span><br><span class="line">    private SubSystem03 obj3=new SubSystem03();</span><br><span class="line">    public void method()</span><br><span class="line">    &#123;</span><br><span class="line">        obj1.method1();</span><br><span class="line">        obj2.method2();</span><br><span class="line">        obj3.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem01</span><br><span class="line">&#123;</span><br><span class="line">    public  void method1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统01的method1()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem02</span><br><span class="line">&#123;</span><br><span class="line">    public  void method2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统02的method2()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//子系统角色</span><br><span class="line">class SubSystem03</span><br><span class="line">&#123;</span><br><span class="line">    public  void method3()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;子系统03的method3()被调用！&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class FacadePattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Facade f=new Facade();</span><br><span class="line">        f.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序运行结果如下：</span><br><span class="line">子系统01的method1()被调用！</span><br><span class="line">子系统02的method2()被调用！</span><br><span class="line">子系统03的method3()被调用！</span><br></pre></td></tr></table></figure></p>
<h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h2><p>在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题，其结构图如下：</p>
<p><img src="/2019/11/27/design-pattern-facade/facade-abs.jpg" alt></p>
<h2 id="与装饰模式区别"><a href="#与装饰模式区别" class="headerlink" title="与装饰模式区别"></a>与装饰模式区别</h2><p>装饰者听名字就知道他是对某个东西进行装饰，但是外观听上去也是对某个东西的外表进行装饰封装？那他们之间到底是有什么区别呢？<br>区别如下：外观是对一系列的接口进行封装，而装饰模式，是对某样东西进行内容的附加，从而得到新的东西。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/26/design-pattern-flyweight/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/26/design-pattern-flyweight/" itemprop="url">享元模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-26T09:14:06+08:00">
                2019-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>享元（Flyweight）模式的定义：运用共享技术来有效地支持<strong>大量细粒度对象的复用</strong>。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>享元模式的主要优点是：<br>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<p>其主要缺点是：<br>1、为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。<br>2、读取享元模式的外部状态会使得运行时间稍微变长。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。<br>2、大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。<br>3、由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</p>
<h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>享元模式中存在以下两种状态：<br>1、内部状态，即不会随着环境的改变而改变的可共享部分；<br>2、外部状态，指随环境改变而改变的不可以共享的部分。<br>享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</p>
<p><img src="/2019/11/26/design-pattern-flyweight/flyweight.jpg" alt></p>
<p>享元模式的主要角色有如下：<br>1、抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。<br>2、具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。<br>3、非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。<br>4、享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</p>
<p>实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">//非享元角色</span><br><span class="line">class UnsharedConcreteFlyweight</span><br><span class="line">&#123;</span><br><span class="line">    private String info;</span><br><span class="line">    UnsharedConcreteFlyweight(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        this.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getInfo()</span><br><span class="line">    &#123;</span><br><span class="line">        return info;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setInfo(String info)</span><br><span class="line">    &#123;</span><br><span class="line">        this.info=info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//抽象享元角色</span><br><span class="line">interface Flyweight</span><br><span class="line">&#123;</span><br><span class="line">    public void operation(UnsharedConcreteFlyweight state);</span><br><span class="line">&#125;</span><br><span class="line">//具体享元角色</span><br><span class="line">class ConcreteFlyweight implements Flyweight</span><br><span class="line">&#123;</span><br><span class="line">    private String key;</span><br><span class="line">    ConcreteFlyweight(String key)</span><br><span class="line">    &#123;</span><br><span class="line">        this.key=key;</span><br><span class="line">        System.out.println(&quot;具体享元&quot;+key+&quot;被创建！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void operation(UnsharedConcreteFlyweight outState)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(&quot;具体享元&quot;+key+&quot;被调用，&quot;);</span><br><span class="line">        System.out.println(&quot;非享元信息是:&quot;+outState.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//享元工厂角色</span><br><span class="line">class FlyweightFactory</span><br><span class="line">&#123;</span><br><span class="line">    private HashMap&lt;String, Flyweight&gt; flyweights=new HashMap&lt;String, Flyweight&gt;();</span><br><span class="line">    public Flyweight getFlyweight(String key)</span><br><span class="line">    &#123;</span><br><span class="line">        Flyweight flyweight=(Flyweight)flyweights.get(key);</span><br><span class="line">        if(flyweight!=null)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(&quot;具体享元&quot;+key+&quot;已经存在，被成功获取！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            flyweight=new ConcreteFlyweight(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        return flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Client</span><br><span class="line">public class FlyweightPattern</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        FlyweightFactory factory=new FlyweightFactory();</span><br><span class="line">        Flyweight f01=factory.getFlyweight(&quot;a&quot;);</span><br><span class="line">        Flyweight f02=factory.getFlyweight(&quot;a&quot;);</span><br><span class="line">        Flyweight f03=factory.getFlyweight(&quot;a&quot;);</span><br><span class="line">        Flyweight f11=factory.getFlyweight(&quot;b&quot;);</span><br><span class="line">        Flyweight f12=factory.getFlyweight(&quot;b&quot;);       </span><br><span class="line">        f01.operation(new UnsharedConcreteFlyweight(&quot;第1次调用a。&quot;));       </span><br><span class="line">        f02.operation(new UnsharedConcreteFlyweight(&quot;第2次调用a。&quot;));       </span><br><span class="line">        f03.operation(new UnsharedConcreteFlyweight(&quot;第3次调用a。&quot;));       </span><br><span class="line">        f11.operation(new UnsharedConcreteFlyweight(&quot;第1次调用b。&quot;));       </span><br><span class="line">        f12.operation(new UnsharedConcreteFlyweight(&quot;第2次调用b。&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序运行结果如下：</span><br><span class="line">具体享元a被创建！</span><br><span class="line">具体享元a已经存在，被成功获取！</span><br><span class="line">具体享元a已经存在，被成功获取！</span><br><span class="line">具体享元b被创建！</span><br><span class="line">具体享元b已经存在，被成功获取！</span><br><span class="line">具体享元a被调用，非享元信息是:第1次调用a。</span><br><span class="line">具体享元a被调用，非享元信息是:第2次调用a。</span><br><span class="line">具体享元a被调用，非享元信息是:第3次调用a。</span><br><span class="line">具体享元b被调用，非享元信息是:第1次调用b。</span><br><span class="line">具体享元b被调用，非享元信息是:第2次调用b。</span><br></pre></td></tr></table></figure></p>
<h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>在前面介绍的享元模式中，其结构图通常包含可以共享的部分和不可以共享的部分。在实际使用过程中，有时候会稍加改变，即存在两种特殊的享元模式：单纯享元模式和复合享元模式，下面分别对它们进行简单介绍。</p>
<p>(1) 单纯享元模式，这种享元模式中的所有的具体享元类都是可以共享的，不存在非共享的具体享元类，其结构图如下图：</p>
<p><img src="/2019/11/26/design-pattern-flyweight/flyweight-simple.jpg" alt></p>
<p>(2) 复合享元模式，这种享元模式中的有些享元对象是由一些单纯享元对象组合而成的，它们就是复合享元对象。虽然复合享元对象本身不能共享，但它们可以分解成单纯享元对象再被共享，其结构图如下图：</p>
<p><img src="/2019/11/26/design-pattern-flyweight/flyweight-composite.jpg" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Shuming Zhao">
            
              <p class="site-author-name" itemprop="name">Shuming Zhao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuming Zhao</span>

  
</div>

<div class="powered-by"><i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人，
<span id="busuanzi_container_site_pv">访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
</span>
</div>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
