<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="1ilOhMWnNE">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/16/db-store-procedure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/16/db-store-procedure/" itemprop="url">MySQL 存储过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-16T14:53:26+08:00">
                2020-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。存储过程思想上很简单，就是<strong>数据库 SQL 语言层面的代码封装与重用</strong>。</p>
<p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p>
<p>MySQL 5.0 版本开始支持存储过程。</p>
<ul>
<li>优点<br>存储过程可封装，并隐藏复杂的商业逻辑。<br>存储过程可以回传值，并可以接受参数。<br>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。<br>存储过程可以用在数据检验，强制实行商业逻辑等。</li>
<li>缺点<br>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。<br>存储过程的性能调校与撰写，受限于各种数据库系统。</li>
</ul>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>MySQL中，创建存储过程的基本形式如下：</p>
<blockquote>
<p><strong>CREATE PROCEDURE sp_name ([proc_parameter[,…]]) [characteristic …] routine_body </strong></p>
</blockquote>
<p>其中，sp_name参数是存储过程的名称；proc_parameter表示存储过程的参数列表； characteristic参数指定存储过程的特性；routine_body参数是SQL代码的内容，可以用BEGIN…END来标志SQL代码的开始和结束。</p>
<h3 id="proc-parameter"><a href="#proc-parameter" class="headerlink" title="proc_parameter"></a>proc_parameter</h3><p>proc_parameter中的每个参数由3部分组成。这3部分分别是输入输出类型、参数名称和参数类型。其形式如下：</p>
<p>[ IN | OUT | INOUT ] param_name type </p>
<p>其中，IN表示输入参数；OUT表示输出参数； INOUT表示既可以是输入，也可以是输出； param_name参数是存储过程的参数名称；type参数指定存储过程的参数类型，该类型可以是MySQL数据库的任意数据类型。</p>
<h3 id="characteristic"><a href="#characteristic" class="headerlink" title="characteristic"></a>characteristic</h3><p>characteristic参数有多个取值。其取值说明如下：</p>
<p>LANGUAGE SQL：说明routine_body部分是由SQL语言的语句组成，这也是数据库系统默认的语言。</p>
<p>[NOT] DETERMINISTIC：指明存储过程的执行结果是否是确定的。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是非确定的，相同的输入可能得到不同的输出。默认情况下，结果是非确定的。</p>
<p>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：指明子程序使用SQL语句的限制。CONTAINS SQL表示子程序包含SQL语句，但不包含读或写数据的语句；NO SQL表示子程序中不包含SQL语句；READS SQL DATA表示子程序中包含读数据的语句；MODIFIES SQL DATA表示子程序中包含写数据的语句。默认情况下，系统会指定为CONTAINS SQL。</p>
<p>SQL SECURITY { DEFINER | INVOKER }：指明谁有权限来执行。DEFINER表示只有定义者自己才能够执行；INVOKER表示调用者可以执行。默认情况下，系统指定的权限是DEFINER。</p>
<p>COMMENT ‘string’：注释信息。</p>
<p>技巧：创建存储过程时，系统默认指定CONTAINS SQL，表示存储过程中使用了SQL语句。但是，如果存储过程中没有使用SQL语句，最好设置为NO SQL。而且，存储过程中最好在COMMENT部分对存储过程进行简单的注释，以便以后在阅读存储过程的代码时更加方便。</p>
<p>【示例1】 下面创建一个名为num_from_employee的存储过程。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE  PROCEDURE  num_from_employee (IN emp_id INT, OUT count_num INT )  </span><br><span class="line">          READS SQL DATA  </span><br><span class="line">          BEGIN  </span><br><span class="line">              SELECT  COUNT(*)  INTO  count_num  </span><br><span class="line">              FROM  employee  </span><br><span class="line">              WHERE  d_id=emp_id ;  </span><br><span class="line">          END</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，存储过程名称为num_from_employee；输入变量为emp_id；输出变量为count_num。SELECT语句从employee表查询d_id值等于emp_id的记录，并用COUNT(*)计算d_id值相同的记录的条数，最后将计算结果存入count_num中。</p>
<p>说明：MySQL中默认的语句结束符为分号（;）。存储过程中的SQL语句需要分号来结束。<strong>为了避免冲突，首先用”DELIMITER &amp;&amp;”将MySQL的结束符设置为&amp;&amp;。最后再用”DELIMITER ;”来将结束符恢复成分号</strong>。这与创建触发器时是一样的。如下示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">DROP PROCEDURE IF EXISTS `TEST`.`getRecord` $$</span><br><span class="line">CREATE PROCEDURE `TEST`.`getRecord` (</span><br><span class="line">IN in_id INTEGER,</span><br><span class="line">OUT out_name VARCHAR(20),</span><br><span class="line">OUT out_age  INTEGER)</span><br><span class="line">BEGIN</span><br><span class="line">   SELECT name, age</span><br><span class="line">   INTO out_name, out_age</span><br><span class="line">   FROM Student where id = in_id;</span><br><span class="line">END $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在MySQL中，创建存储函数的基本形式如下：</p>
<blockquote>
<p><strong>CREATE FUNCTION sp_name ([func_parameter[,…]]) RETURNS type  [characteristic …] routine_body </strong></p>
</blockquote>
<p>其中，sp_name参数是存储函数的名称；func_parameter表示存储函数的参数列表；RETURNS type指定返回值的类型；characteristic参数指定存储函数的特性，该参数的取值与存储过程中的取值是一样的；routine_body参数是SQL代码的内容，可以用BEGIN…END来标志SQL代码的开始和结束。</p>
<p>func_parameter可以由多个参数组成，其中每个参数由参数名称和参数类型组成，其形式如下：param_name type</p>
<p>其中，param_name参数是存储函数的参数名称；type参数指定存储函数的参数类型，该类型可以是MySQL数据库的任意数据类型。</p>
<p>【示例2】 下面创建一个名为name_from_employee的存储函数。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE  FUNCTION  name_from_employee (emp_id INT )  </span><br><span class="line">          RETURNS VARCHAR(20)  </span><br><span class="line">          BEGIN  </span><br><span class="line">              RETURN  (SELECT  name  </span><br><span class="line">              FROM  employee  </span><br><span class="line">              WHERE  num=emp_id );  </span><br><span class="line">          END</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，存储函数的名称为name_from_employee；该函数的参数为emp_id；返回值是VARCHAR类型。SELECT语句从employee表查询num值等于emp_id的记录，并将该记录的name字段的值返回。</p>
<h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><p>在存储过程和函数中，可以定义和使用变量。用户可以使用DECLARE关键字来定义变量。然后可以为变量赋值。这些变量的作用范围是BEGIN…END程序段中。本小节将讲解如何定义变量和为变量赋值。</p>
<h3 id="1．定义变量"><a href="#1．定义变量" class="headerlink" title="1．定义变量"></a>1．定义变量</h3><p>MySQL中可以使用DECLARE关键字来定义变量。定义变量的基本语法如下：</p>
<blockquote>
<p><strong>DECLARE  var_name[,…]  type  [DEFAULT value] </strong></p>
</blockquote>
<p>其中， DECLARE关键字是用来声明变量的；var_name参数是变量的名称，这里可以同时定义多个变量；type参数用来指定变量的类型；DEFAULT value子句将变量默认值设置为value，没有使用DEFAULT子句时，默认值为NULL。</p>
<p>【示例3】 下面定义变量my_sql，数据类型为INT型，默认值为10。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  my_sql  INT  DEFAULT 10 ;</span><br></pre></td></tr></table></figure></p>
<h3 id="2．为变量赋值"><a href="#2．为变量赋值" class="headerlink" title="2．为变量赋值"></a>2．为变量赋值</h3><p>MySQL中可以使用SET关键字来为变量赋值。SET语句的基本语法如下：</p>
<blockquote>
<p><strong>SET  var_name = expr [, var_name = expr] … </strong></p>
</blockquote>
<p>其中，SET关键字是用来为变量赋值的；var_name参数是变量的名称；expr参数是赋值表达式。一个SET语句可以同时为多个变量赋值，各个变量的赋值语句之间用逗号隔开。</p>
<p>【示例4】 下面为变量my_sql赋值为30。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET  my_sql = 30 ;</span><br></pre></td></tr></table></figure></p>
<p>MySQL中还可以使用SELECT…INTO语句为变量赋值。其基本语法如下：</p>
<blockquote>
<p><strong>SELECT  col_name[,…]  INTO  var_name[,…] FROM  table_name  WEHRE  condition </strong></p>
</blockquote>
<p>其中，col_name参数表示查询的字段名称；var_name参数是变量的名称；table_name参数指表的名称；condition参数指查询条件。</p>
<p>【示例5】 下面从employee表中查询id为2的记录，将该记录的d_id值赋给变量my_sql。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT  d_id  INTO  my_sql  FROM  employee  WEHRE  id=2 ;</span><br></pre></td></tr></table></figure></p>
<h2 id="定义条件和处理程序"><a href="#定义条件和处理程序" class="headerlink" title="定义条件和处理程序"></a>定义条件和处理程序</h2><p>定义条件和处理程序是事先定义程序执行过程中可能遇到的问题。并且可以在处理程序中定义解决这些问题的办法。这种方式可以提前预测可能出现的问题，并提出解决办法。这样可以增强程序处理问题的能力，避免程序异常停止。MySQL中都是通过DECLARE关键字来定义条件和处理程序。</p>
<h3 id="定义条件"><a href="#定义条件" class="headerlink" title="定义条件"></a>定义条件</h3><p>MySQL中可以使用DECLARE关键字来定义条件。其基本语法如下：</p>
<blockquote>
<p><strong>DECLARE  condition_name  CONDITION  FOR  condition_value</strong><br>condition_value:<br>      SQLSTATE [VALUE] sqlstate_value | mysql_error_code </p>
</blockquote>
<p>其中，condition_name参数表示条件的名称；condition_value参数表示条件的类型；sqlstate_value参数和mysql_error_code参数都可以表示MySQL的错误。例如ERROR 1146 (42S02)中，sqlstate_value值是42S02，mysql_error_code值是1146。</p>
<p>【示例6】 下面定义”ERROR 1146 (42S02)”这个错误，名称为can_not_find。可以用两种不同的方法来定义，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//方法一：使用sqlstate_value  </span><br><span class="line">DECLARE  can_not_find  CONDITION  FOR  SQLSTATE  &apos;42S02&apos; ;  </span><br><span class="line">//方法二：使用mysql_error_code  </span><br><span class="line">DECLARE  can_not_find  CONDITION  FOR  1146 ;</span><br></pre></td></tr></table></figure></p>
<h3 id="定义处理程序"><a href="#定义处理程序" class="headerlink" title="定义处理程序"></a>定义处理程序</h3><p>MySQL中可以使用DECLARE关键字来定义处理程序。其基本语法如下：</p>
<blockquote>
<p><strong>DECLARE handler_type HANDLER FOR condition_value[,…] sp_statement  </strong><br>handler_type:<br>    CONTINUE | EXIT | UNDO<br>condition_value:<br>    SQLSTATE [VALUE] sqlstate_value | condition_name  | SQLWARNING  | NOT FOUND  | SQLEXCEPTION  | mysql_error_code </p>
</blockquote>
<p>其中，handler_type参数指明错误的处理方式，该参数有3个取值。这3个取值分别是CONTINUE、EXIT和UNDO。CONTINUE表示遇到错误不进行处理，继续向下执行；EXIT表示遇到错误后马上退出；UNDO表示遇到错误后撤回之前的操作，MySQL中暂时还不支持这种处理方式。</p>
<p>注意：通常情况下，执行过程中遇到错误应该立刻停止执行下面的语句，并且撤回前面的操作。但是，MySQL中现在还不能支持UNDO操作。因此，遇到错误时最好执行EXIT操作。如果事先能够预测错误类型，并且进行相应的处理，那么可以执行CONTINUE操作。</p>
<p>condition_value参数指明错误类型，该参数有6个取值。sqlstate_value和mysql_error_code与条件定义中的是同一个意思。condition_name是DECLARE定义的条件名称。SQLWARNING表示所有以01开头的sqlstate_value值。NOT FOUND表示所有以02开头的sqlstate_value值。SQLEXCEPTION表示所有没有被SQLWARNING或NOT FOUND捕获的sqlstate_value值。sp_statement表示一些存储过程或函数的执行语句。</p>
<p>【示例7】 下面是定义处理程序的几种方式。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//方法一：捕获sqlstate_value  </span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &apos;42S02&apos; SET @info=&apos;CAN NOT FIND&apos;;  </span><br><span class="line">//方法二：捕获mysql_error_code  </span><br><span class="line">DECLARE CONTINUE HANDLER FOR 1146 SET @info=&apos;CAN NOT FIND&apos;;  </span><br><span class="line">//方法三：先定义条件，然后调用  </span><br><span class="line">DECLARE  can_not_find  CONDITION  FOR  1146 ;  </span><br><span class="line">DECLARE CONTINUE HANDLER FOR can_not_find SET @info=&apos;CAN NOT FIND&apos;;  </span><br><span class="line">//方法四：使用SQLWARNING  </span><br><span class="line">DECLARE EXIT HANDLER FOR SQLWARNING SET @info=&apos;ERROR&apos;;  </span><br><span class="line">//方法五：使用NOT FOUND  </span><br><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND SET @info=&apos;CAN NOT FIND&apos;;  </span><br><span class="line">//方法六：使用SQLEXCEPTION  </span><br><span class="line">DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info=&apos;ERROR&apos;;</span><br></pre></td></tr></table></figure></p>
<p>上述代码是6种定义处理程序的方法。</p>
<p>第一种方法是捕获sqlstate_value值。如果遇到sqlstate_value值为42S02，执行CONTINUE操作，并且输出”CAN NOT FIND”信息。</p>
<p>第二种方法是捕获mysql_error_code值。如果遇到mysql_error_code值为1146，执行CONTINUE操作，并且输出”CAN NOT FIND”信息。</p>
<p>第三种方法是先定义条件，然后再调用条件。这里先定义can_not_find条件，遇到1146错误就执行CONTINUE操作。</p>
<p>第四种方法是使用SQLWARNING。SQLWARNING捕获所有以01开头的sqlstate_value值，然后执行EXIT操作，并且输出”ERROR”信息。</p>
<p>第五种方法是使用NOT FOUND。NOT FOUND捕获所有以02开头的sqlstate_value值，然后执行EXIT操作，并且输出”CAN NOT FIND”信息。</p>
<p>第六种方法是使用SQLEXCEPTION。SQLEXCEPTION捕获所有没有被SQLWARNING或NOT FOUND捕获的sqlstate_value值，然后执行EXIT操作，并且输出”ERROR”信息。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/mark5/p/11170577.html" target="_blank" rel="noopener">https://www.cnblogs.com/mark5/p/11170577.html</a><br><a href="https://www.runoob.com/w3cnote/mysql-stored-procedure.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/mysql-stored-procedure.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/09/java-spring-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/09/java-spring-basics/" itemprop="url">Spring 知识点笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-09T11:26:23+08:00">
                2020-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/" itemprop="url" rel="index">
                    <span itemprop="name">Java Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>Spring 有可能成为所有企业应用程序的一站式服务点，然而，Spring 是模块化的，允许你挑选和选择适用于你的模块，不必要把剩余部分也引入。Spring 框架提供约 20 个模块，可以根据应用程序的要求来使用。</p>
<p><img src="/2020/07/09/java-spring-basics/spring-framework.png" alt></p>
<h3 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h3><p>核心容器由spring-core，spring-beans，spring-context，spring-context-support和spring-expression（SpEL，Spring表达式语言，Spring Expression Language）等模块组成，它们的细节如下：</p>
<ul>
<li><p>spring-core模块提供了框架的基本组成部分，包括 IoC 和依赖注入功能。</p>
</li>
<li><p>spring-beans 模块提供 BeanFactory，工厂模式的微妙实现，它移除了编码式单例的需要，并且可以把配置和依赖从实际编码逻辑中解耦。</p>
</li>
<li><p>context模块建立在由core和 beans 模块的基础上建立起来的，它以一种类似于JNDI注册的方式访问对象。Context模块继承自Bean模块，并且添加了国际化（比如，使用资源束）、事件传播、资源加载和透明地创建上下文（比如，通过Servelet容器）等功能。Context模块也支持Java EE的功能，比如EJB、JMX和远程调用等。ApplicationContext接口是Context模块的焦点。spring-context-support提供了对第三方库集成到Spring上下文的支持，比如缓存（EhCache, Guava, JCache）、邮件（JavaMail）、调度（CommonJ, Quartz）、模板引擎（FreeMarker, JasperReports, Velocity）等。</p>
</li>
<li><p>spring-expression模块提供了强大的表达式语言，用于在运行时查询和操作对象图。它是JSP2.1规范中定义的统一表达式语言的扩展，支持set和get属性值、属性赋值、方法调用、访问数组集合及索引的内容、逻辑算术运算、命名变量、通过名字从Spring IoC容器检索对象，还支持列表的投影、选择以及聚合等。</p>
</li>
</ul>
<p>它们的完整依赖关系如下图所示：</p>
<p><img src="/2020/07/09/java-spring-basics/spring-core.png" alt></p>
<h3 id="数据访问-集成"><a href="#数据访问-集成" class="headerlink" title="数据访问/集成"></a>数据访问/集成</h3><p>数据访问/集成层包括 JDBC，ORM，OXM，JMS 和事务处理模块，它们的细节如下：注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service）</p>
<ul>
<li><p>JDBC 模块提供了JDBC抽象层，它消除了冗长的JDBC编码和对数据库供应商特定错误代码的解析。</p>
</li>
<li><p>ORM 模块提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理。</p>
</li>
<li><p>OXM 模块提供了对OXM实现的支持，比如JAXB、Castor、XML Beans、JiBX、XStream等。</p>
</li>
<li><p>JMS 模块包含生产（produce）和消费（consume）消息的功能。从Spring 4.1开始，集成了spring-messaging模块。。</p>
</li>
</ul>
<p>事务模块为实现特殊接口类及所有的 POJO 支持编程式和声明式事务管理。（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细）</p>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>Web 层由 Web，Web-MVC，Web-Socket 和 Web-Portlet 组成，它们的细节如下：</p>
<ul>
<li><p>Web 模块提供面向web的基本功能和面向web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分。。</p>
</li>
<li><p>Web-MVC 模块为web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和web表单完全地分离，且可以与Spring框架的其它所有功能进行集成。</p>
</li>
<li><p>Web-Socket 模块为 WebSocket-based 提供了支持，而且在 web 应用程序中提供了客户端和服务器端之间通信的两种方式。</p>
</li>
<li><p>Web-Portlet 模块提供了用于Portlet环境的MVC实现，并反映了spring-webmvc模块的功能。</p>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>还有其他一些重要的模块，像 AOP，Aspects，Instrumentation，Web 和测试模块，它们的细节如下：</p>
<ul>
<li><p>AOP 模块提供了面向方面的编程实现，允许你定义方法拦截器和切入点对代码进行干净地解耦，从而使实现功能的代码彻底的解耦出来。使用源码级的元数据，可以用类似于.Net属性的方式合并行为信息到代码中。</p>
</li>
<li><p>Aspects 模块提供了与 AspectJ 的集成，这是一个功能强大且成熟的面向切面编程（AOP）框架。</p>
</li>
<li><p>Instrumentation 模块在一定的应用服务器中提供了类 instrumentation 的支持和类加载器的实现。</p>
</li>
<li><p>Messaging 模块为 STOMP 提供了支持作为在应用程序中 WebSocket 子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自 WebSocket 客户端的 STOMP 信息。</p>
</li>
<li><p>测试模块支持对具有 JUnit 或 TestNG 框架的 Spring 组件的测试。</p>
</li>
</ul>
<h2 id="Spring-IoC-容器"><a href="#Spring-IoC-容器" class="headerlink" title="Spring IoC 容器"></a>Spring IoC 容器</h2><p>Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用<strong>依赖注入（DI）</strong>来管理组成一个应用程序的组件。这些对象被称为 <strong>Spring Beans</strong>。</p>
<p>IOC 容器具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而<strong>“控制反转”</strong>是指new实例工作不由程序员来做而是交给Spring容器来做。Spring 提供了以下两种不同类型的容器:</p>
<p><img src="/2020/07/09/java-spring-basics/spring-ioc.png" alt></p>
<p><strong>ApplicationContext 容器包括 BeanFactory 容器的所有功能</strong>，所以通常建议超过 BeanFactory。BeanFactory 仍然可以用于轻量级的应用程序，如移动设备或基于 applet 的应用程序，其中它的数据量和速度是显著。</p>
<h3 id="Spring-的-BeanFactory-容器-忽略"><a href="#Spring-的-BeanFactory-容器-忽略" class="headerlink" title="Spring 的 BeanFactory 容器(忽略)"></a>Spring 的 BeanFactory 容器(忽略)</h3><p>这是一个最简单的容器，它主要的功能是为依赖注入 （DI） 提供支持，这个容器接口在 org.springframework.beans.factory.BeanFactor 中被定义。BeanFactory 和相关的接口，比如BeanFactoryAware、DisposableBean、InitializingBean，仍旧保留在 Spring 中，主要目的是向后兼容已经存在的和那些 Spring 整合在一起的第三方框架。</p>
<p>在 Spring 中，有大量对 BeanFactory 接口的实现。其中，最常被使用的是 XmlBeanFactory 类。这个容器从一个 XML 文件中读取配置元数据，由这些元数据来生成一个被配置化的系统或者应用。</p>
<h3 id="Spring-ApplicationContext-容器"><a href="#Spring-ApplicationContext-容器" class="headerlink" title="Spring ApplicationContext 容器"></a>Spring ApplicationContext 容器</h3><p>Application Context 是 BeanFactory 的子接口，也被成为 Spring 上下文。 这个容器在 org.springframework.context.ApplicationContext interface 接口中定义。</p>
<p>最常被使用的 ApplicationContext 接口实现：</p>
<ul>
<li><p>FileSystemXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你需要提供给构造器 XML 文件的完整路径。</p>
</li>
<li><p>ClassPathXmlApplicationContext：该容器从 XML 文件中加载已被定义的 bean。在这里，你不需要提供 XML 文件的完整路径，只需正确配置 CLASSPATH 环境变量即可，因为，容器会从 CLASSPATH 中搜索 bean 配置文件。</p>
</li>
<li><p>WebXmlApplicationContext：该容器会在一个 web 应用程序的范围内加载在 XML 文件中已被定义的 bean。</p>
</li>
</ul>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class HelloSpringSingleton &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;/res/applicationContext.xml&quot;);</span><br><span class="line">        HelloWorld objA = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        objA.setName(&quot;I&apos;m object A&quot;);</span><br><span class="line">        objA.sqyHello();</span><br><span class="line">        HelloWorld objB = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">        objB.sqyHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.out.println(&quot;Bean is going through init.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void destroy()&#123;</span><br><span class="line">        System.out.println(&quot;Bean will destroy now.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /res/applicationContext.xml</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;helloWorld&quot; class=&quot;com.zsm.test.HelloWorld&quot;</span><br><span class="line">          scope=&quot;singleton&quot;&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;helloWorld1&quot; class=&quot;com.zsm.test.HelloWorld&quot;</span><br><span class="line">          init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring-Bean-定义"><a href="#Spring-Bean-定义" class="headerlink" title="Spring Bean 定义"></a>Spring Bean 定义</h3><p>被称作 bean 的对象是构成应用程序的支柱也是由 Spring IoC 容器管理的。bean 是一个被实例化，组装，并通过 Spring IoC 容器所管理的对象。这些 bean 是由用容器提供的配置元数据创建的。</p>
<p>bean 定义包含称为配置元数据的信息，下述容器也需要知道配置元数据：</p>
<ul>
<li><p>如何创建一个 bean</p>
</li>
<li><p>bean 的生命周期的详细信息</p>
</li>
<li><p>bean 的依赖关系</p>
</li>
</ul>
<p><img src="/2020/07/09/java-spring-basics/bean.jpg" alt title="Bean 与 Spring 容器的关系"></p>
<p>Spring IoC 容器完全由实际编写的配置元数据的格式解耦。有下面三个重要的方法把配置元数据提供给 Spring 容器：</p>
<ul>
<li><p>基于 XML 的配置文件</p>
</li>
<li><p>基于注解的配置</p>
</li>
<li><p>基于 Java 的配置</p>
</li>
</ul>
<h3 id="Spring-Bean-作用域"><a href="#Spring-Bean-作用域" class="headerlink" title="Spring Bean 作用域"></a>Spring Bean 作用域</h3><p><img src="/2020/07/09/java-spring-basics/spring-scope.png" alt></p>
<h3 id="Spring-Bean-生命周期"><a href="#Spring-Bean-生命周期" class="headerlink" title="Spring Bean 生命周期"></a>Spring Bean 生命周期</h3><p>为了定义安装和拆卸一个 bean，我们只要声明带有 <strong>init-method 或 destroy-method</strong> 参数的 。init-method 属性指定一个方法，在实例化 bean 时，立即调用该方法。同样，destroy-method 指定一个方法，只有从容器中移除 bean 之后，才能调用该方法。</p>
<p>Bean的生命周期可以表达为：Bean的定义——Bean的初始化——Bean的使用——Bean的销毁。</p>
<h4 id="初始化及销毁回调"><a href="#初始化及销毁回调" class="headerlink" title="初始化及销毁回调"></a>初始化及销毁回调</h4><p>org.springframework.beans.factory.InitializingBean 接口指定一个单一的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void afterPropertiesSet() throws Exception;</span><br></pre></td></tr></table></figure></p>
<p>因此，你可以简单地实现上述接口和初始化工作可以在 afterPropertiesSet() 方法中执行，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean implements InitializingBean &#123;</span><br><span class="line">   public void afterPropertiesSet() &#123;</span><br><span class="line">      // do some initialization work</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在基于 XML 的配置元数据的情况下，你可以使用 init-method 属性来指定带有 void 无参数方法的名称。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot; init-method=&quot;init&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面是类的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line">   public void init() &#123;</span><br><span class="line">      // do some initialization work</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>销毁回调 org.springframework.beans.factory.DisposableBean 与上述初始化回调类似。</p>
<p>main方法中，你需要注册一个在 AbstractApplicationContext 类中声明的关闭 hook 的 <strong>registerShutdownHook()</strong> 方法。它将确保正常关闭，并且调用相关的 destroy 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line">   HelloWorld obj = (HelloWorld) context.getBean(&quot;helloWorld&quot;);</span><br><span class="line">   obj.getMessage();</span><br><span class="line">   context.registerShutdownHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>建议不要使用 InitializingBean 或者 DisposableBean 的回调方法，因为 XML 配置在命名方法上提供了极大的灵活性。</strong></p>
<h4 id="默认的初始化和销毁方法"><a href="#默认的初始化和销毁方法" class="headerlink" title="默认的初始化和销毁方法"></a>默认的初始化和销毁方法</h4><p>如果你有太多具有相同名称的初始化或者销毁方法的 Bean，那么你不需要在每一个 bean 上声明初始化方法和销毁方法。框架使用 元素中的 default-init-method 和 default-destroy-method 属性提供了灵活地配置这种情况，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;</span><br><span class="line">    default-init-method=&quot;init&quot; </span><br><span class="line">    default-destroy-method=&quot;destroy&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt;</span><br><span class="line">       &lt;!-- collaborators and configuration for this bean go here --&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring——Bean-后置处理器"><a href="#Spring——Bean-后置处理器" class="headerlink" title="Spring——Bean 后置处理器"></a>Spring——Bean 后置处理器</h3><p>Bean 后置处理器允许在调用初始化方法前后对 Bean 进行额外的处理。</p>
<p>BeanPostProcessor 接口定义回调方法，你可以实现该方法来提供自己的实例化逻辑，依赖解析逻辑等。你可以配置多个 BeanPostProcessor 接口，通过设置 BeanPostProcessor 实现的 Ordered 接口提供的 order 属性来控制这些 BeanPostProcessor 接口的执行顺序。</p>
<p>ApplicationContext <strong>会自动检测由 BeanPostProcessor 接口的实现定义的 bean</strong>，注册这些 bean 为后置处理器，然后通过在容器中创建 bean，在适当的时候调用它。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class InitHelloWorld implements BeanPostProcessor &#123;</span><br><span class="line">   public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">      System.out.println(&quot;BeforeInitialization : &quot; + beanName);</span><br><span class="line">      return bean;  // you can return any other object as well</span><br><span class="line">   &#125;</span><br><span class="line">   public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">      System.out.println(&quot;AfterInitialization : &quot; + beanName);</span><br><span class="line">      return bean;  // you can return any other object as well</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean class=&quot;com.zsm.test.InitHelloWorld&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Bean-定义继承"><a href="#Bean-定义继承" class="headerlink" title="Bean 定义继承"></a>Bean 定义继承</h3><p>Spring Bean 定义的继承与 Java 类的继承无关，但是继承的概念是一样的。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;message1&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;message2&quot; value=&quot;Hello Second World!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;helloIndia&quot; class=&quot;com.tutorialspoint.HelloIndia&quot; parent=&quot;helloWorld&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;message1&quot; value=&quot;Hello India!&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;message3&quot; value=&quot;Namaste India!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring-依赖注入"><a href="#Spring-依赖注入" class="headerlink" title="Spring 依赖注入"></a>Spring 依赖注入</h2><h3 id="基于构造函数的依赖注入"><a href="#基于构造函数的依赖注入" class="headerlink" title="基于构造函数的依赖注入"></a>基于构造函数的依赖注入</h3><p>几种写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for textEditor bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;textEditor&quot; class=&quot;com.zsm.test.di.TextEditor&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;spellChecker&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for spellChecker bean --&gt;</span><br><span class="line">    &lt;!--&lt;bean id=&quot;spellChecker&quot; class=&quot;com.zsm.test.di.SpellChecker&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;spellChecker&quot; class=&quot;com.zsm.test.di.SpellChecker&quot;&gt;</span><br><span class="line">        &lt;!--存在不止一个参数时，构造函数的参数在 bean 定义中的顺序就是把这些参数提供给适当的构造函数的顺序就可以了。考虑下面的类:--&gt;</span><br><span class="line">        &lt;!--&lt;constructor-arg ref=&quot;helloWorld&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg ref=&quot;helloWorld2&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--如果你使用 type 属性显式的指定了构造函数参数的类型，容器也可以使用与简单类型匹配的类型。例如：--&gt;</span><br><span class="line">        &lt;!--&lt;constructor-arg type=&quot;int&quot; value=&quot;2001&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;Zara&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--最后并且也是最好的传递构造函数参数的方式，使用 index 属性来显式的指定构造函数参数的索引。下面是基于索引为 0 的例子，如下所示：--&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;0&quot; value=&quot;2001&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg index=&quot;1&quot; value=&quot;Zara&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;helloWorld&quot; class=&quot;com.zsm.test.HelloWorld&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;helloWorld2&quot; class=&quot;com.zsm.test.HelloWorld2&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name2&quot; value=&quot;Hello World2!&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">public class SpellChecker &#123;</span><br><span class="line">    public SpellChecker() &#123;</span><br><span class="line">        System.out.println(&quot;Inside SpellChecker constructor.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public SpellChecker(int num, String desc) &#123;</span><br><span class="line">      System.out.println(&quot;Inside SpellChecker constructor:&quot; + num + &quot;;&quot; + desc);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public SpellChecker(HelloWorld num, HelloWorld2 desc) &#123;</span><br><span class="line">      System.out.println(&quot;Inside SpellChecker constructor:&quot; + num.getName() + &quot;;&quot; + desc.getName2());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void checkSpelling() &#123;</span><br><span class="line">        System.out.println(&quot;Inside checkSpelling.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);</span><br><span class="line">      TextEditor te = (TextEditor) context.getBean(&quot;textEditor&quot;);</span><br><span class="line">      te.spellCheck();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于设值函数的依赖注入"><a href="#基于设值函数的依赖注入" class="headerlink" title="基于设值函数的依赖注入"></a>基于设值函数的依赖注入</h3><p>和构造函数注入唯一的区别就是在基于构造函数注入中，我们使用的是〈bean〉标签中的〈constructor-arg〉元素，而在基于设值函数的注入中，我们使用的是〈bean〉标签中的<strong>〈property〉</strong>元素。</p>
<p>第二个需要注意的点是，如果你要把一个引用传递给一个对象，那么你需要使用 标签的 ref 属性，而如果你要直接传递一个值，那么你应该使用 value 属性。</p>
<p>如果你有许多的设值函数方法，那么在 XML 配置文件中使用 <strong>p-namespace</strong> 是非常方便的（ref则须加后缀-ref）。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;john-classic&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</span><br><span class="line">      &lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;name&quot; value=&quot;John Doe&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//上述 XML 配置文件可以使用 p-namespace 以一种更简洁的方式重写，如下所示：</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;john-classic&quot; class=&quot;com.example.Person&quot;</span><br><span class="line">      p:name=&quot;John Doe&quot;</span><br><span class="line">      p:spouse-ref=&quot;jane&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean name=&quot;jane&quot; class=&quot;com.example.Person&quot;</span><br><span class="line">      p:name=&quot;John Doe&quot;/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="注入内部-Beans"><a href="#注入内部-Beans" class="headerlink" title="注入内部 Beans"></a>注入内部 Beans</h3><p>正如你所知道的 Java 内部类是在其他类的范围内被定义的，同理，inner beans 是在其他 bean 的范围内定义的 bean。定义入下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;outerBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;target&quot;&gt;</span><br><span class="line">         &lt;bean id=&quot;innerBean&quot; class=&quot;...&quot;/&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;textEditor&quot; class=&quot;com.zsm.test.interclass.TextEditor&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;spellChecker&quot;&gt;</span><br><span class="line">        &lt;bean class=&quot;com.zsm.test.interclass.SpellChecker&quot;/&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="注入集合"><a href="#注入集合" class="headerlink" title="注入集合"></a>注入集合</h3><p>现在如果你想传递多个值，如 Java Collection 类型 List、Set、Map 和 Properties，应该怎么做呢。为了处理这种情况，Spring 提供了四种类型的集合的配置元素，如下所示：</p>
<p><img src="/2020/07/09/java-spring-basics/spring-collection.png" alt></p>
<p>示例入下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- Definition for javaCollection --&gt;</span><br><span class="line">   &lt;bean id=&quot;javaCollection&quot; class=&quot;com.tutorialspoint.JavaCollection&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressList(java.util.List) call --&gt;</span><br><span class="line">      &lt;property name=&quot;addressList&quot;&gt;</span><br><span class="line">         &lt;list&gt;</span><br><span class="line">            &lt;value&gt;INDIA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">         &lt;/list&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressSet(java.util.Set) call --&gt;</span><br><span class="line">      &lt;property name=&quot;addressSet&quot;&gt;</span><br><span class="line">         &lt;set&gt;</span><br><span class="line">            &lt;value&gt;INDIA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;USA&lt;/value&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressMap(java.util.Map) call --&gt;</span><br><span class="line">      &lt;property name=&quot;addressMap&quot;&gt;</span><br><span class="line">         &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;1&quot; value=&quot;INDIA&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;2&quot; value=&quot;Pakistan&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;3&quot; value=&quot;USA&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;4&quot; value=&quot;USA&quot;/&gt;</span><br><span class="line">         &lt;/map&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- results in a setAddressProp(java.util.Properties) call --&gt;</span><br><span class="line">      &lt;property name=&quot;addressProp&quot;&gt;</span><br><span class="line">         &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;one&quot;&gt;INDIA&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;two&quot;&gt;Pakistan&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;three&quot;&gt;USA&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;four&quot;&gt;USA&lt;/prop&gt;</span><br><span class="line">         &lt;/props&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>也<strong>可以将引用和值混合在一起</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Passing bean reference  for java.util.Set --&gt;</span><br><span class="line">&lt;property name=&quot;addressSet&quot;&gt;</span><br><span class="line">   &lt;set&gt;</span><br><span class="line">      &lt;ref bean=&quot;address1&quot;/&gt;</span><br><span class="line">      &lt;ref bean=&quot;address2&quot;/&gt;</span><br><span class="line">      &lt;value&gt;Pakistan&lt;/value&gt;</span><br><span class="line">   &lt;/set&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Passing bean reference  for java.util.Map --&gt;</span><br><span class="line">&lt;property name=&quot;addressMap&quot;&gt;</span><br><span class="line">   &lt;map&gt;</span><br><span class="line">      &lt;entry key=&quot;one&quot; value=&quot;INDIA&quot;/&gt;</span><br><span class="line">      &lt;entry key =&quot;two&quot; value-ref=&quot;address1&quot;/&gt;</span><br><span class="line">      &lt;entry key =&quot;three&quot; value-ref=&quot;address2&quot;/&gt;</span><br><span class="line">   &lt;/map&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="注入-null-和空字符串的值"><a href="#注入-null-和空字符串的值" class="headerlink" title="注入 null 和空字符串的值"></a>注入 null 和空字符串的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;...&quot; class=&quot;exampleBean&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;email&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>相当于：exampleBean.setEmail(“”)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;...&quot; class=&quot;exampleBean&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;email&quot;&gt;&lt;null/&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>相当于：exampleBean.setEmail(null)。</p>
<h2 id="Beans-自动装配"><a href="#Beans-自动装配" class="headerlink" title="Beans 自动装配"></a>Beans 自动装配</h2><p>Spring 容器可以在不使用&lt;constructor-arg&gt;和&lt;property&gt; 元素的情况下自动装配相互协作的 bean 之间的关系，这有助于减少编写一个大的基于 Spring 的应用程序的 XML 配置的数量。</p>
<p>你可以使用&lt;bean&gt;元素的 <strong>autowire</strong> 属性为一个 bean 定义指定自动装配模式：</p>
<p><img src="/2020/07/09/java-spring-basics/beans-auto.png" alt></p>
<p>可以使用 byType 或者 constructor 自动装配模式来连接数组和其他类型的集合。</p>
<h3 id="自动装配的局限性"><a href="#自动装配的局限性" class="headerlink" title="自动装配的局限性"></a>自动装配的局限性</h3><p>当<strong>自动装配始终在同一个项目中使用时，它的效果最好</strong>。如果通常不使用自动装配，它<strong>可能会使开发人员混淆的使用它来连接只有一个或两个 bean 定义</strong>。不过，自动装配可以显著减少需要指定的属性或构造器参数，但你应该在使用它们之前考虑到自动装配的局限性和缺点。</p>
<p><img src="/2020/07/09/java-spring-basics/beans-auto-limit.png" alt></p>
<h3 id="自动装配-‘byName’"><a href="#自动装配-‘byName’" class="headerlink" title="自动装配 ‘byName’"></a>自动装配 ‘byName’</h3><p>这种模式由属性名称指定自动装配。</p>
<p>例如，在配置文件中，如果一个 bean 定义设置为自动装配 byName，并且它包含 spellChecker 属性（即，它有一个 setSpellChecker(…) 方法），那么 Spring 就会查找定义名为 spellChecker 的 bean，并且用它来设置这个属性。你<strong>仍然可以使用 <property> 标签连接其余的属性</property></strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--&lt;bean id=&quot;textEditor&quot; class=&quot;com.zsm.test.interclass.TextEditor&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;spellChecker&quot; ref=&quot;spellChecker&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;name&quot; value=&quot;Generic Text Editor&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;--&gt;</span><br><span class="line"></span><br><span class="line">//使用autowire后</span><br><span class="line">&lt;bean id=&quot;textEditor&quot; class=&quot;com.tutorialspoint.TextEditor&quot; </span><br><span class="line">  autowire=&quot;byName&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;name&quot; value=&quot;Generic Text Editor&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;spellChecker&quot; class=&quot;com.tutorialspoint.SpellChecker&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="自动装配-‘byType’"><a href="#自动装配-‘byType’" class="headerlink" title="自动装配 ‘byType’"></a>自动装配 ‘byType’</h3><p>这种模式由属性类型指定自动装配。</p>
<h3 id="由构造函数自动装配"><a href="#由构造函数自动装配" class="headerlink" title="由构造函数自动装配"></a>由构造函数自动装配</h3><p>这种模式与 byType 非常相似，但它应用于构造器参数。</p>
<h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h2><p>从 Spring 2.5 开始就可以使用注解来配置依赖注入，而不是采用 XML 来描述一个 bean 连线。在 XML 注入之前进行注解注入，因此后者的配置将通过两种方式的<strong>属性连线</strong>被前者重写。</p>
<p>注解连线在默认情况下在 Spring 容器中不打开。启用配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:annotation-config/&gt;</span><br></pre></td></tr></table></figure></p>
<p>让我们来看看几个重要的注解，并且了解它们是如何工作的：</p>
<p><img src="/2020/07/09/java-spring-basics/annotation.png" alt></p>
<h3 id="Required-注释"><a href="#Required-注释" class="headerlink" title="@Required 注释"></a>@Required 注释</h3><p>@Required 注释应用于 bean 属性的 setter 方法，<strong>它表明受影响的 bean 属性在配置时必须放在 XML 配置文件中</strong>，否则容器就会抛出一个 BeanInitializationException 异常。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">   private Integer age;</span><br><span class="line">   private String name;</span><br><span class="line">   @Required</span><br><span class="line">   public void setAge(Integer age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   public Integer getAge() &#123;</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line">   @Required</span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getName() &#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;student&quot; class=&quot;com.tutorialspoint.Student&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;name&quot;  value=&quot;Zara&quot; /&gt;</span><br><span class="line">      &lt;property name=&quot;age&quot;  value=&quot;11&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Autowired-注释"><a href="#Autowired-注释" class="headerlink" title="@Autowired 注释"></a>@Autowired 注释</h3><p>@Autowired 注释对在哪里和如何完成自动连接提供了更多的细微的控制</p>
<p>1.Setter 方法中的 @Autowired<br>你可以在 XML 文件中的 setter 方法中使用 @Autowired 注释来除去 元素。当 Spring遇到一个在 setter 方法中使用的 @Autowired 注释，它会在方法中视图执行 byType 自动连接。</p>
<p>2.构造函数中的 @Autowired<br>你也可以在构造函数中使用 @Autowired。一个构造函数 @Autowired 说明当创建 bean 时，即使在 XML 文件中没有使用 元素配置 bean ，构造函数也会被自动连接。</p>
<p>3.属性中的 @Autowired<br>你可以在属性中使用 @Autowired 注释来除去 setter 方法。当时使用 为自动连接属性传递的时候，Spring 会将这些传递过来的值或者引用自动分配给那些属性。</p>
<p>4.@Autowired 的（required=false）选项<br>默认情况下，@Autowired 注释意味着依赖是必须的，它类似于 @Required 注释，然而，你可以使用 @Autowired 的 （required=false） 选项关闭默认行为。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class TextEditor &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   private SpellChecker spellChecker;</span><br><span class="line">   public TextEditor() &#123;</span><br><span class="line">      System.out.println(&quot;Inside TextEditor constructor.&quot; );</span><br><span class="line">   &#125;  </span><br><span class="line">   public SpellChecker getSpellChecker( )&#123;</span><br><span class="line">      return spellChecker;</span><br><span class="line">   &#125;  </span><br><span class="line">   public void spellCheck()&#123;</span><br><span class="line">      spellChecker.checkSpelling();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for textEditor bean --&gt;</span><br><span class="line">&lt;bean id=&quot;textEditor&quot; class=&quot;com.tutorialspoint.TextEditor&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for spellChecker bean --&gt;</span><br><span class="line">&lt;bean id=&quot;spellChecker&quot; class=&quot;com.tutorialspoint.SpellChecker&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Qualifier-注释"><a href="#Qualifier-注释" class="headerlink" title="@Qualifier 注释"></a>@Qualifier 注释</h3><p>当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。相当于<strong>别名</strong>。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Profile &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">   @Qualifier(&quot;student1&quot;)</span><br><span class="line">   private Student student;</span><br><span class="line">   public Profile()&#123;</span><br><span class="line">      System.out.println(&quot;Inside Profile constructor.&quot; );</span><br><span class="line">   &#125;</span><br><span class="line">   public void printAge() &#123;</span><br><span class="line">      System.out.println(&quot;Age : &quot; + student.getAge() );</span><br><span class="line">   &#125;</span><br><span class="line">   public void printName() &#123;</span><br><span class="line">      System.out.println(&quot;Name : &quot; + student.getName() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for profile bean --&gt;</span><br><span class="line">&lt;bean id=&quot;profile&quot; class=&quot;com.tutorialspoint.Profile&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for student1 bean --&gt;</span><br><span class="line">&lt;bean id=&quot;student1&quot; class=&quot;com.tutorialspoint.Student&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;name&quot;  value=&quot;Zara&quot; /&gt;</span><br><span class="line">  &lt;property name=&quot;age&quot;  value=&quot;11&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Definition for student2 bean --&gt;</span><br><span class="line">&lt;bean id=&quot;student2&quot; class=&quot;com.tutorialspoint.Student&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;name&quot;  value=&quot;Nuha&quot; /&gt;</span><br><span class="line">  &lt;property name=&quot;age&quot;  value=&quot;2&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring-JSR-250-注释"><a href="#Spring-JSR-250-注释" class="headerlink" title="Spring JSR-250 注释"></a>Spring JSR-250 注释</h3><p>Spring还使用基于 JSR-250 注释，它包括 @PostConstruct， @PreDestroy 和 @Resource 注释。这些注释并不是必需的，只是一个<strong>替代方案</strong>。</p>
<p>为了定义一个 bean 的安装和卸载，我们使用 init-method 和/或 destroy-method 参数简单的声明一下 。init-method 属性指定了一个方法，该方法在 bean 的实例化阶段会立即被调用。同样地，destroy-method 指定了一个方法，该方法只在一个 bean 从容器中删除之前被调用。你<strong>可以使用 @PostConstruct 注释作为初始化回调函数的一个替代，@PreDestroy 注释作为销毁回调函数的一个替代</strong>。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class TextEditor &#123;</span><br><span class="line">   private SpellChecker spellChecker;</span><br><span class="line">   @Resource(name= &quot;spellChecker&quot;)</span><br><span class="line">   public void setSpellChecker( SpellChecker spellChecker )&#123;</span><br><span class="line">      this.spellChecker = spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">   public SpellChecker getSpellChecker()&#123;</span><br><span class="line">      return spellChecker;</span><br><span class="line">   &#125;</span><br><span class="line">   public void spellCheck()&#123;</span><br><span class="line">      spellChecker.checkSpelling();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">   private String message;</span><br><span class="line">   public void setMessage(String message)&#123;</span><br><span class="line">      this.message  = message;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getMessage()&#123;</span><br><span class="line">      System.out.println(&quot;Your Message : &quot; + message);</span><br><span class="line">      return message;</span><br><span class="line">   &#125;</span><br><span class="line">   @PostConstruct</span><br><span class="line">   public void init()&#123;</span><br><span class="line">      System.out.println(&quot;Bean is going through init.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   @PreDestroy</span><br><span class="line">   public void destroy()&#123;</span><br><span class="line">      System.out.println(&quot;Bean will destroy now.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;helloWorld&quot; </span><br><span class="line">   class=&quot;com.tutorialspoint.HelloWorld&quot;</span><br><span class="line">   init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;message&quot; value=&quot;Hello World!&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="基于-Java-的配置"><a href="#基于-Java-的配置" class="headerlink" title="基于 Java 的配置"></a>基于 Java 的配置</h3><p>带有 @Configuration 的注解类表示这个类可以使用 Spring IoC 容器作为 bean 定义的来源。@Bean 注解告诉 Spring，一个带有 @Bean 的注解方法将返回一个对象，该对象应该被注册为在 Spring 应用程序上下文中的 bean。最简单可行的 @Configuration 类如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class HelloWorldConfig &#123;</span><br><span class="line">   @Bean </span><br><span class="line">   public HelloWorld helloWorld()&#123;</span><br><span class="line">      return new HelloWorld();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 上面的代码将等同于下面的 XML 配置：</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">   &lt;bean id=&quot;helloWorld&quot; class=&quot;com.tutorialspoint.HelloWorld&quot; /&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<p>在这里，带有 @Bean 注解的方法名称作为 bean 的 ID，它创建并返回实际的 bean。你的配置类可以声明多个 @Bean。一旦定义了配置类，你就可以使用 AnnotationConfigApplicationContext 来加载并把他们提供给 Spring 容器，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfig.class); </span><br><span class="line">   HelloWorld helloWorld = ctx.getBean(HelloWorld.class);</span><br><span class="line">   helloWorld.setMessage(&quot;Hello World!&quot;);</span><br><span class="line">   helloWorld.getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//你可以加载各种配置类，如下所示：</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line">   ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class="line">   ctx.register(AdditionalConfig.class);</span><br><span class="line">   ctx.refresh();</span><br><span class="line">   MyService myService = ctx.getBean(MyService.class);</span><br><span class="line">   myService.doStuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h4><p>@import 注解允许<strong>从另一个配置类中加载 @Bean 定义</strong>。考虑 ConfigA 类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ConfigA &#123;</span><br><span class="line">   @Bean</span><br><span class="line">   public A a() &#123;</span><br><span class="line">      return new A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//你可以在另一个 Bean 声明中导入上述 Bean 声明，如下所示：</span><br><span class="line">@Configuration</span><br><span class="line">@Import(ConfigA.class)</span><br><span class="line">public class ConfigB &#123;</span><br><span class="line">   @Bean</span><br><span class="line">   public B a() &#123;</span><br><span class="line">      return new A(); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当实例化上下文时，不需要同时指定 ConfigA.class 和 ConfigB.class，只有 ConfigB 类需要提供，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   ApplicationContext ctx = </span><br><span class="line">   new AnnotationConfigApplicationContext(ConfigB.class);</span><br><span class="line">   // now both beans A and B will be available...</span><br><span class="line">   A a = ctx.getBean(A.class);</span><br><span class="line">   B b = ctx.getBean(B.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h4><p>@Bean 注解支持指定任意的初始化和销毁的回调方法，就像在 bean 元素中 Spring 的 XML 的初始化方法和销毁方法的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Foo &#123;</span><br><span class="line">   public void init() &#123;</span><br><span class="line">      // initialization logic</span><br><span class="line">   &#125;</span><br><span class="line">   public void cleanup() &#123;</span><br><span class="line">      // destruction logic</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">   @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;cleanup&quot; )</span><br><span class="line">   public Foo foo() &#123;</span><br><span class="line">      return new Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定 Bean 的范围。<strong>默认范围是单实例，但是你可以重写带有 @Scope 注解的该方法</strong>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">   @Bean</span><br><span class="line">   @Scope(&quot;prototype&quot;)</span><br><span class="line">   public Foo foo() &#123;</span><br><span class="line">      return new Foo();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>Spring 的核心是 ApplicationContext，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。例如，当上下文启动时，ContextStartedEvent 发布，当上下文停止时，ContextStoppedEvent 发布。</p>
<p>Spring 提供了以下的标准事件：</p>
<p><img src="/2020/07/09/java-spring-basics/event.png" alt></p>
<p>由于 <strong>Spring 的事件处理是单线程的</strong>，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被<strong>阻塞</strong>并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.ApplicationEvent;</span><br><span class="line">public class CustomEvent extends ApplicationEvent&#123; </span><br><span class="line">   public CustomEvent(Object source) &#123;</span><br><span class="line">      super(source);</span><br><span class="line">   &#125;</span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return &quot;My Custom Event&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是 CustomEventPublisher.java 文件的内容：</span><br><span class="line">import org.springframework.context.ApplicationEventPublisher;</span><br><span class="line">import org.springframework.context.ApplicationEventPublisherAware;</span><br><span class="line">public class CustomEventPublisher implements ApplicationEventPublisherAware &#123;</span><br><span class="line">   private ApplicationEventPublisher publisher;</span><br><span class="line">   public void setApplicationEventPublisher(ApplicationEventPublisher publisher)&#123;</span><br><span class="line">      this.publisher = publisher;</span><br><span class="line">   &#125;</span><br><span class="line">   public void publish() &#123;</span><br><span class="line">      CustomEvent ce = new CustomEvent(this);</span><br><span class="line">      publisher.publishEvent(ce);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是 CustomEventHandler.java 文件的内容：</span><br><span class="line">import org.springframework.context.ApplicationListener;</span><br><span class="line">public class CustomEventHandler implements ApplicationListener&lt;CustomEvent&gt;&#123;</span><br><span class="line">   public void onApplicationEvent(CustomEvent event) &#123;</span><br><span class="line">      System.out.println(event.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是 MainApp.java 文件的内容：</span><br><span class="line">import org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ConfigurableApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);    </span><br><span class="line">      CustomEventPublisher cvp = (CustomEventPublisher) context.getBean(&quot;customEventPublisher&quot;);</span><br><span class="line">      cvp.publish();  </span><br><span class="line">      cvp.publish();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//下面是配置文件 Beans.xml：</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;customEventHandler&quot; </span><br><span class="line">      class=&quot;com.tutorialspoint.CustomEventHandler&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean id=&quot;customEventPublisher&quot; </span><br><span class="line">      class=&quot;com.tutorialspoint.CustomEventPublisher&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//输出以下信息：</span><br><span class="line">My Custom Event</span><br><span class="line">My Custom Event</span><br></pre></td></tr></table></figure>
<h2 id="Spring-框架的-AOP"><a href="#Spring-框架的-AOP" class="headerlink" title="Spring 框架的 AOP"></a>Spring 框架的 AOP</h2><p>Spring 框架的一个关键组件是<strong>面向方面的编程(AOP)</strong>框架。面向方面的编程需要把程序逻辑分解成不同的部分称为所谓的关注点。跨一个应用程序的多个点的功能被称为<strong>横切关注点</strong>，这些横切关注点在概念上独立于应用程序的业务逻辑。有各种各样的常见的很好的方面的例子，如日志记录、审计、声明式事务、安全性和缓存等。</p>
<p>Spring AOP 模块提供拦截器来拦截一个应用程序，例如，当执行一个方法时，你可以在方法执行之前或之后添加额外的功能。</p>
<h3 id="AOP-术语"><a href="#AOP-术语" class="headerlink" title="AOP 术语"></a>AOP 术语</h3><p><img src="/2020/07/09/java-spring-basics/aop.png" alt></p>
<h3 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h3><p>Spring 方面可以使用下面提到的五种通知工作：</p>
<p><img src="/2020/07/09/java-spring-basics/aop-type.png" alt></p>
<h3 id="基于-AOP-的-XML架构"><a href="#基于-AOP-的-XML架构" class="headerlink" title="基于 AOP 的 XML架构"></a>基于 AOP 的 XML架构</h3><h4 id="声明一个-aspect"><a href="#声明一个-aspect" class="headerlink" title="声明一个 aspect"></a>声明一个 aspect</h4><p>一个 aspect 是使用 元素声明的，支持的 bean 是使用 ref 属性引用的，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明一个切入点"><a href="#声明一个切入点" class="headerlink" title="声明一个切入点"></a>声明一个切入点</h4><p>一个切入点有助于确定使用不同建议执行的感兴趣的连接点（即方法）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;</span><br><span class="line">   &lt;aop:pointcut id=&quot;businessService&quot;</span><br><span class="line">      expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明建议"><a href="#声明建议" class="headerlink" title="声明建议"></a>声明建议</h4><p>你可以使用 &lt;aop:{ADVICE NAME}&gt; 元素在一个 中声明五个建议中的任何一个，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">   &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;aBean&quot;&gt;</span><br><span class="line">      &lt;aop:pointcut id=&quot;businessService&quot;</span><br><span class="line">         expression=&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;/&gt;</span><br><span class="line">      &lt;!-- a before advice definition --&gt;</span><br><span class="line">      &lt;aop:before pointcut-ref=&quot;businessService&quot; </span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">      &lt;!-- an after advice definition --&gt;</span><br><span class="line">      &lt;aop:after pointcut-ref=&quot;businessService&quot; </span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">      &lt;!-- an after-returning advice definition --&gt;</span><br><span class="line">      &lt;!--The doRequiredTask method must have parameter named retVal --&gt;</span><br><span class="line">      &lt;aop:after-returning pointcut-ref=&quot;businessService&quot;</span><br><span class="line">         returning=&quot;retVal&quot;</span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">      &lt;!-- an after-throwing advice definition --&gt;</span><br><span class="line">      &lt;!--The doRequiredTask method must have parameter named ex --&gt;</span><br><span class="line">      &lt;aop:after-throwing pointcut-ref=&quot;businessService&quot;</span><br><span class="line">         throwing=&quot;ex&quot;</span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">      &lt;!-- an around advice definition --&gt;</span><br><span class="line">      &lt;aop:around pointcut-ref=&quot;businessService&quot; </span><br><span class="line">         method=&quot;doRequiredTask&quot;/&gt;</span><br><span class="line">   ...</span><br><span class="line">   &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br><span class="line">&lt;bean id=&quot;aBean&quot; class=&quot;...&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">public class Logging &#123;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * before a selected method execution.</span><br><span class="line">    */</span><br><span class="line">   public void beforeAdvice()&#123;</span><br><span class="line">      System.out.println(&quot;Going to setup student profile.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * after a selected method execution.</span><br><span class="line">    */</span><br><span class="line">   public void afterAdvice()&#123;</span><br><span class="line">      System.out.println(&quot;Student profile has been setup.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * when any method returns.</span><br><span class="line">    */</span><br><span class="line">   public void afterReturningAdvice(Object retVal)&#123;</span><br><span class="line">      System.out.println(&quot;Returning:&quot; + retVal.toString() );</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * if there is an exception raised.</span><br><span class="line">    */</span><br><span class="line">   public void AfterThrowingAdvice(IllegalArgumentException ex)&#123;</span><br><span class="line">      System.out.println(&quot;There has been an exception: &quot; + ex.toString());   </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Student &#123;</span><br><span class="line">   private Integer age;</span><br><span class="line">   private String name;</span><br><span class="line">   public void setAge(Integer age) &#123;</span><br><span class="line">      this.age = age;</span><br><span class="line">   &#125;</span><br><span class="line">   public Integer getAge() &#123;</span><br><span class="line">      System.out.println(&quot;Age : &quot; + age );</span><br><span class="line">      return age;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   public String getName() &#123;</span><br><span class="line">      System.out.println(&quot;Name : &quot; + name );</span><br><span class="line">      return name;</span><br><span class="line">   &#125;  </span><br><span class="line">   public void printThrowException()&#123;</span><br><span class="line">       System.out.println(&quot;Exception raised&quot;);</span><br><span class="line">       throw new IllegalArgumentException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext context =</span><br><span class="line">             new ClassPathXmlApplicationContext(&quot;BeansAop.xml&quot;);</span><br><span class="line">      Student student = (Student) context.getBean(&quot;student&quot;);</span><br><span class="line">      student.getName();</span><br><span class="line">      student.getAge();      </span><br><span class="line">      student.printThrowException();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">    http://www.springframework.org/schema/aop</span><br><span class="line">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;log&quot; ref=&quot;logging&quot;&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;selectAll&quot;</span><br><span class="line">                          expression=&quot;execution(* com.zsm.test.aop.*.*(..))&quot;/&gt;</span><br><span class="line">            &lt;aop:before pointcut-ref=&quot;selectAll&quot; method=&quot;beforeAdvice&quot;/&gt;</span><br><span class="line">            &lt;aop:after pointcut-ref=&quot;selectAll&quot; method=&quot;afterAdvice&quot;/&gt;</span><br><span class="line">            &lt;aop:after-returning pointcut-ref=&quot;selectAll&quot;</span><br><span class="line">                                 returning=&quot;retVal&quot;</span><br><span class="line">                                 method=&quot;afterReturningAdvice&quot;/&gt;</span><br><span class="line">            &lt;aop:after-throwing pointcut-ref=&quot;selectAll&quot;</span><br><span class="line">                                throwing=&quot;ex&quot;</span><br><span class="line">                                method=&quot;AfterThrowingAdvice&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--&lt;aop:config&gt;</span><br><span class="line">        &lt;aop:aspect id=&quot;log&quot; ref=&quot;logging&quot;&gt;</span><br><span class="line">            &lt;aop:pointcut id=&quot;selectAll&quot;</span><br><span class="line">                          expression=&quot;execution(* com.zsm.test.aop.Student.getName(..))&quot;/&gt;</span><br><span class="line">            &lt;aop:before pointcut-ref=&quot;selectAll&quot; method=&quot;beforeAdvice&quot;/&gt;</span><br><span class="line">            &lt;aop:after pointcut-ref=&quot;selectAll&quot; method=&quot;afterAdvice&quot;/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for student bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;com.zsm.test.aop.Student&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot;  value=&quot;Zara&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot;  value=&quot;11&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for logging aspect --&gt;</span><br><span class="line">    &lt;bean id=&quot;logging&quot; class=&quot;com.zsm.test.aop.Logging&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">Going to setup student profile.</span><br><span class="line">Name : Zara</span><br><span class="line">Student profile has been setup.</span><br><span class="line">Returning:Zara</span><br><span class="line">Going to setup student profile.</span><br><span class="line">Age : 11</span><br><span class="line">Student profile has been setup.</span><br><span class="line">Returning:11</span><br><span class="line">Going to setup student profile.</span><br><span class="line">Exception raised</span><br><span class="line">Student profile has been setup.</span><br><span class="line">There has been an exception: java.lang.IllegalArgumentException</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">	at com.zsm.test.aop.Student.printThrowException(Student.java:22)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h3 id="基于-AOP-的-AspectJ"><a href="#基于-AOP-的-AspectJ" class="headerlink" title="基于 AOP 的 @AspectJ"></a>基于 AOP 的 @AspectJ</h3><p>@AspectJ 作为通过 Java 5 注释注释的普通的 Java 类，它指的是声明 aspects 的一种风格。通过在你的基于架构的 XML 配置文件中包含以下元素，@AspectJ 支持是可用的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意：aspectjrt.jar，aspectjweaver.jar添加到lib</p>
<h4 id="声明一个-aspect-1"><a href="#声明一个-aspect-1" class="headerlink" title="声明一个 aspect"></a>声明一个 aspect</h4><p>Aspects 类和其他任何正常的 bean 一样，除了它们将会用 @AspectJ 注释之外，它和其他类一样可能有方法和字段，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class AspectModule &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明一个切入点-1"><a href="#声明一个切入点-1" class="headerlink" title="声明一个切入点"></a>声明一个切入点</h4><p>一个切入点有助于确定使用不同建议执行的感兴趣的连接点（即方法）。在处理基于配置的 XML 架构时，切入点的声明有两个部分：</p>
<ul>
<li><p>一个切入点表达式决定了我们感兴趣的哪个方法会真正被执行。</p>
</li>
<li><p>一个切入点标签包含一个名称和任意数量的参数。方法的真正内容是不相干的，并且实际上它应该是空的。</p>
</li>
</ul>
<p>下面的示例中定义了一个名为 ‘businessService’ 的切入点，该切入点将与 com.xyz.myapp.service 包下的类中可用的每一个方法相匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Pointcut(&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;) // expression </span><br><span class="line">private void businessService() &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明建议-1"><a href="#声明建议-1" class="headerlink" title="声明建议"></a>声明建议</h4><p>你可以使用 @{ADVICE-NAME} 注释声明五个建议中的任意一个，如下所示。这假设你已经定义了一个切入点标签方法 businessService()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Before(&quot;businessService()&quot;)</span><br><span class="line">public void doBeforeTask()&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">@After(&quot;businessService()&quot;)</span><br><span class="line">public void doAfterTask()&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line">@AfterReturning(pointcut = &quot;businessService()&quot;, returning=&quot;retVal&quot;)</span><br><span class="line">public void doAfterReturnningTask(Object retVal)&#123;</span><br><span class="line">  // you can intercept retVal here.</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">@AfterThrowing(pointcut = &quot;businessService()&quot;, throwing=&quot;ex&quot;)</span><br><span class="line">public void doAfterThrowingTask(Exception ex)&#123;</span><br><span class="line">  // you can intercept thrown exception here.</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">@Around(&quot;businessService()&quot;)</span><br><span class="line">public void doAroundTask()&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以为任意一个建议定义你的切入点内联。下面是在建议之前定义内联切入点的一个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Before(&quot;execution(* com.xyz.myapp.service.*.*(..))&quot;)</span><br><span class="line">public doBeforeTask()&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class Logging &#123;</span><br><span class="line">   /** Following is the definition for a pointcut to select</span><br><span class="line">    *  all the methods available. So advice will be called</span><br><span class="line">    *  for all the methods.</span><br><span class="line">    */</span><br><span class="line">   @Pointcut(&quot;execution(* com.zsm.test.aop.anno.*.*(..))&quot;)</span><br><span class="line">   private void selectAll()&#123;&#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * before a selected method execution.</span><br><span class="line">    */</span><br><span class="line">   @Before(&quot;selectAll()&quot;)</span><br><span class="line">   public void beforeAdvice()&#123;</span><br><span class="line">      System.out.println(&quot;Going to setup student profile.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * after a selected method execution.</span><br><span class="line">    */</span><br><span class="line">   @After(&quot;selectAll()&quot;)</span><br><span class="line">   public void afterAdvice()&#123;</span><br><span class="line">      System.out.println(&quot;Student profile has been setup.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /** </span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * when any method returns.</span><br><span class="line">    */</span><br><span class="line">   @AfterReturning(pointcut = &quot;selectAll()&quot;, returning=&quot;retVal&quot;)</span><br><span class="line">   public void afterReturningAdvice(Object retVal)&#123;</span><br><span class="line">      System.out.println(&quot;Returning:&quot; + retVal.toString() );</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * This is the method which I would like to execute</span><br><span class="line">    * if there is an exception raised by any method.</span><br><span class="line">    */</span><br><span class="line">   @AfterThrowing(pointcut = &quot;selectAll()&quot;, throwing = &quot;ex&quot;)</span><br><span class="line">   public void AfterThrowingAdvice(IllegalArgumentException ex)&#123;</span><br><span class="line">      System.out.println(&quot;There has been an exception: &quot; + ex.toString());   </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">    http://www.springframework.org/schema/aop</span><br><span class="line">    http://www.springframework.org/schema/aop/spring-aop-3.0.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for student bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;student&quot; class=&quot;com.zsm.test.aop.anno.Student&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot;  value=&quot;Zara&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;age&quot;  value=&quot;11&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for logging aspect --&gt;</span><br><span class="line">    &lt;bean id=&quot;logging&quot; class=&quot;com.zsm.test.aop.anno.Logging&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-JDBC-框架"><a href="#Spring-JDBC-框架" class="headerlink" title="Spring JDBC 框架"></a>Spring JDBC 框架</h2><p>Spring JDBC 提供几种方法和数据库中相应的不同的类与接口。我将给出使用 JdbcTemplate 类框架的经典和最受欢迎的方法。这是管理所有数据库通信和异常处理的中央框架类。</p>
<h3 id="JdbcTemplate-类"><a href="#JdbcTemplate-类" class="headerlink" title="JdbcTemplate 类"></a>JdbcTemplate 类</h3><p>JdbcTemplate 类执行 SQL 查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。它也捕获 JDBC 异常并转换它们到 org.springframework.dao 包中定义的通用类、更多的信息、异常层次结构。</p>
<p>JdbcTemplate 类的实例是<strong>线程安全</strong>配置的。所以你可以配置 JdbcTemplate 的单个实例，然后将这个共享的引用安全地注入到多个 DAOs 中。</p>
<p>使用 JdbcTemplate 类时常见的做法是在你的 Spring 配置文件中配置数据源，然后共享数据源 bean 依赖注入到 DAO 类中，并在数据源的设值函数中创建了 JdbcTemplate。</p>
<h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>我们在数据库 TEST 中创建一个数据库表 Student。假设你正在使用 MySQL 数据库，如果你使用其他数据库，那么你可以改变你的 DDL 和相应的 SQL 查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student(</span><br><span class="line">   ID   INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">   NAME VARCHAR(20) NOT NULL,</span><br><span class="line">   AGE  INT NOT NULL,</span><br><span class="line">   PRIMARY KEY (ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>现在，我们需要提供一个数据源到 JdbcTemplate 中，所以它可以配置本身来获得数据库访问。你可以在 XML 文件中配置数据源，其中一段代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dataSource&quot;</span><br><span class="line">class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/TEST&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">   &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意点：<br>1.Could not load JDBC driver class [com.mysql.jdbc.Driver]异常： mysql-connector-java-5.1.8.jar<br>2.MySQL在高版本需要指明是否进行SSL连接,在mysql连接字符串url中加入ssl=true或者false即可，如:url=jdbc:mysql://127.0.0.1:3306/framework?useSSL=true</p>
<h3 id="执行-SQL-语句"><a href="#执行-SQL-语句" class="headerlink" title="执行 SQL 语句"></a>执行 SQL 语句</h3><p>我们看看如何使用 SQL 和 jdbcTemplate 对象在数据库表中执行 CRUD(创建、读取、更新和删除)操作。</p>
<p>查询一个整数类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select count(*) from Student&quot;;</span><br><span class="line">int rowCount = jdbcTemplateObject.queryForInt( SQL );</span><br></pre></td></tr></table></figure></p>
<p>查询一个 long 类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select count(*) from Student&quot;;</span><br><span class="line">long rowCount = jdbcTemplateObject.queryForLong( SQL );</span><br></pre></td></tr></table></figure></p>
<p>一个使用绑定变量的简单查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select age from Student where id = ?&quot;;</span><br><span class="line">int age = jdbcTemplateObject.queryForInt(SQL, new Object[]&#123;10&#125;);</span><br></pre></td></tr></table></figure></p>
<p>查询字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select name from Student where id = ?&quot;;</span><br><span class="line">String name = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;10&#125;, String.class);</span><br></pre></td></tr></table></figure></p>
<p>查询并返回一个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select * from Student where id = ?&quot;;</span><br><span class="line">Student student = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;10&#125;, new StudentMapper());</span><br><span class="line">public class StudentMapper implements RowMapper&lt;Student&gt; &#123;</span><br><span class="line">   public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">      Student student = new Student();</span><br><span class="line">      student.setID(rs.getInt(&quot;id&quot;));</span><br><span class="line">      student.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">      student.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查询并返回多个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;select * from Student&quot;;</span><br><span class="line">List&lt;Student&gt; students = jdbcTemplateObject.query(SQL, new StudentMapper());</span><br><span class="line">public class StudentMapper implements RowMapper&lt;Student&gt; &#123;</span><br><span class="line">   public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">      Student student = new Student();</span><br><span class="line">      student.setID(rs.getInt(&quot;id&quot;));</span><br><span class="line">      student.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">      student.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在表中插入一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;insert into Student (name, age) values (?, ?)&quot;;</span><br><span class="line">jdbcTemplateObject.update( SQL, new Object[]&#123;&quot;Zara&quot;, 11&#125; );</span><br></pre></td></tr></table></figure></p>
<p>更新表中的一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;update Student set name = ? where id = ?&quot;;</span><br><span class="line">jdbcTemplateObject.update( SQL, new Object[]&#123;&quot;Zara&quot;, 10&#125; );</span><br></pre></td></tr></table></figure></p>
<p>从表中删除一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;delete Student where id = ?&quot;;</span><br><span class="line">jdbcTemplateObject.update( SQL, new Object[]&#123;20&#125; );</span><br></pre></td></tr></table></figure></p>
<h3 id="执行-DDL-语句"><a href="#执行-DDL-语句" class="headerlink" title="执行 DDL 语句"></a>执行 DDL 语句</h3><p>你可以使用 jdbcTemplate 中的 execute(..) 方法来执行任何 SQL 语句或 DDL 语句。下面是一个使用 CREATE 语句创建一个表的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String SQL = &quot;CREATE TABLE Student( &quot; +</span><br><span class="line">   &quot;ID   INT NOT NULL AUTO_INCREMENT, &quot; +</span><br><span class="line">   &quot;NAME VARCHAR(20) NOT NULL, &quot; +</span><br><span class="line">   &quot;AGE  INT NOT NULL, &quot; +</span><br><span class="line">   &quot;PRIMARY KEY (ID));&quot;</span><br><span class="line">jdbcTemplateObject.execute( SQL );</span><br></pre></td></tr></table></figure></p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public class StudentJDBCTemplate implements StudentDAO &#123;</span><br><span class="line">   private DataSource dataSource;</span><br><span class="line">   private JdbcTemplate jdbcTemplateObject; </span><br><span class="line">   public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">      this.dataSource = dataSource;</span><br><span class="line">      this.jdbcTemplateObject = new JdbcTemplate(dataSource);</span><br><span class="line">   &#125;</span><br><span class="line">   public void create(String name, Integer age) &#123;</span><br><span class="line">      String SQL = &quot;insert into Student (name, age) values (?, ?)&quot;;     </span><br><span class="line">      jdbcTemplateObject.update( SQL, name, age);</span><br><span class="line">      System.out.println(&quot;Created Record Name = &quot; + name + &quot; Age = &quot; + age);</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   public Student getStudent(Integer id) &#123;</span><br><span class="line">      String SQL = &quot;select * from Student where id = ?&quot;;</span><br><span class="line">      Student student = jdbcTemplateObject.queryForObject(SQL, </span><br><span class="line">                        new Object[]&#123;id&#125;, new StudentMapper());</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">   public List&lt;Student&gt; listStudents() &#123;</span><br><span class="line">      String SQL = &quot;select * from Student&quot;;</span><br><span class="line">      List &lt;Student&gt; students = jdbcTemplateObject.query(SQL, </span><br><span class="line">                                new StudentMapper());</span><br><span class="line">      return students;</span><br><span class="line">   &#125;</span><br><span class="line">   public void delete(Integer id)&#123;</span><br><span class="line">      String SQL = &quot;delete from Student where id = ?&quot;;</span><br><span class="line">      jdbcTemplateObject.update(SQL, id);</span><br><span class="line">      System.out.println(&quot;Deleted Record with ID = &quot; + id );</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   public void update(Integer id, Integer age)&#123;</span><br><span class="line">      String SQL = &quot;update Student set age = ? where id = ?&quot;;</span><br><span class="line">      jdbcTemplateObject.update(SQL, age, id);</span><br><span class="line">      System.out.println(&quot;Updated Record with ID = &quot; + id );</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StudentMapper implements RowMapper&lt;Student&gt; &#123;</span><br><span class="line">   public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">      Student student = new Student();</span><br><span class="line">      student.setId(rs.getInt(&quot;id&quot;));</span><br><span class="line">      student.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">      student.setAge(rs.getInt(&quot;age&quot;));</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MainApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;BeansJdbc.xml&quot;);</span><br><span class="line">      StudentJDBCTemplate studentJDBCTemplate = (StudentJDBCTemplate)context.getBean(&quot;studentJDBCTemplate&quot;);</span><br><span class="line">      System.out.println(&quot;------Records Creation--------&quot; );</span><br><span class="line">      studentJDBCTemplate.create(&quot;Zara&quot;, 11);</span><br><span class="line">      studentJDBCTemplate.create(&quot;Nuha&quot;, 2);</span><br><span class="line">      studentJDBCTemplate.create(&quot;Ayan&quot;, 15);</span><br><span class="line">      System.out.println(&quot;------Listing Multiple Records--------&quot; );</span><br><span class="line">      List&lt;Student&gt; students = studentJDBCTemplate.listStudents();</span><br><span class="line">      for (Student record : students) &#123;</span><br><span class="line">         System.out.print(&quot;ID : &quot; + record.getId() );</span><br><span class="line">         System.out.print(&quot;, Name : &quot; + record.getName() );</span><br><span class="line">         System.out.println(&quot;, Age : &quot; + record.getAge());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;----Updating Record with ID = 2 -----&quot; );</span><br><span class="line">      studentJDBCTemplate.update(2, 20);</span><br><span class="line">      System.out.println(&quot;----Listing Record with ID = 2 -----&quot; );</span><br><span class="line">      Student student = studentJDBCTemplate.getStudent(2);</span><br><span class="line">      System.out.print(&quot;ID : &quot; + student.getId() );</span><br><span class="line">      System.out.print(&quot;, Name : &quot; + student.getName() );</span><br><span class="line">      System.out.println(&quot;, Age : &quot; + student.getAge());      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for data source --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for studentJDBCTemplate bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;studentJDBCTemplate&quot; class=&quot;com.zsm.test.jdbc.StudentJDBCTemplate&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="SQL-的存储过程"><a href="#SQL-的存储过程" class="headerlink" title="SQL 的存储过程"></a>SQL 的存储过程</h3><p><strong>SimpleJdbcCall 类可以被用于调用一个包含 IN 和 OUT 参数的存储过程</strong>。你可以在处理任何一个 RDBMS 时使用这个方法，就像 Apache Derby， DB2， MySQL， Microsoft SQL Server， Oracle，和 Sybase。</p>
<p>为了了解这个方法，我们使用 Student 表，它可以在 MySQL TEST 数据库中使用下面的 DDL 进行创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Student(</span><br><span class="line">   ID   INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">   NAME VARCHAR(20) NOT NULL,</span><br><span class="line">   AGE  INT NOT NULL,</span><br><span class="line">   PRIMARY KEY (ID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>下一步，考虑接下来的 MySQL 存储过程，该过程使用 学生 Id 并且使用 OUT 参数返回相应的学生的姓名和年龄。所以让我们在你的 TEST 数据库中使用 MySQL 命令提示符创建这个存储过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">DROP PROCEDURE IF EXISTS `TEST`.`getRecord` $$</span><br><span class="line">CREATE PROCEDURE `TEST`.`getRecord` (</span><br><span class="line">IN in_id INTEGER,</span><br><span class="line">OUT out_name VARCHAR(20),</span><br><span class="line">OUT out_age  INTEGER)</span><br><span class="line">BEGIN</span><br><span class="line">   SELECT name, age</span><br><span class="line">   INTO out_name, out_age</span><br><span class="line">   FROM Student where id = in_id;</span><br><span class="line">END $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class StudentJDBCTemplate implements StudentDAO &#123;</span><br><span class="line">   private DataSource dataSource;</span><br><span class="line">   private SimpleJdbcCall jdbcCall;</span><br><span class="line">   public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">      this.dataSource = dataSource;</span><br><span class="line">      this.jdbcCall =  new SimpleJdbcCall(dataSource).withProcedureName(&quot;getRecord&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   public void create(String name, Integer age) &#123;</span><br><span class="line">      JdbcTemplate jdbcTemplateObject = new JdbcTemplate(dataSource);</span><br><span class="line">      String SQL = &quot;insert into Student (name, age) values (?, ?)&quot;;</span><br><span class="line">      jdbcTemplateObject.update( SQL, name, age);</span><br><span class="line">      System.out.println(&quot;Created Record Name = &quot; + name + &quot; Age = &quot; + age);</span><br><span class="line">   &#125;</span><br><span class="line">   public Student1 getStudent(Integer id) &#123;</span><br><span class="line">      SqlParameterSource in = new MapSqlParameterSource().addValue(&quot;in_id&quot;, id);</span><br><span class="line">      Map&lt;String, Object&gt; out = jdbcCall.execute(in);</span><br><span class="line">      Student1 student = new Student1();</span><br><span class="line">      student.setId(id);</span><br><span class="line">      student.setName((String) out.get(&quot;out_name&quot;));</span><br><span class="line">      student.setAge((Integer) out.get(&quot;out_age&quot;));</span><br><span class="line">      return student;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>一个数据库事务是一个被视为单一的工作单元的操作序列。这些操作应该要么完整地执行，要么完全不执行。事务管理是一个重要组成部分，RDBMS 面向企业应用程序，以确保数据完整性和一致性。事务的概念可以描述为具有以下四个关键属性说成是 ACID：</p>
<ul>
<li><p>原子性(Atomicity)：事务应该当作一个单独单元的操作，这意味着整个序列操作要么是成功，要么是失败的。</p>
</li>
<li><p>一致性(Consistency)：这表示数据库的引用完整性的一致性，表中唯一的主键等。</p>
</li>
<li><p>隔离性(Isolation)：可能同时处理很多有相同的数据集的事务，每个事务应该与其他事务隔离，以防止数据损坏。</p>
</li>
<li><p>持久性(Durability)：一个事务一旦完成全部操作后，这个事务的结果必须是永久性的，不能因系统故障而从数据库中删除。</p>
</li>
</ul>
<p>一个真正的 RDBMS 数据库系统将为每个事务保证所有的四个属性。使用 SQL 发布到数据库中的事务的简单视图如下：</p>
<ul>
<li><p>使用 begin transaction 命令开始事务。</p>
</li>
<li><p>使用 SQL 查询语句执行各种删除、更新或插入操作。</p>
</li>
</ul>
<p>如果所有的操作都成功，则执行提交操作，否则回滚所有操作。</p>
<p>Spring 框架在不同的底层事务管理 APIs 的顶部提供了一个抽象层。Spring 的事务支持旨在通过添加事务能力到 POJOs 来提供给 EJB 事务一个选择方案。Spring 支持编程式和声明式事务管理。EJBs 需要一个应用程序服务器，但 Spring 事务管理可以在不需要应用程序服务器的情况下实现。</p>
<h3 id="编程式-vs-声明式"><a href="#编程式-vs-声明式" class="headerlink" title="编程式 vs. 声明式"></a>编程式 vs. 声明式</h3><p>Spring 支持两种类型的事务管理:</p>
<ul>
<li><p>编程式事务管理 ：这意味着你在编程的帮助下有管理事务。这给了你极大的灵活性，但却很难维护。</p>
</li>
<li><p>声明式事务管理 ：这意味着你从业务代码中分离事务管理。你仅仅使用注释或 XML 配置来管理事务。</p>
</li>
</ul>
<p><strong>声明式事务管理比编程式事务管理更可取</strong>，尽管它不如编程式事务管理灵活，但它允许你通过代码控制事务。但作为一种横切关注点，声明式事务管理可以使用 AOP 方法进行模块化。Spring 支持使用 Spring AOP 框架的声明式事务管理。</p>
<h3 id="事务抽象"><a href="#事务抽象" class="headerlink" title="事务抽象"></a>事务抽象</h3><p>Spring事务管理的五大属性：<strong>隔离级别、传播行为、是否只读、事务超时、回滚规则</strong></p>
<p>Spring 事务抽象的关键是由 org.springframework.transaction.PlatformTransactionManager 接口定义，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line">   //根据指定的传播行为，该方法返回当前活动事务或创建一个新的事务。</span><br><span class="line">   TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;</span><br><span class="line">   //该方法提交给定的事务和关于它的状态。</span><br><span class="line">   void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line">   //该方法执行一个给定事务的回滚。</span><br><span class="line">   void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TransactionDefinition 是在 Spring 中事务支持的核心接口，它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line">   //该方法返回传播行为。Spring 提供了与 EJB CMT 类似的所有的事务传播选项。</span><br><span class="line">   int getPropagationBehavior();</span><br><span class="line">   //该方法返回该事务独立于其他事务的工作的程度。</span><br><span class="line">   int getIsolationLevel();</span><br><span class="line">   //该方法返回该事务的名称。</span><br><span class="line">   String getName();</span><br><span class="line">   //该方法返回以秒为单位的时间间隔，事务必须在该时间间隔内完成。</span><br><span class="line">   int getTimeout();</span><br><span class="line">   //该方法返回该事务是否是只读的。</span><br><span class="line">   boolean isReadOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TransactionStatus 接口为事务代码提供了一个简单的方法来控制事务的执行和查询事务状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager &#123;</span><br><span class="line">   //在当前事务时新的情况下，该方法返回 true。</span><br><span class="line">   boolean isNewTransaction();</span><br><span class="line">   //该方法返回该事务内部是否有一个保存点，也就是说，基于一个保存点已经创建了嵌套事务。</span><br><span class="line">   boolean hasSavepoint();</span><br><span class="line">   //该方法设置该事务为 rollback-only 标记。</span><br><span class="line">   void setRollbackOnly();</span><br><span class="line">   //该方法返回该事务是否已标记为 rollback-only。</span><br><span class="line">   boolean isRollbackOnly();</span><br><span class="line">   //该方法返回该事务是否完成，也就是说，它是否已经提交或回滚。</span><br><span class="line">   boolean isCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>我们可以直接使用 PlatformTransactionManager 来实现编程式方法从而实现事务。要开始一个新事务，你需要有一个带有适当的 transaction 属性的 TransactionDefinition 的实例。当 TransactionDefinition 创建后，你可以通过调用 <strong>getTransaction() 方法来开始你的事务</strong>，该方法会返回 TransactionStatus 的一个实例。 TransactionStatus 对象帮助追踪当前的事务状态，并且最终，如果一切运行顺利，你可以使用 PlatformTransactionManager 的 commit() 方法来提交这个事务，否则的话，你可以使用 rollback() 方法来回滚整个操作。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public void create(String name, Integer age, Integer marks, Integer year)&#123;</span><br><span class="line">  TransactionDefinition def = new DefaultTransactionDefinition();</span><br><span class="line">  TransactionStatus status = transactionManager.getTransaction(def);//开始事务</span><br><span class="line">  try &#123;</span><br><span class="line">     String SQL1 = &quot;insert into Student (name, age) values (?, ?)&quot;;</span><br><span class="line">     jdbcTemplateObject.update( SQL1, name, age);</span><br><span class="line">     // Get the latest student id to be used in Marks table</span><br><span class="line">     String SQL2 = &quot;select max(id) from Student&quot;;</span><br><span class="line">     int sid = jdbcTemplateObject.queryForObject( SQL2, Integer.class );</span><br><span class="line">     String SQL3 = &quot;insert into Marks(sid, marks, year) &quot; + </span><br><span class="line">                   &quot;values (?, ?, ?)&quot;;</span><br><span class="line">     jdbcTemplateObject.update( SQL3, sid, marks, year);</span><br><span class="line">     System.out.println(&quot;Created Name = &quot; + name + &quot;, Age = &quot; + age);</span><br><span class="line">     transactionManager.commit(status);//提交事务</span><br><span class="line">  &#125; catch (DataAccessException e) &#123;</span><br><span class="line">     System.out.println(&quot;Error in creating record, rolling back&quot;);</span><br><span class="line">     transactionManager.rollback(status);</span><br><span class="line">     throw e;</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd &quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for data source --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot;</span><br><span class="line">          class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for TransactionManager --&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for studentJDBCTemplate bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;studentJDBCTemplate&quot; class=&quot;com.zsm.test.transaction.StudentJDBCTemplate&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot;  ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;transactionManager&quot;  ref=&quot;transactionManager&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h3><p>声明式事务管理方法允许你在配置的帮助下而不是源代码硬编程来管理事务。这意味着你可以将事务管理从事务代码中隔离出来。 bean 配置会指定事务型方法。下面是与声明式事务相关的步骤：</p>
<ul>
<li><p>我们使用标签，它创建一个事务处理的建议，同时，我们定义一个匹配所有方法的切入点，我们希望这些方法是事务型的并且会引用事务型的建议。</p>
</li>
<li><p>如果在事务型配置中包含了一个方法的名称，那么创建的建议在调用方法之前就会在事务中开始进行。</p>
</li>
<li><p>目标方法会在 try / catch 块中执行。</p>
</li>
<li><p>如果方法正常结束，AOP 建议会成功的提交事务，否则它执行回滚操作。</p>
</li>
</ul>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">    http://www.springframework.org/schema/tx</span><br><span class="line">    http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for data source --&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot;</span><br><span class="line">          class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?useSSL=false&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name=&quot;create&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=&quot;createOperation&quot; expression=&quot;execution(* com.zsm.test.transac.StudentJDBCTemplate.create(..))&quot;/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;createOperation&quot;/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Initialization for TransactionManager --&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Definition for studentJDBCTemplate bean --&gt;</span><br><span class="line">    &lt;bean id=&quot;studentJDBCTemplate&quot; class=&quot;com.zsm.test.transac.StudentJDBCTemplate&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">public class StudentJDBCTemplate implements StudentDAO&#123;</span><br><span class="line">   private JdbcTemplate jdbcTemplateObject;</span><br><span class="line">   public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">      this.jdbcTemplateObject = new JdbcTemplate(dataSource);</span><br><span class="line">   &#125;</span><br><span class="line">   public void create(String name, Integer age, Integer marks, Integer year)&#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         String SQL1 = &quot;insert into Student (name, age) values (?, ?)&quot;;</span><br><span class="line">         jdbcTemplateObject.update( SQL1, name, age);</span><br><span class="line">         // Get the latest student id to be used in Marks table</span><br><span class="line">         String SQL2 = &quot;select max(id) from Student&quot;;</span><br><span class="line">         int sid = jdbcTemplateObject.queryForObject( SQL2, Integer.class );</span><br><span class="line">         String SQL3 = &quot;insert into Marks(sid, marks, year) &quot; +  &quot;values (?, ?, ?)&quot;;</span><br><span class="line">         jdbcTemplateObject.update( SQL3, sid, marks, year);</span><br><span class="line">         System.out.println(&quot;Created Name = &quot; + name + &quot;, Age = &quot; + age);</span><br><span class="line">         // to simulate the exception.</span><br><span class="line">         throw new RuntimeException(&quot;simulate Error condition&quot;) ;</span><br><span class="line">      &#125; catch (DataAccessException e) &#123;</span><br><span class="line">         System.out.println(&quot;Error in creating record, rolling back&quot;);</span><br><span class="line">         throw e;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   public List&lt;StudentMarks&gt; listStudents() &#123;</span><br><span class="line">      String SQL = &quot;select * from Student, Marks where Student.id=Marks.sid&quot;;</span><br><span class="line">      List &lt;StudentMarks&gt; studentMarks=jdbcTemplateObject.query(SQL, </span><br><span class="line">      new StudentMarksMapper());</span><br><span class="line">      return studentMarks;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//会输出如下所示的异常。在这种情况下，事务会回滚并且在数据库表中不会创建任何记录。</span><br><span class="line">Created Name = Zara, Age = 11</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: simulate Error condition</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring-Web-MVC-框架"><a href="#Spring-Web-MVC-框架" class="headerlink" title="Spring Web MVC 框架"></a>Spring Web MVC 框架</h2><p>Spring web MVC 框架提供了模型-视图-控制的体系结构和可以用来开发灵活、松散耦合的 web 应用程序的组件。</p>
<p>Spring Web 模型-视图-控制（MVC）框架是围绕 DispatcherServlet 设计的，DispatcherServlet 用来处理所有的 HTTP 请求和响应。Spring Web MVC DispatcherServlet 的请求处理的工作流程如下图所示：</p>
<p><img src="/2020/07/09/java-spring-basics/mvc.png" alt></p>
<p>下面是对应于 DispatcherServlet 传入 HTTP 请求的事件序列：</p>
<ul>
<li><p>收到一个 HTTP 请求后，DispatcherServlet 根据 HandlerMapping 来选择并且调用适当的控制器。</p>
</li>
<li><p>控制器接受请求，并基于使用的 GET 或 POST 方法来调用适当的 service 方法。Service 方法将设置基于定义的业务逻辑的模型数据，并返回视图名称到 DispatcherServlet 中。</p>
</li>
<li><p>DispatcherServlet 会从 ViewResolver 获取帮助，为请求检取定义视图。</p>
</li>
<li><p>一旦确定视图，DispatcherServlet 将把模型数据传递给视图，最后呈现在浏览器中。</p>
</li>
</ul>
<p>上面所提到的所有组件，即 HandlerMapping、Controller 和 ViewResolver 是 WebApplicationContext 的一部分，而 WebApplicationContext 是带有一些对 web 应用程序必要的额外特性的 ApplicationContext 的扩展。</p>
<h3 id="需求的配置"><a href="#需求的配置" class="headerlink" title="需求的配置"></a>需求的配置</h3><p>你需要映射你想让 DispatcherServlet 处理的请求，通过使用在 web.xml 文件中的一个 URL 映射。</p>
<p>web.xml 文件将被保留在你的应用程序的 <strong>WebContent/WEB-INF</strong> 目录下。好的，在初始化 HelloWeb DispatcherServlet 时，该框架将尝试加载位于该应用程序的 WebContent/WEB-INF 目录中文件名为 <strong>[servlet-name]-servlet.xml </strong>的应用程序内容。</p>
<p>如果你不想使用默认文件名 [servlet-name]-servlet.xml 和默认位置 WebContent/WEB-INF，你可以通过在 web.xml 文件中添加 servlet 监听器 <strong>ContextLoaderListener 自定义该文件的名称和位置</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app...&gt;</span><br><span class="line">	....</span><br><span class="line">	&lt;context-param&gt;</span><br><span class="line">	   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">	   &lt;param-value&gt;/WEB-INF/HelloWeb-servlet.xml&lt;/param-value&gt;</span><br><span class="line">	&lt;/context-param&gt;</span><br><span class="line">	&lt;listener&gt;</span><br><span class="line">	   &lt;listener-class&gt;</span><br><span class="line">	      org.springframework.web.context.ContextLoaderListener</span><br><span class="line">	   &lt;/listener-class&gt;</span><br><span class="line">	&lt;/listener&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在，检查 HelloWeb-servlet.xml 文件的请求配置，该文件位于 web 应用程序的 WebContent/WEB-INF 目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">   xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;</span><br><span class="line">   http://www.springframework.org/schema/beans</span><br><span class="line">   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">   http://www.springframework.org/schema/context </span><br><span class="line">   http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;context:component-scan base-package=&quot;com.tutorialspoint&quot; /&gt;</span><br><span class="line"></span><br><span class="line">   &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">      &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;</span><br><span class="line">      &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<p>以下是关于 HelloWeb-servlet.xml 文件的一些要点：</p>
<ul>
<li><p>[servlet-name]-servlet.xml 文件将用于创建 bean 定义，重新定义在全局范围内具有相同名称的任何已定义的 bean。</p>
</li>
<li><p>context:component-scan标签将用于激活 Spring MVC 注释扫描功能，该功能允许使用注释，如 @Controller 和 @RequestMapping 等等。</p>
</li>
<li><p>InternalResourceViewResolver 将使用定义的规则来解决视图名称。按照上述定义的规则，一个名称为 hello 的逻辑视图将发送给位于 /WEB-INF/jsp/hello.jsp 中实现的视图。</p>
</li>
</ul>
<h3 id="定义控制器"><a href="#定义控制器" class="headerlink" title="定义控制器"></a>定义控制器</h3><p>DispatcherServlet 发送请求到控制器中执行特定的功能。@Controller 注释表明一个特定类是一个控制器的作用。@RequestMapping 注释用于映射 URL 到整个类或一个特定的处理方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/hello&quot;)</span><br><span class="line">public class HelloController&#123;</span><br><span class="line">   @RequestMapping(method = RequestMethod.GET)</span><br><span class="line">   public String printHello(ModelMap model) &#123;</span><br><span class="line">      model.addAttribute(&quot;message&quot;, &quot;Hello Spring MVC Framework!&quot;);</span><br><span class="line">      return &quot;hello&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@Controller 注释定义该类作为一个 Spring MVC 控制器。在这里，第一次使用的 @RequestMapping 表明在该控制器中处理的所有方法都是相对于 /hello 路径的。下一个注释 @RequestMapping(method = RequestMethod.GET) 用于声明 printHello() 方法作为控制器的默认 service 方法来处理 HTTP GET 请求。你可以在相同的 URL 中定义其他方法来处理任何 POST 请求。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/15/android-kotlin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/15/android-kotlin/" itemprop="url">Kotlin知识点总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-15T09:41:35+08:00">
                2020-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Kotlin 是一种在 Java 虚拟机上运行的静态类型编程语言 ，由 JetBrains 开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。</p>
<h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><p>创建<strong>一种兼容Java的语言</strong></p>
<p>让它比Java更<strong>安全</strong>，能够静态检测常见的陷阱。如：引用空指针</p>
<p>让它比Java更<strong>简洁</strong>，通过支持variable type inference，higher-order functions (closures)，extension functions，mixins and first-class delegation等实现。</p>
<p>Kotlin，类似 Xtend 一样，<strong>旨在提供一种更好的 Java</strong> 而非重建整个新平台。这两种语言都向下编译为字节码（虽然 Xtend 是首先转换成相应的 Java 代码，再让 Java 编译器完成繁重的工作），而且两者都引入了函数和扩展函数（在某个有限范围内静态地增加一个新方法到某个已有类型的能力）。Xtend 是基于 Eclipse 的，而 Kotlin 是基于 IntelliJ 的，两者都提供无界面构建。</p>
<h2 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h2><p>调用某个方法实际上将程序执行顺序转移到该方法所存放在内存中某个地址，将方法的程序内容执行完后，再返回到转去执行该方法前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。也就是通常说的压栈和出栈。因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大。 因此<strong>对于这种内容较短却又反复使用的方法我们可以通过使用内联函数来提升运行效率</strong>。</p>
<p>java中final关键字只是告诉编译器，在编译的时候考虑性能的提升，可以将final函数视为内联函数。但最后编译器会怎么处理，编译器会分析将final函数处理为内联和不处理为内联的性能比较了。（和垃圾处理机制类似，<strong>程序员只有建议权而没有决定权</strong>）</p>
<p>inline 的工作原理就是<strong>将内联函数的函数体复制到调用处实现内联</strong>。</p>
<p>inline 修饰符<strong>影响函数本身和传给它的 lambda 表达式：所有这些都将内联到调用处</strong>。</p>
<p>内联可能导致生成的代码增加；不过如果我们使用得当（即避免内联过大函数），性能上会有所提升，尤其是在循环中的“超多态（megamorphic）”调用处。</p>
<p>reified: 普通函数（非内联函数），不能包含具体化类型参数；若一个类型没有运行时表示（run-time representation）（如非具体化类型参数（non-reified type parameter）或虚拟类型，比如“Nothing”）不能作为一个具体化类型参数的实参。</p>
<p>公有 API 内联函数体内不允许使用非公有声明。</p>
<p><img src="/2020/04/15/android-kotlin/kotlin_inline.png" alt></p>
<p>在Kotlin中对Java中的一些的接口的回调做了一些优化，可以使用一个lambda函数来代替。可以简化写一些不必要的嵌套回调方法。但是需要注意:在lambda表达式，只支持单抽象方法模型，也就是说设计的接口里面只有一个抽象的方法，才符合lambda表达式的规则，多个回调方法不支持。</p>
<h3 id="Let"><a href="#Let" class="headerlink" title="Let"></a>Let</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</p>
</blockquote>
<p>let函数适用的场景<br>场景一: 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。<br>场景二: 然后就是需要去明确一个变量所处特定的作用域范围内可以使用</p>
<h3 id="With"><a href="#With" class="headerlink" title="With"></a>With</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</p>
</blockquote>
<p>with函数的适用的场景<br>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//java实现</span><br><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class="line">    ArticleSnippet item = getItem(position);</span><br><span class="line">    if (item == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    holder.tvNewsTitle.setText(StringUtils.trimToEmpty(item.titleEn));</span><br><span class="line">    holder.tvNewsSummary.setText(StringUtils.trimToEmpty(item.summary));</span><br><span class="line">    String gradeInfo = &quot;难度：&quot; + item.gradeInfo;</span><br><span class="line">    String wordCount = &quot;单词数：&quot; + item.length;</span><br><span class="line">    String reviewNum = &quot;读后感：&quot; + item.numReviews;</span><br><span class="line">    String extraInfo = gradeInfo + &quot; | &quot; + wordCount + &quot; | &quot; + reviewNum;</span><br><span class="line">    holder.tvExtraInfo.setText(extraInfo);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//kotlin实现</span><br><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: return</span><br><span class="line"> </span><br><span class="line">   with(item)&#123;</span><br><span class="line">       holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf.text = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</p>
</blockquote>
<p>适用于let,with函数任何场景。因为run函数是let,with两个函数结合体，准确来说它弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样可以省略，直接访问实例的公有属性和方法，另一方面它弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//借助上个例子kotlin代码,使用run函数后的优化</span><br><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line"> </span><br><span class="line">  getItem(position)?.run&#123;</span><br><span class="line">       holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>public inline fun <t> T.apply(block: T.() -&gt; Unit): T { block(); return this }</t></p>
</blockquote>
<p>从结构上来看apply函数和run函数很像，唯一不同点就是它们各自返回的值不一样，<strong>run函数是以闭包形式返回最后一行代码的值，而apply函数的返回的是传入对象的本身</strong>。apply一般用于一个对象实例初始化的时候，需要对对象中的属性进行赋值。或者动态inflate出一个XML的View的时候需要给View绑定数据也会用到，这种情景非常常见。特别是在我们开发中会有一些数据model向View model转化实例化的过程中需要用到。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, null).apply&#123;</span><br><span class="line">   course_comment_tv_label.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_score.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_cancel.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_tv_confirm.paint.isFakeBoldText = true</span><br><span class="line">   course_comment_seek_bar.max = 10</span><br><span class="line">   course_comment_seek_bar.progress = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多层级判空示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mSectionMetaData?.apply&#123;</span><br><span class="line"> </span><br><span class="line">	//mSectionMetaData不为空的时候操作mSectionMetaData</span><br><span class="line"> </span><br><span class="line">&#125;?.questionnaire?.apply&#123;</span><br><span class="line"> </span><br><span class="line">	//questionnaire不为空的时候操作questionnaire</span><br><span class="line"> </span><br><span class="line">&#125;?.section?.apply&#123;</span><br><span class="line"> </span><br><span class="line">	//section不为空的时候操作section</span><br><span class="line"> </span><br><span class="line">&#125;?.sectionArticle?.apply&#123;</span><br><span class="line"> </span><br><span class="line">	//sectionArticle不为空的时候操作sectionArticle</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Also"><a href="#Also" class="headerlink" title="Also"></a>Also</h3><blockquote>
<p>@kotlin.internal.InlineOnly<br>@SinceKotlin(“1.1”)<br>public inline fun <t> T.also(block: (T) -&gt; Unit): T { block(this); return this }</t></p>
</blockquote>
<p>适用于let函数的任何场景，also函数和let很像，只是唯一的不同点就是<strong>let函数最后的返回值是最后一行的返回值，而also函数的返回值是返回当前的这个对象</strong>。一般可用于多个扩展函数链式调用</p>
<h2 id="协程Coroutine"><a href="#协程Coroutine" class="headerlink" title="协程Coroutine"></a>协程Coroutine</h2><p>协程就像非常轻量级的线程，<strong>是运行在单线程中的并发程序</strong>。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<p>线程是由系统调度的，线程切换或线程阻塞的开销都比较大（涉及到同步锁；涉及到线程阻塞状态和可运行状态之间的切换；涉及到线程的创建及上下文的切换）。而<strong>协程依赖于线程，但协程挂起时不需要阻塞线程，几乎是无代价的，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）</strong>。因此，协程的开销远远小于线程的开销。</p>
<p><img src="/2020/04/15/android-kotlin/coroutines.jpeg" alt></p>
<blockquote>
<p>对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。协程能保留上一次调用时的状态，不需要像线程一样用回调函数，所以性能上会有提升。<strong>缺点是本质是个单线程，不能利用到单个CPU的多个核。</strong></p>
</blockquote>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li><p>因为在同一个线程里，协程之间的切换不涉及线程上下文的切换和线程状态的改变，不存在资源、数据并发，所以不用加锁，只需要判断状态就OK，所以执行效率比多线程高很多</p>
</li>
<li><p>协程是非阻塞式的(也有阻塞API)，一个协程在进入阻塞后不会阻塞当前线程，当前线程会去执行其他协程任务</p>
</li>
</ul>
<p>协程的切换，是通过yield API 让协程在空闲时（比如等待io，网络数据未到达）放弃执行权，然后在合适的时机再通过resume API 唤醒协程继续运行。协程一旦开始运行就不会结束，直到遇到yield交出执行权。Yield、resume 这一对 API 可以非常便捷的实现异步，这可是目前所有高级语法孜孜不倦追求的</p>
<h3 id="suspend-关键字"><a href="#suspend-关键字" class="headerlink" title="suspend 关键字"></a>suspend 关键字</h3><p>协程天然亲近方法，协程表现为标记、切换方法、代码段，协程里使用 suspend 关键字修饰方法，既该方法可以被协程挂起，<strong>没用suspend修饰的方法不能参与协程任务</strong>，suspend修饰的方法只能在协程中只能与另一个suspend修饰的方法交流</p>
<p>一个协程内有多个 suspend 修饰的方法顺序书写时，代码也是顺序运行的，为什么，suspend 函数会将整个协程挂起，而不仅仅是这个 suspend 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">suspend fun requestToken(): Token &#123; ... &#125;   // 挂起函数</span><br><span class="line">suspend fun createPost(token: Token, item: Item): Post &#123; ... &#125;  // 挂起函数</span><br><span class="line"></span><br><span class="line">fun postItem(item: Item) &#123;</span><br><span class="line">    GlobalScope.launch &#123; // 创建一个新协程</span><br><span class="line">        val token = requestToken()</span><br><span class="line">        val post = createPost(token, item)</span><br><span class="line">        processPost(post)</span><br><span class="line">        // 需要异常处理，直接加上 try/catch 语句即可</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h3><p>kotlin 中 GlobalScope 类提供了几个构造函数：</p>
<ul>
<li>launch - 创建协程</li>
<li>async - 创建带返回值的协程，返回的是 Deferred 类</li>
<li>withContext - 不创建新的协程，在指定协程上运行代码块</li>
<li>runBlocking - 不是 GlobalScope 的 API，可以独立使用，区别是 runBlocking 里面的 delay 会阻塞线程，而 launch 创建的不会</li>
</ul>
<p>kotlin 在 1.3 之后要求协程必须由 CoroutineScope 创建，CoroutineScope 不阻塞当前线程，在后台创建一个新协程，也可以指定协程调度器。CoroutineScope 并不运行协程，它只是确保您不会失去对协程的追踪。<strong>CoroutineScope 会跟踪所有协程，并且可以取消由它所启动的所有协程</strong>。比如 CoroutineScope.launch{} 可以看成 new Coroutine</p>
<h3 id="launch"><a href="#launch" class="headerlink" title="launch"></a>launch</h3><p>launch 函数定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public fun CoroutineScope.launch(</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">): Job</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">GlobalScope.launch(Dispatchers.Unconfined) &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们需要关心的是 launch 的3个参数和返回值 Job：</p>
<p>1.<strong>CoroutineContext</strong> - 可以理解为协程的上下文，在这里我们可以设置 CoroutineDispatcher 协程运行的线程调度器，有 4种线程模式：</p>
<blockquote>
<p>Dispatchers.Default - 使用共享的后台线程池<br>Dispatchers.IO - 用于IO操作的协程<br>Dispatchers.Main - 主线程<br>Dispatchers.Unconfined - 没指定，就是在当前线程(用于不消耗CPU时间的任务以及不更新UI的协程)<br>用newSingleThreadContext创建的调度器：为协和的运行启动了一个线程（一个专用的纯种是一种非常昂贵的资源）</p>
</blockquote>
<p>不写的话就是 Dispatchers.Default 模式的，或者我们可以自己创建协程上下文，也就是线程池，newSingleThreadContext 单线程，newFixedThreadPoolContext 线程池，具体的可以点进去看看，这2个都是方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val singleThreadContext = newSingleThreadContext(&quot;aa&quot;)</span><br><span class="line">GlobalScope.launch(singleThreadContext) &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>CoroutineStart</strong> - 启动模式，默认是DEAFAULT，也就是创建就启动；还有一个是LAZY，意思是等你需要它的时候，再调用启动</p>
<blockquote>
<p>DEAFAULT - 模式模式，不写就是默认<br>ATOMIC -<br>UNDISPATCHED<br>LAZY - 懒加载模式，你需要它的时候，再调用启动，看这个例子</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var job:Job = GlobalScope.launch( start = CoroutineStart.LAZY )&#123;</span><br><span class="line">    Log.d(&quot;AA&quot;, &quot;协程开始运行，时间: &quot; + System.currentTimeMillis())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.sleep( 1000L )</span><br><span class="line">// 手动启动协程</span><br><span class="line">job.start()</span><br></pre></td></tr></table></figure>
<p>3.<strong>block</strong> - 闭包方法体，定义协程内需要执行的操作</p>
<blockquote>
<p>Job - 协程构建函数的返回值，可以把 Job 看成协程对象本身，协程的操作方法都在 Job 身上了<br>job.start() - 启动协程，除了 lazy 模式，协程都不需要手动启动<br>job.join() - 等待协程执行完毕<br>job.cancel() - 取消一个协程<br>job.cancelAndJoin() - 等待协程执行完毕然后再取消</p>
</blockquote>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async 同 launch 唯一的区别就是 async 是有返回值的，看下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Unconfined) &#123;</span><br><span class="line">  val deferred = GlobalScope.async&#123;</span><br><span class="line">  delay(1000L)</span><br><span class="line">  Log.d(&quot;AA&quot;,&quot;This is async &quot;)</span><br><span class="line">  return@async &quot;taonce&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log.d(&quot;AA&quot;,&quot;协程 other start&quot;)</span><br><span class="line">  val result = deferred.await()</span><br><span class="line">  Log.d(&quot;AA&quot;,&quot;async result is $result&quot;)</span><br><span class="line">  Log.d(&quot;AA&quot;,&quot;协程 other end &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log.d(&quot;AA&quot;, &quot;主线程位于协程之后的代码执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">This is async</span><br><span class="line">协程 other start</span><br><span class="line">主线程位于协程之后的代码执行，时间: 1553866185250</span><br><span class="line">async result is taonce</span><br><span class="line">协程 other end</span><br></pre></td></tr></table></figure></p>
<p>async 返回的是 Deferred 类型，Deferred 继承自 Job 接口，Job有的它都有，增加了一个方法 <strong>await</strong> ，这个方法接收的是 async 闭包中返回的值，async 的特点是不会阻塞当前线程，但会阻塞所在协程，也就是挂起。</p>
<p>但是注意啊，<strong>async 并不会阻塞线程，只是阻塞锁调用的协程</strong></p>
<h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><p>runBlocking 和 launch 区别的地方就是 runBlocking 的 delay 方法是可以阻塞当前的线程的，和Thread.sleep() 一样，看下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">  runBlocking &#123;</span><br><span class="line">    // 阻塞1s</span><br><span class="line">    delay(1000L)</span><br><span class="line">    println(&quot;This is a coroutines $&#123;TimeUtil.getTimeDetail()&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 阻塞2s</span><br><span class="line">  Thread.sleep(2000L)</span><br><span class="line">  println(&quot;main end $&#123;TimeUtil.getTimeDetail()&#125;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">~~~~~~~~~~~~~~log~~~~~~~~~~~~~~~~</span><br><span class="line">This is a coroutines 11:00:51</span><br><span class="line">main end 11:00:53</span><br></pre></td></tr></table></figure></p>
<p>runBlocking 通常的用法是用来桥接普通阻塞代码和挂起风格的非阻塞代码，在 runBlocking 闭包里面可以启动另外的协程，协程里面是可以嵌套启动别的协程的。</p>
<h3 id="协程的挂起和恢复"><a href="#协程的挂起和恢复" class="headerlink" title="协程的挂起和恢复"></a>协程的挂起和恢复</h3><p>1.<strong>协程执行时， 协程和协程，协程和线程内代码是顺序运行的</strong><br>最简单的协程运行模式，不涉及挂起时，谁写在前面谁先运行，后面的等前面的协程运行完之后再运行。涉及到挂起时，前面的协程挂起了，那么线程不会空闲，而是继续运行下一个协程，而前面挂起的那个协程在挂起结速后不会马上运行，而是等待当前正在运行的协程运行完毕后再去执行</p>
<p>2.<strong>协程挂起时，就不会执行了，而是等待挂起完成且线程空闲时才能继续执行</strong><br>一个协程内有多个 suspend 修饰的方法顺序书写时，代码也是顺序运行的，为什么，suspend 函数会将整个协程挂起，而不仅仅是这个 suspend 函数。</p>
<p>suspend 修饰的方法挂起的是协程本身，而非该方法，注意这点，看下面的代码体会下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">suspend fun getToken(): String &#123;</span><br><span class="line">  delay(300)</span><br><span class="line">  Log.d(&quot;AA&quot;, &quot;getToken 开始执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line">  return &quot;ask&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">suspend fun getResponse(token: String): String &#123;</span><br><span class="line">  delay(100)</span><br><span class="line">  Log.d(&quot;AA&quot;, &quot;getResponse 开始执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line">  return &quot;response&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun setText(response: String) &#123;</span><br><span class="line">  Log.d(&quot;AA&quot;, &quot;setText 执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 运行代码</span><br><span class="line">GlobalScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">  Log.d(&quot;AA&quot;, &quot;协程 开始执行，时间:  $&#123;System.currentTimeMillis()&#125;&quot;)</span><br><span class="line">  val token = getToken()</span><br><span class="line">  val response = getResponse(token)</span><br><span class="line">  setText(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">协程 开始执行，时间: 1553848676780</span><br><span class="line">getToken 开始执行，时间: 1553848676781</span><br><span class="line">getResponse 开始执行，时间: 1553848677088</span><br><span class="line">setText 执行，时间: 1553848677190</span><br></pre></td></tr></table></figure></p>
<p>在 getToken 方法将协程挂起时，getResponse 函数永远不会运行，只有等 getToken 挂起结速将协程恢复时才会运行。</p>
<p>多协程间 suspend 函数运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch(Dispatchers.Unconfined)&#123;</span><br><span class="line">  var token = GlobalScope.async(Dispatchers.Unconfined) &#123;</span><br><span class="line">    return@async getToken()</span><br><span class="line">   &#125;.await()</span><br><span class="line"></span><br><span class="line">  var response = GlobalScope.async(Dispatchers.Unconfined) &#123;</span><br><span class="line">    return@async getResponse(token)</span><br><span class="line">  &#125;.await()</span><br><span class="line"></span><br><span class="line">  setText(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//运行结果</span><br><span class="line">getToken 开始执行，时间: 1553848676781</span><br><span class="line">getResponse 开始执行，时间: 1553848677088</span><br><span class="line">setText 执行，时间: 1553848677190</span><br></pre></td></tr></table></figure></p>
<p>注意我外面要包裹一层 GlobalScope.launch，要不运行不了。这里我们搞了2个协程出来，但是我们在这里使用了await，这样就会阻塞外部协程，所以代码还是按顺序执行的。这样适用于多个同级 IO 操作的情况，这样写比 rxjava 要省事不少。</p>
<p>协程挂起后再恢复时在哪个线程运行：<br>哪个线程恢复的协程，协程就运行在哪个线程中。<br>注意协程内部，若是在前面有代码切换了线程，后面的代码若是没有指定线程，那么就是运行在这个切换到的线程上的。<br>我们最好给异步任务在外面套一个协程，这样我们可以挂起整个异步任务，然后给每段代码指定运行线程调度器，这样省的因为协程内部挂起恢复变更线程而带来的问题。<br>非 Dispatchers.Main 调度器的协程，会在协程挂起后把协程当做一个任务 DelayedResumeTask 放到默认线程池 DefaultExecutor 队列的最后，在延迟的时间到达才会执行恢复协程任务。虽然多个协程之间可能不是在同一个线程上运行的，但是协程内部的机制可以保证我们书写的协程是按照我们指定的顺序或者逻辑自行。</p>
<h3 id="delay、yield-区别"><a href="#delay、yield-区别" class="headerlink" title="delay、yield 区别"></a>delay、yield 区别</h3><p>delay 和 yield 方法是协程内部的操作，可以挂起协程，区别是 delay 是挂起协程并经过执行时间恢复协程，当线程空闲时就会运行协程；yield 是挂起协程，让协程放弃本次 cpu 执行机会让给别的协程，当线程空闲时再次运行协程。我们只要使用 kotlin 提供的协程上下文类型，线程池是有多个线程的，再次执行的机会很快就会有的。</p>
<p>除了 main 类型，协程在挂起后都会封装成任务放到协程默认线程池的任务队列里去，有延迟时间的在时间过后会放到队列里去，没有延迟时间的直接放到队列里去</p>
<h3 id="协程的取消"><a href="#协程的取消" class="headerlink" title="协程的取消"></a>协程的取消</h3><p>我们在创建协程过后可以接受一个 Job 类型的返回值，我们操作 job 可以取消协程任务，job.cancel 就可以了。</p>
<p>协程的取消有些特质，因为协程内部可以在创建协程的，这样的协程组织关系可以称为父协程，子协程：</p>
<ul>
<li>父协程手动调用 cancel() 或者异常结束，会立即取消它的所有子协程（而抛出CancellationException却会当作正常的协程结束不会取消其父协程）</li>
<li>父协程必须等待所有子协程完成（处于完成或者取消状态）才能完成</li>
<li>子协程抛出未捕获的异常时，默认情况下会取消其父协程</li>
</ul>
<p>现在问题来了，在 Thread 中我们想关闭线程有时候也不是掉个方法就行的，需要我们自行在线程中判断线程是不是已经结束了。在协程中一样，cancel 方法只是修改了协程的状态，在协程自身的方法比如 realy，yield 等中会判断协程的状态从而结束协程，但是若是在协程我们没有用这几个方法怎么办，比如都是逻辑代码，这时就要我们自己手动判断了，使用 job.isActive ，isActive 是个标记，用来检查协程状态</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>每一个挂起点和初始挂起点对应的 Continuation 都会转化为一种状态，协程恢复只是跳转到下一种状态中。挂起函数将执行过程分为多个 Continuation 片段，并且利用状态机的方式保证各个片段是顺序执行的。</p>
<p><img src="/2020/04/15/android-kotlin/suspend.webp" alt></p>
<p>await()挂起函数恢复协程的原理是，将 launch 协程封装为 ResumeAwaitOnCompletion 作为 handler 节点添加到 aynsc 协程的 state.list，然后在 async 协程完成时会通知 handler 节点调用 launch 协程的 resume(result) 方法将结果传给 launch 协程，并恢复 launch 协程继续执行 await 挂起点之后的逻辑。</p>
<p>协程其实有三层包装。常用的launch和async返回的Job、Deferred，里面封装了协程状态，提供了取消协程接口，而它们的实例都是继承自AbstractCoroutine，它是协程的第一层包装。第二层包装是编译器生成的SuspendLambda的子类，封装了协程的真正运算逻辑，继承自BaseContinuationImpl，其中completion属性就是协程的第一层包装。第三层包装是线程调度时的DispatchedContinuation，封装了线程调度逻辑，包含了协程的第二层包装。三层包装都实现了Continuation接口，通过代理模式将协程的各层包装组合在一起，每层负责不同的功能。</p>
<p>下面是协程运行的流程图：</p>
<p><img src="/2020/04/15/android-kotlin/flow.webp" alt></p>
<p>总结：协程就是一段可以挂起和恢复执行的运算逻辑，而协程的挂起是通过挂起函数实现的，挂起函数用状态机的方式用挂起点将协程的运算逻辑拆分为不同的片段，每次运行协程执行的不同的逻辑片段。所以协程有两个很大的好处：一是简化异步编程，支持异步返回；而是挂起不阻塞线程，提供线程利用率。</p>
<h3 id="协程的并发"><a href="#协程的并发" class="headerlink" title="协程的并发"></a>协程的并发</h3><p>协程就是可以挂起和恢复执行的运算逻辑，挂起函数用状态机的方式用挂起点将协程的运算逻辑拆分为不同的片段，每次运行协程执行的不同的逻辑片段。所以协程在运行时只是线程中的一块代码，线程的并发处理方式都可以用在协程上。不过协程还提供两种特有的方式，一是不阻塞线程的互斥锁Mutex，一是通过 ThreadLocal 实现的协程局部数据。</p>
<h4 id="Mutex-协程互斥锁"><a href="#Mutex-协程互斥锁" class="headerlink" title="Mutex 协程互斥锁"></a>Mutex 协程互斥锁</h4><p>线程中锁都是阻塞式，在没有获取锁时无法执行其他逻辑，而协程可以通过挂起函数解决这个，没有获取锁就挂起协程，获取后再恢复协程，协程挂起时线程并没有阻塞可以执行其他逻辑。这种互斥锁就是 Mutex，它与 synchronized 关键字有些类似，还提供了 withLock 扩展函数，替代常用的 mutex.lock; try {…} finally { mutex.unlock() }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val mutex = Mutex()</span><br><span class="line">    var counter = 0</span><br><span class="line">    repeat(10000) &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            mutex.withLock &#123;</span><br><span class="line">                counter ++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;The final count is $counter&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Mutex的使用比较简单，不过需要注意的是多个协程竞争的应该是同一个Mutex互斥锁。</p>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>线程中可以使用ThreadLocal作为线程局部数据，每个线程中的数据都是独立的。协程中可以通过<strong>ThreadLocal.asContextElement()扩展函数实现协程局部数据，每次协程切换会恢复之前的值</strong>。先看下面的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; &#123;</span><br><span class="line">    val threadLocal = ThreadLocal&lt;String&gt;().apply &#123; set(&quot;Init&quot;) &#125;</span><br><span class="line">    printlnValue(threadLocal)</span><br><span class="line">    val job = GlobalScope.launch(threadLocal.asContextElement(&quot;launch&quot;)) &#123;</span><br><span class="line">        printlnValue(threadLocal)</span><br><span class="line">        threadLocal.set(&quot;launch changed&quot;)</span><br><span class="line">        printlnValue(threadLocal)</span><br><span class="line">        yield()</span><br><span class="line">        printlnValue(threadLocal)</span><br><span class="line">    &#125;</span><br><span class="line">    job.join()</span><br><span class="line">    printlnValue(threadLocal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private fun printlnValue(threadLocal: ThreadLocal&lt;String&gt;) &#123;</span><br><span class="line">    println(&quot;$&#123;Thread.currentThread()&#125; thread local value: $&#123;threadLocal.get()&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出如下：</span><br><span class="line">Thread[main,5,main] thread local value: Init</span><br><span class="line">Thread[DefaultDispatcher-worker-1,5,main] thread local value: launch</span><br><span class="line">Thread[DefaultDispatcher-worker-1,5,main] thread local value: launch changed</span><br><span class="line">Thread[DefaultDispatcher-worker-2,5,main] thread local value: launch</span><br><span class="line">Thread[main,5,main] thread local value: Init</span><br></pre></td></tr></table></figure></p>
<p>上面的输出有个疑问的地方，为什么执行yield()挂起函数后 threadLocal 的值不是launch changed而变回了launch?<br>最重要的牢记它的原理：<strong>启动和恢复时保存ThreadLocal在当前线程的值，并修改为 value，挂起和结束时修改当前线程ThreadLocal的值为之前保存的值。</strong></p>
<h2 id="委托by"><a href="#委托by" class="headerlink" title="委托by"></a>委托by</h2><p>委托模式是软件设计模式中的一项基本技巧。在委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。Kotlin 直接支持委托模式，更加优雅，简洁。Kotlin 通过关键字 by 实现委托。</p>
<h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>类的委托即一个类中定义的方法实际是调用另一个类的对象的方法来实现的。</p>
<p>以下实例中派生类 Derived 继承了接口 Base 所有方法，并且委托一个传入的 Base 类的对象来执行这些方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 创建接口</span><br><span class="line">interface Base &#123;   </span><br><span class="line">    fun print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现此接口的被委托的类</span><br><span class="line">class BaseImpl(val x: Int) : Base &#123;</span><br><span class="line">    override fun print() &#123; print(x) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过关键字 by 建立委托类</span><br><span class="line">class Derived(b: Base) : Base by b</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val b = BaseImpl(10)</span><br><span class="line">    Derived(b).print() // 输出 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Derived 声明中，by 子句表示，将 b 保存在 Derived 的对象实例内部，而且编译器将会生成继承自 Base 接口的所有方法, 并将调用转发给 b。</p>
<h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p>属性委托指的是一个类的某个属性值不是在类中直接进行定义，而是将其托付给一个代理类，从而实现对该类的属性统一管理。</p>
<p>属性委托语法格式：</p>
<blockquote>
<p>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</p>
</blockquote>
<ul>
<li>var/val：属性类型(可变/只读)</li>
<li>属性名：属性名称</li>
<li>类型：属性的数据类型</li>
<li>表达式：委托代理类</li>
</ul>
<p>by 关键字之后的表达式就是委托, 属性的 get() 方法(以及set() 方法)将被委托给这个对象的 getValue() 和 setValue() 方法。<strong>属性委托不必实现任何接口, 但必须提供 getValue() 函数(对于 var属性,还需要 setValue() 函数)。</strong></p>
<p>该类需要包含 getValue() 方法和 setValue() 方法，且参数 thisRef 为进行委托的类的对象，prop 为进行委托的属性的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import kotlin.reflect.KProperty</span><br><span class="line">// 定义包含属性委托的类</span><br><span class="line">class Example &#123;</span><br><span class="line">    var p: String by Delegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 委托的类</span><br><span class="line">class Delegate &#123;</span><br><span class="line">    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;</span><br><span class="line">        return &quot;$thisRef, 这里委托了 $&#123;property.name&#125; 属性&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;</span><br><span class="line">        println(&quot;$thisRef 的 $&#123;property.name&#125; 属性赋值为 $value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val e = Example()</span><br><span class="line">    println(e.p)     // 访问该属性，调用 getValue() 函数</span><br><span class="line"></span><br><span class="line">    e.p = &quot;Runoob&quot;   // 调用 setValue() 函数</span><br><span class="line">    println(e.p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果为：</span><br><span class="line">Example@433c675d, 这里委托了 p 属性</span><br><span class="line">Example@433c675d 的 p 属性赋值为 Runoob</span><br><span class="line">Example@433c675d, 这里委托了 p 属性</span><br></pre></td></tr></table></figure></p>
<h3 id="延迟属性-Lazy"><a href="#延迟属性-Lazy" class="headerlink" title="延迟属性 Lazy"></a>延迟属性 Lazy</h3><p>lazy() 是一个函数, 接受一个 Lambda 表达式作为参数, 返回一个 Lazy <t> 实例的函数，返回的实例可以作为实现延迟属性的委托： <strong>第一次调用 get() 会执行已传递给 lazy() 的 lamda 表达式并记录结果， 后续调用 get() 只是返回记录的结果</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val lazyValue: String by lazy &#123;</span><br><span class="line">    println(&quot;computed!&quot;)     // 第一次调用输出，第二次调用不执行</span><br><span class="line">    &quot;Hello&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(lazyValue)   // 第一次执行，执行两次输出表达式</span><br><span class="line">    println(lazyValue)   // 第二次执行，只输出返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行输出结果：</span><br><span class="line">computed!</span><br><span class="line">Hello</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></t></p>
<p>你可以将局部变量声明为委托属性。 例如，你可以使一个局部变量惰性初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun example(computeFoo: () -&gt; Foo) &#123;</span><br><span class="line">    val memoizedFoo by lazy(computeFoo)</span><br><span class="line"></span><br><span class="line">    if (someCondition &amp;&amp; memoizedFoo.isValid()) &#123;</span><br><span class="line">        memoizedFoo.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>memoizedFoo 变量只会在第一次访问时计算。 如果 someCondition 失败，那么该变量根本不会计算。</p>
<h3 id="提供委托provideDelegate"><a href="#提供委托provideDelegate" class="headerlink" title="提供委托provideDelegate"></a>提供委托provideDelegate</h3><p>通过定义 provideDelegate 操作符，<strong>可以扩展创建属性实现所委托对象的逻辑</strong>。 如果 by 右侧所使用的对象将 provideDelegate 定义为成员或扩展函数，那么会调用该函数来 创建属性委托实例。</p>
<p>provideDelegate 的一个可能的使用场景是在创建属性时（而不仅在其 getter 或 setter 中）检查属性一致性。</p>
<p>例如，如果要在绑定之前检查属性名称，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class ResourceLoader&lt;T&gt;(id: ResourceID&lt;T&gt;) &#123;</span><br><span class="line">    operator fun provideDelegate(</span><br><span class="line">            thisRef: MyUI,</span><br><span class="line">            prop: KProperty&lt;*&gt;</span><br><span class="line">    ): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">        checkProperty(thisRef, prop.name)</span><br><span class="line">        // 创建委托</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun checkProperty(thisRef: MyUI, name: String) &#123; …… &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; bindResource(id: ResourceID&lt;T&gt;): ResourceLoader&lt;T&gt; &#123; …… &#125;</span><br><span class="line"></span><br><span class="line">class MyUI &#123;</span><br><span class="line">    val image by bindResource(ResourceID.image_id)</span><br><span class="line">    val text by bindResource(ResourceID.text_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>provideDelegate 的参数与 getValue 相同：</p>
<blockquote>
<p>thisRef —— 必须与 属性所有者 类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型<br>property —— 必须是类型 KProperty&lt;*&gt; 或其超类型。</p>
</blockquote>
<p>在创建 MyUI 实例期间，为每个属性调用 provideDelegate 方法，并立即执行必要的验证。</p>
<p>如果没有这种拦截属性与其委托之间的绑定的能力，为了实现相同的功能， 你必须显式传递属性名，这不是很方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 检查属性名称而不使用“provideDelegate”功能</span><br><span class="line">class MyUI &#123;</span><br><span class="line">    val image by bindResource(ResourceID.image_id, &quot;image&quot;)</span><br><span class="line">    val text by bindResource(ResourceID.text_id, &quot;text&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; MyUI.bindResource(</span><br><span class="line">        id: ResourceID&lt;T&gt;,</span><br><span class="line">        propertyName: String</span><br><span class="line">): ReadOnlyProperty&lt;MyUI, T&gt; &#123;</span><br><span class="line">   checkProperty(this, propertyName)</span><br><span class="line">   // 创建委托</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在生成的代码中，会调用 provideDelegate 方法来初始化辅助的 prop$delegate 属性。 比较对于属性声明 val prop: Type by MyDelegate() 生成的代码与 上面（当 provideDelegate 方法不存在时）生成的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class C &#123;</span><br><span class="line">    var prop: Type by MyDelegate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这段代码是当“provideDelegate”功能可用时</span><br><span class="line">// 由编译器生成的代码：</span><br><span class="line">class C &#123;</span><br><span class="line">    // 调用“provideDelegate”来创建额外的“delegate”属性</span><br><span class="line">    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)</span><br><span class="line">    val prop: Type</span><br><span class="line">        get() = prop$delegate.getValue(this, this::prop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，provideDelegate 方法只影响辅助属性的创建，并不会影响为 getter 或 setter 生成的代码。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><p>在定义的时候忽略返回值等于是隐式声明函数的返回值是空。在Kotlin中，这种隐式返回的类型称之为：Unit。这个Unit类型的作用类似Java语言中的void类型。Unit是一种只有一个值——Unit的类型。这个值不需要显式返回。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>Kotlin中的闭包是一个功能性自包含模块，可以在代码中被当做参数传递或者直接使用。<strong>函数里面声明函数，函数里面返回函数，就是闭包。</strong></p>
<p>闭包就是一个代码块，<strong>用“{ }”包起来</strong>。Kotlin语言中有三种闭包形式：全局函数、自嵌套函数、匿名函数体。下面举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 执行test闭包的内容</span><br><span class="line">    test</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个比较测试闭包</span><br><span class="line">val test = if (5 &gt; 3) &#123;</span><br><span class="line">    println(&quot;yes&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    println(&quot;no&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 原语句等价于 val test = println(&quot;yes&quot;) ,test是一个Unit对象，而Unit是个object，也就是个单例类,所以，上面的代码等价于</span><br><span class="line">val test  = Unit</span><br><span class="line">object Unit &#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;yes&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//因为单例对象只会初始化一次，所以不管定义多少次只会打印一次yes。</span><br><span class="line">//实际上，val test = &#123;println(&quot;yes&quot;)&#125; ，大括号包裹的是另外一种，等价于 val test = fun()&#123; println(&quot;yes&quot;) &#125; 这种才是函数的调用形式，使用test()</span><br></pre></td></tr></table></figure></p>
<p>闭包的用途：<strong>能够读取其他函数的内部变量，另一个用处就是让这些变量的值始终保持在内存中(在内存中维持一个变量)。</strong></p>
<p>注意：闭包会使得函数中的变量都被保存在内存中，内存消耗很大.闭包赋值给变量后,待变量销毁,内存释放</p>
<blockquote>
<p>广义上来说，在Kotlin语言之中，函数、条件语句、控制流语句、花括号逻辑块、Lambda表达式都可以称之为闭包，但通常情况下，我们所指的闭包都是在说Lambda表达式。</p>
</blockquote>
<h3 id="双冒号"><a href="#双冒号" class="headerlink" title="双冒号 ::"></a>双冒号 ::</h3><p>Kotlin 中 双冒号操作符 表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。</p>
<p>一般情况，我们调用当前类的方法 this 都是可省略的。为了防止作用域混淆 ，:: 调用的函数如果是类的成员函数或者是扩展函数，必须使用限定符,比如this。</p>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 给一个字符串拼接前缀和后缀</span><br><span class="line"> * 前缀默认值：***</span><br><span class="line"> * 后缀默认值：###</span><br><span class="line"> */</span><br><span class="line">fun catString(myString: String, prefix: String = &quot;***&quot;, suffix: String = &quot;###&quot;): String&#123;</span><br><span class="line">    return prefix + myString + suffix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用的时候，可以忽略带有默认值的参数不传</span><br><span class="line">catString(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="可变个数参数（vararg）"><a href="#可变个数参数（vararg）" class="headerlink" title="可变个数参数（vararg）"></a>可变个数参数（vararg）</h3><p>声明可变个数形参需要用到vararg关键字，当参数传递进入函数体之后，参数在函数体内可以通过集合的形式访问。<strong>函数最多可以有一个可变个数的形参，而且它必须出现在参数列表的最后</strong>。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 求多个数字的和</span><br><span class="line"> */</span><br><span class="line">fun sumNumbers(vararg numbers : Double) : Double&#123;</span><br><span class="line">    var result : Double = 0.0</span><br><span class="line">    for (number in numbers) &#123;</span><br><span class="line">        result += number</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用的时候，则可以传任意多个参数</span><br><span class="line">sumNumbers(1.2,2.56,3.14)</span><br></pre></td></tr></table></figure></p>
<h3 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h3><p>在结构化编程盛行的年代，嵌套函数被广泛使用，在一个函数体中定义另外一个函数体就为嵌套函数。<strong>嵌套函数默认对外界是隐藏的，但仍然可以通过它们包裹的函数调用和使用它</strong>，举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 嵌套函数demo</span><br><span class="line"> *</span><br><span class="line"> * 比较数字numberA和数字numberB的二次幂谁大</span><br><span class="line"> */</span><br><span class="line">fun compare(numberA: Int, numberB: Int) : Int&#123;</span><br><span class="line">    var powerB = 0</span><br><span class="line"></span><br><span class="line">    // 嵌套函数，求一个数字的二次幂</span><br><span class="line">    fun power(num : Int) : Int&#123;</span><br><span class="line">        return num * num</span><br><span class="line">    &#125;</span><br><span class="line">    powerB = power(numberB)</span><br><span class="line"></span><br><span class="line">    if (numberA &gt; powerB) &#123;</span><br><span class="line">        return numberA</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return powerB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    // 报错!!! </span><br><span class="line">    // 无法直接调用内部嵌套的函数</span><br><span class="line">    power()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/Zachary_46/article/details/80446851" target="_blank" rel="noopener">https://blog.csdn.net/Zachary_46/article/details/80446851</a><br><a href="https://www.runoob.com/kotlin/kotlin-delegated.html" target="_blank" rel="noopener">https://www.runoob.com/kotlin/kotlin-delegated.html</a><br><a href="https://www.jianshu.com/p/76d2f47b900d" target="_blank" rel="noopener">Coroutine 协程</a><br><a href="https://www.jianshu.com/p/2857993af646" target="_blank" rel="noopener">Kotlin Coroutines(协程) 完全解析（三）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/09/android-jetpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/09/android-jetpack/" itemprop="url">Android Jetpack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-09T16:19:49+08:00">
                2020-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Google 在2018年推出了 Android Jetpack。Jetpack 是一套库、工具和指南，可帮助开发者更轻松地编写优质应用。这些组件可帮助您遵循最佳做法、让您摆脱编写样板代码的工作并简化复杂任务，以便您将精力集中放在所需的代码上。</p>
<p>Android Jetpack 组件是库的集合，这些库是为协同工作而构建的，不过也可以单独采用，同时利用 Kotlin 语言功能帮助您提高工作效率。可全部使用，也可混合搭配！Jetpack 也包含了与平台 API 解除捆绑的 androidx.* 软件包库。</p>
<p>特点如下：</p>
<ul>
<li>加速开发：组件可以单独采用（不过这些组件是为协同工作而构建的），同时利用 Kotlin 语言功能帮助您提高工作效率。</li>
<li>消除样板代码：Android Jetpack 可管理繁琐的 Activity（如后台任务、导航和生命周期管理），以便您可以专注于如何让自己的应用出类拔萃。</li>
<li>构建高质量的强大应用：Android Jetpack 组件围绕现代化设计实践构建而成，具有向后兼容性，可以减少崩溃和内存泄漏。</li>
</ul>
<h2 id="JetPack的组成"><a href="#JetPack的组成" class="headerlink" title="JetPack的组成"></a>JetPack的组成</h2><p><img src="/2020/04/09/android-jetpack/jetpack-composition.png" alt></p>
<p>WorkManager很强大，需要的地方可以替代以前的方案。LifeCycles也不错，扩展其他类具有关联生命周期的。还有Room数据库的框架，简单了很多。LiveData和ViewModel的结合基本上就是RxJava和RxAndroid的结合的功能了。</p>
<h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><p>Navigation是一个可简化Android导航的库和插件</p>
<p>Navigation是用来<strong>管理Fragment的切换</strong>，并且可以通过可视化的方式，看见App的交互流程。这完美的契合了Jake Wharton大神<strong>单Activity</strong>的建议。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>处理Fragment的切换（上文已说过）</li>
<li>默认情况下正确处理Fragment的前进和后退</li>
<li>为过渡和动画提供标准化的资源</li>
<li>实现和处理深层连接</li>
<li>可以绑定Toolbar、BottomNavigationView和ActionBar等</li>
<li>SafeArgs（Gradle插件） 数据传递时提供类型安全性</li>
<li>ViewModel支持</li>
</ul>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ol>
<li><p>Navigation Graph(New XML resource)： 这是一个新的资源文件，用户在可视化界面可以看出他能够到达的Destination(用户能够到达的屏幕界面)，以及流程关系。</p>
</li>
<li><p>NavHostFragment(Layout XML view)： 当前Fragment的容器</p>
</li>
<li><p>NavController(Kotlin/Java object)： 导航的控制者</p>
</li>
</ol>
<p>可能我这么解释还是有点抽象，做一个不是那么恰当的比喻，我们可以将Navigation Graph看作一个地图，NavHostFragment看作一个车，以及把NavController看作车中的方向盘，Navigation Graph中可以看出各个地点（Destination）和通往各个地点的路径，NavHostFragment可以到达地图中的各个目的地，但是决定到什么目的地还是方向盘NavController，虽然它取决于开车人（用户）。</p>
<h3 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>app:startDestination</td>
<td>navigation标签: 默认的起始位置</td>
</tr>
<tr>
<td>app:destination</td>
<td>action标签: 跳转完成到达的fragment的Id</td>
</tr>
<tr>
<td>app:popUpTo</td>
<td>action标签: 将fragment从栈中弹出，直到某个Id的fragment</td>
</tr>
<tr>
<td>app:argType</td>
<td>argument标签: 标签的类型</td>
</tr>
<tr>
<td>android:defaultValue</td>
<td>argument标签: 默认值</td>
</tr>
<tr>
<td>app:navGraph</td>
<td>fragment标签: 存放的是第二步建好导航的资源文件，也就是确定了Navigation Graph</td>
</tr>
<tr>
<td>app:defaultNavHost=”true”</td>
<td>fragment标签: 与系统的返回按钮相关联</td>
</tr>
</tbody>
</table>
<p>导航示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">btnLogin.setOnClickListener &#123;</span><br><span class="line">            // 设置动画参数</span><br><span class="line">            val navOption = navOptions &#123;</span><br><span class="line">                anim &#123;</span><br><span class="line">                    enter = R.anim.slide_in_right</span><br><span class="line">                    exit = R.anim.slide_out_left</span><br><span class="line">                    popEnter = R.anim.slide_in_left</span><br><span class="line">                    popExit = R.anim.slide_out_right</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 参数设置</span><br><span class="line">            val bundle = Bundle()</span><br><span class="line">            bundle.putString(&quot;name&quot;,&quot;TeaOf&quot;)</span><br><span class="line">            findNavController().navigate(R.id.login, bundle,navOption)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不用Safe Args，action可以由Navigation.createNavigateOnClickListener(R.id.next_action, null)方式生成</p>
<h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p><img src="/2020/04/09/android-jetpack/livedata.png" alt></p>
<p>LiveData有个内部类LifecycleBoundObserver，它实现了GenericLifecycleObserver，而GenericLifecycleObserver继承了LifecycleObserver接口。当组件（Fragment、Activity）生命周期变化时会通过onStateChanged()方法回调过来。</p>
<p>LiveData主要涉及到的时序有三个：<br>在Fragment/Activity中通过LiveData.observer()添加观察者（observer()方法中的第二个参数）。<br>根据Fragment/Activity生命周期发生变化时，移除观察者或者通知观察者更新数据。<br>当调用LiveData的setValue()、postValue()方法后，通知观察者更新数据(setValue必须发生在主线程,如果当前线程是子线程可以使用postValue)。</p>
<p>在LiveData.observe()方法中添加了组件（实现了LifecycleOwner接口的Fragment和Activity）生命周期观察者。而这个观察者就是LifecycleBoundObserver对象.</p>
<p><strong>应用及知识点</strong>：</p>
<ol>
<li><p>使用ViewModel在同一个Activity中的Fragment之间共享数据：想要利用ViewModel实现Fragment之间数据共享，前提是Fragment中的FragmentActivity得相同。</p>
</li>
<li><p>map是你将你的函数用于你传参的livedata的数据通过函数体中的逻辑改变，然后将结果传到下游。而switchmap，转换跟map差不多，只不过传到下游的是<strong>livedata类型</strong>。</p>
</li>
<li><p>MediatorLiveData 是 LiveData 的子类，允许您合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。</p>
</li>
<li><p>使用LiveData共享数据：定义一个类然后继承LiveData，并使用单例模式即可。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 登录信息</span><br><span class="line">data class LoginInfo constructor(val account:String, val pwd:String, val email:String)</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 自定义单例LiveData</span><br><span class="line"> */</span><br><span class="line">class LoginLiveData:LiveData&lt;LoginInfo&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        private lateinit var sInstance: LoginLiveData</span><br><span class="line"></span><br><span class="line">        @MainThread</span><br><span class="line">        fun get(): LoginLiveData &#123;</span><br><span class="line">            sInstance = if (::sInstance.isInitialized) sInstance else LoginLiveData()</span><br><span class="line">            return sInstance</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：您可以使用 observeForever(Observer) 方法来注册未关联 LifecycleOwner 对象的观察者。在这种情况下，观察者会被视为始终处于活跃状态，因此它始终会收到关于修改的通知。您可以通过调用 removeObserver(Observer) 方法来移除这些观察者。</p>
<h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel类是被设计用来以可感知生命周期的方式存储和管理 UI 相关数据，ViewModel中数据会一直存活即使 activity configuration发生变化，比如横竖屏切换的时候。</p>
<p>由于 ViewModel 生命周期可能长与 activity 生命周期，所以为了避免内存泄漏 Google 禁止在 ViewModel 中持有 Context 或 activity 或 view 的引用。</p>
<p><img src="/2020/04/09/android-jetpack/viewmodel-lifecycle.webp" alt title="ViewModel生命周期"></p>
<p>viewmodel初始化：</p>
<blockquote>
<p>ViewModelProviders.of(activity，factory).get(MyViewModel.class)</p>
</blockquote>
<p>1、初始化了<strong>ViewModelProvider内部维护了 用于创建 VM 的 Factory，和用户存放 VM 的ViewModelStore</strong>；<br>2、初始化了 用来生成 ViewModel 的 Factory（默认为DefaultFactory）；<br>3、通过ViewModelStores的静态方法实例化了 HolderFragment，并实例化了ViewModelStore<br>4、然后是ViewModelProvider的 get 方法</p>
<p><img src="/2020/04/09/android-jetpack/viewmodel-init.png" alt title="ViewModel初始化"></p>
<h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><p><img src="/2020/04/09/android-jetpack/room.webp" alt></p>
<h2 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h2><p>DataBinding 是google发布的一个数据绑定框架，<strong>用于降低布局和逻辑的耦合性</strong>，使代码逻辑更加清晰。大量减少 Activity 内的代码，数据能够单向或双向绑定到 layout 文件中，<strong>有助于防止内存泄漏</strong>，而且<strong>能自动进行空检测以避免空指针异常</strong>。</p>
<p><img src="/2020/04/09/android-jetpack/data-binding.webp" alt></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>app及对应module添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">   dataBinding &#123;</span><br><span class="line">       enabled = true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>1.activity中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    val dataBinding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)</span><br><span class="line">    // 给user初始化值</span><br><span class="line">    dataBinding.user = User(&quot;zhangsan&quot;, &quot;12345&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.在 Fragment 中的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123;</span><br><span class="line">     val blankFragmentBinding: BlankFragmentBinding =</span><br><span class="line">         DataBindingUtil.inflate(inflater, R.layout.blank_fragment, container, false)</span><br><span class="line">     return blankFragmentBinding.root</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>3.在RecyclerView中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerViewHolder 	&#123;</span><br><span class="line">     val itemMvvmBinding = DataBindingUtil.inflate&lt;ViewDataBinding&gt;(</span><br><span class="line">         LayoutInflater.from(parent.context), R.layout.item_mvvm, parent, false)</span><br><span class="line">     itemMvvmBinding.getRoot().setOnClickListener(this)</span><br><span class="line">     return RecyclerViewHolder(itemMvvmBinding)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">override fun onBindViewHolder(holder: RecyclerViewHolder, position: Int) &#123;</span><br><span class="line">     val itemMvvmBinding = holder.getBinding()</span><br><span class="line">     val userBean = data.get(position)</span><br><span class="line">     itemMvvmBinding.setUser(userBean)</span><br><span class="line">     itemMvvmBinding.btnUpdate.setOnClickListener(OnBtnClickListener(1, userBean))</span><br><span class="line">     ...</span><br><span class="line">     // 立刻执行绑定</span><br><span class="line">     itemMvvmBinding.executePendingBindings()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="单向绑定"><a href="#单向绑定" class="headerlink" title="单向绑定"></a>单向绑定</h3><p>一个简单的ViewModel 类被更新后，并不会让 UI 自动更新。而数据绑定后，我们自然会希望数据变更后 UI 会即时刷新，Observable 就是为此而生的概念。实现数据变化自动驱动 UI 刷新的方式有三种：BaseObservable、ObservableField、ObservableCollection</p>
<h4 id="BaseObservable"><a href="#BaseObservable" class="headerlink" title="BaseObservable"></a>BaseObservable</h4><p>BaseObservable 提供了 notifyChange() 和 notifyPropertyChanged() 两个方法:</p>
<ul>
<li>notifyChange() 它会刷新所有的值。</li>
<li>notifyPropertyChanged() 它只会根据对应的BR的flag更新，该 BR 的生成通过注释 @Bindable 生成，可以通过 BR notify 特定属性关联的视图。</li>
</ul>
<p>//由于kotlin的属性默认是public修饰，所以可以直接在属性上@Bindable, 如何设置了修饰符且不为public的话，则可使用@get Bindable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class UserInfo : BaseObservable() &#123;</span><br><span class="line">	// 对name进行@Bindable标志，然后会生成BR.name</span><br><span class="line">    @Bindable</span><br><span class="line">    var name: String = &quot;&quot;</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            // 当name,发生改变时只会刷新与name相关控件的值，不会刷新其他的值</span><br><span class="line">            notifyPropertyChanged(BR.name)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    @get: Bindable</span><br><span class="line">    var password: String = &quot;&quot;</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">            // 当password 发生改变时，也会刷新其他属性相关的控件的值</span><br><span class="line">            notifyChange()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现了 Observable 接口的类允许注册一个监听器OnPropertyChangedCallback，当可观察对象的属性更改时就会通知这个监听器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//当中 propertyId 就用于标识特定的字段</span><br><span class="line">user.addOnPropertyChangedCallback(object : Observable.OnPropertyChangedCallback()&#123;</span><br><span class="line">     override fun onPropertyChanged(sender: Observable, propertyId: Int) &#123;</span><br><span class="line">                </span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="ObservableField"><a href="#ObservableField" class="headerlink" title="ObservableField"></a>ObservableField</h4><p>继承于 Observable 类相对来说限制有点高，且也需要进行notify 操作，因此为了<strong>简单起见可以选择使用 ObservableField</strong>。 可以理解为官方对 BaseObservable 中字段的注解和刷新等操作的封装，官方原生提供了对基本数据类型的封装，例如 ObservableBoolean、ObservableByte、ObservableChar、ObservableShort、ObservableInt、ObservableLong、ObservableFloat、ObservableDouble 以及 ObservableParcelable ，也可通过 ObservableField 泛型来申明其他类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data class ObservableUser(</span><br><span class="line">    var name: ObservableField&lt;String&gt;,</span><br><span class="line">    var password: ObservableField&lt;String&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h4 id="ObservableCollection"><a href="#ObservableCollection" class="headerlink" title="ObservableCollection"></a>ObservableCollection</h4><p>dataBinding 也提供了包装类用于替代原生的 List 和 Map，分别是 ObservableList 和 ObservableMap,当其包含的数据发生变化时，绑定的视图也会随之进行刷新</p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>双向绑定的意思即为当数据改变时同时使视图刷新，而视图改变时也可以同时改变数据。绑定变量的方式比单向绑定多了一个等号，如：android:text=”@={user.name}”</p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>严格意义上来说，事件绑定也是一种变量绑定，只不过设置的变量是回调接口而已。</p>
<p>事件绑定包括方法引用和监听绑定：</p>
<ul>
<li>方法引用：参数类型和返回类型要一致，参考et_pwd EditText的android:onTextChanged引用。</li>
<li>监听绑定：相比较于方法引用，监听绑定的要求就没那么高了，我们可以使用自行定义的函数，参考et_account EditText的android:onTextChanged引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">        xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;!--需要的viewModel,通过mBinding.vm=mViewMode注入--&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;model&quot;</span><br><span class="line">            type=&quot;com.joe.jetpackdemo.viewmodel.LoginModel&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;activity&quot;</span><br><span class="line">            type=&quot;androidx.fragment.app.FragmentActivity&quot;/&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line"></span><br><span class="line">    &lt;androidx.constraintlayout.widget.ConstraintLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/txt_cancel&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;()-&gt; activity.onBackPressed()&#125;&quot;</span><br><span class="line">            /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TextView</span><br><span class="line">            android:id=&quot;@+id/txt_title&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br><span class="line">            .../&gt;</span><br><span class="line"></span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:id=&quot;@+id/et_account&quot;</span><br><span class="line">            android:text=&quot;@&#123;model.n.get()&#125;&quot;</span><br><span class="line">            android:onTextChanged=&quot;@&#123;(text, start, before, count)-&gt;model.onNameChanged(text)&#125;&quot;</span><br><span class="line">            ...</span><br><span class="line">            /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;EditText</span><br><span class="line">            android:id=&quot;@+id/et_pwd&quot;</span><br><span class="line">            android:text=&quot;@&#123;model.p.get()&#125;&quot;</span><br><span class="line">            android:onTextChanged=&quot;@&#123;model::onPwdChanged&#125;&quot;</span><br><span class="line">            ...</span><br><span class="line">            /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Button</span><br><span class="line">            android:id=&quot;@+id/btn_login&quot;</span><br><span class="line">            android:text=&quot;Sign in&quot;</span><br><span class="line">            android:onClick=&quot;@&#123;() -&gt; model.login()&#125;&quot;</span><br><span class="line">            android:enabled=&quot;@&#123;(model.p.get().isEmpty()||model.n.get().isEmpty()) ? false : true&#125;&quot;</span><br><span class="line">            .../&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用类方法"><a href="#使用类方法" class="headerlink" title="使用类方法"></a>使用类方法</h3><p>首先定义一个静态方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">object StringUtils &#123;</span><br><span class="line"></span><br><span class="line">   fun toUpperCase( str:String):String &#123;</span><br><span class="line">        return str.toUpperCase();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 data 标签中导入该工具类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import type=&quot;com.github.ixiaow.sample.StringUtils&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后就可以像对待一般的函数一样来调用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">   android:layout_width=&quot;match_parent&quot;</span><br><span class="line">   android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">   android:onClick=&quot;@&#123;()-&gt;userPresenter.onUserNameClick(userInfo)&#125;&quot;</span><br><span class="line">   android:text=&quot;@&#123;StringUtils.toUpperCase(userInfo.name)&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ul>
<li>运算符 + - / * %</li>
<li>字符串连接 +</li>
<li>逻辑与或 &amp;&amp; ||</li>
<li>二进制 &amp; | ^</li>
<li>一元 + - ! ~</li>
<li>移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt;</li>
<li>比较 == &gt; &lt; &gt;= &lt;= (Note that &lt; needs to be escaped as &lt;)</li>
<li>instanceof</li>
<li>Grouping ()</li>
<li>Literals - character, String, numeric, null</li>
<li>Cast</li>
<li>方法调用</li>
<li>域访问</li>
<li>数组访问</li>
<li>三元操作符</li>
</ul>
<p>除了上述之外，Data Binding新增了<strong>空合并操作符??</strong>，例如android:text=”@{user.displayName ?? user.lastName}”，它等价于android:text=”@{user.displayName != null ? user.displayName : user.lastName}”。</p>
<h3 id="BindingMethod"><a href="#BindingMethod" class="headerlink" title="BindingMethod"></a>BindingMethod</h3><p>如果XXXView类有成员变量borderColor，并且XXXView类有setBoderColor(int color)方法，那么在布局中我们就可以借助Data Binding直接使用app:borderColor这个属性。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    app:scrimColor=&quot;@&#123;@color/scrim&#125;&quot;</span><br><span class="line">    app:drawerListener=&quot;@&#123;fragment.drawerListener&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>还用XXXView为例，它有成员变量borderColor，这次设置borderColor的方法是setBColor(总有程序员乱写方法名~)，强行用app:borderColor显然是行不通的，可以这样用的前提是必须有setBoderColor(int color)方法，显然setBColor不匹配，但我们可以通过BindingMethods注解实现app:borderColor的使用，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@BindingMethods(value = [</span><br><span class="line">    BindingMethod(</span><br><span class="line">        type = 包名.XXXView::class,</span><br><span class="line">        attribute = &quot;app:borderColor&quot;,</span><br><span class="line">        method = &quot;setBColor&quot;)])</span><br></pre></td></tr></table></figure></p>
<h3 id="BindingAdapter"><a href="#BindingAdapter" class="headerlink" title="@BindingAdapter"></a>@BindingAdapter</h3><blockquote>
<ul>
<li>用于标记修饰方法,方法必须为公共静态方法</li>
<li>方法的第一个参数的类型必须为View类型，不然报错</li>
<li>用来自定义view的任意属性</li>
</ul>
</blockquote>
<p>dataBinding 提供了 BindingAdapter 这个注解用于支持自定义属性，或者是修改原有属性。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&#123;&quot;url&quot;&#125;)</span><br><span class="line">public static void loadImage(ImageView view, String url) &#123;</span><br><span class="line">	Log.d(TAG, &quot;loadImage url : &quot; + url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在 xml 文件中关联变量值，当中，bind 这个名称可以自定义</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;data&gt;</span><br><span class="line">        &lt;import type=&quot;com.github.ixiaow.databindingsample.model.Image&quot; /&gt;</span><br><span class="line">        &lt;variable</span><br><span class="line">            name=&quot;image&quot;</span><br><span class="line">            type=&quot;Image&quot; /&gt;</span><br><span class="line">    &lt;/data&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;android.support.constraint.ConstraintLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:id=&quot;@+id/image&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">            bind:url=&quot;@&#123;image.url&#125;&quot; /&gt;</span><br><span class="line">    &lt;/android.support.constraint.ConstraintLayout&gt;</span><br><span class="line">&lt;/layout&gt;</span><br></pre></td></tr></table></figure></p>
<p>BindingAdapter 更为强大的一点是可以覆盖 Android 原先的控件属性。例如，可以设定每一个 Button 的文本都要加上后缀：“-Button”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@BindingAdapter(&quot;android:text&quot;)</span><br><span class="line">public static void setText(Button view, String text) &#123;</span><br><span class="line">	view.setText(text + &quot;-Button&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;Button</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:onClick=&quot;@&#123;()-&gt;handler.onClick(image)&#125;&quot;</span><br><span class="line">    android:text=&apos;@&#123;&quot;改变图片Url&quot;&#125;&apos;/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="InverseBindingAdapter"><a href="#InverseBindingAdapter" class="headerlink" title="@InverseBindingAdapter"></a>@InverseBindingAdapter</h3><blockquote>
<ul>
<li>作用于方法，方法须为公共静态方法。</li>
<li>方法的第一个参数必须为View类型，如TextView等</li>
<li>用于双向绑定</li>
<li>需要与@BindingAdapter配合使用</li>
</ul>
</blockquote>
<p>死循环绑定的解决方式：只处理新旧数据不一样的数据，参考源码中的例子：android.databinding.adapters.TextViewBindingAdapter。</p>
<p>需要注意的是，使用该语法必须要有反向绑定的方法，android原生view都是自带的，所以<strong>使用原生控件无须担心</strong>，但是自定义view的话需要我们通过InverseBindingAdapter注解类实现</p>
<h3 id="BindingConversion"><a href="#BindingConversion" class="headerlink" title="@BindingConversion"></a>@BindingConversion</h3><p>dataBinding 还支持<strong>对数据进行转换</strong>，或者进行<strong>类型转换</strong>。作用于方法，被该注解标记的方法，被视为dataBinding的转换方法。方法必须为公共静态（public static）方法，且有且只能有1个参数。</p>
<p>与 BindingAdapter 类似，以下方法会将布局文件中所有以@{String}方式引用到的String类型变量加上后缀-conversionString<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@BindingConversion</span><br><span class="line">public static String conversionString(String text) &#123;</span><br><span class="line">	return text + &quot;-conversionString&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 BindingConversion 的优先级要高些, 此外，BindingConversion 也可以用于转换属性值的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@BindingConversion</span><br><span class="line">public static Drawable convertStringToDrawable(String str) &#123;</span><br><span class="line">    if (str.equals(&quot;红色&quot;)) &#123;</span><br><span class="line">        return new ColorDrawable(Color.parseColor(&quot;#FF4081&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (str.equals(&quot;蓝色&quot;)) &#123;</span><br><span class="line">        return new ColorDrawable(Color.parseColor(&quot;#3F51B5&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    return new ColorDrawable(Color.parseColor(&quot;#344567&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.自定义生成的绑定类的类名</p>
<p>每个数据绑定布局文件都会生成一个绑定类，ViewDataBinding 的实例名是<strong>根据布局文件名来生成，采用驼峰命名法来命名，并省略布局文件名包含的下划线。控件的获取方式类似，但首字母小写。</strong></p>
<p>通过如下方式自定义 ViewDataBinding 的实例名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;data class=&quot;CustomBinding&quot;&gt;&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.alias 别名</p>
<p>如果存在 import 的类名相同的情况，可以使用 alias 指定别名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;import type=&quot;com.github.ixiaow.sample.model1.User&quot; /&gt;</span><br><span class="line">    &lt;import</span><br><span class="line">       alias=&quot;TempUser&quot;</span><br><span class="line">       type=&quot;com.github.ixiaow.sample.model2.User&quot; /&gt;</span><br><span class="line">    &lt;variable</span><br><span class="line">       name=&quot;user&quot;</span><br><span class="line">       type=&quot;User&quot; /&gt;</span><br><span class="line">    &lt;variable</span><br><span class="line">       name=&quot;tempUserInfo&quot;</span><br><span class="line">       type=&quot;TempUser&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;import type=&quot;java.util.List&quot;/&gt;</span><br><span class="line">	//&lt;需要被替换成&amp;lt;</span><br><span class="line">	&lt;variable name=&quot;users&quot; type=&quot;List&amp;lt;User&gt;&quot;/&gt;</span><br><span class="line">&lt;/data&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.默认值(默认值将只在预览视图中显示，且默认值不能包含引号)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:text=&quot;@&#123;userInfo.name,default=defaultValue&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>4.DataBinding的坑<br>官网上的demo很简单，简单到UserInfo中的所有字段都是string，它并没有告诉我们当字段是int时会有什么问题。假设我们没有在layout中对age写String.valueOf方法的话， userAge就是一个int对象，它会在这里被直接setText<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// batch finished</span><br><span class="line">if ((dirtyFlags &amp; 0xdL) != 0) &#123;</span><br><span class="line">    // api target 1</span><br><span class="line">    android.databinding.adapters.TextViewBindingAdapter.setText(this.tvAge, userAge); //&lt;--设置UI的操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对setText传一个int值，会被当做Resource索引，然后导致崩溃。如果你是刚接触DataBinding的新手，估计会看到下面这种崩溃原因</p>
<blockquote>
<p>Resource #0x0</p>
</blockquote>
<p>原因就是缺少了String.valueOf调用了。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>DataBinding使用了apt技术，我们build项目时DataBinding会生成多个文件。</p>
<p>DataBinding通过布局中的tag将控件查找出来，然后根据生成的配置文件将V与M进行对应的同步操作，设置一个全局的布局变化监听来实时更新，M通过他的set方法进行同步。</p>
<p>数据绑定框架的目标就是免除开发者繁琐的操作UI，它帮我们做这些事情就好了。 所以它通过注解在编译期生成了ActivityMainBinding类，就是下面这里:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    ....</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);</span><br><span class="line">        mUser = new UserInfo();</span><br><span class="line">        binding.setUser(mUser);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>ActivityMainBinding可以理解为观察者，它的父类是ViewDataBinding, 它有个抽象方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @hide</span><br><span class="line"> */</span><br><span class="line">protected abstract void executeBindings();</span><br></pre></td></tr></table></figure></p>
<p>所有的layout都会生成一个Binding类，这个类继承ViewDataBinding，然后实现了execute*方法。 理解DataBinding框架的关键代码就在这里，其他可以选择性忽略，我们看代码的时候是这样的，先抽脉络，细枝末节的处理可以在理解了框架之后再慢慢体会。 下面是这个抽象方法的具体实现逻辑，这些代码都是DataBinding帮我们生成的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void executeBindings() &#123;</span><br><span class="line">    long dirtyFlags = 0;</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        dirtyFlags = mDirtyFlags;</span><br><span class="line">        mDirtyFlags = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    java.lang.String userName = null;</span><br><span class="line">    java.lang.String stringValueOfUserAge = null;</span><br><span class="line">    int userAge = 0;</span><br><span class="line">    com.phoenix.databindingdemo.UserInfo user = mUser; //&lt;--我们传入的对象</span><br><span class="line"></span><br><span class="line">    if ((dirtyFlags &amp; 0xfL) != 0) &#123;</span><br><span class="line">        if ((dirtyFlags &amp; 0xbL) != 0) &#123;</span><br><span class="line">                if (user != null) &#123;</span><br><span class="line">                    // read user.name</span><br><span class="line">                    userName = user.getName();//&lt;--UserInfo类中注解标识的get方法</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((dirtyFlags &amp; 0xdL) != 0) &#123;</span><br><span class="line">                if (user != null) &#123;</span><br><span class="line">                    // read user.age</span><br><span class="line">                    userAge = user.getAge();//&lt;--UserInfo类中注解标识的get方法</span><br><span class="line">                &#125;</span><br><span class="line">                // read String.valueOf(user.age)</span><br><span class="line">                stringValueOfUserAge = java.lang.String.valueOf(userAge);//&lt;--layout中的String.valueOf</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // batch finished</span><br><span class="line">    if ((dirtyFlags &amp; 0xdL) != 0) &#123;</span><br><span class="line">        // api target 1</span><br><span class="line">        android.databinding.adapters.TextViewBindingAdapter.setText(this.tvAge, stringValueOfUserAge); //&lt;--设置UI的操作</span><br><span class="line">    &#125;</span><br><span class="line">    if ((dirtyFlags &amp; 0xbL) != 0) &#123;</span><br><span class="line">        // api target 1</span><br><span class="line">        android.databinding.adapters.TextViewBindingAdapter.setText(this.tvName, userName); //&lt;--设置UI的操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在activity中把 mUser对象传入了binding类，在每次对它进行set操作的时候都会触发notify， 之后DataBinding框架会回调execute方法， 框架通过注解拿到get方法，然后拿到和UI所对应的数据，之后结合layout中对应的标注去更新UI。 整个观察者模式的逻辑基本就是这样。</p>
<h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h2><p>service一直被用来做后台运行的操作，包括一些保活，上传数据之类的，这个后台运行的弊端很多，比如耗电，比如设计用户隐私之类的，谷歌对这些后台行为进行了一些处理，从Android Oreo(API 26) 开始，如果一个应用的目标版本为Android 8.0，当它在某些不被允许创建后台服务的场景下，调用了Service的startService()方法，该方法会抛出IllegalStateException。如果想继续使用service，必须调用Context.startForegroundService()。所以，在不久的将来，service的使用范围会越来越小，取而代之的，是谷歌推出的新的技术：WorkManager。</p>
<p>WorkManager 在工作的触发器 满足时, 运行可推迟的后台工作。WorkManager会根据设备API的情况，自动选用JobScheduler, 或是AlarmManager来实现后台任务，WorkManager里面的任务在应用退出之后还可以继续执行，这个技术适用于在应用退出之后任务还需要继续执行的需求。</p>
<p>WorkManager库的架构图如下所示：</p>
<p><img src="/2020/04/09/android-jetpack/workmanager.jpg" alt></p>
<p>WorkManager可以做很多事情: 取消任务, 组合任务, 构建任务链, 将一个任务的参数合并到另一个任务。大部分的后台任务处理，WorkManager都可以胜任:</p>
<p><img src="/2020/04/09/android-jetpack/work_manager.webp" alt></p>
<h2 id="相关应用架构"><a href="#相关应用架构" class="headerlink" title="相关应用架构"></a>相关应用架构</h2><p><img src="/2020/04/09/android-jetpack/jetpack-architecture.png" alt></p>
<blockquote>
<p>注意：任何应用编写方式都不可能是每种情况的最佳选择。话虽如此，但推荐的这个架构是个不错的起点，适合大多数情况和工作流。如果您已经有编写 Android 应用的好方法（遵循常见的架构原则），则无需更改。</p>
</blockquote>
<h3 id="常见的架构原则"><a href="#常见的架构原则" class="headerlink" title="常见的架构原则"></a>常见的架构原则</h3><p>如果您不应使用应用组件存储应用数据和状态，那么您应该如何设计应用呢？</p>
<p><strong>分离关注点</strong></p>
<p>要遵循的最重要的原则是分离关注点。一种常见的错误是在一个 Activity 或 Fragment 中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。您应尽可能使这些类保持精简，这样可以避免许多与生命周期相关的问题。</p>
<p>请注意，您并非拥有 Activity 和 Fragment 的实现；它们只是表示 Android 操作系统与应用之间关系的粘合类。操作系统可能会根据用户互动或因内存不足等系统条件随时销毁它们。为了提供令人满意的用户体验和更易于管理的应用维护体验，您最好尽量减少对它们的依赖。</p>
<p><strong>通过模型驱动界面</strong></p>
<p>另一个重要原则是您应该通过模型驱动界面（最好是持久性模型）。模型是负责处理应用数据的组件。它们独立于应用中的 View 对象和应用组件，因此不受应用的生命周期以及相关的关注点的影响。</p>
<p>持久性是理想之选，原因如下：</p>
<ul>
<li>如果 Android 操作系统销毁应用以释放资源，用户不会丢失数据。</li>
<li>当网络连接不稳定或不可用时，应用会继续工作。</li>
</ul>
<p>应用所基于的模型类<strong>应明确定义数据管理职责</strong>，这样将使应用更可测试且更一致。</p>
<h3 id="最佳做法"><a href="#最佳做法" class="headerlink" title="最佳做法"></a>最佳做法</h3><p>编程是一个创造性的领域，构建 Android 应用也不例外。无论是在多个 Activity 或 Fragment 之间传递数据，检索远程数据并将其保留在本地以在离线模式下使用，还是复杂应用遇到的任何其他常见情况，解决问题的方法都会有很多种。</p>
<p>虽然以下建议不是强制性的，但根据我们的经验，从长远来看，遵循这些建议会使您的代码库更强大、可测试性更高且更易维护：</p>
<p><strong>避免将应用的入口点（如 Activity、Service 和广播接收器）指定为数据源。</strong></p>
<p>相反，您应只将其与其他组件协调，以检索与该入口点相关的数据子集。每个应用组件存在的时间都很短暂，具体取决于用户与其设备的交互情况以及系统当前的整体运行状况。</p>
<p><strong>在应用的各个模块之间设定明确定义的职责界限。</strong></p>
<p>例如，请勿在代码库中将从网络加载数据的代码散布到多个类或软件包中。同样，也不要将不相关的职责（如数据缓存和数据绑定）定义到同一个类中。</p>
<p><strong>尽量少公开每个模块中的代码。</strong></p>
<p>请勿试图创建“就是那一个”快捷方式来呈现一个模块的内部实现细节。短期内，您可能会省点时间，但随着代码库的不断发展，您可能会反复陷入技术上的麻烦。</p>
<p><strong>考虑如何使每个模块可独立测试。</strong></p>
<p>例如，如果使用明确定义的 API 从网络获取数据，将会更容易测试在本地数据库中保留该数据的模块。如果您将这两个模块的逻辑混放在一处，或将网络代码分散在整个代码库中，那么即便能够进行测试，难度也会大很多。</p>
<p><strong>专注于应用的独特核心，以使其从其他应用中脱颖而出。</strong></p>
<p>不要一次又一次地编写相同的样板代码，这是在做无用功。相反，您应将时间和精力集中放在能让应用与众不同的方面上，并让 Android 架构组件以及建议的其他库处理重复的样板。</p>
<p><strong>保留尽可能多的相关数据和最新数据。</strong></p>
<p>这样，即使用户的设备处于离线模式，他们也可以使用您应用的功能。请注意，并非所有用户都能享受到稳定的高速连接。</p>
<p><strong>将一个数据源指定为单一可信来源。</strong></p>
<p>每当应用需要访问这部分数据时，这部分数据都应一律源于此单一可信来源。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.android.google.cn/jetpack?hl=zh_cn" target="_blank" rel="noopener">https://developer.android.google.cn/jetpack?hl=zh_cn</a><br><a href="https://www.jianshu.com/p/66b93df4b7a6" target="_blank" rel="noopener">即学即用Android Jetpack</a><br><a href="https://www.jianshu.com/p/35d143e84d42" target="_blank" rel="noopener">深入了解架构组件之ViewModel</a><br><a href="https://developer.android.google.cn/jetpack/docs/guide?hl=zh_cn#recommended-app-arch" target="_blank" rel="noopener">应用架构指南</a><br><a href="https://juejin.im/post/5b04d064f265da0b80711759" target="_blank" rel="noopener">从Service到WorkManager</a><br><a href="https://github.com/googlecodelabs/android-navigation" target="_blank" rel="noopener">android-navigation demo</a><br><a href="https://blog.csdn.net/xiaowu_zhu/article/details/91826467" target="_blank" rel="noopener">Android DataBinding 使用</a><br><a href="https://www.jianshu.com/p/9bd2f3069d2e" target="_blank" rel="noopener">DataBinding常用注解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/07/android-plugin-virtualApp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/07/android-plugin-virtualApp/" itemprop="url">VirtualApp沙盒基本原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-07T13:41:44+08:00">
                2020-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android插件化/" itemprop="url" rel="index">
                    <span itemprop="name">Android插件化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>VirtualApp是一款运行于Android系统的沙盒产品，可以理解为轻量级的“Android虚拟机”。是一个开源的Android App虚拟化引擎，允许在其中创建虚拟空间，并在这个虚拟空间中运行其他应用。</p>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>Android应用隔离是基于Linux系统的多用户机制实现的，即每个应用在安装时被分配了不同的Linux用户uid/gid。而在VirtualApp中，client应用（通过VirtualApp安装的应用）与host应用（即VirtualApp本身）是<strong>具有相同用户uid</strong>的。</p>
<p>因此，VirtualApp在运行时，包含以下三部分：</p>
<ul>
<li>Main Process，进程名io.virtualapp，主要负责VirtualApp用户界面及应用管理</li>
<li>Server Process，进程名io.virtualapp:x，主要负责系统服务的代理，是通过Content Provider启动的</li>
<li>VApp Process，进程名io.virtualapp:p[0-…]，作为将来运行client应用的进程，当client应用启动后，其进程名会更新为client应用的包名</li>
</ul>
<p>下面是在VirtualApp中运行应用后通过ps命令得到的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">generic_x86:/ $ ps |grep u0_a60</span><br><span class="line">u0_a60    2385  1258  996260 54456 SyS_epoll_ 00000000 S io.virtualapp</span><br><span class="line">u0_a60    2412  1258  980940 48272 SyS_epoll_ 00000000 S io.virtualapp:x</span><br><span class="line">u0_a60    3705  1258  993632 54472 SyS_epoll_ 00000000 S org.galaxy.simpleapp</span><br></pre></td></tr></table></figure></p>
<p>可以看到，以上进程，均是以VirtualApp的用户uid运行的。因此，Android应用隔离此时不再适用，我们可以对client应用进行hook而无需root权限。</p>
<h2 id="注入逻辑"><a href="#注入逻辑" class="headerlink" title="注入逻辑"></a>注入逻辑</h2><p>要想实现对一个APP的虚拟化，就是不直接把APP安装进系统，同时又要提供APP运行过程中所需的一切，从而可以让它误以为自己是运行在正常系统中。这里就需要实现系统服务的虚拟化和相关路径的虚拟化。</p>
<p>其中，<strong>系统服务的虚拟化主要靠注入大量framework组件来实现</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">@VirtualApp/lib/src/main/java/com/lody/virtual/client/core/InvocationStubManager.java</span><br><span class="line">private void injectInternal() throws Throwable &#123;</span><br><span class="line">  if (VirtualCore.get().isMainProcess()) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (VirtualCore.get().isServerProcess()) &#123;</span><br><span class="line">    addInjector(new ActivityManagerStub());</span><br><span class="line">    addInjector(new PackageManagerStub());</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (VirtualCore.get().isVAppProcess()) &#123;</span><br><span class="line">    addInjector(new LibCoreStub());</span><br><span class="line">    addInjector(new ActivityManagerStub());</span><br><span class="line">    addInjector(new PackageManagerStub());</span><br><span class="line">    addInjector(HCallbackStub.getDefault());</span><br><span class="line">    addInjector(new ISmsStub());</span><br><span class="line">    addInjector(new ISubStub());</span><br><span class="line">    addInjector(new DropBoxManagerStub());</span><br><span class="line">    addInjector(new NotificationManagerStub());</span><br><span class="line">    addInjector(new LocationManagerStub());</span><br><span class="line">    addInjector(new WindowManagerStub());</span><br><span class="line">    addInjector(new ClipBoardStub());</span><br><span class="line">    addInjector(new MountServiceStub());</span><br><span class="line">    addInjector(new BackupManagerStub());</span><br><span class="line">    addInjector(new TelephonyStub());</span><br><span class="line">    addInjector(new TelephonyRegistryStub());</span><br><span class="line">    addInjector(new PhoneSubInfoStub());</span><br><span class="line">    addInjector(new PowerManagerStub());</span><br><span class="line">    addInjector(new AppWidgetManagerStub());</span><br><span class="line">    addInjector(new AccountManagerStub());</span><br><span class="line">    addInjector(new AudioManagerStub());</span><br><span class="line">    addInjector(new SearchManagerStub());</span><br><span class="line">    addInjector(new ContentServiceStub());</span><br><span class="line">    addInjector(new ConnectivityStub());</span><br><span class="line"> </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR2) &#123;</span><br><span class="line">      addInjector(new VibratorStub());</span><br><span class="line">      addInjector(new WifiManagerStub());</span><br><span class="line">      addInjector(new BluetoothStub());</span><br><span class="line">      addInjector(new ContextHubServiceStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR1) &#123;</span><br><span class="line">      addInjector(new UserManagerStub());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= JELLY_BEAN_MR1) &#123;</span><br><span class="line">      addInjector(new DisplayStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= LOLLIPOP) &#123;</span><br><span class="line">      addInjector(new PersistentDataBlockServiceStub());</span><br><span class="line">      addInjector(new InputMethodManagerStub());</span><br><span class="line">      addInjector(new MmsStub());</span><br><span class="line">      addInjector(new SessionManagerStub());</span><br><span class="line">      addInjector(new JobServiceStub());</span><br><span class="line">      addInjector(new RestrictionStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= KITKAT) &#123;</span><br><span class="line">      addInjector(new AlarmManagerStub());</span><br><span class="line">      addInjector(new AppOpsManagerStub());</span><br><span class="line">      addInjector(new MediaRouterServiceStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= LOLLIPOP_MR1) &#123;</span><br><span class="line">      addInjector(new GraphicsStatsStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= M) &#123;</span><br><span class="line">      addInjector(new NetworkManagementStub());</span><br><span class="line">    &#125;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= N) &#123;</span><br><span class="line">              addInjector(new WifiScannerStub());</span><br><span class="line">              addInjector(new ShortcutServiceStub());</span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个注入过程是发生在io.virtualapp.VApp.attachBaseContext中，因此，每次启动一个子进程都会执行到这里，这会区分是isMainProcess（io.virtualapp）或者isServerProcess（io.virtualapp:x）或者isVAppProcess（被安装APP）来进行不同的注入，可以看到，注入最多的还是在被安装APP的进程中。</p>
<h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>从启动VirtualApp到运行其中的应用，大致流程如下：</p>
<h3 id="启动host应用"><a href="#启动host应用" class="headerlink" title="启动host应用"></a>启动host应用</h3><p>我们启动VirtualApp，其Application为io.virtualapp.VApp。<strong>在attachBaseContext()</strong>方法中会调用到com.lody.virtual.client.core.PatchManager#injectInternal，但此时为<strong>Main Process</strong>，不进行系统服务的替换。</p>
<h3 id="启动Server-Process"><a href="#启动Server-Process" class="headerlink" title="启动Server Process"></a>启动Server Process</h3><p>host应用会进行一些初始化，其中就包括获取全部已安装应用，这会调用到com.lody.virtual.client.core.VirtualCore#getAllApps。而这一方法最终会访问com.lody.virtual.server.BinderProvider。由AndroidManifest.xml可知，该provider会运行在新进程io.virtualapp:x中，即<strong>Server Process</strong>。</p>
<p>由于在新进程中启动组件，同样会首先创建该应用的Application，因此也会调用到com.lody.virtual.client.core.PatchManager#injectInternal。此时，<strong>会进行相应系统服务(ActivityManager和PackageManager)的代理构造和替换。</strong></p>
<h3 id="启动VApp-Process"><a href="#启动VApp-Process" class="headerlink" title="启动VApp Process"></a>启动VApp Process</h3><p>点击一个已安装应用，此时会通过替换掉的系统服务访问真实的系统服务（主要是ActivityManager），并在新进程中启动组件com.lody.virtual.client.stub.StubActivity.C0。由AndroidManifest.xml可知，该进程具有后缀:p0。</p>
<p>同样的，在该Activity组件启动之前会初始化io.virtualapp.VApp，并在com.lody.virtual.client.core.PatchManager#injectInternal中<strong>完成系统服务的代理构造和替换。</strong></p>
<h3 id="启动client应用"><a href="#启动client应用" class="headerlink" title="启动client应用"></a>启动client应用</h3><p>此时，真正的client应用尚未启动，进程io.virtualapp:p0仅仅是作为一个placeholder。StubActivity会从Intent中获取到client应用的相关信息，并修改自身ActivityThread的handler。随后调用startActivity启动client应用。</p>
<p>由于之前Server Process和VApp Process都已完成了相关系统服务的替换，这里会完成client应用的bindApplication调用、构造client应用的LoadedApk，并通过反射完成真正的Application和Activity的创建。</p>
<p>最终，client应用便运行在了我们的VApp Process中。</p>
<h2 id="系统服务的代理和替换"><a href="#系统服务的代理和替换" class="headerlink" title="系统服务的代理和替换"></a>系统服务的代理和替换</h2><p>VirtualApp之所以能够实现虚拟空间，是因为其对许多系统服务进行了代理和替换。因此，这部分便是整个框架的核心。系统服务运行在system_server中，Android应用调用系统服务，是通过Binder机制进行IPC。因此，<strong>应用所持有的是系统服务的BinderProxy，通过对这些BinderProxer构造代理并替换，便实现了对系统服务的代理和替换。</strong></p>
<p>具体地，我们以com.lody.virtual.client.hook.patchs.am.ActivityManagerPatch为例，这个类实现了对ActivityManager服务的代理和替换。</p>
<h3 id="代理的构造"><a href="#代理的构造" class="headerlink" title="代理的构造"></a>代理的构造</h3><p>可以看到，这个类的注记中包含了大量类名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Patch(&#123;StartActivity.class, StartActivityAsCaller.class,</span><br><span class="line">        StartActivityAndWait.class, StartActivityWithConfig.class, StartActivityIntentSender.class,</span><br><span class="line">        StartNextMatchingActivity.class, StartVoiceActivity.class,</span><br><span class="line">        GetIntentSender.class, RegisterReceiver.class, GetContentProvider.class,</span><br><span class="line">        GetContentProviderExternal.class,</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p>
<p>而这些列出的每一个类，对应于一个方法的hook，例如，com.lody.virtual.client.hook.patchs.am.StartActivity是ActivityManager服务的startActivity方法的hook。这些类均继承自com.lody.virtual.client.hook.base.Hook，包含了方法beforeCall(), call(), afterCall()，这些方法便是hook的具体内容。</p>
<p>ActivityManagerPatch在创建时，会调用到其父类的方法com.lody.virtual.client.hook.base.PatchDelegate#onBindHooks。这里会检查上述注记中列出的hook，并对符合条件的hook调用addHook()方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Class&lt;? extends PatchDelegate&gt; clazz = getClass();</span><br><span class="line">Patch patch = clazz.getAnnotation(Patch.class);</span><br><span class="line">int version = Build.VERSION.SDK_INT;</span><br><span class="line">if (patch != null) &#123;</span><br><span class="line">    Class&lt;?&gt;[] hookTypes = patch.value();</span><br><span class="line">    for (Class&lt;?&gt; hookType : hookTypes) &#123;</span><br><span class="line">        ApiLimit apiLimit = hookType.getAnnotation(ApiLimit.class);</span><br><span class="line">        boolean needToAddHook = true;</span><br><span class="line">        if (apiLimit != null) &#123;</span><br><span class="line">            int apiStart = apiLimit.start();</span><br><span class="line">            int apiEnd = apiLimit.end();</span><br><span class="line">            boolean highThanStart = apiStart == -1 || version &gt; apiStart;</span><br><span class="line">            boolean lowThanEnd = apiEnd == -1 || version &lt; apiEnd;</span><br><span class="line">            if (!highThanStart || !lowThanEnd) &#123;</span><br><span class="line">                needToAddHook = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (needToAddHook) &#123;</span><br><span class="line">            addHook(hookType);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>而addHook()最终会调用到com.lody.virtual.client.hook.base.HookDelegate#addHook，其实质便是将这个hook添加至映射表internalHookTable中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Hook addHook(Hook hook) &#123;</span><br><span class="line">    if (hook != null &amp;&amp; !TextUtils.isEmpty(hook.getName())) &#123;</span><br><span class="line">        if (internalHookTable.containsKey(hook.getName())) &#123;</span><br><span class="line">            VLog.w(TAG, &quot;The Hook(%s, %s) you added has been in existence.&quot;, hook.getName(),</span><br><span class="line">                    hook.getClass().getName());</span><br><span class="line">            return hook;</span><br><span class="line">        &#125;</span><br><span class="line">        internalHookTable.put(hook.getName(), hook);</span><br><span class="line">    &#125;</span><br><span class="line">    return hook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>internalHookTable维护了所有的hook，以hook的名称（一般就是所hook的方法的名称）作为key。随后，在com.lody.virtual.client.hook.base.HookDelegate.HookHandler的invoke()方法中，查找表 internalHookTable中是否包含将要执行的方法名；如果有，则依次执行对应hook的beforeCall(), call(), afterCall()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private class HookHandler implements InvocationHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        Hook hook = getHook(method.getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            if (hook != null &amp;&amp; hook.isEnable()) &#123;</span><br><span class="line">                if (hook.beforeCall(mBaseInterface, method, args)) &#123;</span><br><span class="line">                    Object res = hook.call(mBaseInterface, method, args);</span><br><span class="line">                    res = hook.afterCall(mBaseInterface, method, args, res);</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return method.invoke(mBaseInterface, args);</span><br></pre></td></tr></table></figure></p>
<p>而这里的类HookHandler，就是构造的Java代理的Handler：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public HookDelegate(T baseInterface, Class&lt;?&gt;... proxyInterfaces) &#123;</span><br><span class="line">    this.mBaseInterface = baseInterface;</span><br><span class="line">    if (baseInterface != null) &#123;</span><br><span class="line">        if (proxyInterfaces == null) &#123;</span><br><span class="line">            proxyInterfaces = HookUtils.getAllInterface(baseInterface.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        mProxyInterface = (T) Proxy.newProxyInstance(baseInterface.getClass().getClassLoader(), proxyInterfaces, new HookHandler());</span><br></pre></td></tr></table></figure></p>
<p>对于ActivityManagerPatch来说，这里的baseInterface便是原始的BinderProxy: ActivityManagerProxy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ActivityManagerPatch() &#123;</span><br><span class="line">    super(new HookDelegate&lt;IInterface&gt;(ActivityManagerNative.getDefault.call()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>综上，我们根据baseInterface，为其构造了代理mProxyInterface。从而访问mProxyInterface时，便会执行HookHandler的invoke()方法，进而查找internalHookTable，对设置了hook的方法执行hook。</p>
<h3 id="系统服务的替换"><a href="#系统服务的替换" class="headerlink" title="系统服务的替换"></a>系统服务的替换</h3><p>如之前所说，对系统服务的替换，是通过对应用所持有的系统服务的BinderProxy进行替换的。以上是构造代理的基本过程，那么如何将应用所持有的BinderProxy替换成我们构造的代理呢？回到ActivityManagerPatch，这个类的inject()方法完成了实际的替换工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void inject() throws Throwable &#123;</span><br><span class="line">    if (ActivityManagerNative.gDefault.type() == IActivityManager.TYPE) &#123;</span><br><span class="line">        ActivityManagerNative.gDefault.set(getHookDelegate().getProxyInterface());</span><br><span class="line"></span><br><span class="line">    &#125; else if (ActivityManagerNative.gDefault.type() == Singleton.TYPE) &#123;</span><br><span class="line">        Object gDefault = ActivityManagerNative.gDefault.get();</span><br><span class="line">        Singleton.mInstance.set(gDefault, getHookDelegate().getProxyInterface());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>ActivityManagerNative.gDefault便是应用所持有的原始ActivityManagerProxy对象，通过Java反射，将替换成为getHookDelegate().getProxyInterface()。而替换的内容，便是我们所构造的代理mProxyInterface。</p>
<p>由此，我们完成了对系统服务进行代理和替换的整个过程。随后，在调用系统服务时，便会执行以下操作：</p>
<ul>
<li>访问BinderProxy的代理，即我们设置了hook的代理</li>
<li>根据hook的具体内容操作，对数据进行处理；需要调用原始系统服务时，访问原始的BinderProxy</li>
<li>真正的系统服务接收到Binder，进行处理并返回</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上介绍可以看到，VirtualApp在原有系统服务之上构造了代理，进而为其中的应用搭建了一套虚拟环境，应用可以无感知地运行在这其中。更进一步，我们可以设置这套虚拟环境，使其实现应用多开、非侵入式应用hook等高级功能。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">https://github.com/asLody/VirtualApp</a><br><a href="http://rk700.github.io/2017/03/15/virtualapp-basic/" target="_blank" rel="noopener">http://rk700.github.io/2017/03/15/virtualapp-basic/</a><br><a href="https://blog.csdn.net/weixin_40581980/article/details/81169266" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40581980/article/details/81169266</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/03/android-plugin-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/03/android-plugin-knowledge/" itemprop="url">Android插件化方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-03T15:20:16+08:00">
                2020-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android插件化/" itemprop="url" rel="index">
                    <span itemprop="name">Android插件化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>插件化技术涉及得非常广泛，其中最核心的就是Android的类加载机制和反射机制。下图载自腾讯bugly：</p>
<p><img src="/2020/04/03/android-plugin-knowledge/plugin_history.jpg" alt title="图1：插件化概要"></p>
<h2 id="插件化发展历史"><a href="#插件化发展历史" class="headerlink" title="插件化发展历史"></a>插件化发展历史</h2><p>插件化技术最初源于免安装运行apk的想法，这个免安装的apk可以理解为插件。支持插件化的app可以在运行时加载和运行插件，这样便可以将app中一些不常用的功能模块做成插件，一方面减小了安装包的大小，另一方面可以实现app功能的动态扩展。想要实现插件化，主要是解决下面三个问题：</p>
<ul>
<li>插件中代码的加载和与主工程的互相调用</li>
<li>插件中资源的加载和与主工程的互相访问</li>
<li>四大组件生命周期的管理</li>
</ul>
<p>下面是比较出名的几个开源的插件化框架，按照出现的时间排序。研究它们的实现原理，可以大致看出插件化技术的发展，根据实现原理可以将这几个框架划分成了三代。</p>
<p><img src="/2020/04/03/android-plugin-knowledge/plugin_generate.jpg" alt></p>
<p><strong>第一代</strong>：dynamic-load-apk最早使用ProxyActivity这种静态代理技术，由ProxyActivity去控制插件中PluginActivity的生命周期。该种方式缺点明显，插件中的activity必须继承PluginActivity，开发时要小心处理context。而DroidPlugin通过Hook系统服务的方式启动插件中的Activity，使得开发插件的过程和开发普通的app没有什么区别，但是由于hook过多系统服务，异常复杂且不够稳定。<br><strong>第二代</strong>：为了同时达到<strong>插件开发的低侵入性（像开发普通app一样开发插件）和框架的稳定性</strong>，在实现原理上都是趋近于选择尽量少的hook，并通过在manifest中预埋一些组件实现对四大组件的插件化。另外各个框架根据其设计思想都做了不同程度的扩展，其中Small更是做成了一个跨平台，组件化的开发框架。<br><strong>第三代</strong>：VirtualApp比较厉害，能够完全模拟app的运行环境，能够实现app的免安装运行和双开技术。Atlas是阿里开源出来的一个结合组件化和热修复技术的一个app基础框架，其广泛的应用与阿里系的各个app，其号称是一个容器化框架。</p>
<h2 id="Atlas-VirtualApk-RePlugin对比"><a href="#Atlas-VirtualApk-RePlugin对比" class="headerlink" title="Atlas/VirtualApk/RePlugin对比"></a>Atlas/VirtualApk/RePlugin对比</h2><p>Atlas是伴随着手机淘宝的不断发展而衍生出来的一个运行于Android系统上的一个容器化框架，我们也叫<strong>动态组件化(Dynamic Bundle)框架</strong>。它主要提供了解耦化、组件化、动态性的支持。覆盖了工程师的工程编码期、Apk运行期以及后续运维期的各种问题。</p>
<p>VirtualAPK是滴滴出行自研的一款优秀的插件化框架，功能完备。支持几乎所有的Android特性；四大组件均不需要在宿主manifest中预注册，每个组件都有完整的生命周期，入侵性极低。</p>
<p>RePlugin是一套完整的、稳定的、适合全面使用的，占坑类插件化方案，由360手机卫士的RePlugin Team研发，也是业内首个提出”全面插件化“（全面特性、全面兼容、全面使用）的方案。</p>
<p>Atlas：<a href="https://github.com/alibaba/atlas/tree/master/atlas-docs" target="_blank" rel="noopener">https://github.com/alibaba/atlas/tree/master/atlas-docs</a><br>VirtualAPK：<a href="https://github.com/didi/VirtualAPK/wiki" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK/wiki</a><br>RePlugin：<a href="https://github.com/Qihoo360/RePlugin/wiki" target="_blank" rel="noopener">https://github.com/Qihoo360/RePlugin/wiki</a></p>
<h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p>从定义上说，<strong>Atlas定义为组件化，而VirtualAPK和RePlugin则定义为插件化</strong>。这两种还是有一点点不同的，<strong>组件化偏重于编译期，插件化偏重于运行期</strong>。换句话来说，Atlas在编译的时候是需要把bundle放在一起处理的，而后面两个则可以完全独立开，和开发新的一个apk一样，最后打包的时候配置一下就行。</p>
<h3 id="二、接入难度"><a href="#二、接入难度" class="headerlink" title="二、接入难度"></a>二、接入难度</h3><p>初次接入Atlas，那真的会有点懵逼，官方文档已经万年没更新的，GitHub上面的demo和文档上的好多都不一样，就算接入了，也会出现一堆问题，简直想死。VirtualAPK，滴滴这个，接入还算简单的了，文档也比较完善。RePlugin，360这个也挺简单的，宿主和插件分得很清楚。所以接入难度：<strong>RePlugin最快，VirtualAPK其次，Atlas最麻烦。</strong></p>
<h3 id="三、功能"><a href="#三、功能" class="headerlink" title="三、功能"></a>三、功能</h3><p>三者<strong>都有的功能是远程bundle，按需加载</strong>。意思是项目中某个模块，打包的时候不打进apk，等你安装了，需要用到的时候再下载那个模块进行加载显示，从而减少apk的安装体积。<strong>Atlas会把插件打成so的形式，而VirtualAPK和RePlugin会打成apk的形式，都是放在内存卡，然后调用各自的安装加载方法就行</strong>。Atlas安装后，可以把so删掉，但VirtualAPK的apk需要一直在内存卡，否则是打不开的，而RePlugin安装后会自动备份一个apk到缓存目录。除了远程bundle功能，Atlas还有热修复的功能，可以不升级apk就实现宿主和组件的更新。</p>
<h3 id="四、更新插件方式"><a href="#四、更新插件方式" class="headerlink" title="四、更新插件方式"></a>四、更新插件方式</h3><p>Atlas更新插件的话，必须要和宿主一起，打差异补丁才能更新，而VirtualAPK和RePlugin是可以直接通过下载一个新的插件apk，然后调安装方法就能实现插件的更新。</p>
<h3 id="五、插件独立性"><a href="#五、插件独立性" class="headerlink" title="五、插件独立性"></a>五、插件独立性</h3><p>Atlas和宿主的依赖还是挺多，毕竟官方也强调是组件化，不是插件化。<strong>而VirtualAPK，它可以是一个独立的app，但插件里面也定义和宿主的关联，就是说这个插件apk并不能给其他宿主用，只能给插件里面声明的那个宿主使用。RePlugin呢，就比较独立了，里面不用声明和宿主的联系，所以你生成一个插件后，这个插件可以给其他宿主调用。</strong></p>
<h3 id="六、宿主和插件的公共库"><a href="#六、宿主和插件的公共库" class="headerlink" title="六、宿主和插件的公共库"></a>六、宿主和插件的公共库</h3><p>如果宿主和插件都用到一些公共依赖库，比如http库，图片加载库，这个时候怎么处理？Atlas处理就简单了，毕竟是组件化，和宿主的项目都是在一起。可以在项目里面定义一个middleLibrary，这个库里面依赖一些公共的库或者资源，然后宿主和插件都依赖他就行了<strong>。VirtualAPK呢，由于插件里面要声明和宿主的关联，所以他会自动检测，如果插件中依赖的库，在宿主里面也有的话，他会自动去掉一个，不会重复。RePlugin是比较独立的，没有和宿主太多联系，所以目前大家的做法是宿主compile，插件 provided的形式，而共用资源的话，RePlugin是不提倡的了。</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你的app需要热更新和插件的功能，推荐使用Atlas；如果你的app仅用到插件，在需要的时候才下载加载的话，你可以选择VirtualAPK和RePlugin；如果你的插件希望其他宿主也能用的话，那就只能RePlugin了，RePlugin就像一个应用市场，你的宿主仅仅是一个壳，然后把需要的插件下载加载使用就行，更新的话也无需更新宿主，直接更新插件就行。</p>
<h2 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h2><p>Atlas是伴随着手机淘宝的不断发展而衍生出来的一个运行于Android系统上的一个容器化框架，我们也叫动态组件化(Dynamic Bundle)框架。它主要提供了解耦化、组件化、动态性的支持。覆盖了工程师的工程编码期、Apk运行期以及后续运维期的各种问题。</p>
<h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><p><img src="/2020/04/03/android-plugin-knowledge/atlas-package.webp" alt title="包结构"></p>
<p>其整体包结构和正常Apk包结构类似。区别在于armeabi中存放大量的so，每个so都是APK转过来的，作为一个单独的bundle。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/2020/04/03/android-plugin-knowledge/atlas-layer.webp" alt></p>
<p>这一块是Atlas的整体设计，分为五层：</p>
<ul>
<li>第一层我们称之为Hack层，包括OS  Hack  toolkit &amp; verifier，这里我们对系统能力做一些扩展，然后做一些安全校验。</li>
<li>第二层是Bundle  Franework，就是我们的容器基础框架，提供Bundle管理、加载、生命周期、安全等一些最基本的能力。</li>
<li>第三层是运行期管理层，包括清单，我们会把所有的Bundle和它们的能力列在一个清单上，在调用时方便查找；另外是版本管理，会对所有Bundle的版本进行管理；再就是代理，这里就是和业界一些插件化框架机制类似的地方，我们会代理系统的运行环境，让Bundle运行在我们的容器框架上；然后还有调试和监控工具，是为了方便工程期开发调试。</li>
<li>第四层是业务层了，这里我们向业务方暴露了一些接口，如框架生命周期、配置文件、工具库等等。</li>
<li>最上面一层是应用接入层，就是我们的业务代码了。</li>
</ul>
<h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>1、Manifest与依赖<br>Bundle的Manifest在编译期会进行Merge，Bundle的依赖会单独Merge，因为涉及依赖仲裁最终输出BundleInfoList</p>
<p>2、多ClassLoader<br>为什么要用多ClassLoader，我的猜想是，类卸载。<br>JVM提供的类加载器始终不会释放，因此根据可达性，其加载出来的类，也始终不会释放，但是用户自定义的就可以。<br>这保证了一个组件在使用完以后，不存在任何实例化对象，任何类对象，保证了性能与稳定。</p>
<p><img src="/2020/04/03/android-plugin-knowledge/atlas-path.webp" alt></p>
<p>DelegateClassLoader先查找宿主Bundle的PathClassLoader，然后根据BundleInfoList，查找对应Bundle的BundleClassLoader</p>
<p>3、资源</p>
<p><img src="/2020/04/03/android-plugin-knowledge/atlas-res.webp" alt></p>
<p>用DelegeteResources替换系统的Resource，Bundle的资源在运行期会添加到AssertsPath中<br>并且进行分区，防止资源错乱<br>并且根据ART、Dalvik适配以及机型适配<br>为了防止资源名冲突，在资源名前后添加bundle独有id</p>
<p>4、按需加载</p>
<p>在想用一个组件的时候，到BundleInfoList中查找对应的Bundle，进行加载<br>每个组件都有生命周期管理，这样保证组件在不用的时候资源可以释放</p>
<p>5、动态化</p>
<p>主Bundle基于ClassLoader实现，业务Bundle基于差量Merge<br>可以结合Andfix，它基于Native Hook实现，用于方法的动态修改</p>
<p><img src="/2020/04/03/android-plugin-knowledge/atlas-apk.webp" alt></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>为什么atlas这么好，支付宝却开始弃用了呢？诱因是android p的发布，大家可以看看这篇了解下 <a href="https://blog.csdn.net/tyro_smallnew/article/details/80468034" target="_blank" rel="noopener">https://blog.csdn.net/tyro_smallnew/article/details/80468034</a> （Android P阻止调用非sdk api后，Atlas该何去何从）。</p>
<p>android p开始android开始禁止开发者使用非官方api，也就是禁止反射使用android不想让开发者使用的类和属性，但是atlas的工作原理就是反射这些不让用的api。</p>
<p>然而android p并不是主要原因，主要原因是 Atlas并不是刚需而且有些限制：<br>1、基于动态化加载的方案有许多，前端技术已经开始应用到app开发中，weex rn性能也已经达到开发者预期，前端方案明显是比atlas更有优势，而在支付宝中你会发现大部分都是前端页面<br>2、插件更新其实并不常用，一般大厂的应用都通过严谨的测试，出问题的概率比较小，大部分逻辑都是服务端来实现，可控性很强，所以插件更新在一些公司没有用武之地<br>3、Atlas依赖管理比较复杂，插件之间存在依赖也可能是多级依赖，如果要跨插件依赖需要整理好依赖树，但需求常改，之前的依赖树可能不符合需求需要重整，这个时候非常耗时耗力，而原生开发的依赖管理就方便得多<br>4、兼容问题，Atlas经历了好几代android的兼容：5.0时代的art虚拟机兼容、7.0浏览器资源加载兼容、各个版本的api兼容。。。你会在atlas核心代码中发现很多if else来判断android版本，不过atlas做的不错兼容的也很好，但每次android出版本都要兼容一次确实费时费力</p>
<h3 id="Atlas-support-android-Q"><a href="#Atlas-support-android-Q" class="headerlink" title="Atlas support android Q"></a><a href="https://github.com/alibaba/atlas/releases" target="_blank" rel="noopener">Atlas support android Q</a></h3><p>Atlas 5.1.0.9-rc26 已发布，此次更新较为重大，官方提醒升级请慎重。</p>
<p>主要更新内容如下：</p>
<ul>
<li>支持 Android Q，弃用 atlasupdate 项目</li>
<li>bundle 需要在运行时打包在 maindex 中</li>
<li>未来将不再支持动态部署</li>
<li>dexpatch 仅在 Android P 以下的版本受支持，并且 Atlas 不会在 Android P 及更高版本上加载补丁（新补丁将在稍后提供）</li>
<li>弃用 DelegateClassloader、DelegateResources、BundleClassloader、InstrumentationHook 等</li>
<li>如果想要在使用这个 bundle 之前初始化一个 bundle，可以使用：BundleIniter.initBundle（String bundleName，null）</li>
<li>不支持 bundle 依赖项，因为所有 bundle 都在运行时使用 PathClassloader</li>
<li>之后将不支持远程视图和远程片段，因为所有 bundle 都在运行时使用 PathClassloader</li>
<li>AtlasDemo 已更新</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/ceded2da7847" target="_blank" rel="noopener">https://www.jianshu.com/p/ceded2da7847</a><br><a href="https://mp.weixin.qq.com/s/Uwr6Rimc7Gpnq4wMFZSAag?utm_source=androidweekly&amp;utm_medium=website" target="_blank" rel="noopener">《Android插件化技术——原理篇》</a></p>
<p>atlas:<br>1.<a href="https://github.com/alibaba/atlas" target="_blank" rel="noopener">https://github.com/alibaba/atlas</a><br>2.<a href="https://blog.csdn.net/qq_36523667/article/details/99178542" target="_blank" rel="noopener">https://blog.csdn.net/qq_36523667/article/details/99178542</a><br>3.<a href="https://mp.weixin.qq.com/s/G0dsrVYytT8WdJ6U90NPiA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/G0dsrVYytT8WdJ6U90NPiA</a><br>4.<a href="https://www.jianshu.com/p/d3d881a59561" target="_blank" rel="noopener">https://www.jianshu.com/p/d3d881a59561</a><br>5.<a href="https://edu.aliyun.com/course/68/lesson/list?spm=5176.8764728.aliyun-edu-course-tab.2.73736355X6f7Nr&amp;previewAs=guest&amp;accounttraceid=0fc924ae8401453ba825c59f1e55158fzmti" target="_blank" rel="noopener">开源Android容器化框架Atlas开发者指南</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/07/c-plus-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/07/c-plus-language/" itemprop="url">C++ 语言笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-07T13:06:49+08:00">
                2020-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p>
<p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：封装、抽象、继承、多态。</p>
<p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。C++ 是 C 的一个超集，任何合法的 C 程序都是合法的 C++ 程序。</p>
<p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</p>
<p>注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p>
<p>本章只针对和C语言不同处介绍。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。</p>
<h3 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// main() 是程序开始执行的地方</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;Hello World&quot;; // 输出 Hello World</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们讲解一下上面这段程序：</p>
<blockquote>
<ul>
<li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <iostream>。</iostream></li>
<li>下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li>
<li>下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。</li>
<li>下一行 int main() 是主函数，程序从这里开始执行。</li>
<li>下一行 cout &lt;&lt; “Hello World”; 会在屏幕上显示消息 “Hello World”。</li>
<li>下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。</li>
</ul>
</blockquote>
<h3 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h3><p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。</p>
<h3 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h3><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。<strong>三字符序列总是以两个问号开头</strong>。</p>
<p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。<strong>以前为了表示键盘上没有的字符</strong>，这是必不可少的一种方法。三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p>
<p>g++仍默认支持三字符组，但会给出编译警告。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>布尔型</td>
<td>bool</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
</tr>
<tr>
<td>浮点型</td>
<td>float</td>
</tr>
<tr>
<td>双浮点型</td>
<td>double</td>
</tr>
<tr>
<td>无类型</td>
<td>void</td>
</tr>
<tr>
<td>宽字符型</td>
<td>wchar_t</td>
</tr>
</tbody>
</table>
<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><p>布尔常量共有两个，它们都是标准的 C++ 关键字：</p>
<blockquote>
<ul>
<li>true 值代表真。</li>
<li>false 值代表假。</li>
</ul>
</blockquote>
<p>我们不应把 true 的值看成 1，把 false 的值看成 0。</p>
<h3 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h3><p>wchar_t为宽字符型    ，占2 或 4 个字节。其实 wchar_t 是这样来的：</p>
<blockquote>
<p>typedef short int wchar_t;</p>
</blockquote>
<p>所以 wchar_t 实际上的空间是和 short int 一样。</p>
<h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><p>类型限定符提供了变量的额外信息。</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>const</td>
<td>const 类型的对象在程序执行期间不能被修改改变。</td>
</tr>
<tr>
<td>volatile</td>
<td>修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。</td>
</tr>
<tr>
<td>restrict</td>
<td>由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
</tbody>
</table>
<h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：</p>
<blockquote>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>mutable</li>
<li>thread_local (C++11)</li>
</ul>
</blockquote>
<p>从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。</p>
<h3 id="mutable-存储类"><a href="#mutable-存储类" class="headerlink" title="mutable 存储类"></a>mutable 存储类</h3><p>mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。</p>
<h3 id="thread-local-存储类"><a href="#thread-local-存储类" class="headerlink" title="thread_local 存储类"></a>thread_local 存储类</h3><p>使用 thread_local 说明符声明的变量<strong>仅可在它在其上创建的线程上访问</strong>。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
<p>thread_local 说明符可以与 static 或 extern 合并。</p>
<p>可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。</p>
<p>以下演示了可以被声明为 thread_local 的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thread_local int x;  // 命名空间下的全局变量</span><br><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">    static thread_local std::string s; // 类的static成员变量</span><br><span class="line">&#125;;</span><br><span class="line">static thread_local std::string X::s;  // X::s 是需要定义的</span><br><span class="line"> </span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    thread_local std::vector&lt;int&gt; v;  // 本地变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。</p>
<p>Cast：强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><p>当您定义一个函数，您<strong>可以为参数列表中后边的每一个参数指定默认值</strong>。当调用函数时，如果实际参数的值留空，则使用这个默认值。</p>
<p>这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int sum(int a, int b=20)</span><br><span class="line">&#123;</span><br><span class="line">  int result;</span><br><span class="line"> </span><br><span class="line">  result = a + b;</span><br><span class="line">  </span><br><span class="line">  return (result);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   // 局部变量声明</span><br><span class="line">   int a = 100;</span><br><span class="line">   int b = 200;</span><br><span class="line">   int result;</span><br><span class="line"> </span><br><span class="line">   // 调用函数来添加值</span><br><span class="line">   result = sum(a, b);</span><br><span class="line">   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 再次调用函数</span><br><span class="line">   result = sum(a);</span><br><span class="line">   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Total value is :300</span><br><span class="line">Total value is :120</span><br></pre></td></tr></table></figure></p>
<h3 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a>Lambda 函数与表达式</h3><p>C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。</p>
<p>Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。</p>
<p>Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下:</p>
<blockquote>
<p>[capture](parameters)-&gt;return-type{body}<br>[capture](parameters){body}</p>
</blockquote>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[](int x, int y)&#123; return x &lt; y ; &#125;</span><br><span class="line"></span><br><span class="line">[]&#123; ++global_x; &#125; </span><br><span class="line"></span><br><span class="line">[](int x, int y) -&gt; int &#123; int z = x + y; return z + x; &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。</p>
<p>在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定：</p>
<blockquote>
<p>[]      // 沒有定义任何变量。使用未定义变量会引发错误。<br>[x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。<br>[&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。<br>[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。<br>[&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。<br>[=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</p>
</blockquote>
<p>另外有一点需要注意。对于[=]或[&amp;]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：</p>
<blockquote>
<p>[this]() { this-&gt;someFunc(); }();</p>
</blockquote>
<h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h2><p>C++ 提供了以下两种类型的字符串表示形式：</p>
<blockquote>
<ul>
<li>C 风格字符串</li>
<li>C++ 引入的 string 类类型</li>
</ul>
</blockquote>
<p>C++ 标准库提供了 string 类类型，支持C 风格字符串所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   string str1 = &quot;Hello&quot;;</span><br><span class="line">   string str2 = &quot;World&quot;;</span><br><span class="line">   string str3;</span><br><span class="line">   int  len ;</span><br><span class="line"> </span><br><span class="line">   // 复制 str1 到 str3</span><br><span class="line">   str3 = str1;</span><br><span class="line">   cout &lt;&lt; &quot;str3 : &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 连接 str1 和 str2</span><br><span class="line">   str3 = str1 + str2;</span><br><span class="line">   cout &lt;&lt; &quot;str1 + str2 : &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 连接后，str3 的总长度</span><br><span class="line">   len = str3.size();</span><br><span class="line">   cout &lt;&lt; &quot;str3.size() :  &quot; &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">str3 : Hello</span><br><span class="line">str1 + str2 : HelloWorld</span><br><span class="line">str3.size() :  10</span><br></pre></td></tr></table></figure></p>
<h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++ 引用"></a>C++ 引用</h2><p>引用变量是一个<strong>别名</strong>，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。引用通常用于函数参数列表和函数返回值。</p>
<h3 id="C-引用-vs-指针"><a href="#C-引用-vs-指针" class="headerlink" title="C++ 引用 vs 指针"></a>C++ 引用 vs 指针</h3><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p>
<blockquote>
<ul>
<li><strong>不存在空引用</strong>。引用必须连接到一块合法的内存。</li>
<li><strong>一旦引用被初始化为一个对象，就不能被指向到另一个对象</strong>。指针可以在任何时候指向到另一个对象。</li>
<li><strong>引用必须在创建时被初始化</strong>。指针可以在任何时间被初始化。</li>
</ul>
</blockquote>
<h3 id="C-中创建引用"><a href="#C-中创建引用" class="headerlink" title="C++ 中创建引用"></a>C++ 中创建引用</h3><p>试想<strong>变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签</strong>。因此，您可以通过原始变量名称或引用来访问变量的内容。例如：</p>
<blockquote>
<p>int i = 17;</p>
</blockquote>
<p>我们可以为 i 声明引用变量，如下所示：</p>
<blockquote>
<p>int&amp;  r = i;<br>double&amp; s = d;</p>
</blockquote>
<p>在这些声明中，&amp; 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   // 声明简单的变量</span><br><span class="line">   int    i;</span><br><span class="line">   double d;</span><br><span class="line"> </span><br><span class="line">   // 声明引用变量</span><br><span class="line">   int&amp;    r = i;</span><br><span class="line">   double&amp; s = d;</span><br><span class="line">   </span><br><span class="line">   i = 5;</span><br><span class="line">   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   d = 11.7;</span><br><span class="line">   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of i : 5</span><br><span class="line">Value of i reference : 5</span><br><span class="line">Value of d : 11.7</span><br><span class="line">Value of d reference : 11.7</span><br></pre></td></tr></table></figure>
<h2 id="C-输入输出"><a href="#C-输入输出" class="headerlink" title="C++ 输入输出"></a>C++ 输入输出</h2><h3 id="I-O-库头文件"><a href="#I-O-库头文件" class="headerlink" title="I/O 库头文件"></a>I/O 库头文件</h3><p>下列的头文件在 C++ 编程中很重要：</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>函数和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;iostream></td>
<td>该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>
</tr>
<tr>
<td>&lt;iomanip></td>
<td>该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。</td>
</tr>
<tr>
<td>&lt;fstream></td>
<td>该文件为用户控制的文件处理声明服务。</td>
</tr>
</tbody>
</table>
<h3 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a>标准输出流（cout）</h3><p>预定义的对象 cout 是 iostream 类的一个实例。cout 对象”连接”到标准输出设备，通常是显示屏。cout 是与流插入运算符 &lt;&lt; 结合使用的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char str[] = &quot;Hello C++&quot;;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。</p>
<p>cerr、clog类似。但良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。</p>
<h3 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a>标准输入流（cin）</h3><p>预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 &gt;&gt; 结合使用的，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char name[50];</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;请输入您的名称： &quot;;</span><br><span class="line">   cin &gt;&gt; name;</span><br><span class="line">   cout &lt;&lt; &quot;您的名称是： &quot; &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句：</p>
<blockquote>
<p>cin &gt;&gt; name &gt;&gt; age;</p>
</blockquote>
<h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。</p>
<p>下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<blockquote>
<p>void open(const char *filename, ios::openmode mode);</p>
</blockquote>
<p>在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式:</p>
<p>模式标志     | 描述<br>| - | - |<br>ios::app     | 追加模式。所有写入都追加到文件末尾。<br>ios::ate     | 文件打开后定位到文件末尾。<br>ios::in     | 打开文件用于读取。<br>ios::out     | 打开文件用于写入。<br>ios::trunc     | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。</p>
<p>您可以把以上两种或两种以上的模式结合使用。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法</span><br><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(&quot;file.dat&quot;, ios::out | ios::trunc );</span><br><span class="line"></span><br><span class="line">//类似地，您如果想要打开一个文件用于读写，可以使用下面的语法：</span><br><span class="line">ifstream  afile;</span><br><span class="line">afile.open(&quot;file.dat&quot;, ios::out | ios::in );</span><br></pre></td></tr></table></figure></p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。</p>
<p>下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。</p>
<blockquote>
<p>void close();</p>
</blockquote>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息或流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 、 fstream  或 ifstream 、 fstream 对象，而不是 cout 对象或 cin 对象。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">   char data[100];</span><br><span class="line"> </span><br><span class="line">   // 以写模式打开文件</span><br><span class="line">   ofstream outfile;</span><br><span class="line">   outfile.open(&quot;afile.dat&quot;);</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Writing to the file&quot; &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Enter your name: &quot;; </span><br><span class="line">   cin.getline(data, 100);</span><br><span class="line"> </span><br><span class="line">   // 向文件写入用户输入的数据</span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Enter your age: &quot;; </span><br><span class="line">   cin &gt;&gt; data;</span><br><span class="line">   cin.ignore();</span><br><span class="line">   </span><br><span class="line">   // 再次向文件写入用户输入的数据</span><br><span class="line">   outfile &lt;&lt; data &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   // 关闭打开的文件</span><br><span class="line">   outfile.close();</span><br><span class="line"> </span><br><span class="line">   // 以读模式打开文件</span><br><span class="line">   ifstream infile; </span><br><span class="line">   infile.open(&quot;afile.dat&quot;); </span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Reading from the file&quot; &lt;&lt; endl; </span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line"> </span><br><span class="line">   // 在屏幕上写入数据</span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   // 再次从文件读取数据，并显示它</span><br><span class="line">   infile &gt;&gt; data; </span><br><span class="line">   cout &lt;&lt; data &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   // 关闭打开的文件</span><br><span class="line">   infile.close();</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列输入和输出：</span><br><span class="line">$./a.out</span><br><span class="line">Writing to the file</span><br><span class="line">Enter your name: Zara</span><br><span class="line">Enter your age: 9</span><br><span class="line">Reading from the file</span><br><span class="line">Zara</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<p>上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。</p>
<h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><p>istream 和 ostream 都提供了用于<strong>重新定位文件位置指针</strong>的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get”）和关于 ostream 的 seekp（”seek put”）。</p>
<p>seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。</p>
<p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）</span><br><span class="line">fileObject.seekg( n );</span><br><span class="line"> </span><br><span class="line">// 把文件的读指针从 fileObject 当前位置向后移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::cur );</span><br><span class="line"> </span><br><span class="line">// 把文件的读指针从 fileObject 末尾往回移 n 个字节</span><br><span class="line">fileObject.seekg( n, ios::end );</span><br><span class="line"> </span><br><span class="line">// 定位到 fileObject 的末尾</span><br><span class="line">fileObject.seekg( 0, ios::end );</span><br></pre></td></tr></table></figure></p>
<h2 id="C-类和继承"><a href="#C-类和继承" class="headerlink" title="C++ 类和继承"></a>C++ 类和继承</h2><p>类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。</p>
<h3 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h3><p>定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。</p>
<p>类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      double length;   // 盒子的长度</span><br><span class="line">      double breadth;  // 盒子的宽度</span><br><span class="line">      double height;   // 盒子的高度</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected。</p>
<h3 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h3><p>当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。继承代表了 is a 关系。</p>
<p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<blockquote>
<p>class derived-class: access-specifier base-class</p>
</blockquote>
<p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p>
<h3 id="继承类型access-specifier"><a href="#继承类型access-specifier" class="headerlink" title="继承类型access-specifier"></a>继承类型access-specifier</h3><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 protected 或 private 继承，<strong>通常使用 public 继承</strong>。当使用不同类型的继承时，遵循以下几个规则：</p>
<ul>
<li>公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</li>
<li>保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。</li>
<li>私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。</p>
<p>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。</p>
<blockquote>
<p>Box operator+(const Box&amp;);</p>
</blockquote>
<p>声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：</p>
<blockquote>
<p>Box operator+(const Box&amp;, const Box&amp;);</p>
</blockquote>
<p>下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Box</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line"> </span><br><span class="line">      double getVolume(void)</span><br><span class="line">      &#123;</span><br><span class="line">         return length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      void setLength( double len )</span><br><span class="line">      &#123;</span><br><span class="line">          length = len;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      void setBreadth( double bre )</span><br><span class="line">      &#123;</span><br><span class="line">          breadth = bre;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      void setHeight( double hei )</span><br><span class="line">      &#123;</span><br><span class="line">          height = hei;</span><br><span class="line">      &#125;</span><br><span class="line">      // 重载 + 运算符，用于把两个 Box 对象相加</span><br><span class="line">      Box operator+(const Box&amp; b)</span><br><span class="line">      &#123;</span><br><span class="line">         Box box;</span><br><span class="line">         box.length = this-&gt;length + b.length;</span><br><span class="line">         box.breadth = this-&gt;breadth + b.breadth;</span><br><span class="line">         box.height = this-&gt;height + b.height;</span><br><span class="line">         return box;</span><br><span class="line">      &#125;</span><br><span class="line">   private:</span><br><span class="line">      double length;      // 长度</span><br><span class="line">      double breadth;     // 宽度</span><br><span class="line">      double height;      // 高度</span><br><span class="line">&#125;;</span><br><span class="line">// 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Box Box1;                // 声明 Box1，类型为 Box</span><br><span class="line">   Box Box2;                // 声明 Box2，类型为 Box</span><br><span class="line">   Box Box3;                // 声明 Box3，类型为 Box</span><br><span class="line">   double volume = 0.0;     // 把体积存储在该变量中</span><br><span class="line"> </span><br><span class="line">   // Box1 详述</span><br><span class="line">   Box1.setLength(6.0); </span><br><span class="line">   Box1.setBreadth(7.0); </span><br><span class="line">   Box1.setHeight(5.0);</span><br><span class="line"> </span><br><span class="line">   // Box2 详述</span><br><span class="line">   Box2.setLength(12.0); </span><br><span class="line">   Box2.setBreadth(13.0); </span><br><span class="line">   Box2.setHeight(10.0);</span><br><span class="line"> </span><br><span class="line">   // Box1 的体积</span><br><span class="line">   volume = Box1.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box1 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   // Box2 的体积</span><br><span class="line">   volume = Box2.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box2 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   // 把两个对象相加，得到 Box3</span><br><span class="line">   Box3 = Box1 + Box2;</span><br><span class="line"> </span><br><span class="line">   // Box3 的体积</span><br><span class="line">   volume = Box3.getVolume();</span><br><span class="line">   cout &lt;&lt; &quot;Volume of Box3 : &quot; &lt;&lt; volume &lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Volume of Box1 : 210</span><br><span class="line">Volume of Box2 : 1560</span><br><span class="line">Volume of Box3 : 5400</span><br></pre></td></tr></table></figure></p>
<h3 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符/不可重载运算符"></a>可重载运算符/不可重载运算符</h3><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>双目算术运算符</td>
<td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td>
</tr>
<tr>
<td>关系运算符</td>
<td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&#124;&#124;(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>&#124; (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)`</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=, +=, -=, *=, /= , % = , &amp;=, &#124;=, ^=, &lt;&lt;=, &gt;&gt;=</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td>()(函数调用)，-&gt;(成员访问)，,(逗号)，[](下标)</td>
</tr>
</tbody>
</table>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li>.：成员访问运算符</li>
<li>.<em>, -&gt;</em>：成员指针访问运算符</li>
<li>::：域运算符</li>
<li>sizeof：长度运算符</li>
<li>?:：条件运算符</li>
<li>#： 预处理符号</li>
</ul>
<h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++ 多态"></a>C++ 多态</h2><p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      int area()</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Rectangle: public Shape&#123;</span><br><span class="line">   public:</span><br><span class="line">      Rectangle( int a=0, int b=0):Shape(a, b) &#123; &#125;</span><br><span class="line">      int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         cout &lt;&lt; &quot;Rectangle class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Triangle: public Shape&#123;</span><br><span class="line">   public:</span><br><span class="line">      Triangle( int a=0, int b=0):Shape(a, b) &#123; &#125;</span><br><span class="line">      int area ()</span><br><span class="line">      &#123; </span><br><span class="line">         cout &lt;&lt; &quot;Triangle class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return (width * height / 2); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 程序的主函数</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   Rectangle rec(10,7);</span><br><span class="line">   Triangle  tri(10,5);</span><br><span class="line"> </span><br><span class="line">   // 存储矩形的地址</span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   // 调用矩形的求面积函数 area</span><br><span class="line">   shape-&gt;area();</span><br><span class="line"> </span><br><span class="line">   // 存储三角形的地址</span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   // 调用三角形的求面积函数 area</span><br><span class="line">   shape-&gt;area();</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Parent class area</span><br><span class="line">Parent class area</span><br></pre></td></tr></table></figure>
<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的<strong>静态多态或静态链接</strong> - 函数调用在程序执行前就准备好了。有时候这也被称为<strong>早绑定</strong>，因为 area() 函数在程序编译期间就已经设置好了。</p>
<p>但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      virtual int area()</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt; &quot;Parent class area :&quot; &lt;&lt;endl;</span><br><span class="line">         return 0;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">修改后，当编译和执行前面的实例代码时，它会产生以下结果：</span><br><span class="line">Rectangle class area</span><br><span class="line">Triangle class area</span><br></pre></td></tr></table></figure></p>
<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>
<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。</p>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>虚函数 是在基类中使用关键字 <strong>virtual</strong> 声明的函数。在派生类中重新定义基类中定义的虚函数时，会<strong>告诉编译器不要静态链接到该函数</strong>。</p>
<p>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为<strong>动态链接或后期绑定</strong>。</p>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>
<p>我们可以把基类中的虚函数 area() 改写如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">   protected:</span><br><span class="line">      int width, height;</span><br><span class="line">   public:</span><br><span class="line">      Shape( int a=0, int b=0)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      // pure virtual function</span><br><span class="line">      virtual int area() = 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>= 0 告诉编译器，<strong>函数没有主体</strong>，上面的虚函数是纯虚函数。</p>
<h2 id="C-动态内存"><a href="#C-动态内存" class="headerlink" title="C++ 动态内存"></a>C++ 动态内存</h2><p>C++ 程序中的内存分为两个部分：</p>
<blockquote>
<ul>
<li>栈：在函数内部声明的所有变量都将占用栈内存。</li>
<li>堆：这是程序中未使用的内存，在程序运行时可用于动态分配内存。</li>
</ul>
</blockquote>
<p>很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。</p>
<p>在 C++ 中，这种运算符即 new 运算符。如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。</p>
<h3 id="new-和-delete-运算符"><a href="#new-和-delete-运算符" class="headerlink" title="new 和 delete 运算符"></a>new 和 delete 运算符</h3><p>通用语法：</p>
<blockquote>
<p>new data-type;<br>delete member; </p>
</blockquote>
<p>在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double* pvalue  = NULL; // 初始化为 null 的指针</span><br><span class="line">pvalue  = new double;   // 为变量请求内存</span><br></pre></td></tr></table></figure></p>
<p>如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double* pvalue  = NULL;</span><br><span class="line">if( !(pvalue  = new double ))</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;Error: out of memory.&quot; &lt;&lt;endl;</span><br><span class="line">   exit(1);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pvalue = 29494.99;     // 在分配的地址存储值</span><br><span class="line">cout &lt;&lt; &quot;Value of pvalue : &quot; &lt;&lt; *pvalue &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">delete pvalue;        // 释放 pvalue 所指向的内存</span><br></pre></td></tr></table></figure></p>
<p>malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。</p>
<h2 id="C-命名空间"><a href="#C-命名空间" class="headerlink" title="C++ 命名空间"></a>C++ 命名空间</h2><p>命名空间可作为附加信息来<strong>区分不同库中相同名称的函数、类、变量等</strong>。使用了命名空间即定义了<strong>上下文</strong>。本质上，命名空间就是定义了一个范围。</p>
<h3 id="定义命名空间"><a href="#定义命名空间" class="headerlink" title="定义命名空间"></a>定义命名空间</h3><p>命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示：</p>
<blockquote>
<p>namespace namespace_name {<br>   // 代码声明<br>}</p>
</blockquote>
<p>为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示：</p>
<blockquote>
<p>name::code;  // code 可以是变量或函数</p>
</blockquote>
<p>让我们来看看命名空间如何为变量或函数等实体定义范围：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 第一个命名空间</span><br><span class="line">namespace first_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二个命名空间</span><br><span class="line">namespace second_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   // 调用第一个命名空间中的函数</span><br><span class="line">   first_space::func();</span><br><span class="line">   </span><br><span class="line">   // 调用第二个命名空间中的函数</span><br><span class="line">   second_space::func(); </span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Inside first_space</span><br><span class="line">Inside second_space</span><br></pre></td></tr></table></figure></p>
<h3 id="using-指令"><a href="#using-指令" class="headerlink" title="using 指令"></a>using 指令</h3><p>您可以使用 using namespace 指令，这样在使用命名空间时就<strong>可以不用在前面加上命名空间的名称</strong>。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">// 第一个命名空间</span><br><span class="line">namespace first_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside first_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第二个命名空间</span><br><span class="line">namespace second_space&#123;</span><br><span class="line">   void func()&#123;</span><br><span class="line">      cout &lt;&lt; &quot;Inside second_space&quot; &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">using namespace first_space;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   // 调用第一个命名空间中的函数</span><br><span class="line">   func();</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Inside first_space</span><br></pre></td></tr></table></figure></p>
<p>using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：</p>
<blockquote>
<p>using std::cout;</p>
</blockquote>
<p>随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using std::cout;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;std::endl is used with std!&quot; &lt;&lt; std::endl;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">std::endl is used with std!</span><br></pre></td></tr></table></figure></p>
<p>using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。</p>
<h3 id="不连续的命名空间"><a href="#不连续的命名空间" class="headerlink" title="不连续的命名空间"></a>不连续的命名空间</h3><p>命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。<strong>一个命名空间的各个组成部分可以分散在多个文件中</strong>。</p>
<p>所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素。</p>
<h3 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="headerlink" title="嵌套的命名空间"></a>嵌套的命名空间</h3><p>命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name1 &#123;</span><br><span class="line">   // 代码声明</span><br><span class="line">   namespace namespace_name2 &#123;</span><br><span class="line">      // 代码声明</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 访问 namespace_name2 中的成员</span><br><span class="line">using namespace namespace_name1::namespace_name2;</span><br><span class="line"> </span><br><span class="line">// 访问 namespace:name1 中的成员</span><br><span class="line">using namespace namespace_name1;</span><br></pre></td></tr></table></figure></p>
<p>在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的</p>
<h2 id="C-模板"><a href="#C-模板" class="headerlink" title="C++ 模板"></a>C++ 模板</h2><p>模板是<strong>泛型</strong>编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<p>模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>模板函数定义的一般形式如下所示：</p>
<blockquote>
<p>template <class type> ret-type func-name(parameter list)<br>{<br>   // 函数的主体<br>}</class></p>
</blockquote>
<p>在这里，<strong>type 是函数所使用的数据类型的占位符名称</strong>。这个名称可以在函数定义中使用。</p>
<p>下面是函数模板的实例，返回两个数中的最大值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">inline T const&amp; Max (T const&amp; a, T const&amp; b) </span><br><span class="line">&#123; </span><br><span class="line">    return a &lt; b ? b:a; </span><br><span class="line">&#125; </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    int i = 39;</span><br><span class="line">    int j = 20;</span><br><span class="line">    cout &lt;&lt; &quot;Max(i, j): &quot; &lt;&lt; Max(i, j) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    double f1 = 13.5; </span><br><span class="line">    double f2 = 20.7; </span><br><span class="line">    cout &lt;&lt; &quot;Max(f1, f2): &quot; &lt;&lt; Max(f1, f2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">    string s1 = &quot;Hello&quot;; </span><br><span class="line">    string s2 = &quot;World&quot;; </span><br><span class="line">    cout &lt;&lt; &quot;Max(s1, s2): &quot; &lt;&lt; Max(s1, s2) &lt;&lt; endl; </span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Max(i, j): 39</span><br><span class="line">Max(f1, f2): 20.7</span><br><span class="line">Max(s1, s2): World</span><br></pre></td></tr></table></figure>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</p>
<blockquote>
<p>template <class type> class class-name {<br>.<br>.<br>.<br>}</class></p>
</blockquote>
<p>在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您<strong>可以使用一个逗号分隔的列表来定义多个泛型数据类型</strong>。</p>
<p>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stdexcept&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">class Stack &#123; </span><br><span class="line">  private: </span><br><span class="line">    vector&lt;T&gt; elems;     // 元素 </span><br><span class="line"> </span><br><span class="line">  public: </span><br><span class="line">    void push(T const&amp;);  // 入栈</span><br><span class="line">    void pop();               // 出栈</span><br><span class="line">    T top() const;            // 返回栈顶元素</span><br><span class="line">    bool empty() const&#123;       // 如果为空则返回真。</span><br><span class="line">        return elems.empty(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Stack&lt;T&gt;::push (T const&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    // 追加传入元素的副本</span><br><span class="line">    elems.push_back(elem);    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void Stack&lt;T&gt;::pop () </span><br><span class="line">&#123; </span><br><span class="line">    if (elems.empty()) &#123; </span><br><span class="line">        throw out_of_range(&quot;Stack&lt;&gt;::pop(): empty stack&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 删除最后一个元素</span><br><span class="line">    elems.pop_back();         </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">T Stack&lt;T&gt;::top () const </span><br><span class="line">&#123; </span><br><span class="line">    if (elems.empty()) &#123; </span><br><span class="line">        throw out_of_range(&quot;Stack&lt;&gt;::top(): empty stack&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    // 返回最后一个元素的副本 </span><br><span class="line">    return elems.back();      </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        Stack&lt;int&gt;         intStack;  // int 类型的栈 </span><br><span class="line">        Stack&lt;string&gt; stringStack;    // string 类型的栈 </span><br><span class="line"> </span><br><span class="line">        // 操作 int 类型的栈 </span><br><span class="line">        intStack.push(7); </span><br><span class="line">        cout &lt;&lt; intStack.top() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        // 操作 string 类型的栈 </span><br><span class="line">        stringStack.push(&quot;hello&quot;); </span><br><span class="line">        cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.pop(); </span><br><span class="line">        stringStack.pop(); </span><br><span class="line">    &#125; </span><br><span class="line">    catch (exception const&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; ex.what() &lt;&lt;endl; </span><br><span class="line">        return -1;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">7</span><br><span class="line">hello</span><br><span class="line">Exception: Stack&lt;&gt;::pop(): empty stack</span><br></pre></td></tr></table></figure></p>
<h2 id="和-运算符"><a href="#和-运算符" class="headerlink" title="# 和 ## 运算符"></a># 和 ## 运算符</h2><p># 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌<strong>转换</strong>为用引号引起来的字符串。</p>
<p>请看下面的宏定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define MKSTR( x ) #x</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">HELLO C++</span><br></pre></td></tr></table></figure>
<p>## 运算符用于连接两个令牌。下面是一个实例：</p>
<blockquote>
<p>#define CONCAT( x, y )  x ## y</p>
</blockquote>
<p>当 CONCAT 出现在程序中时，它的参数会被<strong>连接</strong>起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define concat(a, b) a ## b</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int xy = 100;</span><br><span class="line">   </span><br><span class="line">   cout &lt;&lt; concat(x, y);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<h2 id="C-友元"><a href="#C-友元" class="headerlink" title="C++ 友元"></a>C++ 友元</h2><p>友元机制<strong>允许一个类将对其非公有成员的访问权授予指定的函数或者类</strong>，友元的声明以friend开始，它只能出现在类定义的内部，友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受其声明出现部分的访问控制影响。通常，将友元声明成组地放在类定义的开始或结尾是个好主意。</p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>友元函数是指某些虽然不是类成员函数却能够访问类的所有成员的函数。类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend void set_show(int x, A &amp;a);      //该函数是友元函数的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void set_show(int x, A &amp;a)  //友元函数定义，为了访问类A中的成员</span><br><span class="line">&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line"></span><br><span class="line">    set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。</p>
<p>关于友元类的注意事项：<br>(1) 友元关系不能被继承。<br>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。<br>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend class C;                         //这是友元类的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C             //友元类定义，为了访问类A中的成员</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void set_show(int x, A &amp;a) &#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line">    class C c;</span><br><span class="line"></span><br><span class="line">    c.set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h3><p>使类B中的成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员了。</p>
<p>当用到友元成员函数时，需注意友元声明和友元定义之间的相互依赖，在该例子中，类B必须先定义，否则类A就不能将一个B的函数指定为友元。然而，只有在定义了类A之后，才能定义类B的该成员函数。更一般的讲，必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A;    //当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。这是类A的声明</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void set_show(int x, A &amp;a);             //该函数是类A的友元函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    friend void B::set_show(int x, A &amp;a);   //该函数是友元成员函数的声明</span><br><span class="line">private:</span><br><span class="line">    int data;</span><br><span class="line">    void show() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void B::set_show(int x, A &amp;a)       //只有在定义类A后才能定义该函数，毕竟，它被设为友元是为了访问类A的成员</span><br><span class="line">&#123;</span><br><span class="line">    a.data = x;</span><br><span class="line">    cout &lt;&lt; a.data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    class A a;</span><br><span class="line">    class B b;</span><br><span class="line"></span><br><span class="line">    b.set_show(1, a);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-信号处理"><a href="#C-信号处理" class="headerlink" title="C++ 信号处理"></a>C++ 信号处理</h2><p>信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。</p>
<p>有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 <csignal> 中。</csignal></p>
<table>
<thead>
<tr>
<th>信号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGABRT</td>
<td>程序的异常终止，如调用 abort。</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>错误的算术运算，比如除以零或导致溢出的操作。</td>
</tr>
<tr>
<td>SIGILL</td>
<td>检测非法指令。</td>
</tr>
<tr>
<td>SIGINT</td>
<td>接收到交互注意信号。</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>非法访问内存。</td>
</tr>
<tr>
<td>SIGTERM</td>
<td>发送到程序的终止请求。</td>
</tr>
</tbody>
</table>
<h3 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal() 函数"></a>signal() 函数</h3><p>C++ 信号处理库提供了 signal 函数，用来<strong>捕获突发事件</strong>。以下是 signal() 函数的语法：</p>
<blockquote>
<p>void (*signal (int sig, void (*func)(int)))(int); </p>
</blockquote>
<p>这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;csignal&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void signalHandler( int signum )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\n&quot;;</span><br><span class="line"> </span><br><span class="line">    // 清理并关闭</span><br><span class="line">    // 终止程序  </span><br><span class="line"> </span><br><span class="line">   exit(signum);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    // 注册信号 SIGINT 和信号处理程序</span><br><span class="line">    signal(SIGINT, signalHandler);  </span><br><span class="line"> </span><br><span class="line">    while(1)&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;</span><br><span class="line">       sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line"></span><br><span class="line">现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure>
<h3 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise() 函数"></a>raise() 函数</h3><p>您可以使用函数 raise() <strong>生成信号</strong>，该函数带有一个整数信号编号作为参数，语法如下：</p>
<blockquote>
<p>int raise (signal sig);</p>
</blockquote>
<p>在这里，sig 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;csignal&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">void signalHandler( int signum )</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Interrupt signal (&quot; &lt;&lt; signum &lt;&lt; &quot;) received.\n&quot;;</span><br><span class="line"> </span><br><span class="line">    // 清理并关闭</span><br><span class="line">    // 终止程序 </span><br><span class="line"> </span><br><span class="line">   exit(signum);  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    // 注册信号 SIGINT 和信号处理程序</span><br><span class="line">    signal(SIGINT, signalHandler);  </span><br><span class="line"> </span><br><span class="line">    while(++i)&#123;</span><br><span class="line">       cout &lt;&lt; &quot;Going to sleep....&quot; &lt;&lt; endl;</span><br><span class="line">       if( i == 3 )&#123;</span><br><span class="line">          raise( SIGINT);</span><br><span class="line">       &#125;</span><br><span class="line">       sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果，并会自动退出：</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Going to sleep....</span><br><span class="line">Interrupt signal (2) received.</span><br></pre></td></tr></table></figure></p>
<h2 id="C-多线程"><a href="#C-多线程" class="headerlink" title="C++ 多线程"></a>C++ 多线程</h2><p>多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。</p>
<h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p>pthread_t：线程ID<br>pthread_attr_t：线程属性</p>
<ol>
<li><p>操纵函数<br>pthread_create()：创建一个线程<br>pthread_exit()：终止当前线程<br>pthread_cancel()：中断另外一个线程的运行，Android中没有<br>pthread_join()：阻塞当前的线程，直到另外一个线程运行结束<br>pthread_attr_init()：初始化线程的属性<br>pthread_attr_setdetachstate()：设置脱离状态的属性（决定这个线程在终止时是否可以被结合）<br>pthread_attr_getdetachstate()：获取脱离状态的属性<br>pthread_attr_destroy()：删除线程的属性<br>pthread_kill()：向线程发送一个信号</p>
</li>
<li><p>同步函数<br>pthread_mutex_init() 初始化互斥锁<br>pthread_mutex_destroy() 删除互斥锁<br>pthread_mutex_lock()：占有互斥锁（阻塞操作）<br>pthread_mutex_trylock()：试图占有互斥锁（不阻塞操作）。即，当互斥锁空闲时，将占有该锁；否则，立即返回。<br>pthread_mutex_unlock(): 释放互斥锁<br>pthread_cond_init()：初始化条件变量<br>pthread_cond_destroy()：销毁条件变量<br>pthread_cond_signal(): 唤醒第一个调用pthread_cond_wait()而进入睡眠的线程<br>pthread_cond_wait(): 等待条件变量的特殊条件发生<br>Thread-local storage（或者以Pthreads术语，称作线程特有数据）：<br>pthread_key_create(): 分配用于标识进程中线程特定数据的键<br>pthread_setspecific(): 为指定线程特定数据键设置线程特定绑定<br>pthread_getspecific(): 获取调用线程的键绑定，并将该绑定存储在 value 指向的位置中<br>pthread_key_delete(): 销毁现有线程特定数据键<br>pthread_attr_getschedparam();获取线程优先级<br>pthread_attr_setschedparam();设置线程优先级</p>
</li>
<li><p>工具函数<br>pthread_equal(): 对两个线程的线程标识号进行比较<br>pthread_detach(): 分离线程<br>pthread_self(): 查询线程自身线程标识号</p>
</li>
</ol>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>下面的程序，我们可以用它来创建一个 POSIX 线程：</p>
<blockquote>
<p>#include &lt;pthread.h&gt;<br>pthread_create (thread, attr, start_routine, arg) </p>
</blockquote>
<p>在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>thread</td>
<td>指向线程标识符指针。</td>
</tr>
<tr>
<td>attr</td>
<td>一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。</td>
</tr>
<tr>
<td>start_routine</td>
<td>线程运行函数起始地址，一旦线程被创建就会执行。</td>
</tr>
<tr>
<td>arg</td>
<td>运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。</td>
</tr>
</tbody>
</table>
<p>创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。</p>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>使用下面的程序，我们可以用它来终止一个 POSIX 线程：</p>
<blockquote>
<p>#include &lt;pthread.h&gt;<br>pthread_exit (status) </p>
</blockquote>
<p>在这里，pthread_exit 用于显式地退出一个线程。通常情况下，<strong>pthread_exit() 函数是在线程完成工作后无需继续存在时被调用</strong>。</p>
<p>如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS     5</span><br><span class="line"> </span><br><span class="line">struct thread_data&#123;</span><br><span class="line">   int  thread_id;</span><br><span class="line">   char *message;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void *PrintHello(void *threadarg)</span><br><span class="line">&#123;</span><br><span class="line">   struct thread_data *my_data;</span><br><span class="line"> </span><br><span class="line">   my_data = (struct thread_data *) threadarg;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Thread ID : &quot; &lt;&lt; my_data-&gt;thread_id ;</span><br><span class="line">   cout &lt;&lt; &quot; Message : &quot; &lt;&lt; my_data-&gt;message &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   pthread_t threads[NUM_THREADS];</span><br><span class="line">   struct thread_data td[NUM_THREADS];</span><br><span class="line">   int rc;</span><br><span class="line">   int i;</span><br><span class="line"> </span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt;&quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      td[i].thread_id = i;</span><br><span class="line">      td[i].message = (char*)&quot;This is message&quot;;</span><br><span class="line">      rc = pthread_create(&amp;threads[i], NULL,</span><br><span class="line">                          PrintHello, (void *)&amp;td[i]);</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -Wno-write-strings test.cpp -lpthread -o test.o</span><br><span class="line">$ ./test.o</span><br><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">Thread ID : 0 Message : This is message</span><br><span class="line">main() : creating thread, Thread ID : 21</span><br><span class="line"> Message : This is message</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">Thread ID : 2 Message : This is message</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Thread ID : 3 Message : This is message</span><br><span class="line">Thread ID : 4 Message : This is message</span><br></pre></td></tr></table></figure></p>
<h3 id="连接和分离线程"><a href="#连接和分离线程" class="headerlink" title="连接和分离线程"></a>连接和分离线程</h3><p>我们可以使用以下两个函数来连接或分离线程：</p>
<blockquote>
<p>pthread_join (threadid, status)<br>pthread_detach (threadid) </p>
</blockquote>
<p><strong>pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止</strong>。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。</p>
<p>一个线程默认的状态是joinable，如果线程是joinable状态，当线程函数自己返回退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符。只有当你<strong>调用了pthread_join之后这些资源才会被释放</strong>。</p>
<p>这个实例演示了如何使用 pthread_join() 函数来等待线程的完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdlib&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define NUM_THREADS     5</span><br><span class="line"> </span><br><span class="line">void *wait(void *t)</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   long tid;</span><br><span class="line"> </span><br><span class="line">   tid = (long)t;</span><br><span class="line"> </span><br><span class="line">   sleep(1);</span><br><span class="line">   cout &lt;&lt; &quot;Sleeping in thread &quot; &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; &quot;Thread with id : &quot; &lt;&lt; tid &lt;&lt; &quot;  ...exiting &quot; &lt;&lt; endl;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int rc;</span><br><span class="line">   int i;</span><br><span class="line">   pthread_t threads[NUM_THREADS];</span><br><span class="line">   pthread_attr_t attr;</span><br><span class="line">   void *status;</span><br><span class="line"> </span><br><span class="line">   // 初始化并设置线程为可连接的（joinable）</span><br><span class="line">   pthread_attr_init(&amp;attr);</span><br><span class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"> </span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      cout &lt;&lt; &quot;main() : creating thread, &quot; &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      rc = pthread_create(&amp;threads[i], NULL, wait, (void *)&amp;i );</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to create thread,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // 删除属性，并等待其他线程</span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   for( i=0; i &lt; NUM_THREADS; i++ )&#123;</span><br><span class="line">      rc = pthread_join(threads[i], &amp;status);</span><br><span class="line">      if (rc)&#123;</span><br><span class="line">         cout &lt;&lt; &quot;Error:unable to join,&quot; &lt;&lt; rc &lt;&lt; endl;</span><br><span class="line">         exit(-1);</span><br><span class="line">      &#125;</span><br><span class="line">      cout &lt;&lt; &quot;Main: completed thread id :&quot; &lt;&lt; i ;</span><br><span class="line">      cout &lt;&lt; &quot;  exiting with status :&quot; &lt;&lt; status &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   cout &lt;&lt; &quot;Main: program exiting.&quot; &lt;&lt; endl;</span><br><span class="line">   pthread_exit(NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当上面的代码被编译和执行时，它会产生下列结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main() : creating thread, 0</span><br><span class="line">main() : creating thread, 1</span><br><span class="line">main() : creating thread, 2</span><br><span class="line">main() : creating thread, 3</span><br><span class="line">main() : creating thread, 4</span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 4  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 3  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 2  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 1  ...exiting </span><br><span class="line">Sleeping in thread </span><br><span class="line">Thread with id : 0  ...exiting </span><br><span class="line">Main: completed thread id :0  exiting with status :0</span><br><span class="line">Main: completed thread id :1  exiting with status :0</span><br><span class="line">Main: completed thread id :2  exiting with status :0</span><br><span class="line">Main: completed thread id :3  exiting with status :0</span><br><span class="line">Main: completed thread id :4  exiting with status :0</span><br><span class="line">Main: program exiting.</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/cplusplus/cpp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-tutorial.html</a><br><a href="https://www.jianshu.com/p/34d88df0cfe0" target="_blank" rel="noopener">https://www.jianshu.com/p/34d88df0cfe0</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/03/android-ndk-jni-invoke/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/03/android-ndk-jni-invoke/" itemprop="url">JNI 的调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-03T13:19:25+08:00">
                2020-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-NDK/" itemprop="url" rel="index">
                    <span itemprop="name">Android NDK</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="注册native函数"><a href="#注册native函数" class="headerlink" title="注册native函数"></a>注册native函数</h2><p>JNI有两种注册native方法的途径：</p>
<blockquote>
<ul>
<li>静态注册：<br>先由Java得到本地方法的声明，然后再通过JNI实现该声明方法</li>
<li>动态注册：<br>先通过JNI重载JNI_OnLoad()实现本地方法，然后直接在Java中调用本地方法。</li>
</ul>
</blockquote>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>静态注册就是根据函数名来遍历Java和JNI函数之间的关联，而且要求JNI层函数的名字必须遵循特定的格式。具体的实现很简单，首先在Java代码中声明native函数，然后通过javah来生成native函数的具体形式，接下来在JNI代码中实现这些函数即可。</p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class JniDemo1&#123;</span><br><span class="line">       static &#123;</span><br><span class="line">             System.loadLibrary(&quot;samplelib_jni&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private native void nativeMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接来下通过javah来产生jni代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -d ./jni/ -classpath /Users/YOUR_NAME/Library/Android/sdk/platforms/android-21/android.jar:../../build/intermediates/classes/debug/ com.xxxpackagename.JniDemo1</span><br></pre></td></tr></table></figure></p>
<p>然后就会得到一个JNI的.h文件，里面包含这几个native函数的声明，观察一下文件名以及函数名。JNI方法名的规范：</p>
<blockquote>
<p>返回值 + Java前缀+全路径类名+方法名+参数1JNIEnv+参数2jobject+其他参数</p>
</blockquote>
<p>注意事项：</p>
<blockquote>
<ul>
<li>注意分隔符：<br>Java前缀与类名以及类名之间的包名和方法名之间使用”_”进行分割；</li>
<li>注意静态：<br>如果在Java中声明的方法是”静态的”，则native方法也是static。否则不是。</li>
</ul>
</blockquote>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册，也就是通过RegisterNatives方法把C/C++中的方法映射到Java中的native方法，而无需遵循特定的方法命名格式。</p>
<p>当我们使用System.loadLibarary()方法加载so库的时候，Java虚拟机就会找到这个<strong>JNI_OnLoad</strong>函数并调用该函数，<strong>这个函数的作用是告诉Dalvik虚拟机此C库使用的是哪一个JNI版本</strong>，如果你的库里面没有写明JNI_OnLoad()函数，VM会默认该库使用最老的JNI 1.1版本。由于最新版本的JNI做了很多扩充，也优化了一些内容，如果需要使用JNI新版本的功能，就必须在JNI_OnLoad()函数声明JNI的版本，同时也可以在该函数中做一些初始化的动作。该函数前面也有三个关键字分别是JNIEXPORT，JNICALL ，jint。其中JNIEXPORT和JNICALL是两个宏定义，用于指定该函数时JNI函数。jint是JNI定义的数据类型，因为Java层和C/C++的数据类型或者对象不能直接相互的引用或者使用，JNI层定义了自己的数据类型，用于衔接Java层和JNI层。与JNI_OnLoad()函数相对应的有JNI_OnUnload()函数，当虚拟机释放的该C库的时候，则会调用JNI_OnUnload()函数来进行善后清除工作。</p>
<p>该函数会有两个参数，其中*jvm为Java虚拟机实例，JavaVM结构体定义一下函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DestroyJavaVM</span><br><span class="line">AttachCurrentThread</span><br><span class="line">DetachCurrentThread</span><br><span class="line">GetEnv</span><br></pre></td></tr></table></figure></p>
<p>举例说明，首先是加载so库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class JniDemo1&#123;</span><br><span class="line">       static &#123;</span><br><span class="line">             System.loadLibrary(&quot;samplelib_jni&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在jni中的实现，并且在这个函数里面去动态的注册native方法，完整的参考代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &quot;Log4Android.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">static const char *className = &quot;com/gebilaolitou/jnidemo/JNIDemo2&quot;;</span><br><span class="line"></span><br><span class="line">static void sayHello(JNIEnv *env, jobject, jlong handle) &#123;</span><br><span class="line">    LOGI(&quot;JNI&quot;, &quot;native: say hello ###&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static JNINativeMethod gJni_Methods_table[] = &#123;</span><br><span class="line">    &#123;&quot;sayHello&quot;, &quot;(J)V&quot;, (void*)sayHello&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int jniRegisterNativeMethods(JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;JNI&quot;,&quot;Registering %s natives\n&quot;, className);</span><br><span class="line">    clazz = (env)-&gt;FindClass( className);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;Native registration unable to find class &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    if ((env)-&gt;RegisterNatives(clazz, gJni_Methods_table, numMethods) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;RegisterNatives failed for &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (env)-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jint JNI_OnLoad(JavaVM* vm, void* reserved)&#123;</span><br><span class="line">    LOGI(&quot;JNI&quot;, &quot;enter jni_onload&quot;);</span><br><span class="line"></span><br><span class="line">    JNIEnv* env = NULL;</span><br><span class="line">    jint result = -1;</span><br><span class="line"></span><br><span class="line">    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jniRegisterNativeMethods(env, className, gJni_Methods_table, sizeof(gJni_Methods_table) / sizeof(JNINativeMethod));</span><br><span class="line"></span><br><span class="line">    return JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>我们一个个来说，首先看JNI_OnLoad函数的实现，里面代码很简单，主要就是两个代码块，一个是if语句，一个是jniRegisterNativeMethods函数的实现。那我们一个一个来分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123;</span><br><span class="line">    return result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了GetEnv函数时为了<strong>获取JNIEnv结构体指针</strong>，其实JNIEnv结构体指向了一个函数表，该函数表指向了对应的JNI函数，我们通过这些JNI函数实现JNI编程。</p>
<p>然后就调用了jniRegisterNativeMethods函数来实现注册，这里面注意一个静态变量gJni_Methods_table。它其实代表了一个native方法的数组，如果你在一个Java类中有一个native方法，这里它的size就是1，如果是两个native方法，它的size就是2，大家看下这个gJni_Methods_table变量的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod gJni_Methods_table[] = &#123;</span><br><span class="line">    &#123;&quot;sayHello&quot;, &quot;(J)V&quot;, (void*)sayHello&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们看到他的类型是JNINativeMethod ，那我们就来研究下JNINativeMethod</p>
<p>JNI允许我们提供一个<strong>函数映射表</strong>，注册给Java虚拟机，这样JVM就可以用函数映射表来调用相应的函数。这样就可以不必通过函数名来查找需要调用的函数了。Java与JNI通过JNINativeMethod的结构来建立联系，它被定义在jni.h中，其结构内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123; </span><br><span class="line">    const char* name; </span><br><span class="line">    const char* signature; </span><br><span class="line">    void* fnPtr; </span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure></p>
<p>这里面有3个变量，那我们就依次来讲解下：<br>第一个变量name，代表的是Java中的函数名<br>第二个变量signature，代表的是Java中的参数和返回值<br>第三个变量fnPtr，代表的是的指向C函数的函数指针</p>
<p>下面我们再来看下jniRegisterNativeMethods函数内部的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static int jniRegisterNativeMethods(JNIEnv* env, const char* className,</span><br><span class="line">    const JNINativeMethod* gMethods, int numMethods)</span><br><span class="line">&#123;</span><br><span class="line">    jclass clazz;</span><br><span class="line"></span><br><span class="line">    LOGI(&quot;JNI&quot;,&quot;Registering %s natives\n&quot;, className);</span><br><span class="line">    clazz = (env)-&gt;FindClass( className);</span><br><span class="line">    if (clazz == NULL) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;Native registration unable to find class &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int result = 0;</span><br><span class="line">    if ((env)-&gt;RegisterNatives(clazz, gJni_Methods_table, numMethods) &lt; 0) &#123;</span><br><span class="line">        LOGE(&quot;JNI&quot;,&quot;RegisterNatives failed for &apos;%s&apos;\n&quot;, className);</span><br><span class="line">        result = -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (env)-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过clazz = (env)-&gt;FindClass( className);找到声明native方法的类<br>然后通过调用<strong>RegisterNatives</strong>函数将注册函数的Java类，以及注册函数的数组，以及个数注册在一起，这样就实现了绑定。</p>
<p>上面在讲解JNINativeMethod结构体的时候，提到一个概念，就是”signature”即签名，我们下面就来讲解下。</p>
<h2 id="JNI中的签名"><a href="#JNI中的签名" class="headerlink" title="JNI中的签名"></a>JNI中的签名</h2><p>Java是支持函数重载的。但如果JNI仅仅是根据函数名，是没有办法找到重载的函数的，所以为了解决这个问题，JNI就衍生了一个概念——“签名”，即<strong>参数类型和返回值类型的组合</strong>。如果拥有一个该函数的签名信息和这个函数的函数名，我们就可以顺序的找到对应的Java层中的函数了。</p>
<h3 id="查看类中的方法的签名"><a href="#查看类中的方法的签名" class="headerlink" title="查看类中的方法的签名"></a>查看类中的方法的签名</h3><p>可以使用 java -p命令(建议使用该命令来对比签名)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">javap -s -p MainActivity.class</span><br><span class="line"></span><br><span class="line">Compiled from &quot;MainActivity.java&quot;</span><br><span class="line">public class com.example.hellojni.MainActivity extends android.app.Activity &#123;</span><br><span class="line">  static &#123;&#125;;</span><br><span class="line">    Signature: ()V</span><br><span class="line"></span><br><span class="line">  public com.example.hellojni.MainActivity();</span><br><span class="line">    Signature: ()V</span><br><span class="line"></span><br><span class="line">  protected void onCreate(android.os.Bundle);</span><br><span class="line">    Signature: (Landroid/os/Bundle;)V</span><br><span class="line"></span><br><span class="line">  public boolean onCreateOptionsMenu(android.view.Menu);</span><br><span class="line">    Signature: (Landroid/view/Menu;)Z</span><br><span class="line"></span><br><span class="line">  public native java.lang.String stringFromJNI(); //native 方法</span><br><span class="line">    Signature: ()Ljava/lang/String;  //签名</span><br><span class="line"></span><br><span class="line">  public native int max(int, int); //native 方法</span><br><span class="line">    Signature: (II)I    //签名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到上面有()V ，(Landroid/os/Bundle;)V，(Landroid/view/Menu;)Z，(II)I我们一脸懵逼，这是什么鬼，所以我们要来研究下签名的格式</p>
<h3 id="JNI定义的函数签名信息"><a href="#JNI定义的函数签名信息" class="headerlink" title="JNI定义的函数签名信息"></a>JNI定义的函数签名信息</h3><blockquote>
<p>(参数1类型标示；参数2类型标示；参数3类型标示…)返回值类型标示</p>
</blockquote>
<p>当参数为引用类型的时候，参数类型的标示的根式为”L包名”，其中包名的.(点)要换成”/“，看我上面的例子就差不多，比如String就是Ljava/lang/String，Menu为Landroid/view/Menu。</p>
<p>如果是基本类类型，其签名如下：</p>
<table>
<thead>
<tr>
<th>类型标示</th>
<th>Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
</tr>
</tbody>
</table>
<p>除了boolean和long，其他都是首字母大写。如果返回值是void，对应的签名是<strong>V</strong>。</p>
<p>这里重点说1个特殊的类型，一个是数组及Array:</p>
<table>
<thead>
<tr>
<th>类型标示</th>
<th>Java类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>[签名</td>
<td>数组</td>
</tr>
<tr>
<td>[i</td>
<td>int[]</td>
</tr>
<tr>
<td>[Ljava/lang/Object</td>
<td>String[]</td>
</tr>
</tbody>
</table>
<h2 id="Native调用Java代码"><a href="#Native调用Java代码" class="headerlink" title="Native调用Java代码"></a>Native调用Java代码</h2><p>上面讲解了如何从JNI中调用Java类中的方法，其实在jni.h中已经定义了一系列函数来实现这一目的，下面我们就以此举例说明：</p>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>为了能够在C/C++中调用Java中的类，jni.h的头文件专门定义了jclass类型表示Java中Class类。JNIEnv中有3个函数可以获取jclass。</p>
<blockquote>
<ul>
<li>jclass FindClass(const char* clsName)：<br>通过类的名称来获取jclass。</li>
<li>jclass GetObjectClass(jobject obj)：<br>通过对象实例来获取jclass，相当于Java中的getClass()函数</li>
<li>jclass getSuperClass(jclass obj)：<br>通过jclass可以获取其父类的jclass对象</li>
</ul>
</blockquote>
<p>通过类的名称获取jclass(类的全名，这时候包名不是用’”.”点号而是用”/“来区分的)。比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取Java中的String对象的class对象</span><br><span class="line">jclass jcl_string=env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br></pre></td></tr></table></figure></p>
<h3 id="获取属性方法"><a href="#获取属性方法" class="headerlink" title="获取属性方法"></a>获取属性方法</h3><p>为了在C/C++获取Java层的属性和方法，JNI在jni.h头文件中定义了jfieldID和jmethodID这两种类型来分别代表Java端的属性和方法。</p>
<p>常见的调用Java层的方法如下，一般是使用JNIEnv来进行操作：</p>
<blockquote>
<p>GetFieldID/GetMethodID：获取某个属性/某个方法<br>GetStaticFieldID/GetStaticMethodID：获取某个静态属性/静态方法</p>
</blockquote>
<p>方法的具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jfieldID GetFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jfieldID GetStaticFieldID(JNIEnv *env, jclass clazz, const char *name, const char *sig);</span><br><span class="line">jmethodID GetStaticMethodID(JNIEnv *env, jclass clazz,const char *name, const char *sig);</span><br></pre></td></tr></table></figure></p>
<p>他们都是4个入参，并且都一样。JNIEnv代表一个JNI环境接口，jclass上面也说了代表Java层中的”类”，name则代表方法名或者属性名，那最后一个char *sig代表签名。</p>
<h3 id="构造一个对象"><a href="#构造一个对象" class="headerlink" title="构造一个对象"></a>构造一个对象</h3><p>常用的JNI中创建对象的方法如下：</p>
<blockquote>
<p>jobject NewObject(jclass clazz, jmethodID methodID, …)</p>
</blockquote>
<p>比如有我们知道Java类中可能有多个构造函数，当我们要指定调用某个构造函数的时候，会调用下面这个方法，即把指定的构造函数传入进去即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmethodID mid = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">obj = (*env)-&gt;NewObject(env, cls, mid);</span><br></pre></td></tr></table></figure></p>
<p>现在我们来看下他上面的二个主要参数</p>
<blockquote>
<p>clazz：是需要创建的Java对象的Class对象<br>methodID：是传递一个方法ID，想一想Java对象创建的时候，需要执行什么操作？就是执行构造函数。</p>
</blockquote>
<p>有人会说这要走两行代码，有没有一行代码的，是有的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobject NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);</span><br></pre></td></tr></table></figure></p>
<p>这里多了一个参数，即jvalue *args，这里是args代表的是对应构造函数的所有参数的，我们可以应将传递给构造函数的所有参数放在jvalues类型的数组args中，该数组紧跟着放在methodID参数的后面。NewObject()收到数组中的这些参数后，将把它们传给所要调用的Java方法。</p>
<p>上面说到，参数是个数组，如果参数不是数组怎么处理，jni.h同样也提供了一个方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobject NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);</span><br></pre></td></tr></table></figure></p>
<p>这个方法和上面不同在于，这里将构造函数的所有参数放到在va_list类型的参数args中，该参数紧跟着放在methodID参数的后面。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>JNI获取类的成员变量的ID调用GetFieldID获取，通过Set[类型]Field修改变量值。</li>
<li>JNI获取类的静态变量的ID调用GetStaticFieldID获取，通过SetStatic[类型]Field修改变量值。</li>
<li>JNI获取类的方法的ID调用GetMethodID获取，通过Call[类型]Method调用方法。</li>
<li>JNI获取类的静态方法的ID调用GetStaticMethodID获取，通过CallStatic[类型]Method调用方法。</li>
<li>JNI获取类的构造方法的ID调用GetMethodID获取，通过NewObject构造，构造函数名为”<init>“。</init></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/b71aeb4ed13d" target="_blank" rel="noopener">https://www.jianshu.com/p/b71aeb4ed13d</a><br><a href="https://www.jianshu.com/p/0f34c097028a" target="_blank" rel="noopener">JNI学习Demo</a><br><a href="https://www.jianshu.com/p/83f3ec4f3ac1" target="_blank" rel="noopener">JNI访问Java变量和方法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/02/android-ndk-jni/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/02/android-ndk-jni/" itemprop="url">JNI 详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-02T10:40:44+08:00">
                2020-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-NDK/" itemprop="url" rel="index">
                    <span itemprop="name">Android NDK</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JNI，全称为Java Native Interface，即Java本地接口，JNI是Java调用Native 语言的一种特性。通过JNI可以使得Java与C/C++机型交互。即可以在Java代码中调用C/C++等语言的代码或者在C/C++代码中调用Java代码。由于JNI是JVM规范的一部分，因此可以将我们写的JNI的程序在任何实现了JNI规范的Java虚拟机中运行。</p>
<p>JNI的主要竞争优势在于：它在设计之初就确保了二进制的兼容性，JNI编写的应用程序兼容性以及其在某些具体平台上的Java虚拟机兼容性(当谈及JNI时，这里并不特比针对Davik虚拟机，JNI适用于所有JVM虚拟机)。这就是为什么C/C++编译后的代码无论在任何平台上都能执行。不过，一些早期版本并不支持二进制兼容。二进制兼容性是一种程序兼容性类型，允许一个程序在不改变其可执行文件的条件下在不同的编译环境中工作。</p>
<p>JNI下一共涉及到三个角色：C/C++代码、本地方法接口类、Java层中具体业务类。</p>
<h2 id="JNI的命名规则"><a href="#JNI的命名规则" class="headerlink" title="JNI的命名规则"></a>JNI的命名规则</h2><p>举例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNIExport jstring JNICALL Java_com_example_hellojni_MainActivity_stringFromJNI( JNIEnv* env,jobject thiz )</span><br></pre></td></tr></table></figure></p>
<p>jstring 是返回值类型<br>Java_com_example_hellojni 是包名<br>MainActivity 是类名<br>stringFromJNI 是方法名</p>
<p>其中JNIExport和JNICALL是不固定保留的关键字不要修改</p>
<h2 id="如何实现JNI"><a href="#如何实现JNI" class="headerlink" title="如何实现JNI"></a>如何实现JNI</h2><p>JNI开发流程的步骤：</p>
<blockquote>
<ul>
<li>第1步：在Java中先声明一个native方法</li>
<li>第2步：编译Java源文件javac得到.class文件</li>
<li>第3步：通过javah -jni命令导出JNI的.h头文件</li>
<li>第4步：使用Java需要交互的本地代码，实现在Java中声明的Native方法（如果Java需要与C++交互，那么就用C++实现Java的Native方法。）</li>
<li>第5步：将本地代码编译成动态库(Windows系统下是.dll文件，如果是Linux系统下是.so文件，如果是Mac系统下是.jnilib)</li>
<li>第6步：通过Java命令执行Java程序，最终实现Java调用本地代码。</li>
</ul>
</blockquote>
<p>PS：javah 是JDK自带的一个命令，-jni参数表示将class 中用到native 声明的函数生成JNI 规则的函数</p>
<p><img src="/2020/01/02/android-ndk-jni/jni-flow.webp" alt title="JNI开发流程"></p>
<h2 id="JNI结构"><a href="#JNI结构" class="headerlink" title="JNI结构"></a>JNI结构</h2><p><img src="/2020/01/02/android-ndk-jni/jni-struct.webp" alt title="JNI结构"><br>这张JNI函数表的组成就像C++的虚函数表。虚拟机可以运行多张函数表，举例来说，一张调试函数表，另一张是调用函数表。JNI接口指针仅在当前线程中起作用。这意味着指针不能从一个线程进入另一个线程。然而，可以在不同的线程中调用本地方法。</p>
<p><img src="/2020/01/02/android-ndk-jni/jni-interface.webp" alt title="JNI接口"></p>
<p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (JNIEnv *env, jobject obj, jint i, jstring s)</span><br><span class="line">&#123;</span><br><span class="line">     const char *str = (*env)-&gt;GetStringUTFChars(env, s, 0); </span><br><span class="line">     (*env)-&gt;ReleaseStringUTFChars(env, s, str); </span><br><span class="line">     return 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>里面的方法有三个入参，我们就依次来看下：</p>
<blockquote>
<ul>
<li>*env：一个接口指针</li>
<li>obj：在本地方法中声明的对象引用</li>
<li>i和s：用于传递的参数</li>
</ul>
</blockquote>
<p>关于obj、i和s的类型大家可以参考下面的JNI数据类型，JNI有自己的原始数据类型和数据引用类型如下：</p>
<p><img src="/2020/01/02/android-ndk-jni/jni-type.webp" alt></p>
<h2 id="JNI原理"><a href="#JNI原理" class="headerlink" title="JNI原理"></a>JNI原理</h2><p>Java语言的执行环境是Java虚拟机(JVM)，JVM其实是主机环境中的一个进程，每个JVM虚拟机都在本地环境中有一个JavaVM结构体，该结构体在创建Java虚拟机时被返回，在JNI环境中创建JVM的函数为JNI_CreateJavaVM。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JNI_CreateJavaVM(JavaVM **pvm, void **penv, void*args);</span><br></pre></td></tr></table></figure></p>
<h3 id="JavaVM"><a href="#JavaVM" class="headerlink" title="JavaVM"></a>JavaVM</h3><p>JavaVM是Java虚拟机在JNI层的代表，<strong>JNI全局仅仅有一个JavaVM结构中封装了一些函数指针（或叫函数表结构）</strong>，JavaVM中封装的这些函数指针主要是对JVM操作接口。另外，在C和C++中的JavaVM的定义有所不同，在C中JavaVM是JNIInvokeInterface_类型指针，而在C++中有对JNIInvokeInterface_进行了一次封装，比C中少了一个参数，这也是为什么JNI代码更推荐使用C++来编写的原因。</p>
<h3 id="JNIEnv"><a href="#JNIEnv" class="headerlink" title="JNIEnv"></a>JNIEnv</h3><p>JNIEnv是一个线程相关的结构体，该结构体代表了Java在本线程的执行环境。该 JNIEnv 将用于线程本地存储。因此，您<strong>无法在线程之间共享 JNIEnv</strong>。</p>
<p>一个JVM对应一个JavaVM结构，而一个JVM中可能创建多个Java线程，每个线程对应一个JNIEnv结构，它们保存在线程本地存储TLS中。因此，不同的线程的JNIEnv是不同，也不能相互共享使用。JNIEnv结构也是一个函数表，在本地代码中通过JNIEnv的函数表来操作Java数据或者调用Java方法。也就是说，只要在本地代码中拿到了JNIEnv结构，就可以在本地代码中调用Java代码。</p>
<h4 id="JNIEnv的作用"><a href="#JNIEnv的作用" class="headerlink" title="JNIEnv的作用"></a>JNIEnv的作用</h4><ul>
<li>调用Java 函数：JNIEnv代表了Java执行环境，能够使用JNIEnv调用Java中的代码</li>
<li>操作Java代码：Java对象传入JNI层就是jobject对象，需要使用JNIEnv来操作这个Java对象</li>
</ul>
<h4 id="JNIEnv的创建"><a href="#JNIEnv的创建" class="headerlink" title="JNIEnv的创建"></a>JNIEnv的创建</h4><p>JNIEnv 创建与释放：从JavaVM获得，这里面又分为C与C++，我们就依次来看下：</p>
<ul>
<li>C 中——JNIInvokeInterface：JNIInvokeInterface是C语言环境中的JavaVM结构体，调用 (*AttachCurrentThread)(JavaVM*, JNIEnv*, void) 方法，能够获得JNIEnv结构体</li>
<li>C++中 ——_JavaVM：_JavaVM是C++中JavaVM结构体，调用jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) 方法，能够获取JNIEnv结构体；</li>
</ul>
<h4 id="JNIEnv的释放"><a href="#JNIEnv的释放" class="headerlink" title="JNIEnv的释放"></a>JNIEnv的释放</h4><ul>
<li>C 中释放：调用JavaVM结构体JNIInvokeInterface中的(*DetachCurrentThread)(JavaVM*)方法，能够释放本线程的JNIEnv</li>
<li>C++ 中释放：调用JavaVM结构体_JavaVM中的jint DetachCurrentThread(){ return functions-&gt;DetachCurrentThread(this); } 方法，就可以释放 本线程的JNIEnv</li>
</ul>
<h4 id="JNIEnv与线程"><a href="#JNIEnv与线程" class="headerlink" title="JNIEnv与线程"></a>JNIEnv与线程</h4><p>JNIEnv是线程相关的，即在每一个线程中都有一个JNIEnv指针，每个JNIEnv都是线程专有的，其他线程不能使用本线程中的JNIEnv，即线程A不能调用线程B的JNIEnv。所以JNIEnv不能跨线程。</p>
<h4 id="JNIEnv结构"><a href="#JNIEnv结构" class="headerlink" title="JNIEnv结构"></a>JNIEnv结构</h4><p>JNIEnv是一个指针，指向一个线程相关的结构，线程相关结构指向JNI函数指针数组，这个数组中存放了大量的JNI函数指针，这些指针指向了详细的JNI函数：</p>
<p><img src="/2020/01/02/android-ndk-jni/jnienv-struct.webp" alt title="JNIEnv结构图"></p>
<h4 id="与JNIEnv相关的常用函数"><a href="#与JNIEnv相关的常用函数" class="headerlink" title="与JNIEnv相关的常用函数"></a>与JNIEnv相关的常用函数</h4><h5 id="创建Java中的对象"><a href="#创建Java中的对象" class="headerlink" title="创建Java中的对象"></a>创建Java中的对象</h5><blockquote>
<ul>
<li>jobject NewObject(JNIEnv *env, jclass clazz,jmethodID methodID, …)：</li>
<li>jobject NewObjectA(JNIEnv *env, jclass clazz,jmethodID methodID, const jvalue *args)：</li>
<li>jobject NewObjectV(JNIEnv *env, jclass clazz,jmethodID methodID, va_list args)：</li>
</ul>
</blockquote>
<p>第一个参数jclass class 代表的你要创建哪个类的对象，第二个参数,jmethodID methodID代表你要使用那个构造方法ID来创建这个对象。只要有jclass和jmethodID，我们就可以在本地方法创建这个Java类的对象。</p>
<h5 id="创建Java类中的String对象"><a href="#创建Java类中的String对象" class="headerlink" title="创建Java类中的String对象"></a>创建Java类中的String对象</h5><blockquote>
<p>jstring NewString(JNIEnv *env, const jchar *unicodeChars, jsize len)：</p>
</blockquote>
<p>通过Unicode字符的数组来创建一个新的String对象。<br>env是JNI接口指针；unicodeChars是指向Unicode字符串的指针；len是Unicode字符串的长度。返回值是Java字符串对象，如果无法构造该字符串，则为null。</p>
<p>那有没有一个直接直接new一个utf-8的字符串的方法呢？答案是有的，就是jstring NewStringUTF(JNIEnv *env, const char *bytes)这个方法就是直接new一个编码为utf-8的字符串。</p>
<h5 id="创建类型为基本类型PrimitiveType的数组"><a href="#创建类型为基本类型PrimitiveType的数组" class="headerlink" title="创建类型为基本类型PrimitiveType的数组"></a>创建类型为基本类型PrimitiveType的数组</h5><blockquote>
<p>ArrayType New<primitivetype>Array(JNIEnv *env, jsize length)</primitivetype></p>
</blockquote>
<p>指定一个长度然后返回相应的Java基本类型的数组。用于构造一个新的数组对象，类型是原始类型。基本的原始类型如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>New<primitivetype>Array Routines</primitivetype></td>
<td>Array Type</td>
</tr>
<tr>
<td>NewBooleanArray()</td>
<td>jbooleanArray</td>
</tr>
<tr>
<td>NewByteArray()</td>
<td>jbyteArray</td>
</tr>
<tr>
<td>NewCharArray()</td>
<td>jcharArray</td>
</tr>
<tr>
<td>NewShortArray()</td>
<td>jshortArray</td>
</tr>
<tr>
<td>NewIntArray()</td>
<td>jintArray</td>
</tr>
<tr>
<td>NewLongArray()</td>
<td>jlongArray</td>
</tr>
<tr>
<td>NewFloatArray()</td>
<td>jfloatArray</td>
</tr>
<tr>
<td>NewDoubleArray()</td>
<td>jdoubleArray</td>
</tr>
</tbody>
</table>
<h5 id="创建类型为elementClass的数组"><a href="#创建类型为elementClass的数组" class="headerlink" title="创建类型为elementClass的数组"></a>创建类型为elementClass的数组</h5><blockquote>
<p>jobjectArray NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement);</p>
</blockquote>
<p>造一个新的数据组，类型是elementClass，所有类型都被初始化为initialElement。</p>
<h5 id="获取数组中某个位置的元素"><a href="#获取数组中某个位置的元素" class="headerlink" title="获取数组中某个位置的元素"></a>获取数组中某个位置的元素</h5><blockquote>
<p>jobject GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index);</p>
</blockquote>
<p>返回Object数组的一个元素</p>
<h5 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h5><blockquote>
<p>jsize GetArrayLength(JNIEnv *env, jarray array);</p>
</blockquote>
<p>获取array数组的长度.</p>
<h5 id="GetArrayElements"><a href="#GetArrayElements" class="headerlink" title="GetArrayElements"></a>GetArrayElements</h5><blockquote>
<p>NativeType *Get<primitivetype>ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy);</primitivetype></p>
</blockquote>
<p>返回指向数组元素的指针，如果操作失败则返回NULL。</p>
<p>这是用来<strong>返回原生数据类型数组体的家族函数</strong>。函数返回的指针在调用对应的ReleaseArrayElements()函数之前都是有效的（就是指针指向的区域没有被释放，是可以使用的）。因为这个函数返回的数组可能是Java数组的一份拷贝，所以直到调用ReleaseArrayElements()方法，对返回的数组所做的修改才会反映到原始数组中。</p>
<p>GetArrayElements()函数的返回值是和JVM相关的，如果JVM的GC支持pin操作，那么返回值就是指向原始数组的指针；否则返回的就是原始数组的一份拷贝的首地址。</p>
<p>如果isCopy不为NULL，如果进行了复制，则*isCopy设置为JNI_TRUE; 如果没有复制，则设置为JNI_FALSE。</p>
<p>下表描述了特定的原始数组元素访问器。您应该进行以下替换：</p>
<blockquote>
<ul>
<li>将GetArrayElements替换为下表中的一个实际原始元素访问器例程名称。</li>
<li>将ArrayType替换为相应的数组类型。</li>
<li>将NativeType替换为该例程的相应本地类型。</li>
</ul>
</blockquote>
<p>无论如何在JVM中表示布尔数组，GetBooleanArrayElements()始终返回指向jbooleans的指针，每个字节表示一个元素（解包表示）。其他类型的所有数组都保证在内存中是连续的。</p>
<table>
<thead>
<tr>
<th>GetArrayElements例程</th>
<th>数组类型</th>
<th>本地类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>GetBooleanArrayElements()</td>
<td>jbooleanArray</td>
<td>jboolean</td>
</tr>
<tr>
<td>GetByteArrayElements()</td>
<td>jbyteArray</td>
<td>jbyte</td>
</tr>
<tr>
<td>GetCharArrayElements()    jcharArray</td>
<td>jchar</td>
</tr>
<tr>
<td>GetShortArrayElements()</td>
<td>jshortArray</td>
<td>jshort</td>
</tr>
<tr>
<td>GetIntArrayElements()</td>
<td>jintArray</td>
<td>jint</td>
</tr>
<tr>
<td>GetLongArrayElements()</td>
<td>jlongArray</td>
<td>jlong</td>
</tr>
<tr>
<td>GetFloatArrayElements()</td>
<td>jfloatArray</td>
<td>jfloat</td>
</tr>
<tr>
<td>GetDoubleArrayElements()</td>
<td>jdoubleArray</td>
<td>jdouble</td>
</tr>
</tbody>
</table>
<h5 id="ReleaseArrayElements"><a href="#ReleaseArrayElements" class="headerlink" title="ReleaseArrayElements"></a>ReleaseArrayElements</h5><blockquote>
<p>void Release<primitivetype>ArrayElements(JNIEnv *env, ArrayType array, NativeType *elems, jint mode);</primitivetype></p>
</blockquote>
<p>一系列函数，通知VM本地代码不再需要访问elems。elems参数是使用相应的GetArrayElements()函数从数组派生的指针。<strong>如有必要，此函数会将对elems所做的所有更改复制回原始数组</strong>。</p>
<p>mode参数提供有关如何释放数组缓冲区的信息。如果elems不是数组中元素的副本，则mode无效。否则，模式会产生以下影响，如下表所示：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>复制回内容并释放elems缓冲区</td>
</tr>
<tr>
<td>JNI_COMMIT</td>
<td>复制回内容，但不释放elems缓冲区</td>
</tr>
<tr>
<td>JNI_ABORT</td>
<td>释放缓冲区而不复制回可能的更改</td>
</tr>
</tbody>
</table>
<p>在大多数情况下，程序员<strong>将“0”传递给mode参数，以确保固定和复制数组的一致行为</strong>。其他选项使程序员可以更好地控制内存管理，并且应该非常谨慎地使用。</p>
<p>关于更多JNI的常用方法，文档可以参考 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp9502" target="_blank" rel="noopener">JNI Functions</a></p>
<h2 id="JNI的引用"><a href="#JNI的引用" class="headerlink" title="JNI的引用"></a>JNI的引用</h2><p>在JNI规范中定义了三种引用：局部引用（Local Reference）、全局引用（Global Reference）、弱全局引用（Weak Global Reference）。</p>
<h3 id="局部引用-Local-Reference"><a href="#局部引用-Local-Reference" class="headerlink" title="局部引用(Local Reference)"></a>局部引用(Local Reference)</h3><p>局部引用，也成本地引用，通常是在函数中创建并使用。会阻止GC回收所有引用对象。</p>
<p>最常见的引用类型，基本上通过JNI返回来的引用都是局部引用，例如使用NewObject，就会返回创建出来的实例的局部引用，局部引用值在该native函数有效，所有在该函数中产生的局部引用，都会<strong>在函数返回的时候自动释放(freed)，也可以使用DeleteLocalRef函数手动释放该应用</strong>。之所以使用DeleteLocalRef函数：实际上局部引用存在，就会防止其指向对象被垃圾回收期回收，尤其是当一个局部变量引用指向一个很庞大的对象，或是在一个循环中生成一个局部引用，最好的做法就是在使用完该对象后，或在该循环尾部把这个引用是释放掉，以确保在垃圾回收器被触发的时候被回收。在局部引用的有效期中，可以传递到别的本地函数中，要强调的是它的有效期仍然只是在第一次的Java本地函数调用中，所以千万不能用C++全部变量保存它或是把它定义为C++静态局部变量。</p>
<h3 id="全局引用-Global-Reference"><a href="#全局引用-Global-Reference" class="headerlink" title="全局引用(Global Reference)"></a>全局引用(Global Reference)</h3><p>全局引用可以跨方法、跨线程使用，直到被开发者<strong>显式释放</strong>。类似局部引用，一个全局引用在被释放前保证引用对象不被GC回收。能创建全部引用的函数只有NewGlobalRef，而释放它需要使用ReleaseGlobalRef函数</p>
<h3 id="弱全局引用-Weak-Global-Reference"><a href="#弱全局引用-Weak-Global-Reference" class="headerlink" title="弱全局引用(Weak Global Reference)"></a>弱全局引用(Weak Global Reference)</h3><p>与全局引用类似，创建跟删除都需要由编程人员来进行，不一样的是，弱引用将不会阻止垃圾回收期回收这个引用所指向的对象，所以在使用时需要多加小心，它所引用的对象可能是不存在的或者已经被回收。</p>
<p>通过使用NewWeakGlobalRef、ReleaseWeakGlobalRef来产生和解除引用。</p>
<h3 id="引用比较"><a href="#引用比较" class="headerlink" title="引用比较"></a>引用比较</h3><p>在给定两个引用，不管是什么引用，我们只需要调用IsSameObject函数来判断他们是否是指向相同的对象。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*env)-&gt;IsSameObject(env, obj1, obj2)</span><br></pre></td></tr></table></figure></p>
<p>如果obj1和obj2指向相同的对象，则返回JNI_TRUE(或者1)，否则返回JNI_FALSE(或者0),</p>
<p>PS：有一个特殊的引用需要注意：NULL，JNI中的NULL引用指向JVM中的null对象，如果obj是一个全局或者局部引用，使用(*env)-&gt;IsSameObject(env, obj, NULL)或者obj == NULL用来判断obj是否指向一个null对象即可。但是需要注意的是，IsSameObject用于弱全局引用与NULL比较时，返回值的意义是不同于局部引用和全局引用的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobject local_obj_ref = (*env)-&gt;NewObject(env, xxx_cls,xxx_mid);</span><br><span class="line">jobject g_obj_ref = (*env)-&gt;NewWeakGlobalRef(env, local_ref);</span><br><span class="line">// ... 业务逻辑处理</span><br><span class="line">jboolean isEqual = (*env)-&gt;IsSameObject(env, g_obj_ref, NULL);</span><br></pre></td></tr></table></figure></p>
<h2 id="UTF-8-和-UTF-16-字符串"><a href="#UTF-8-和-UTF-16-字符串" class="headerlink" title="UTF-8 和 UTF-16 字符串"></a>UTF-8 和 UTF-16 字符串</h2><p>Java 编程语言使用的是 UTF-16。为方便起见，JNI 还提供了使用修改后的 UTF-8 的方法。修改后的编码对 C 代码非常有用，因为它将 \u0000 编码为 0xc0 0x80，而不是 0x00。这样做的好处是，您可以依靠以零终止的 C 样式字符串，非常适合与标准 libc 字符串函数配合使用。但缺点是，您<strong>无法将任意 UTF-8 数据传递给 JNI 并期望它能够正常工作</strong>。</p>
<p>如果可能，使用 UTF-16 字符串执行操作通常会更快。Android 目前不需要 GetStringChars 的副本，而 GetStringUTFChars 需要分配和转换为 UTF-8。请注意，UTF-16 字符串不是以零终止的，并且允许使用 \u0000，因此您需要保留字符串长度和 jchar 指针。</p>
<p><strong>不要忘记 Release 您 Get 的字符串</strong>。字符串函数会返回 jchar* 或 jbyte*，它们是指向原始数据而非局部引用的 C 样式指针。这些指针在调用 Release 之前保证有效，这意味着在原生方法返回时不会释放这些指针。</p>
<p><strong>传递给 NewStringUTF 的数据必须采用修改后的 UTF-8 格式</strong>。一种常见的错误就是从文件或网络数据流中读取字符数据，并在未过滤的情况下将其传递给 NewStringUTF。除非您确定数据是有效的 MUTF-8（或 7 位 ASCII，这是一个兼容子集），否则您需要剔除无效字符或将它们转换为适当的修改后的 UTF-8 格式。如果不这样做，UTF-16 转换可能会产生意外的结果。CheckJNI 默认状态下为模拟器启用，它会扫描字符串并且在收到无效输入时会中止虚拟机。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/87ce6f565d37" target="_blank" rel="noopener">https://www.jianshu.com/p/87ce6f565d37</a><br><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html#wp9502" target="_blank" rel="noopener">JNI Functions</a><br><a href="https://www.jianshu.com/p/67081d9b0a9c" target="_blank" rel="noopener">JNI的常用方法的中文API</a><br><a href="https://developer.android.google.cn/training/articles/perf-jni#%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">JNI 提示</a><br><a href="https://blog.csdn.net/afei__/article/details/81290711" target="_blank" rel="noopener">Android NDK 从入门到精通（汇总篇）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/24/c-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/24/c-language/" itemprop="url">C 语言笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-24T14:30:18+08:00">
                2019-12-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C 语言是一种通用的高级语言，最初是由丹尼斯·里奇在贝尔实验室为开发 UNIX 操作系统而设计的。C 语言最开始是于 1972 年在 DEC PDP-11 计算机上被首次实现。</p>
<p>在 1978 年，布莱恩·柯林汉（Brian Kernighan）和丹尼斯·里奇（Dennis Ritchie）制作了 C 的第一个公开可用的描述，现在被称为 K&amp;R 标准。</p>
<ul>
<li>易于学习。</li>
<li>结构化语言。</li>
<li>它产生高效率的程序。</li>
<li>它可以处理底层的活动。</li>
<li>它可以在多种计算机平台上编译。</li>
</ul>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>C 程序主要包括以下部分：<br>1、预处理器指令<br>2、函数<br>3、变量<br>4、语句 &amp; 表达式<br>5、注释</p>
<p>让我们看一段简单的代码，可以输出单词 “Hello World”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   /* 我的第一个 C 程序 */</span><br><span class="line">   printf(&quot;Hello, World! \n&quot;);</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译 &amp; 执行 C 程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc hello.c</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure></p>
<p>a.out 为可执行文件，如果是多个 c 代码的源码文件，编译方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc test1.c test2.c -o main.out</span><br><span class="line">$ ./main.out</span><br></pre></td></tr></table></figure></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="C-的令牌（Tokens）"><a href="#C-的令牌（Tokens）" class="headerlink" title="C 的令牌（Tokens）"></a>C 的令牌（Tokens）</h3><p>C 程序由各种令牌组成，令牌可以是关键字、标识符、常量、字符串值，或者是一个符号。例如，下面的 C 语句包括五个令牌：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Hello, World! \n&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这五个令牌分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf</span><br><span class="line">(</span><br><span class="line">&quot;Hello, World! \n&quot;</span><br><span class="line">)</span><br><span class="line">;</span><br></pre></td></tr></table></figure></p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>C 标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p>
<p>C 标识符内不允许出现标点字符，比如 @、$ 和 %。C 是<strong>区分大小写</strong>的编程语言。因此，在 C 中，Manpower 和 manpower 是两个不同的标识符。下面列出几个有效的标识符：</p>
<blockquote>
<p>mohd       zara    abc   move_name  a_123<br>myname50   _temp   j     a23b9      retVal</p>
</blockquote>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下表列出了 C 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>声明自动变量</td>
</tr>
<tr>
<td>break</td>
<td>跳出当前循环</td>
</tr>
<tr>
<td>case</td>
<td>开关语句分支</td>
</tr>
<tr>
<td>char</td>
<td>声明字符型变量或函数返回值类型</td>
</tr>
<tr>
<td>const</td>
<td>声明只读变量</td>
</tr>
<tr>
<td>continue</td>
<td>结束当前循环，开始下一轮循环</td>
</tr>
<tr>
<td>default</td>
<td>开关语句中的”其它”分支</td>
</tr>
<tr>
<td>do</td>
<td>循环语句的循环体</td>
</tr>
<tr>
<td>double</td>
<td>声明双精度浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td>else</td>
<td>条件语句否定分支（与 if 连用）</td>
</tr>
<tr>
<td>enum</td>
<td>声明枚举类型</td>
</tr>
<tr>
<td>extern</td>
<td>声明变量或函数是在其它文件或本文件的其他位置定义</td>
</tr>
<tr>
<td>float</td>
<td>声明浮点型变量或函数返回值类型</td>
</tr>
<tr>
<td>for</td>
<td>一种循环语句</td>
</tr>
<tr>
<td>goto</td>
<td>无条件跳转语句</td>
</tr>
<tr>
<td>if</td>
<td>条件语句</td>
</tr>
<tr>
<td>int</td>
<td>声明整型变量或函数</td>
</tr>
<tr>
<td>long</td>
<td>声明长整型变量或函数返回值类型</td>
</tr>
<tr>
<td>register</td>
<td>声明寄存器变量</td>
</tr>
<tr>
<td>return</td>
<td>子程序返回语句（可以带参数，也可不带参数）</td>
</tr>
<tr>
<td>short</td>
<td>声明短整型变量或函数</td>
</tr>
<tr>
<td>signed</td>
<td>声明有符号类型变量或函数</td>
</tr>
<tr>
<td>sizeof</td>
<td>计算数据类型或变量长度（即所占字节数）</td>
</tr>
<tr>
<td>static</td>
<td>声明静态变量</td>
</tr>
<tr>
<td>struct</td>
<td>声明结构体类型</td>
</tr>
<tr>
<td>switch</td>
<td>用于开关语句</td>
</tr>
<tr>
<td>typedef</td>
<td>用以给数据类型取别名</td>
</tr>
<tr>
<td>unsigned</td>
<td>声明无符号类型变量或函数</td>
</tr>
<tr>
<td>union</td>
<td>声明共用体类型</td>
</tr>
<tr>
<td>void</td>
<td>声明函数无返回值或无参数，声明无类型指针</td>
</tr>
<tr>
<td>volatile</td>
<td>说明变量在程序执行中可被隐含地改变</td>
</tr>
<tr>
<td>while</td>
<td>循环语句的循环条件</td>
</tr>
</tbody>
</table>
<p>C99 新增关键字：<br>_Bool    _Complex    _Imaginary    inline    restrict</p>
<p>C11 新增关键字：<br>_Alignas    _Alignof    _Atomic    _Generic    _Noreturn<br>_Static_assert    _Thread_local          </p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。</p>
<p>C 中的类型可分为以下几种：</p>
<style>
table th:nth-of-type(1) {
    width: 100px;
}
</style>

<table>
<thead>
<tr>
<th>序号</th>
<th>类型与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。</td>
</tr>
<tr>
<td>2</td>
<td>枚举类型：它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。</td>
</tr>
<tr>
<td>3</td>
<td>void 类型：类型说明符 void 表明没有可用的值。</td>
</tr>
<tr>
<td>4</td>
<td>派生类型：它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。</td>
</tr>
</tbody>
</table>
<p>数组类型和结构类型统称为聚合类型。函数的类型指的是函数返回值的类型。     </p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>下表列出了关于标准整数类型的存储大小和值范围的细节：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>1 字节</td>
<td>-128 到 127 或 0 到 255</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1 字节</td>
<td>0 到 255</td>
</tr>
<tr>
<td>signed char</td>
<td>1 字节</td>
<td>-128 到 127</td>
</tr>
<tr>
<td>int</td>
<td>2 或 4 字节</td>
<td>-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>unsigned int</td>
<td>2 或 4 字节</td>
<td>0 到 65,535 或 0 到 4,294,967,295</td>
</tr>
<tr>
<td>short</td>
<td>2 字节</td>
<td>-32,768 到 32,767</td>
</tr>
<tr>
<td>unsigned short</td>
<td>2 字节</td>
<td>0 到 65,535</td>
</tr>
<tr>
<td>long</td>
<td>4 字节</td>
<td>-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>unsigned long</td>
<td>4 字节</td>
<td>0 到 4,294,967,295</td>
</tr>
</tbody>
</table>
<p>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。为了得到某个类型或某个变量在特定平台上的准确大小，您可以使用 sizeof 运算符。表达式 sizeof(type) 得到对象或类型的存储字节大小。</p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小</th>
<th>值范围</th>
<th>精度</th>
</tr>
</thead>
<tbody>
<tr>
<td>float</td>
<td>4 字节</td>
<td>1.2E-38 到 3.4E+38</td>
<td>6 位小数</td>
</tr>
<tr>
<td>double</td>
<td>8 字节</td>
<td>2.3E-308 到 1.7E+308</td>
<td>15 位小数</td>
</tr>
<tr>
<td>long double</td>
<td>16 字节</td>
<td>3.4E-4932 到 1.1E+4932</td>
<td>19 位小数</td>
</tr>
</tbody>
</table>
<h3 id="void-类型"><a href="#void-类型" class="headerlink" title="void 类型"></a>void 类型</h3><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>类型与描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>函数返回为空：C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);</td>
</tr>
<tr>
<td>2</td>
<td>函数参数为空：C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);</td>
</tr>
<tr>
<td>3</td>
<td>指针指向 void：类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。</td>
</tr>
</tbody>
</table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。</p>
<h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：</p>
<blockquote>
<p>type variable_list;</p>
</blockquote>
<p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>
<p>变量的声明有两种情况：<br>1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。<br>2、另一种是<strong>不需要建立存储空间</strong>的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。</p>
<p>除非有extern关键字，否则都是变量的定义:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int i; //声明，不是定义</span><br><span class="line">int i; //声明，也是定义</span><br></pre></td></tr></table></figure></p>
<p>如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><p>整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。</p>
<p>整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。</p>
<p>以下是各种类型的整数常量的实例：</p>
<pre><code>85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
</code></pre><h3 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h3><p>浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。</p>
<p>当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。</p>
<p>下面列举几个浮点常量的实例：</p>
<pre><code>3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
.e55          /* 非法的：缺少整数或分数 */
</code></pre><h3 id="字符常量-字符串常量"><a href="#字符常量-字符串常量" class="headerlink" title="字符常量/字符串常量"></a>字符常量/字符串常量</h3><p>字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\t’），或一个通用的字符（例如 ‘\u02C0’）。</p>
<p>在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\n）或制表符（\t）等。</p>
<p>字符串字面值或常量是括在双引号 “” 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。您可以使用空格做分隔符，把一个很长的字符串常量进行分行。</p>
<h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><p>在 C 中，有两种简单的定义常量的方式：<br>1、使用 #define 预处理器。<br>2、使用 const 关键字。</p>
<p><strong>#define 预处理器</strong><br>下面是使用 #define 预处理器定义常量的形式：</p>
<blockquote>
<p>#define identifier value</p>
</blockquote>
<p><strong>const 关键字</strong><br>您可以使用 const 前缀声明指定类型的常量，如下所示：</p>
<blockquote>
<p>const type variable = value;</p>
</blockquote>
<h2 id="存储类"><a href="#存储类" class="headerlink" title="存储类"></a>存储类</h2><p>存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：</p>
<ul>
<li>auto</li>
<li>register</li>
<li>static</li>
<li>extern</li>
</ul>
<h3 id="auto-存储类"><a href="#auto-存储类" class="headerlink" title="auto 存储类"></a>auto 存储类</h3><p>auto 存储类是所有局部变量默认的存储类。</p>
<pre><code>{
   int mount;
   auto int month;
}
</code></pre><p>上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。</p>
<h3 id="register-存储类"><a href="#register-存储类" class="headerlink" title="register 存储类"></a>register 存储类</h3><p>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。</p>
<pre><code>{
   register int  miles;
}
</code></pre><p><strong>寄存器只用于需要快速访问的变量，比如计数器</strong>。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着<strong>变量可能存储在寄存器中</strong>，这取决于硬件和实现的限制。</p>
<h3 id="static-存储类"><a href="#static-存储类" class="headerlink" title="static 存储类"></a>static 存储类</h3><p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
<p>static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。</p>
<p>以下实例演示了 static 修饰全局变量和局部变量的应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void func1(void);</span><br><span class="line"> </span><br><span class="line">static int count=10;        /* 全局变量 - static 是默认的 */</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  while (count--) &#123;</span><br><span class="line">      func1();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void func1(void)</span><br><span class="line">&#123;</span><br><span class="line">/* &apos;thingy&apos; 是 &apos;func1&apos; 的局部变量 - 只初始化一次</span><br><span class="line"> * 每次调用函数 &apos;func1&apos; &apos;thingy&apos; 值不会被重置。</span><br><span class="line"> */                </span><br><span class="line">  static int thingy=5;</span><br><span class="line">  thingy++;</span><br><span class="line">  printf(&quot; thingy 为 %d ， count 为 %d\n&quot;, thingy, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"> thingy 为 6 ， count 为 9</span><br><span class="line"> thingy 为 7 ， count 为 8</span><br><span class="line"> thingy 为 8 ， count 为 7</span><br><span class="line"> thingy 为 9 ， count 为 6</span><br><span class="line"> thingy 为 10 ， count 为 5</span><br><span class="line"> thingy 为 11 ， count 为 4</span><br><span class="line"> thingy 为 12 ， count 为 3</span><br><span class="line"> thingy 为 13 ， count 为 2</span><br><span class="line"> thingy 为 14 ， count 为 1</span><br><span class="line"> thingy 为 15 ， count 为 0</span><br></pre></td></tr></table></figure></p>
<h3 id="extern-存储类"><a href="#extern-存储类" class="headerlink" title="extern 存储类"></a>extern 存储类</h3><p>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。</p>
<p>当您有<strong>多个文件</strong>且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，<strong>extern 是用来在另一个文件中声明一个全局变量或函数。</strong></p>
<p>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//第一个文件：main.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int count ;</span><br><span class="line">extern void write_extern();</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   count = 5;</span><br><span class="line">   write_extern();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//第二个文件：support.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">extern int count;</span><br><span class="line"> </span><br><span class="line">void write_extern(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;count is %d\n&quot;, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.c 中定义的 count。现在 ，编译这两个文件，如下所示：</span><br><span class="line"> $ gcc main.c support.c</span><br><span class="line">//这会产生 a.out 可执行程序，当程序被执行时，它会产生下列结果：</span><br><span class="line">count is 5</span><br></pre></td></tr></table></figure></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>杂项运算符</li>
</ul>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>if…else 语句<br>switch 语句<br>? : 运算符(三元运算符)</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>while 循环<br>do…while 循环<br>for 循环</p>
<p>控制语句包括：break 语句、continue 语句、goto 语句    </p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C 语言中的函数定义的一般形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name( parameter list )</span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p>
<p>函数声明包括以下几个部分：</p>
<blockquote>
<p>return_type function_name( parameter list );</p>
</blockquote>
<p>针对上面定义的函数 max()，以下是函数声明：</p>
<blockquote>
<p>int max(int num1, int num2);</p>
</blockquote>
<p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明：</p>
<blockquote>
<p>int max(int, int);</p>
</blockquote>
<p>当您<strong>在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的</strong>。在这种情况下，您应该在调用函数的文件顶部声明函数。</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量，这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>
<p>当调用函数时，有两种向函数传递参数的方式：</p>
<table>
<thead>
<tr>
<th>调用类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>传值调用</td>
<td>该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。</td>
</tr>
<tr>
<td>引用调用</td>
<td>通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。</td>
</tr>
</tbody>
</table>
<p><strong>默认情况下，C 使用传值调用来传递参数</strong>。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>全局变量与局部变量在内存中的区别：<br>1、全局变量保存在内存的全局存储区中，占用静态的存储单元；<br>2、局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。</p>
<p>当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化。</p>
<p>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p>
<p>在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>
<blockquote>
<p>type arrayName [ arraySize ];</p>
</blockquote>
<h2 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h2><p>在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的。</p>
<p>枚举语法定义格式为：</p>
<blockquote>
<p>enum　枚举名　{枚举元素1,枚举元素2,……};</p>
</blockquote>
<p>使用枚举的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
<p>可以在定义枚举类型时改变枚举元素的值：</p>
<blockquote>
<p>enum season {spring, summer=3, autumn, winter};</p>
</blockquote>
<p>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p>
<h3 id="枚举变量的定义"><a href="#枚举变量的定义" class="headerlink" title="枚举变量的定义"></a>枚举变量的定义</h3><p>前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。</p>
<p>我们可以通过以下三种方式来定义枚举变量</p>
<p>1、先定义枚举类型，再定义枚举变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br><span class="line">enum DAY day;</span><br></pre></td></tr></table></figure></p>
<p>2、定义枚举类型的同时定义枚举变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure></p>
<p>3、省略枚举名称，直接定义枚举变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">      MON=1, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125; day;</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>按照 C 语言规范是没有办法遍历枚举类型的。不过在一些特殊的情况下，枚举类型<strong>必须连续</strong>是可以实现有条件的遍历。</p>
<p>也可以将整数转换为枚举。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。</p>
<p>请看下面的实例，它将输出定义的变量地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int  var1;</span><br><span class="line">   char var2[10];</span><br><span class="line"> </span><br><span class="line">   printf(&quot;var1 变量的地址： %p\n&quot;, &amp;var1  );</span><br><span class="line">   printf(&quot;var2 变量的地址： %p\n&quot;, &amp;var2  );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">var1 变量的地址： 0x7fff5cc109d4</span><br><span class="line">var2 变量的地址： 0x7fff5cc109de</span><br></pre></td></tr></table></figure></p>
<h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><p>指针<strong>是一个变量，其值为另一个变量的地址，即内存位置的直接地址</strong>。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>
<blockquote>
<p>type *var-name;</p>
</blockquote>
<p>所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应<strong>指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数</strong>。</p>
<p>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。</p>
<h3 id="如何使用指针？"><a href="#如何使用指针？" class="headerlink" title="如何使用指针？"></a>如何使用指针？</h3><p>使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int  var = 20;   /* 实际变量的声明 */</span><br><span class="line">   int  *ip;        /* 指针变量的声明 */</span><br><span class="line"> </span><br><span class="line">   ip = &amp;var;  /* 在指针变量中存储 var 的地址 */</span><br><span class="line"> </span><br><span class="line">   printf(&quot;Address of var variable: %p\n&quot;, &amp;var  );</span><br><span class="line"> </span><br><span class="line">   /* 在指针变量中存储的地址 */</span><br><span class="line">   printf(&quot;Address stored in ip variable: %p\n&quot;, ip );</span><br><span class="line"> </span><br><span class="line">   /* 使用指针访问值 */</span><br><span class="line">   printf(&quot;Value of *ip variable: %d\n&quot;, *ip );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Address of var variable: bffd8b3c</span><br><span class="line">Address stored in ip variable: bffd8b3c</span><br><span class="line">Value of *ip variable: 20</span><br></pre></td></tr></table></figure></p>
<h3 id="C-中的-NULL-指针"><a href="#C-中的-NULL-指针" class="headerlink" title="C 中的 NULL 指针"></a>C 中的 NULL 指针</h3><p>在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。</p>
<p>NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   int  *ptr = NULL;</span><br><span class="line"> </span><br><span class="line">   printf(&quot;ptr 的地址是 %p\n&quot;, ptr  );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">ptr 的地址是 0x0</span><br></pre></td></tr></table></figure></p>
<p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。</p>
<p>如需检查一个空指针，您可以使用 if 语句，如下所示：</p>
<pre><code>if(ptr)     /* 如果 p 非空，则完成 */
if(!ptr)    /* 如果 p 为空，则完成 */
</code></pre><h3 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p>
<p>一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：</p>
<blockquote>
<p>int **var;</p>
</blockquote>
<h2 id="函数指针与回调函数"><a href="#函数指针与回调函数" class="headerlink" title="函数指针与回调函数"></a>函数指针与回调函数</h2><p>函数指针是指向函数的指针变量。</p>
<p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。函数指针可以像一般函数一样，用于调用函数、传递参数。</p>
<p>函数指针变量的声明：</p>
<blockquote>
<p>typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型</p>
</blockquote>
<p>以下实例声明了函数指针变量 p，指向函数 max：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int max(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /* p 是函数指针 */</span><br><span class="line">    int (* p)(int, int) = &amp; max; // &amp;可以省略</span><br><span class="line">    int a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;请输入三个数字:&quot;);</span><br><span class="line">    scanf(&quot;%d %d %d&quot;, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    /* 与直接调用函数等价，d = max(max(a, b), c) */</span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    printf(&quot;最大的数字是: %d\n&quot;, d);</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">请输入三个数字:1 2 3</span><br><span class="line">最大的数字是: 3</span><br></pre></td></tr></table></figure></p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数指针作为某个函数的参数，回调函数就是一个通过函数指针调用的函数。</p>
<p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p>
<p>实例中 populate_array 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">// 回调函数</span><br><span class="line">void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))</span><br><span class="line">&#123;</span><br><span class="line">    for (size_t i=0; i&lt;arraySize; i++)</span><br><span class="line">        array[i] = getNextValue();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 获取随机值</span><br><span class="line">int getNextRandomValue(void)</span><br><span class="line">&#123;</span><br><span class="line">    return rand();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int myarray[10];</span><br><span class="line">    populate_array(myarray, 10, getNextRandomValue);</span><br><span class="line">    for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, myarray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709</span><br></pre></td></tr></table></figure></p>
<h2 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C 字符串"></a>C 字符串</h2><p>在 C 语言中，<strong>字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组</strong>。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>
<p>下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。</p>
<blockquote>
<p>char greeting[6] = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘\0’};</p>
</blockquote>
<p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p>
<blockquote>
<p>char greeting[] = “Hello”;</p>
</blockquote>
<p>其实，您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。</p>
<p>C 中有大量操作字符串的函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>strcpy(s1, s2)</td>
<td>复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td>strcat(s1, s2)</td>
<td>连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td>strlen(s1)</td>
<td>返回字符串 s1 的长度。</td>
</tr>
<tr>
<td>strcmp(s1, s2)</td>
<td>如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。</s2></td>
</tr>
<tr>
<td>strchr(s1, ch)</td>
<td>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td>strstr(s1, s2)</td>
<td>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody>
</table>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构是 C 编程中一种用户自定义的可用的数据类型，它允许您<strong>存储不同类型的数据项</strong>。</p>
<p>为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct tag &#123; </span><br><span class="line">    member-list</span><br><span class="line">    member-list </span><br><span class="line">    member-list  </span><br><span class="line">    ...</span><br><span class="line">&#125; variable-list ;</span><br></pre></td></tr></table></figure></p>
<p>tag 是结构体标签。<br>member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。<br>variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125; book;</span><br></pre></td></tr></table></figure></p>
<p>在一般情况下，tag、member-list、variable-list 这 3 部分至少要出现 2 个。以下为实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//同时又声明了结构体变量s1</span><br><span class="line">//这个结构体并没有标明其标签</span><br><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125; s1;</span><br><span class="line"> </span><br><span class="line">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span><br><span class="line">//结构体的标签被命名为SIMPLE,没有声明变量</span><br><span class="line">struct SIMPLE</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125;;</span><br><span class="line">//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span><br><span class="line">struct SIMPLE t1, t2[20], *t3;</span><br><span class="line"> </span><br><span class="line">//也可以用typedef创建新类型</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    double c; </span><br><span class="line">&#125; Simple2;</span><br><span class="line">//现在可以用Simple2作为类型声明新的结构体变量</span><br><span class="line">Simple2 u1, u2[20], *u3;</span><br></pre></td></tr></table></figure></p>
<p>在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&amp;s1，则是非法的。</p>
<p>结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//此结构体的声明包含了其他的结构体</span><br><span class="line">struct COMPLEX</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct SIMPLE a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//此结构体的声明包含了指向自己类型的指针</span><br><span class="line">struct NODE</span><br><span class="line">&#123;</span><br><span class="line">    char string[100];</span><br><span class="line">    struct NODE *next_node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果<strong>两个结构体互相包含，则需要对其中一个结构体进行不完整声明</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct B;    //对结构体B进行不完整声明</span><br><span class="line"> </span><br><span class="line">//结构体A中包含指向结构体B的指针</span><br><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line">    struct B *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明</span><br><span class="line">struct B</span><br><span class="line">&#123;</span><br><span class="line">    struct A *partner;</span><br><span class="line">    //other members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h3><p>和其它类型变量一样，对结构体变量可以在定义时指定初始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125; book = &#123;&quot;C 语言&quot;, &quot;RUNOOB&quot;, &quot;编程语言&quot;, 123456&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;, book.title, book.author, book.subject, book.book_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行输出结果为：</span><br><span class="line">title : C 语言</span><br><span class="line">author: RUNOOB</span><br><span class="line">subject: 编程语言</span><br><span class="line">book_id: 123456</span><br></pre></td></tr></table></figure></p>
<h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><p>您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：</p>
<blockquote>
<p>struct Books *struct_pointer;</p>
</blockquote>
<p>现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示：</p>
<blockquote>
<p>struct_pointer = &Book1;</p>
</blockquote>
<p>为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示：</p>
<blockquote>
<p>struct_pointer-&gt;title;</p>
</blockquote>
<p>实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* 函数声明 */</span><br><span class="line">void printBook( struct Books *book );</span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   struct Books Book1;        /* 声明 Book1，类型为 Books */</span><br><span class="line">   struct Books Book2;        /* 声明 Book2，类型为 Books */</span><br><span class="line"> </span><br><span class="line">   /* Book1 详述 */</span><br><span class="line">   strcpy( Book1.title, &quot;C Programming&quot;);</span><br><span class="line">   strcpy( Book1.author, &quot;Nuha Ali&quot;); </span><br><span class="line">   strcpy( Book1.subject, &quot;C Programming Tutorial&quot;);</span><br><span class="line">   Book1.book_id = 6495407;</span><br><span class="line"> </span><br><span class="line">   /* Book2 详述 */</span><br><span class="line">   strcpy( Book2.title, &quot;Telecom Billing&quot;);</span><br><span class="line">   strcpy( Book2.author, &quot;Zara Ali&quot;);</span><br><span class="line">   strcpy( Book2.subject, &quot;Telecom Billing Tutorial&quot;);</span><br><span class="line">   Book2.book_id = 6495700;</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book1 的地址来输出 Book1 信息 */</span><br><span class="line">   printBook( &amp;Book1 );</span><br><span class="line"> </span><br><span class="line">   /* 通过传 Book2 的地址来输出 Book2 信息 */</span><br><span class="line">   printBook( &amp;Book2 );</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line">void printBook( struct Books *book )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;Book title : %s\n&quot;, book-&gt;title);</span><br><span class="line">   printf( &quot;Book author : %s\n&quot;, book-&gt;author);</span><br><span class="line">   printf( &quot;Book subject : %s\n&quot;, book-&gt;subject);</span><br><span class="line">   printf( &quot;Book book_id : %d\n&quot;, book-&gt;book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>有些信息在存储时，<strong>并不需要占用一个完整的字节，而只需占几个或一个二进制位</strong>。例如在存放一个开关量时，只有 0 和 1 两种状态，用 1 位二进位即可。为了节省存储空间，并使处理简便，C 语言又提供了一种数据结构，称为”位域”或”位段”。</p>
<p>所谓”位域”是把一个字节中的二进位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示。</p>
<p>典型的实例：<br>1、用 1 位二进位存放一个开关量时，只有 0 和 1 两种状态。<br>2、读取外部文件格式——可以读取非标准的文件格式。例如：9 位的整数。</p>
<p>位域定义与结构定义相仿，其形式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  type [member_name] : width ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>type：只能为 int(整型)，unsigned int(无符号整型)，signed int(有符号整型) 三种类型，决定了如何解释位域的值。<br>member_name：位域的名称。<br>width：位域中位的数量。宽度必须小于或等于指定类型的位宽度。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//data 为 bs 变量，共占两个字节。其中位域 a 占 8 位，位域 b 占 2 位，位域 c 占 6 位。</span><br><span class="line">struct bs&#123;</span><br><span class="line">    int a:8;</span><br><span class="line">    int b:2;</span><br><span class="line">    int c:6;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure></p>
<h3 id="位域说明"><a href="#位域说明" class="headerlink" title="位域说明"></a>位域说明</h3><p>1、一个位域存储在同一个字节中，如一个字节所剩空间不够存放另一位域时，则会从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//在这个位域定义中，a 占第一字节的 4 位，后 4 位填 0 表示不使用，b 从第二字节开始，占用 4 位，c 占用 4 位。</span><br><span class="line">struct bs&#123;</span><br><span class="line">    unsigned a:4;</span><br><span class="line">    unsigned  :4;    /* 空域 */</span><br><span class="line">    unsigned b:4;    /* 从下一单元开始存放 */</span><br><span class="line">    unsigned c:4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、由于<strong>位域不允许跨两个字节</strong>，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位。如果最大长度大于计算机的整数字长，一些编译器可能会允许域的内存重叠，另外一些编译器可能会把大于一个域的部分存储在下一个字中。</p>
<p>3、位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct k&#123;</span><br><span class="line">    int a:1;</span><br><span class="line">    int  :2;    /* 该 2 位不能使用 */</span><br><span class="line">    int b:3;</span><br><span class="line">    int c:2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从以上分析可以看出，<strong>位域在本质上就是一种结构类型，不过其成员是按二进位分配的</strong>。</p>
<h3 id="位域的使用"><a href="#位域的使用" class="headerlink" title="位域的使用"></a>位域的使用</h3><p>位域的使用和结构成员的使用相同，其一般形式为：</p>
<blockquote>
<p>位域变量名.位域名<br>位域变量名-&gt;位域名</p>
</blockquote>
<p>位域允许用各种格式输出。</p>
<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体是一种特殊的数据类型，<strong>允许您在相同的内存位置存储不同的数据类型，但任何时候只能有一个成员带有值</strong>。共用体提供了一种使用相同的内存位置的有效方式。</p>
<p>共用体占用的内存应足够存储共用体中最大的成员。</p>
<p>为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union [union tag]</span><br><span class="line">&#123;</span><br><span class="line">   member definition;</span><br><span class="line">   member definition;</span><br><span class="line">   ...</span><br><span class="line">   member definition;</span><br><span class="line">&#125; [one or more union variables];</span><br></pre></td></tr></table></figure></p>
<p>union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。</p>
<p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">union Data</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char  str[20];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   union Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = 10;</span><br><span class="line">   data.f = 220.5;</span><br><span class="line">   strcpy( data.str, &quot;C Programming&quot;);</span><br><span class="line"> </span><br><span class="line">   printf( &quot;data.i : %d\n&quot;, data.i);</span><br><span class="line">   printf( &quot;data.f : %f\n&quot;, data.f);</span><br><span class="line">   printf( &quot;data.str : %s\n&quot;, data.str);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">data.i : 1917853763</span><br><span class="line">data.f : 4122360580327794860452759994368.000000</span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">union Data</span><br><span class="line">&#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char  str[20];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   union Data data;        </span><br><span class="line"> </span><br><span class="line">   data.i = 10;</span><br><span class="line">   printf( &quot;data.i : %d\n&quot;, data.i);</span><br><span class="line">   </span><br><span class="line">   data.f = 220.5;</span><br><span class="line">   printf( &quot;data.f : %f\n&quot;, data.f);</span><br><span class="line">   </span><br><span class="line">   strcpy( data.str, &quot;C Programming&quot;);</span><br><span class="line">   printf( &quot;data.str : %s\n&quot;, data.str);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">data.i : 10</span><br><span class="line">data.f : 220.500000</span><br><span class="line">data.str : C Programming</span><br></pre></td></tr></table></figure></p>
<p>在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。</p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>C 语言提供了 typedef 关键字，您可以使用它来<strong>为类型取一个新的名字</strong>。下面的实例为单字节数字定义了一个术语 BYTE(按照惯例定义时会大写字母，但也可以使用小写字母)：</p>
<blockquote>
<p>typedef unsigned char BYTE;</p>
</blockquote>
<p>在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如：</p>
<blockquote>
<p>BYTE  b1, b2;</p>
</blockquote>
<p>也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">typedef struct Books</span><br><span class="line">&#123;</span><br><span class="line">   char  title[50];</span><br><span class="line">   char  author[50];</span><br><span class="line">   char  subject[100];</span><br><span class="line">   int   book_id;</span><br><span class="line">&#125; Book;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   Book book;</span><br><span class="line"> </span><br><span class="line">   strcpy( book.title, &quot;C 教程&quot;);</span><br><span class="line">   strcpy( book.author, &quot;Runoob&quot;); </span><br><span class="line">   strcpy( book.subject, &quot;编程语言&quot;);</span><br><span class="line">   book.book_id = 12345;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;书标题 : %s\n&quot;, book.title);</span><br><span class="line">   printf( &quot;书作者 : %s\n&quot;, book.author);</span><br><span class="line">   printf( &quot;书类目 : %s\n&quot;, book.subject);</span><br><span class="line">   printf( &quot;书 ID : %d\n&quot;, book.book_id);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="typedef-vs-define"><a href="#typedef-vs-define" class="headerlink" title="typedef vs #define"></a>typedef vs #define</h3><p>#define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同：</p>
<ul>
<li>typedef 仅限于为类型定义符号名称，<strong>#define 不仅可以为类型定义别名，也能为数值定义别名</strong>，比如您可以定义 1 为 ONE。</li>
<li>typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。</li>
</ul>
<p>下面是 #define 的最简单的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">#define TRUE  1</span><br><span class="line">#define FALSE 0</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   printf( &quot;TRUE 的值: %d\n&quot;, TRUE);</span><br><span class="line">   printf( &quot;FALSE 的值: %d\n&quot;, FALSE);</span><br><span class="line"> </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">TRUE 的值: 1</span><br><span class="line">FALSE 的值: 0</span><br></pre></td></tr></table></figure></p>
<h2 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数(inline)"></a>内联函数(inline)</h2><p>在c/c++中，<strong>为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题</strong>，特别的引入了inline修饰符，表示为内联函数。</p>
<p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p>
<p>在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p>
<p>下面我们来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//函数定义为inline即:内联函数</span><br><span class="line">inline char* dbtest(int a) &#123;</span><br><span class="line">    return (i % 2 &gt; 0) ? &quot;奇&quot; : &quot;偶&quot;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int i = 0;</span><br><span class="line">   for (i=1; i &lt; 100; i++) &#123;</span><br><span class="line">       printf(&quot;i:%d    奇偶性:%s /n&quot;, i, dbtest(i));    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个for<strong>循环的内部任何调用dbtest(i)的地方都换成了(i%2&gt;0)?”奇”:”偶”</strong>，这样就<strong>避免了频繁调用函数对栈内存重复开辟所带来的消耗</strong>。</p>
<h3 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h3><p>inline的使用是有所限制的，inline<strong>只适合函数体内代码简单的涵数使用</strong>，不能包含复杂的结构控制语句例如while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。</p>
<h3 id="对编译器的建议"><a href="#对编译器的建议" class="headerlink" title="对编译器的建议"></a>对编译器的建议</h3><p>inline函数仅仅是一个<strong>对编译器的建议</strong>，所以最后<strong>能否真正内联要看编译器的意思</strong>，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。</p>
<h3 id="类中的成员函数与inline"><a href="#类中的成员函数与inline" class="headerlink" title="类中的成员函数与inline"></a>类中的成员函数与inline</h3><p><strong>定义在类中的成员函数缺省都是内联的</strong>，如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public:void Foo(int x, int y) &#123;  &#125; // 自动地成为内联函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 头文件</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    public:</span><br><span class="line">    void Foo(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义文件</span><br><span class="line">inline void A::Foo(int x, int y)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="inline-是一种“用于实现的关键字”"><a href="#inline-是一种“用于实现的关键字”" class="headerlink" title="inline 是一种“用于实现的关键字”"></a>inline 是一种“用于实现的关键字”</h3><p>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。</p>
<p>如下风格的函数Foo 不能成为内联函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline void Foo(int x, int y); // inline 仅与函数声明放在一起</span><br><span class="line"></span><br><span class="line">void Foo(int x, int y)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>而如下风格的函数Foo 则成为内联函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void Foo(int x, int y);</span><br><span class="line"></span><br><span class="line">inline void Foo(int x, int y) &#123;&#125; // inline 与函数定义体放在一起</span><br></pre></td></tr></table></figure></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>1.建议：inline函数的定义放在头文件中<br>2.慎用inline：内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。<br>3.最令人烦恼的还是当编译器拒绝内联的时候。如果内联函数不能增强性能，就避免使用它！</p>
<h2 id="输入-amp-输出"><a href="#输入-amp-输出" class="headerlink" title="输入 &amp; 输出"></a>输入 &amp; 输出</h2><p>C 语言把所有的设备都当作文件。所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕。</p>
<table>
<thead>
<tr>
<th>标准文件</th>
<th>文件指针</th>
<th>设备</th>
</tr>
</thead>
<tbody>
<tr>
<td>标准输入</td>
<td>stdin</td>
<td>键盘</td>
</tr>
<tr>
<td>标准输出</td>
<td>stdout</td>
<td>屏幕</td>
</tr>
<tr>
<td>标准错误</td>
<td>stderr</td>
<td>屏幕</td>
</tr>
</tbody>
</table>
<h3 id="getchar-amp-putchar-函数"><a href="#getchar-amp-putchar-函数" class="headerlink" title="getchar() &amp; putchar() 函数"></a>getchar() &amp; putchar() 函数</h3><p>int getchar(void) 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。</p>
<p>int putchar(int c) 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。</p>
<p>请看下面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   int c;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;Enter a value :&quot;);</span><br><span class="line">   c = getchar( );</span><br><span class="line"> </span><br><span class="line">   printf( &quot;\nYou entered: &quot;);</span><br><span class="line">   putchar( c );</span><br><span class="line">   printf( &quot;\n&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：</span><br><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: r</span><br></pre></td></tr></table></figure></p>
<h3 id="gets-amp-puts-函数"><a href="#gets-amp-puts-函数" class="headerlink" title="gets() &amp; puts() 函数"></a>gets() &amp; puts() 函数</h3><p>char *gets(char *s) 函数从 stdin 读取一行到 s 所指向的缓冲区，直到一个终止符或 EOF。</p>
<p>int puts(const char *s) 函数把字符串 s 和一个尾随的换行符写入到 stdout。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">   char str[100];</span><br><span class="line"> </span><br><span class="line">   printf( &quot;Enter a value :&quot;);</span><br><span class="line">   gets( str );</span><br><span class="line"> </span><br><span class="line">   printf( &quot;\nYou entered: &quot;);</span><br><span class="line">   puts( str );</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：</span><br><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob</span><br><span class="line"></span><br><span class="line">You entered: runoob</span><br></pre></td></tr></table></figure>
<h3 id="scanf-和-printf-函数"><a href="#scanf-和-printf-函数" class="headerlink" title="scanf() 和 printf() 函数"></a>scanf() 和 printf() 函数</h3><p>int scanf(const char *format, …) 函数从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。</p>
<p>int printf(const char *format, …) 函数把输出写入到标准输出流 stdout ，并根据提供的格式产生输出。</p>
<p>format 可以是一个简单的常量字符串，但是您可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p>
<p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main( ) &#123;</span><br><span class="line"> </span><br><span class="line">   char str[100];</span><br><span class="line">   int i;</span><br><span class="line"> </span><br><span class="line">   printf( &quot;Enter a value :&quot;);</span><br><span class="line">   scanf(&quot;%s %d&quot;, str, &amp;i);</span><br><span class="line"> </span><br><span class="line">   printf( &quot;\nYou entered: %s %d &quot;, str, i);</span><br><span class="line">   printf(&quot;\n&quot;);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：</span><br><span class="line">$./a.out</span><br><span class="line">Enter a value :runoob 123</span><br><span class="line"></span><br><span class="line">You entered: runoob 123</span><br></pre></td></tr></table></figure></p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。原型为：</p>
<blockquote>
<p>FILE *fopen( const char * filename, const char * mode );</p>
</blockquote>
<p>在这里，filename 是字符串，用来命名文件，访问模式 mode 的值可以是下列值中的一个：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>打开一个已有的文本文件，允许读取文件。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td>
</tr>
<tr>
<td>r+</td>
<td>打开一个文本文件，允许读写文件。</td>
</tr>
<tr>
<td>w+</td>
<td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td>
</tr>
<tr>
<td>a+</td>
<td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td>
</tr>
</tbody>
</table>
<p>如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：</p>
<blockquote>
<p>“rb”, “wb”, “ab”, “rb+”, “r+b”, “wb+”, “w+b”, “ab+”, “a+b”</p>
</blockquote>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：</p>
<blockquote>
<p>int fclose( FILE *fp );</p>
</blockquote>
<p>如果成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量。</p>
<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF。下面是把字符写入到流中的最简单的函数：</p>
<blockquote>
<p>int fputc( int c, FILE *fp );</p>
</blockquote>
<p>函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：</p>
<blockquote>
<p>int fputs( const char *s, FILE *fp );</p>
</blockquote>
<p>您也可以使用 int fprintf(FILE *fp,const char *format, …) 函数来写把一个字符串写入到文件中。尝试下面的实例：</p>
<p>注意：请确保您有可用的 tmp 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。/tmp 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: C:\tmp、D:\tmp等。</p>
<p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line">   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;w+&quot;);</span><br><span class="line">   fprintf(fp, &quot;This is testing for fprintf...\n&quot;);</span><br><span class="line">   fputs(&quot;This is testing for fputs...\n&quot;, fp);</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF。下面是从文件读取单个字符的最简单的函数：</p>
<blockquote>
<p>int fgetc( FILE * fp );</p>
</blockquote>
<p>函数 fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。如果这个函数在读取最后一个字符之前就遇到一个换行符 ‘\n’ 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。下面的函数允许您从流中读取一个字符串：</p>
<blockquote>
<p>char *fgets( char *buf, int n, FILE *fp );</p>
</blockquote>
<p>您也可以使用 int fscanf(FILE *fp, const char *format, …) 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   FILE *fp = NULL;</span><br><span class="line">   char buff[255];</span><br><span class="line"> </span><br><span class="line">   fp = fopen(&quot;/tmp/test.txt&quot;, &quot;r&quot;);</span><br><span class="line">   fscanf(fp, &quot;%s&quot;, buff);</span><br><span class="line">   printf(&quot;1: %s\n&quot;, buff );</span><br><span class="line"> </span><br><span class="line">   fgets(buff, 255, (FILE*)fp);</span><br><span class="line">   printf(&quot;2: %s\n&quot;, buff );</span><br><span class="line">   </span><br><span class="line">   fgets(buff, 255, (FILE*)fp);</span><br><span class="line">   printf(&quot;3: %s\n&quot;, buff );</span><br><span class="line">   fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：</span><br><span class="line">1: This</span><br><span class="line">2: is testing for fprintf...</span><br><span class="line"></span><br><span class="line">3: This is testing for fputs...</span><br></pre></td></tr></table></figure>
<p>首先，fscanf() 方法只读取了 This，因为它在后边遇到了一个空格。其次，调用 fgets() 读取剩余的部分，直到行尾。最后，调用 fgets() 完整地读取第二行。</p>
<h3 id="二进制-I-O-函数"><a href="#二进制-I-O-函数" class="headerlink" title="二进制 I/O 函数"></a>二进制 I/O 函数</h3><p>下面两个函数用于二进制输入和输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t fread(void *ptr, size_t size_of_elements, </span><br><span class="line">             size_t number_of_elements, FILE *a_file);</span><br><span class="line">              </span><br><span class="line">size_t fwrite(const void *ptr, size_t size_of_elements, </span><br><span class="line">             size_t number_of_elements, FILE *a_file);</span><br></pre></td></tr></table></figure></p>
<p>这两个函数都是用于存储块的读写 - 通常是数组或结构体。</p>
<h2 id="C-预处理器"><a href="#C-预处理器" class="headerlink" title="C 预处理器"></a>C 预处理器</h2><p>C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤。简言之，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。</p>
<p>所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>#define</td>
<td>定义宏</td>
</tr>
<tr>
<td>#include</td>
<td>包含一个源代码文件</td>
</tr>
<tr>
<td>#undef</td>
<td>取消已定义的宏</td>
</tr>
<tr>
<td>#ifdef</td>
<td>如果宏已经定义，则返回真</td>
</tr>
<tr>
<td>#ifndef</td>
<td>如果宏没有定义，则返回真</td>
</tr>
<tr>
<td>#if</td>
<td>如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#else</td>
<td>#if 的替代方案</td>
</tr>
<tr>
<td>#elif</td>
<td>如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td>#endif</td>
<td>结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td>#error</td>
<td>当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td>#pragma</td>
<td>使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody>
</table>
<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>__DATE__</td>
<td>当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td>
</tr>
<tr>
<td>__TIME__</td>
<td>当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td>
</tr>
<tr>
<td>__FILE__</td>
<td>这会包含当前文件名，一个字符串常量。</td>
</tr>
<tr>
<td>__LINE__</td>
<td>这会包含当前行号，一个十进制常量。</td>
</tr>
<tr>
<td>__STDC__</td>
<td>当编译器以 ANSI 标准编译时，则定义为 1。</td>
</tr>
</tbody>
</table>
<h3 id="预处理器运算符"><a href="#预处理器运算符" class="headerlink" title="预处理器运算符"></a>预处理器运算符</h3><p>C 预处理器提供了下列的运算符来帮助您创建宏：</p>
<h4 id="宏延续运算符（-）"><a href="#宏延续运算符（-）" class="headerlink" title="宏延续运算符（\）"></a>宏延续运算符（\）</h4><p>一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define  message_for(a, b)  \</span><br><span class="line">    printf(#a &quot; and &quot; #b &quot;: We love you!\n&quot;)</span><br></pre></td></tr></table></figure></p>
<h4 id="字符串常量化运算符（-）"><a href="#字符串常量化运算符（-）" class="headerlink" title="字符串常量化运算符（#）"></a>字符串常量化运算符（#）</h4><p>在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define  message_for(a, b)  \</span><br><span class="line">    printf(#a &quot; and &quot; #b &quot;: We love you!\n&quot;)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   message_for(Carole, Debra);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Carole and Debra: We love you!</span><br></pre></td></tr></table></figure></p>
<h4 id="标记粘贴运算符（-）"><a href="#标记粘贴运算符（-）" class="headerlink" title="标记粘贴运算符（##）"></a>标记粘贴运算符（##）</h4><p>宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define tokenpaster(n) printf (&quot;token&quot; #n &quot; = %d&quot;, token##n)</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   int token34 = 40;</span><br><span class="line">   </span><br><span class="line">   tokenpaster(34);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">token34 = 40</span><br></pre></td></tr></table></figure></p>
<p>这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：</p>
<blockquote>
<p>printf (“token34 = %d”, token34);</p>
</blockquote>
<p>这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了字符串常量化运算符（#）和标记粘贴运算符（##）。</p>
<h4 id="defined-运算符"><a href="#defined-运算符" class="headerlink" title="defined() 运算符"></a>defined() 运算符</h4><p>预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#if !defined (MESSAGE)</span><br><span class="line">   #define MESSAGE &quot;You wish!&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Here is the message: %s\n&quot;, MESSAGE);  </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Here is the message: You wish!</span><br></pre></td></tr></table></figure></p>
<h3 id="参数化的宏"><a href="#参数化的宏" class="headerlink" title="参数化的宏"></a>参数化的宏</h3><p>CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，计算一个数的平方，我们可以使用宏重写上面的代码，如下：</p>
<blockquote>
<p>#define square(x) ((x) * (x))</p>
</blockquote>
<p>在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Max between 20 and 10 is %d\n&quot;, MAX(10, 20));  </span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Max between 20 and 10 is 20</span><br></pre></td></tr></table></figure></p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>头文件是扩展名为 .h 的文件，包含了 C 函数声明和宏定义，被多个源文件中引用共享。有两种类型的头文件：编译器自带的头文件和程序员编写的头文件（如下）。在编译源代码时，您可以通过 -I 选项把目录前置在该列表前。</p>
<blockquote>
<p>#include &lt;file></p>
<p>#include “file”</p>
</blockquote>
<p>A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。</p>
<h3 id="只引用一次头文件"><a href="#只引用一次头文件" class="headerlink" title="只引用一次头文件"></a>只引用一次头文件</h3><p>如果一个头文件被引用两次，编译器会处理两次头文件的内容，这将产生错误。为了防止这种情况，标准的做法是把文件的整个内容放在条件编译语句中，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef HEADER_FILE</span><br><span class="line">#define HEADER_FILE</span><br><span class="line"></span><br><span class="line">the entire header file file</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>这种结构就是通常所说的包装器 #ifndef。当再次引用头文件时，条件为假，因为 HEADER_FILE 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。</p>
<h3 id="有条件引用"><a href="#有条件引用" class="headerlink" title="有条件引用"></a>有条件引用</h3><p>有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if SYSTEM_1</span><br><span class="line">   # include &quot;system_1.h&quot;</span><br><span class="line">#elif SYSTEM_2</span><br><span class="line">   # include &quot;system_2.h&quot;</span><br><span class="line">#elif SYSTEM_3</span><br><span class="line">   ...</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>但是如果头文件比较多的时候，这么做是很不妥当的，预处理器使用宏来定义头文件的名称。这就是所谓的有条件引用。它不是用头文件的名称作为 #include 的直接参数，您只需要使用宏名称代替即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define SYSTEM_H &quot;system_1.h&quot;</span><br><span class="line">...</span><br><span class="line">#include SYSTEM_H</span><br></pre></td></tr></table></figure></p>
<p>SYSTEM_H 会扩展，预处理器会查找 system_1.h，就像 #include 最初编写的那样。SYSTEM_H 可通过 -D 选项被您的 Makefile 定义。</p>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换是把变量从一种类型转换为另一种数据类型。您可以使用强制类型转换运算符来把值显式地从一种类型转换为另一种类型，如下所示：</p>
<blockquote>
<p>(type_name) expression</p>
</blockquote>
<p>在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。</p>
<h3 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h3><p>整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。请看下面的实例，在 int 中添加一个字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int  i = 17;</span><br><span class="line">   char c = &apos;c&apos;; /* ascii 值是 99 */</span><br><span class="line">   int sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   printf(&quot;Value of sum : %d\n&quot;, sum );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of sum : 116</span><br></pre></td></tr></table></figure></p>
<p>在这里，sum 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 ‘c’ 的值转换为对应的 ascii 值。</p>
<h3 id="常用的算术转换"><a href="#常用的算术转换" class="headerlink" title="常用的算术转换"></a>常用的算术转换</h3><p>常用的算术转换是隐式地把值强制转换为相同的类型。编译器首先执行整数提升，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：</p>
<p><img src="/2019/12/24/c-language/usual_arithmetic_conversion.png" alt><br>让我们看看下面的实例来理解这个概念：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int  i = 17;</span><br><span class="line">   char c = &apos;c&apos;; /* ascii 值是 99 */</span><br><span class="line">   float sum;</span><br><span class="line"> </span><br><span class="line">   sum = i + c;</span><br><span class="line">   printf(&quot;Value of sum : %f\n&quot;, sum );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Value of sum : 116.000000</span><br></pre></td></tr></table></figure></p>
<p>在这里，c 首先被转换为整数，但是由于最后的值是 float 型的，所以会应用常用的算术转换，编译器会把 i 和 c 转换为浮点型，并把它们相加得到一个浮点数。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>C 语言<strong>不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据</strong>。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。您可以在 errno.h 头文件中找到各种各样的错误代码。</p>
<p>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯。0 值表示程序中没有错误。</p>
<h3 id="errno、perror-和-strerror"><a href="#errno、perror-和-strerror" class="headerlink" title="errno、perror() 和 strerror()"></a>errno、perror() 和 strerror()</h3><p>C 语言提供了 perror() 和 strerror() 函数来显示与 errno 相关的文本消息。</p>
<ul>
<li>perror() 函数显示您传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。</li>
<li>strerror() 函数，返回一个指针，指针指向当前 errno 值的文本表示形式。</li>
</ul>
<p>让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。另外有一点需要注意，您应该使用 stderr 文件流来输出所有的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">extern int errno ;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   FILE * pf;</span><br><span class="line">   int errnum;</span><br><span class="line">   pf = fopen (&quot;unexist.txt&quot;, &quot;rb&quot;);</span><br><span class="line">   if (pf == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">      errnum = errno;</span><br><span class="line">      fprintf(stderr, &quot;错误号: %d\n&quot;, errno);</span><br><span class="line">      perror(&quot;通过 perror 输出错误&quot;);</span><br><span class="line">      fprintf(stderr, &quot;打开文件错误: %s\n&quot;, strerror( errnum ));</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      fclose (pf);</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">错误号: 2</span><br><span class="line">通过 perror 输出错误: No such file or directory</span><br><span class="line">打开文件错误: No such file or directory</span><br></pre></td></tr></table></figure></p>
<h3 id="程序退出状态"><a href="#程序退出状态" class="headerlink" title="程序退出状态"></a>程序退出状态</h3><p>通常情况下，程序成功执行完一个操作正常退出的时候会带有值 EXIT_SUCCESS。在这里，EXIT_SUCCESS 是宏，它被定义为 0。</p>
<p>如果程序中存在一种错误情况，当您退出程序时，会带有状态值 EXIT_FAILURE，被定义为 -1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">   int dividend = 20;</span><br><span class="line">   int divisor = 5;</span><br><span class="line">   int quotient;</span><br><span class="line"> </span><br><span class="line">   // 在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。</span><br><span class="line">   if( divisor == 0)&#123;</span><br><span class="line">      fprintf(stderr, &quot;除数为 0 退出运行...\n&quot;);</span><br><span class="line">      exit(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   quotient = dividend / divisor;</span><br><span class="line">   fprintf(stderr, &quot;quotient 变量的值为: %d\n&quot;, quotient );</span><br><span class="line"> </span><br><span class="line">   exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">quotient 变量的值为 : 4</span><br></pre></td></tr></table></figure></p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int func(int, ... ) </span><br><span class="line">&#123;</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   func(2, 2, 3);</span><br><span class="line">   func(3, 2, 3, 4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，函数 func() 最后一个参数写成省略号，即三个点号（…），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：</p>
<ul>
<li>定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。</li>
<li>在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。</li>
<li>使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。</li>
<li>使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。</li>
<li>使用宏 va_end 来清理赋予 va_list 变量的内存。</li>
</ul>
<p>现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"> </span><br><span class="line">double average(int num,...)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    va_list valist;</span><br><span class="line">    double sum = 0.0;</span><br><span class="line">    int i;</span><br><span class="line"> </span><br><span class="line">    /* 为 num 个参数初始化 valist */</span><br><span class="line">    va_start(valist, num);</span><br><span class="line"> </span><br><span class="line">    /* 访问所有赋给 valist 的参数 */</span><br><span class="line">    for (i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       sum += va_arg(valist, int);</span><br><span class="line">    &#125;</span><br><span class="line">    /* 清理为 valist 保留的内存 */</span><br><span class="line">    va_end(valist);</span><br><span class="line"> </span><br><span class="line">    return sum/num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Average of 2, 3, 4, 5 = %f\n&quot;, average(4, 2,3,4,5));</span><br><span class="line">   printf(&quot;Average of 5, 10, 15 = %f\n&quot;, average(3, 5,10,15));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Average of 2, 3, 4, 5 = 3.500000</span><br><span class="line">Average of 5, 10, 15 = 10.000000</span><br></pre></td></tr></table></figure></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>语言为内存的分配和管理提供了几个函数。这些函数可以在 &lt;stdlib.h&gt; 头文件中找到。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>函数和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>void *calloc(int num, int size)  <br>在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</td>
</tr>
<tr>
<td>2</td>
<td>void free(void *address) <br> 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。</td>
</tr>
<tr>
<td>3</td>
<td>void *malloc(int num) <br> 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。</td>
</tr>
<tr>
<td>4</td>
<td>void *realloc(void *address, int newsize) <br> 该函数重新分配内存，把内存扩展到 newsize。</td>
</tr>
</tbody>
</table>
<p>注意：void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。</p>
<h3 id="动态分配内存"><a href="#动态分配内存" class="headerlink" title="动态分配内存"></a>动态分配内存</h3><p>如果您预先不知道需要存储的文本长度，例如您向存储有关一个主题的详细描述。在这里，我们需要<strong>定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存</strong>，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 200 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student in class 10th</span><br></pre></td></tr></table></figure></p>
<p>上面的程序也可以使用 calloc() 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：</p>
<blockquote>
<p>calloc(200, sizeof(char));</p>
</blockquote>
<p>当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些<strong>预先定义了大小的数组，一旦定义则无法改变大小</strong>。</p>
<h3 id="重新调整内存的大小和释放内存"><a href="#重新调整内存的大小和释放内存" class="headerlink" title="重新调整内存的大小和释放内存"></a>重新调整内存的大小和释放内存</h3><p>当程序退出时，<strong>操作系统会自动释放所有分配给程序的内存</strong>，但是，<strong>建议您在不需要内存时，都应该调用函数 free() 来释放内存</strong>。</p>
<p>或者，您可以通过调用函数 realloc() 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   char name[100];</span><br><span class="line">   char *description;</span><br><span class="line"> </span><br><span class="line">   strcpy(name, &quot;Zara Ali&quot;);</span><br><span class="line"> </span><br><span class="line">   /* 动态分配内存 */</span><br><span class="line">   description = (char *)malloc( 30 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcpy( description, &quot;Zara ali a DPS student.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   /* 假设您想要存储更大的描述信息 */</span><br><span class="line">   description = (char *) realloc( description, 100 * sizeof(char) );</span><br><span class="line">   if( description == NULL )</span><br><span class="line">   &#123;</span><br><span class="line">      fprintf(stderr, &quot;Error - unable to allocate required memory\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      strcat( description, &quot;She is in class 10th&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   printf(&quot;Name = %s\n&quot;, name );</span><br><span class="line">   printf(&quot;Description: %s\n&quot;, description );</span><br><span class="line"> </span><br><span class="line">   /* 使用 free() 函数释放内存 */</span><br><span class="line">   free(description);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当上面的代码被编译和执行时，它会产生下列结果：</span><br><span class="line">Name = Zara Ali</span><br><span class="line">Description: Zara ali a DPS student.She is in class 10th</span><br></pre></td></tr></table></figure></p>
<p>您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>命令行参数是使用 main() 函数参数来处理的，其中，argc 是指传入参数的个数，argv[] 是一个指针数组，指向传递给程序的每个参数。下面是一个简单的实例，检查命令行是否有提供参数，并根据参数执行相应的动作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main( int argc, char *argv[] )  </span><br><span class="line">&#123;</span><br><span class="line">   if( argc == 2 )</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;The argument supplied is %s\n&quot;, argv[1]);</span><br><span class="line">   &#125;</span><br><span class="line">   else if( argc &gt; 2 )</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;Too many arguments supplied.\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">      printf(&quot;One argument expected.\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用一个参数，编译并执行上面的代码，它会产生下列结果：</span><br><span class="line">$./a.out testing</span><br><span class="line">The argument supplied is testing</span><br><span class="line"></span><br><span class="line">使用两个参数，编译并执行上面的代码，它会产生下列结果：</span><br><span class="line">$./a.out testing1 testing2</span><br><span class="line">Too many arguments supplied.</span><br><span class="line"></span><br><span class="line">不传任何参数，编译并执行上面的代码，它会产生下列结果：</span><br><span class="line">$./a.out</span><br><span class="line">One argument expected</span><br></pre></td></tr></table></figure></p>
<p>应当指出的是，<strong>argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针</strong>，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2。</p>
<p>多个命令行参数之间用空格分隔，但是如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 “” 或单引号 ‘’ 内部。</p>
<h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><h3 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h3><p>C 库函数 int printf(const char *format, …) 发送格式化输出到标准输出 stdout。</p>
<p>规定符:</p>
<ul>
<li>%d 十进制有符号整数</li>
<li>%u 十进制无符号整数</li>
<li>%f 浮点数</li>
<li>%s 字符串</li>
<li>%c 单个字符</li>
<li>%p 指针的值</li>
<li>%e 指数形式的浮点数</li>
<li>%x, %X 无符号以十六进制表示的整数</li>
<li>%o 无符号以八进制表示的整数</li>
<li>%g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出</li>
<li>%p 输出地址符</li>
<li>%lu 32位无符号整数</li>
<li>%llu 64位无符号整数</li>
</ul>
<h2 id="C11"><a href="#C11" class="headerlink" title="C11"></a>C11</h2><p>C11（也被称为C1X）指ISO标准ISO/IEC 9899:2011，是当前最新的C语言标准。在它之前的C语言标准为C99。</p>
<p>新特性：</p>
<ul>
<li><p>对齐处理（Alignment）的标准化（包括_Alignas标志符，alignof运算符，aligned_alloc函数以及&lt;stdalign.h&gt;头文件）。</p>
</li>
<li><p>_Noreturn 函数标记，类似于 gcc 的 <strong>attribute</strong>((noreturn))。</p>
</li>
<li><p>_Generic 关键字。</p>
</li>
<li><p>多线程（Multithreading）支持，包括：<br>_Thread_local存储类型标识符，&lt;threads.h&gt;头文件，里面包含了线程的创建和管理函数。<br>_Atomic类型修饰符和&lt;stdatomic.h&gt;头文件。</p>
</li>
<li><p>增强的Unicode的支持。基于C Unicode技术报告ISO/IEC TR 19769:2004，增强了对Unicode的支持。包括为UTF-16/UTF-32编码增加了char16_t和char32_t数据类型，提供了包含unicode字符串转换函数的头文件&lt;uchar.h&gt;。</p>
</li>
<li><p>删除了 gets() 函数，使用一个新的更安全的函数gets_s()替代。</p>
</li>
<li><p>增加了边界检查函数接口，定义了新的安全的函数，例如 fopen_s()，strcat_s() 等等。</p>
</li>
<li><p>增加了更多浮点处理宏(宏)。</p>
</li>
<li><p>匿名结构体/联合体支持。这个在gcc早已存在，C11将其引入标准。</p>
</li>
<li><p>静态断言（Static assertions），_Static_assert()，在解释 #if 和 #error 之后被处理。</p>
</li>
<li><p>新的 fopen() 模式，(“…x”)。类似 POSIX 中的 O_CREAT|O_EXCL，在文件锁中比较常用。</p>
</li>
<li><p>新增 quick_exit() 函数作为第三种终止程序的方式。当 exit()失败时可以做最少的清理工作。</p>
</li>
</ul>
<h2 id="重入函数"><a href="#重入函数" class="headerlink" title="重入函数"></a>重入函数</h2><p>在实时系统的设计中，经常会出现多个任务调用同一个函数的情况。所谓<strong>可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会 出错</strong>。不可重入函数在实时系统设计中被视为不安全函数。</p>
<p>可重入函数可以被一个以上的任务调用，而不必担心数据被破坏。可重入函数任何时候都可以被中断，一段时间以后又可以运行，而相应的数据不会丢失。可重入函数或者只使用局部变量，即保存在CPU寄存器中或堆栈中；或者使用全局变量，则要对全局变量予以保护。而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等等，所以他如果被中断的话，可能出现问题，所以这类函数是 不能运行在多任务环境下的。</p>
<p>满足下列条件的函数多数是不可重入的：<br>（1）函数体内使用了静态的数据结构；<br>（2）函数体内调用了malloc()或者free()函数；<br>（3）函数体内调用了标准I/O函数。</p>
<p>如何写出可重入的函数？<br>在函数体内不访问那些全局变量，不使用静态局部变量，坚持只使用缺省态（auto）局部变量，写出的函数就将是可重入的。如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断。</p>
<p>把一个不可重入函数变成可重入的唯一方法是用可重入规则来重写他。只要遵守以下几条很容易理解的规则：<br>第一，不要使用全局变量。因为别的代码很可能覆盖这些变量值。<br>第二，在和硬件发生交互的时候，切记执行类似disinterrupt()之类的操作，就是关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入/退出核心”或者用OS_ENTER_KERNAL/OS_EXIT_KERNAL来描述。<br>第三，不能调用任何不可重入的函数。<br>第四，谨慎使用堆栈。最好先在使用前先OS_ENTER_KERNAL。<br>还有一些规则，都是很好理解的，总之，时刻记住一句话：<strong>保证中断是安全的</strong>！<br>通俗的来讲吧：由于中断是可能随时发生的，断点位置也是无法预期的。所以必须保证每个函数都具有不被中断发生，压栈，转向ISR，弹栈后继续执行影响的稳定性。也就是说具有不会被中断影响的能力。既然有这个要求，你提供和编写的每个函数就不能拿公共的资源或者是变量来使用，因为该函数使用的同时，ISR（中断服务程序）也可那会去修改或者是获取这个资源，从而有可能使中断返回之后，这部分公用的资源已经面目全非。</p>
<p>案例：<br>相信很多人都看过下面这个面试题<br>中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 <strong>interrupt。下面的代码就使用了</strong>interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__interrupt double compute_area (double radius) </span><br><span class="line">&#123;</span><br><span class="line">    double area = PI * radius * radius;</span><br><span class="line">    printf(&quot;\nArea = %f&quot;, area);</span><br><span class="line">    return area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数有太多的错误了，以至让人不知从何说起了：<br>1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。<br>2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。<br>3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。<br>4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/cprogramming/c-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-tutorial.html</a><br><a href="https://www.cnblogs.com/AlwaysOnLines/p/3912680.html" target="_blank" rel="noopener">C语言之可重入函数 &amp;&amp; 不可重入函数</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Shuming Zhao">
            
              <p class="site-author-name" itemprop="name">Shuming Zhao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">72</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuming Zhao</span>

  
</div>

<div class="powered-by"><i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人，
<span id="busuanzi_container_site_pv">访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
</span>
</div>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
