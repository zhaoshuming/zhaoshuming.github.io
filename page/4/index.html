<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="1ilOhMWnNE">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/design-mode-prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/21/design-mode-prototype/" itemprop="url">原型模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-21T11:03:21+08:00">
                2019-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原型模式属于对象的创建模式：<strong>通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象</strong>。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、对象之间相同或相似，即只是个别的几个属性不同的时候。<br>2、对象的创建过程比较麻烦，但复制比较简单的时候。</p>
<h2 id="原型模式的结构"><a href="#原型模式的结构" class="headerlink" title="原型模式的结构"></a>原型模式的结构</h2><p>原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。</p>
<p><img src="/2019/10/21/design-mode-prototype/prototype.png" alt></p>
<p>这种形式涉及到三个角色：<br>（1）客户(Client)角色：客户类提出创建对象的请求。<br>（2）抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。<br>（3）具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。</p>
<h2 id="浅克隆与深克隆"><a href="#浅克隆与深克隆" class="headerlink" title="浅克隆与深克隆"></a>浅克隆与深克隆</h2><p>浅克隆只是复制了基础属性，列如八大基本类型，然而引用类型实际上没有复制，只是将对应的引用给复制了。</p>
<p>简单的说：如果一个对象中只有基本类型属性，那深克隆和浅克隆效果都是一样的，基本类型数据不管是用深克隆还是浅克隆都会被克隆出一份，但如果对象中包含引用对象属性，那浅克隆其实这是拷贝了一份引用，而深克隆确实把整个引用对象都拷贝了一份。</p>
<h2 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h2><p>（1）根据客户端要求实现动态创建对象，客户端不需要知道对象的创建细节，便于代码的维护和扩展。</p>
<p>（2）使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是<strong>复制大对象时</strong>，性能的差别非常明显。所以在<strong>需要重复地创建相似对象时</strong>可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。</p>
<p>（3）原型模式类似于工厂模式，但它没有了工厂模式中的抽象工厂和具体工厂的实现，代码结构更清晰和简单。</p>
<p>（4）可用于<strong>保护性拷贝</strong>，避免原始的对象被外部修改。</p>
<h2 id="原型模式的注意事项"><a href="#原型模式的注意事项" class="headerlink" title="原型模式的注意事项"></a>原型模式的注意事项</h2><p>（1）使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不 会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为 private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的。</p>
<p>（2）在使用时要注意深拷贝与浅拷贝的问题。clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//具体原型类</span><br><span class="line">class Realizetype implements Cloneable</span><br><span class="line">&#123;</span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体原型创建成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Object clone() throws CloneNotSupportedException</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;具体原型复制成功！&quot;);</span><br><span class="line">        return (Realizetype)super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//原型模式的测试类</span><br><span class="line">public class PrototypeTest</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)throws CloneNotSupportedException</span><br><span class="line">    &#123;</span><br><span class="line">        Realizetype obj1=new Realizetype();</span><br><span class="line">        Realizetype obj2=(Realizetype)obj1.clone();</span><br><span class="line">        System.out.println(&quot;obj1==obj2?&quot;+(obj1==obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序的运行结果如下：</span><br><span class="line">具体原型创建成功！</span><br><span class="line">具体原型复制成功！</span><br><span class="line">obj1==obj2?false</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/design-mode-builder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/21/design-mode-builder/" itemprop="url">建造者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-21T10:51:11+08:00">
                2019-10-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>建造者模式的定义是：<strong>将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示</strong>。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<p>主要优点如下：<br>1、各个具体的建造者相互独立，有利于系统的扩展。<br>2、客户端不必知道产品内部组成的细节，便于控制细节风险。</p>
<p>其缺点如下：<br>1、产品的组成部分必须相同，这限制了其使用范围。<br>2、如果产品的内部变化复杂，该模式会增加很多的建造者类。</p>
<p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。<br>2、创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</p>
<h2 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h2><p>建造者（Builder）模式的主要角色如下：<br>1、产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。<br>2、抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。<br>3、具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。<br>4、指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</p>
<p><img src="/2019/10/21/design-mode-builder/builder.jpg" alt title="结构图"></p>
<p>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">class Product</span><br><span class="line">&#123;</span><br><span class="line">    private String partA;</span><br><span class="line">    private String partB;</span><br><span class="line">    private String partC;</span><br><span class="line">    public void setPartA(String partA)</span><br><span class="line">    &#123;</span><br><span class="line">        this.partA=partA;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPartB(String partB)</span><br><span class="line">    &#123;</span><br><span class="line">        this.partB=partB;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPartC(String partC)</span><br><span class="line">    &#123;</span><br><span class="line">        this.partC=partC;</span><br><span class="line">    &#125;</span><br><span class="line">    public void show()</span><br><span class="line">    &#123;</span><br><span class="line">        //显示产品的特性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class Builder</span><br><span class="line">&#123;</span><br><span class="line">    //创建产品对象</span><br><span class="line">    protected Product product=new Product();</span><br><span class="line">    public abstract void buildPartA();</span><br><span class="line">    public abstract void buildPartB();</span><br><span class="line">    public abstract void buildPartC();</span><br><span class="line">    //返回产品对象</span><br><span class="line">    public Product getResult()</span><br><span class="line">    &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteBuilder extends Builder</span><br><span class="line">&#123;</span><br><span class="line">    public void buildPartA()</span><br><span class="line">    &#123;</span><br><span class="line">        product.setPartA(&quot;建造 PartA&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void buildPartB()</span><br><span class="line">    &#123;</span><br><span class="line">        product.setPartA(&quot;建造 PartB&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void buildPartC()</span><br><span class="line">    &#123;</span><br><span class="line">        product.setPartA(&quot;建造 PartC&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Director</span><br><span class="line">&#123;</span><br><span class="line">    private Builder builder;</span><br><span class="line">    public Director(Builder builder)</span><br><span class="line">    &#123;</span><br><span class="line">        this.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">    //产品构建与组装方法</span><br><span class="line">    public Product construct()</span><br><span class="line">    &#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        return builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Builder builder=new ConcreteBuilder();</span><br><span class="line">        Director director=new Director(builder);</span><br><span class="line">        Product product=director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模式的扩展"><a href="#模式的扩展" class="headerlink" title="模式的扩展"></a>模式的扩展</h2><p>建造者（Builder）模式在应用过程中可以根据需要改变，如果创建的产品种类只有一种，只需要一个具体建造者，这时可以省略掉抽象建造者，甚至可以省略掉指挥者角色。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/ds-string-matching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/17/ds-string-matching/" itemprop="url">字符串匹配算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-17T18:14:19+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字符串的匹配算法有：<br>1、单模式串匹配算法（BF算法，RK算法，BM算法，KMP算法）<br>2、多模式串匹配算法有（Trie树，AC自动机）</p>
<h2 id="BF（Brute-Force）算法"><a href="#BF（Brute-Force）算法" class="headerlink" title="BF（Brute Force）算法"></a>BF（Brute Force）算法</h2><p>BF算法就是拿模式串m，从主串n的第0位开始匹配，如果匹配不成功，则后移一位继续匹配。<br>是比较简单的一种字符串匹配算法，在处理简单的数据时候就可以用这种算法，完全匹配，速度很慢，时间复杂度最坏情况O(M*N)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int bf(String str,String sub)&#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = 0;</span><br><span class="line">        while(i &lt; str.length())&#123;</span><br><span class="line">            while(j &lt; sub.length())&#123;</span><br><span class="line">                if(str.charAt(i) == sub.charAt(j))&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    i = i-j+1;</span><br><span class="line">                    j =0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        return i-j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="RK（Rabin-Karp）算法"><a href="#RK（Rabin-Karp）算法" class="headerlink" title="RK（Rabin-Karp）算法"></a>RK（Rabin-Karp）算法</h2><p>RK算法：数字的匹配比字符串快速，就把主串中的这n-m+1的子串分别求哈希值，然后在分别跟模式串的哈希值进行比较。如果哈希值不一样那肯定不匹配，如果哈希值一样，因为哈希算法存在哈希冲突，这时候在拿模式串跟该子串对比一下就好了。</p>
<p>虽然模式串跟子串的对比速度提高了，但是我们事先需要遍历主串，逐个求子串的哈希值，这部分也挺耗时的，所以需要设计比较高效的哈希算法尽量的减少哈希冲突的产生。</p>
<h2 id="BM（Boyer-Moore）算法"><a href="#BM（Boyer-Moore）算法" class="headerlink" title="BM（Boyer-Moore）算法"></a>BM（Boyer-Moore）算法</h2><p>上面两种字符串匹配算法都有缺点，BF算法在极端情况下效率会很低，RK算法需要有一个很好的哈希算法，而设计一个好的哈希算法并不简单，有没有尽可能的高效，极端情况下效率退化也不大的算法呢，下面看看BM算法。</p>
<p>BM算法是一种非常高效的算法，各种记事本的查找功能一般都是采用的这种算法。该算法从模式串的尾部开始匹配，且拥有在最坏情况下 O(N) 的时间复杂度。在实践中，比 KMP 算法的实际效能高。</p>
<p>BM 算法定义了两个规则：</p>
<ul>
<li>坏字符规则：当文本串中的某个字符跟模式串的某个字符不匹配时，我们称文本串中的这个失配字符为坏字符，此时模式串需要向右移动，移动的位数 = 坏字符在模式串中的位置 坏字符在模式串中最右出现的位置。此外，如果”坏字符”不包含在模式串之中，则最右出现位置为 -1。</li>
<li>好后缀规则：当字符失配时，后移位数 = 好后缀在模式串中的位置 - 好后缀在模式串上一次出现的位置，且如果好后缀在模式串中没有再次出现，则为 -1。</li>
</ul>
<p>通过坏字符算法与好后缀算法分别获取位移值，取两者中的最大值进行位移操作。</p>
<p>案例可参考：<a href="http://wiki.jikexueyuan.com/project/kmp-algorithm/bm.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/kmp-algorithm/bm.html</a></p>
<p>BM算法完整代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// a,b 表示主串和模式串；n，m 表示主串和模式串的长度。</span><br><span class="line">public int bm(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置</span><br><span class="line">  generateBC(b, m, bc); // 构建坏字符哈希表</span><br><span class="line">  int[] suffix = new int[m];</span><br><span class="line">  boolean[] prefix = new boolean[m];</span><br><span class="line">  generateGS(b, m, suffix, prefix);</span><br><span class="line">  int i = 0; // j 表示主串与模式串匹配的第一个字符</span><br><span class="line">  while (i &lt;= n - m) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    for (j = m - 1; j &gt;= 0; --j) &#123; // 模式串从后往前匹配</span><br><span class="line">      if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是 j</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &lt; 0) &#123;</span><br><span class="line">      return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br><span class="line">    &#125;</span><br><span class="line">    int x = j - bc[(int)a[i+j]];</span><br><span class="line">    int y = 0;</span><br><span class="line">    if (j &lt; m-1) &#123; // 如果有好后缀的话</span><br><span class="line">      y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    i = i + Math.max(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// j 表示坏字符对应的模式串中的字符下标 ; m 表示模式串长度</span><br><span class="line">private int moveByGS(int j, int m, int[] suffix, boolean[] prefix) &#123;</span><br><span class="line">  int k = m - 1 - j; // 好后缀长度</span><br><span class="line">  if (suffix[k] != -1) return j - suffix[k] +1;</span><br><span class="line">  for (int r = j+2; r &lt;= m-1; ++r) &#123;</span><br><span class="line">    if (prefix[m-r] == true) &#123;</span><br><span class="line">      return r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void generateBC(char[] b, int m, int[] bc) &#123;</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            bc[i] = -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            int ascii = (int) b[i];</span><br><span class="line">            bc[ascii] = i; // 如果ascii相同只需要存储 bc[ascii] = 最后一个</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateGS(char[] b, int m, int[] suffix, boolean[] prefix) &#123;</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123; //初始化</span><br><span class="line">            suffix[i] = -1;</span><br><span class="line">            prefix[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m - 1; ++i) &#123; // b[0,i]</span><br><span class="line">            int j = i;</span><br><span class="line">            int k = 0;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; b[j] == b[m - 1 - k]) &#123;</span><br><span class="line">                --j;</span><br><span class="line">                ++k;</span><br><span class="line">                suffix[k] = j + 1;//记录模式串每个可以匹配前缀子串的长度 等于 最大下标值</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (j == -1) prefix[k] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="KMP（Knuth-Morris-Pratt）算法"><a href="#KMP（Knuth-Morris-Pratt）算法" class="headerlink" title="KMP（Knuth Morris Pratt）算法"></a>KMP（Knuth Morris Pratt）算法</h2><p>模式串跟主串左端对齐，先比较第一个字符，如果不一样就，模式串后移，直到第一个字符相等</p>
<p>第一个字符匹配上之后在匹配第二个，直到有不相等的为止，比如下面</p>
<p>主串：cd<strong>ababaea</strong>bac</p>
<p>模式串：ababacd</p>
<p>e和c不匹配，e就可以理解为坏字符，ababa可以理解为好前缀，那移动几位呢？</p>
<p>我们拿好前缀本身，在它的后缀子串中查找最长的那个可以跟好前缀的前缀子串匹配的。</p>
<p>移动位数 = 已匹配的字符数 - 对应的部分匹配值的长度</p>
<p>如何求这个对应的匹配值呢？这个不涉及到主串只需要根据模式串就可以求出来。</p>
<p>比如这里的模式串是 ababacd</p>
<p>a的前缀和后缀都是空，共有元素为0<br>ab的前缀是[a]后缀是[b]，共有元素为0<br>aba的前缀是[a,ab]后缀是[ba,a]，共有元素a的长度是1<br>abab的前缀是[a,ab,aba]后缀是[bab,ab,b],共有元素是[ab]长度为2<br>ababa的前缀是[a,ab,aba,abab]后缀是[baba,aba,ba,a],最长共有元素是[aba]长度是3<br>ababac的前缀是[a,ab,aba,abab,ababa]后缀是[babac,abac,bac,ac,c]共有元素为0<br>ababacd的前缀是[a,ab,aba,abab,ababa,ababac]后缀是[babacd,abacd,bacd,acd,cd,d]共有元素是0</p>
<p>代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// a, b 分别是主串和模式串；n, m 分别是主串和模式串的长度。</span><br><span class="line">public static int kmp(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[] next = getNexts(b, m);</span><br><span class="line">  int j = 0;</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    while (j &gt; 0 &amp;&amp; a[i] != b[j]) &#123; // 一直找到 a[i] 和 b[j]</span><br><span class="line">      j = next[j - 1] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a[i] == b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j == m) &#123; // 找到匹配模式串的了</span><br><span class="line">      return i - m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line">// b 表示模式串，m 表示模式串的长度</span><br><span class="line">private static int[] getNexts(char[] b, int m) &#123;</span><br><span class="line">  int[] next = new int[m];</span><br><span class="line">  next[0] = -1;</span><br><span class="line">  int k = -1;</span><br><span class="line">  for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">    while (k != -1 &amp;&amp; b[k + 1] != b[i]) &#123;</span><br><span class="line">      k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    if (b[k + 1] == b[i]) &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/mingyunxiaohai/article/details/87563292" target="_blank" rel="noopener">https://blog.csdn.net/mingyunxiaohai/article/details/87563292</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/design-mode-singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/17/design-mode-singleton/" itemprop="url">单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-17T16:17:38+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。（事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效，下面会讨论。）</p>
<p>主要优点：<br>1、提供了对唯一实例的受控访问。<br>2、由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。<br>3、允许可变数目的实例。</p>
<p>主要缺点：<br>1、由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。<br>2、单例类的职责过重，在一定程度上违背了“单一职责原则”。<br>3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</p>
<p>以下列出单例模式的几种写法及单例模式的漏洞解决方案：</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>类初始化时创建对象，不管需不需要实例对象，都会创建。不存在线程安全问题，因为实例是在类创建和初始化时创建，是由类加载器完成的，类加载器是线程安全的。</p>
<p>缺点，无法延时加载,没有使用就已经加载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"> </span><br><span class="line">    private static final Singleton mInstance = new Singleton();</span><br><span class="line"> </span><br><span class="line">    private Singleton()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>优化了恶汉式无法延迟加载的问题。<br>缺点：存在同步问题，多线程并发的时候会失效，getInstance不同步。比如：一个线程在创建mInstance时，还未创建完成，另一个线程访问mInstance此时还是为空，又创建了一次。</p>
<p>对懒汉式的优化，主要是在线程安全方面，使用synchronized关键字或同步代码块修饰，使得同时只能有一个线程访问。但存在性能缺陷的，因为使用了synchronized关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"> </span><br><span class="line">    private static Singleton mInstance;</span><br><span class="line"> </span><br><span class="line">    private Singleton()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        if(mInstance == null)&#123;</span><br><span class="line">            mInstance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DCL双重检查锁"><a href="#DCL双重检查锁" class="headerlink" title="DCL双重检查锁"></a>DCL双重检查锁</h2><p>DCL双重检查锁，是对第二种方法性能缺陷的优化。</p>
<p>DCL双重检查锁仅在真正创建mInstance实例的时候加上了synchronized关键字。而且使用volatile关键字修饰，是为了禁止编译器对volatile变量重排序，并且保证volatile变量的读操作发生在写操作之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"> </span><br><span class="line">    private static volatile Singleton mInstance =null; //volatile关键字是为了禁止编译器对 volatile关键字修饰的变量进行重排序，并保证volatile变量的读操作发生在写操作之后</span><br><span class="line"> </span><br><span class="line">    private Singleton()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        if(mInstance == null)&#123; //第一次检查</span><br><span class="line">            synchronized (Singleton.class)&#123; //同步代码块</span><br><span class="line">                if(mInstance == null)&#123; //第二次检查</span><br><span class="line">                    mInstance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mInstance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>利用static final关键字的同步机制，初始化后就无法修改保证了线程安全。使用静态内部类的方式保证了延迟加载，不使用不会被加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123; //完成了懒汉式的延迟加载，同时static保证了线程安全。</span><br><span class="line"> </span><br><span class="line">    private  Singleton()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getIntance()&#123;</span><br><span class="line">        return SingletonHolder.mIntance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static class SingletonHolder&#123; //私有的，初始化的时候，没有调用getIntance方法则不会加载</span><br><span class="line">        private static final Singleton mIntance = new Singleton();  //static,final是jvm提供的同步机制，初始化后就无法修改了</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举（推荐用法）"><a href="#枚举（推荐用法）" class="headerlink" title="枚举（推荐用法）"></a>枚举（推荐用法）</h2><p>1.简洁<br>2.线程安全<br>3.可以防止反射注入,反序列化它也不会重新生成新的实例</p>
<p>所有的枚举类型隐性地继承自java.lang.Enum 。枚举实质上还是类！而每个枚举的成员实质就是一个枚举类型的实例，他们默认都是public static final 修饰的。可以直接通过枚举类型名使用它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton &#123;</span><br><span class="line"></span><br><span class="line">  INSTANCE;</span><br><span class="line"></span><br><span class="line">  public void doSomething()&#123;</span><br><span class="line">     System.out.println(&quot;do sth.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="单例模式存在的漏洞"><a href="#单例模式存在的漏洞" class="headerlink" title="单例模式存在的漏洞"></a>单例模式存在的漏洞</h2><p>1、 通过反射获取单例对象</p>
<p>我们观察反射获取单例的代码，发现它还是调用了私有的构造方法获取对象【声明为私有的构造方法就是为了不让类外直接new对象】。如果只让私有的构造器只能调用一次就可以避免反射。</p>
<p>2、 反序列化获得单例模式对象</p>
<p>传统的单例模式的另外一个问题是一旦你实现了serializable接口，他们就不再是单例的了，因为readObject()方法总是返回一个 新的实例对象，就像java中的构造器一样。如果定义了readResolve()则直接返回此方法指定的对象，而不需要再创建新的对象！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 序列化必须实现Serializable接口，否则序列化时会报错</span><br><span class="line"> */</span><br><span class="line">public class Singleton implements Serializable&#123;</span><br><span class="line">     </span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"> </span><br><span class="line">    private static Singleton sl;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        //如果sl不为空即这不是第一次调用该构造器</span><br><span class="line">        if(sl != null)</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(sl == null) &#123;</span><br><span class="line">            sl = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return sl;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    /**</span><br><span class="line">     * 反序列化时，如果定义了readResolve()则直接返回此方法指定的对象，而不需要在创建新的对象！</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Object readResolve() &#123; </span><br><span class="line">        return getInstance(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/d9d9dcf23359" target="_blank" rel="noopener">为什么说枚举是最好的Java单例实现方法？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/design-mode-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/17/design-mode-principle/" itemprop="url">面向对象7大原则</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-17T15:51:03+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这 7 种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</p>
<h2 id="开闭原则-Open-Close-Principle"><a href="#开闭原则-Open-Close-Principle" class="headerlink" title="开闭原则(Open Close Principle)"></a>开闭原则(Open Close Principle)</h2><p>开闭原则的定义是：软件中的对象（类、模块、函数等）应该对于扩展是开放的，对于修改是封闭的。意思就是说当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p>
<p>开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下：<br>1、软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。<br>2、粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。<br>3、遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p>
<p>实现方法：<br>可以通过“<strong>抽象约束、封装变化</strong>”来实现开闭原则，即<strong>通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中</strong>。<br>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<h2 id="里式替换原则-Liskov-Substitution-Principle"><a href="#里式替换原则-Liskov-Substitution-Principle" class="headerlink" title="里式替换原则(Liskov Substitution Principle)"></a>里式替换原则(Liskov Substitution Principle)</h2><p>继承必须确保超类所拥有的性质在子类中仍然成立（Inheritance should ensure that any property proved about supertype objects also holds for subtype objects）。</p>
<p>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p>
<p>它包含以下4层含义：<br>1、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>2、子类中可以增加自己特有的方法。<br>3、当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。<br>4、当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p>
<p>里氏替换原则通俗来讲就是：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。</p>
<h2 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h2><p>依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；<strong>抽象不应该依赖细节，细节应该依赖抽象</strong>（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是：<strong>要面向接口编程，不要面向实现编程</strong>。</p>
<p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p>
<p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p>
<p>主要作用如下：<br>1、可以降低类间的耦合性。<br>2、可以提高系统的稳定性。<br>3、可以减少并行开发引起的风险。<br>4、可以提高代码的可读性和可维护性。</p>
<p>实现方法：<br>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则：<br>1、每个类尽量提供接口或抽象类，或者两者都具备。<br>2、变量的声明类型尽量是接口或者是抽象类。<br>3、任何类都不应该从具体类派生。<br>4、使用继承时尽量遵循里氏替换原则。</p>
<h2 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single Responsibility Principle)"></a>单一职责原则(Single Responsibility Principle)</h2><p>这里的职责是指类变化的原因，单一职责原则规定<strong>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</strong>（There should never be more than one reason for a class to change）。简单来说，一个类中应该是一组相关性很高的函数、数据的封装。</p>
<p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：<br>1、一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；<br>2、当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</p>
<p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点：<br>1、降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。<br>2、提高类的可读性。复杂性降低，自然其可读性会提高。<br>3、提高系统的可维护性。可读性提高，那自然更容易维护了。<br>4、变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</p>
<p>实现方法：<br>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>
<p>注意：单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。</p>
<h2 id="接口隔离原则-Interface-Segregation-Principles"><a href="#接口隔离原则-Interface-Segregation-Principles" class="headerlink" title="接口隔离原则(Interface Segregation Principles)"></a>接口隔离原则(Interface Segregation Principles)</h2><p>定义是：客户端不应该被迫依赖于它不使用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong>（The dependency of one class to another one should depend on the smallest possible interface）。</p>
<p>以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p>
<p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：<br>1、单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。<br>2、单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p>
<p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点：<br>1、将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。<br>2、接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。<br>3、如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。<br>4、使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。<br>5、能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</p>
<p>实现方法：<br>在具体应用接口隔离原则时，应该根据以下几个规则来衡量：<br>1、接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。<br>2、为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。<br>3、了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。<br>4、提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p>
<h2 id="迪米特原则-Law-of-Demeter"><a href="#迪米特原则-Law-of-Demeter" class="headerlink" title="迪米特原则(Law of Demeter)"></a>迪米特原则(Law of Demeter)</h2><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。又称为最少知识原则：<strong>一个对象应该对其他对象有最少的了解</strong>。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点：<br>1、降低了类之间的耦合度，提高了模块的相对独立性。<br>2、由于亲合度降低，从而提高了类的可复用率和系统的扩展性。<br>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p>
<p>实现方法：<br>从迪米特法则的定义和特点可知，它强调以下两点：<br>1、从依赖者的角度来说，只依赖应该依赖的对象。<br>2、从被依赖者的角度说，只暴露应该暴露的方法。<br>所以，在运用迪米特法则时要注意以下 6 点：<br>1、在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。<br>2、在类的结构设计上，尽量降低类成员的访问权限。<br>3、在类的设计上，优先考虑将一个类设置成不变类。<br>4、在对其他类的引用上，将引用其他对象的次数降到最低。<br>5、不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。<br>6、谨慎使用序列化（Serializable）功能。</p>
<h2 id="合成复用原则-Composite-Reuse-Principle"><a href="#合成复用原则-Composite-Reuse-Principle" class="headerlink" title="合成复用原则(Composite Reuse Principle)"></a>合成复用原则(Composite Reuse Principle)</h2><p>合成复用原则又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p>
<p>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点:<br>1.继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。<br>2.子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。<br>3.它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</p>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点:<br>1.它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。<br>2.新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。<br>3.复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</p>
<p>实现方法：<br>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/ds-hashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/16/ds-hashmap/" itemprop="url">HashMap实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-16T15:26:44+08:00">
                2019-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK8的HashMap源码进行分析。</p>
<h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><p>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>
<p>　　 <strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)<br>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)<br>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。<br>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p>
<p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构和链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p>
<p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>
<p>　　　　　　　　<strong>存储位置 = f(关键字)</strong></p>
<p>　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>
<p><img src="/2019/10/16/ds-hashmap/hash-insert.png" alt></p>
<p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，<strong>当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞</strong>。哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而<strong>HashMap即是采用了链地址法，也就是数组+链表+红黑树的方式</strong>。</p>
<h2 id="HashMap底层存储结构"><a href="#HashMap底层存储结构" class="headerlink" title="HashMap底层存储结构"></a>HashMap底层存储结构</h2><p>HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The table, initialized on first use, and resized as</span><br><span class="line"> * necessary. When allocated, length is always a power of two.</span><br><span class="line"> * (We also tolerate length zero in some operations to allow</span><br><span class="line"> * bootstrapping mechanics that are currently not needed.)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Basic hash bin node, used for most entries.  (See below for</span><br><span class="line"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><br><span class="line"> */</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line">    public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125;</span><br><span class="line">    public final V setValue(V newValue) &#123; ... &#125;</span><br><span class="line">    public final boolean equals(Object o) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为table数组的长度是有限的，再好的hash函数也会出现index冲突的情况，所以我们用<strong>链表</strong>来解决这个问题，table数组的每一个元素不只是一个Entry对象，也是一个链表的头节点，每一个Entry对象通过Next指针指向下一个Entry节点。当新来的Entry映射到冲突数组位置时，只需要插入对应的链表即可。</p>
<p>需要注意的是：新来的Entry节点插入链表时，会插在链表的头部，因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。</p>
<p>HashMap中的table数组如下所示：</p>
<p><img src="/2019/10/16/ds-hashmap/hashmap-table.png" alt></p>
<p>所以，HashMap是<strong>数组+链表+红黑树</strong>（在Java 8中为了优化Entry的查找性能，新加了红黑树部分）实现的。</p>
<h2 id="Put方法原理"><a href="#Put方法原理" class="headerlink" title="Put方法原理"></a>Put方法原理</h2><p>调用hashMap.put(“str”, 1)，将会在HashMap的table数组中插入一个Key为“str”的元素，这时候需要我们用一个hash()函数来确定Entry的插入位置，而每种数据类型有自己的hashCode()函数，比如String类型的hashCode()函数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int hashCode(byte[] value) &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line">    for (byte v : value) &#123;</span><br><span class="line">        h = 31 * h + (v &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，put()函数的执行路径是这样的：</p>
<ol>
<li>首先put(“str”, 1)会调用HashMap的hash(“str”)方法。</li>
<li>在hash()内部，会调用String(Latin1)内部的hashcode()获取字符串”str”的hashcode。</li>
<li>“str”的hashcode被返回给put()，put()通过一定计算得到最终的插入位置index。</li>
<li>最后将这个Entry插入到table的index位置。</li>
</ol>
<p>这里就出现了两个问题，问题1: 在put()里怎样得到插入位置index？问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？</p>
<h3 id="问题1-在put-里怎样得到插入位置index？"><a href="#问题1-在put-里怎样得到插入位置index？" class="headerlink" title="问题1: 在put()里怎样得到插入位置index？"></a>问题1: 在put()里怎样得到插入位置index？</h3><p>对于不同的hash码我们希望它被插入到不同的位置，所以我们首先会想到对数组长度的取模运算，但是由于取模运算的效率很低，所以HashMap的发明者用<strong>位运算</strong>替代了取模运算。</p>
<p>在put()里是通过如下的语句得到插入位置的(<strong>key的哈希值与map长度-1相与</strong>)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash(key) &amp; (Length - 1)</span><br></pre></td></tr></table></figure></p>
<p>其中Length是table数组的长度。为了实现和取模运算相同的功能，这里要求(Length - 1)这部分的二进制表示全为1，我们用HashMap的默认初始长度16举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设&quot;str&quot;的hash吗为: 1001 0110 1011 1110 1101 0010 1001 0101</span><br><span class="line"></span><br><span class="line">Length - 1 = 15 : 1111</span><br><span class="line"></span><br><span class="line">hash(&quot;str&quot;) &amp; (Length - 1) = 0101</span><br></pre></td></tr></table></figure>
<p>如果(Length - 1)这部分不全为1，假如Length是10，那么Length - 1 = 9 ：1001 那么无论再和任何hash码做与操作，中间两位数都会是0，这样就会出现大量不同的hash码被映射到相同位置的情况。</p>
<p>所以，<strong>在HashMap中table数组的默认长度是16，并且要求每次自动扩容或者手动扩容时，长度都必须是2的幂。</strong></p>
<h3 id="问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？"><a href="#问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？" class="headerlink" title="问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？"></a>问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？</h3><p>HashMap中的hash()函数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>HashMap中的hash()函数是将得到hashcode做进一步处理，它将hashcode的高16位和低16位进行异或操作</strong>，这样做的目的是：在table的长度比较小的情况下，也能保证hashcode的高位参与到地址映射的计算当中，同时不会有太大的开销。</p>
<p>综上所述：从hashcode计算得到table索引的计算过程如下所示：</p>
<p><img src="/2019/10/16/ds-hashmap/hash-process.png" alt></p>
<p>put()方法的执行过程如下所示：</p>
<p><img src="/2019/10/16/ds-hashmap/hash-put.png" alt></p>
<h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><p>在HashMap中有一下两个属性和扩容相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int threshold;</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure></p>
<p>其中threshold = Length * loadFactor，Length表示table数组的长度（默认值是16），<strong>loadFactor为负载因子（默认值是0.75）</strong>，阀值threshold表示当table数组中存储的元素超过这个阀值的时候，就需要扩容了。以默认长度16，和默认负载因子0.75为例，threshold = 16 * 0.75 = 12，即当table数组中存储的元素个数超过12个的时候，table数组就该扩容了。</p>
<p>当然Java中的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，然后将旧数组中的元素经过重新计算放到新数组中，那么怎样对旧元素进行重新映射呢？</p>
<p>其实很简单，由于我们在扩容时，是使用2的幂扩展，即数组的长度扩大到原来的2倍, 4倍, 8倍…，因此<strong>在resize时(Length - 1)这部分相当于在高位新增一个或多个1bit</strong>，我们以扩大到原来的两倍为例说明：</p>
<p><img src="/2019/10/16/ds-hashmap/rehash1.png" alt></p>
<p>(a)中n为16，(b)中n扩大到两倍为32，相当于(n - 1)这部分的高位多了一个1, 然后和原hash码作与操作，<strong>这样元素在数组中映射的位置要么不变，要不向后移动16个位置</strong>：</p>
<p><img src="/2019/10/16/ds-hashmap/rehash2.png" alt></p>
<p>因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="/2019/10/16/ds-hashmap/rehash3.png" alt></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中resize的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<p>JDK 1.8 以后哈希表的 添加、删除、查找、扩容方法都增加了一种 节点为 TreeNode 的情况：</p>
<ul>
<li>添加时，当桶中链表个数超过 8 时会转换成红黑树；</li>
<li>删除、扩容时，如果桶中结构为红黑树，并且树中元素个数太少的话，会进行修剪或者直接还原成链表结构；</li>
<li>查找时即使哈希函数不优，大量元素集中在一个桶中，由于有红黑树结构，性能也不会差。</li>
</ul>
<h2 id="HashMap死锁形成原理"><a href="#HashMap死锁形成原理" class="headerlink" title="HashMap死锁形成原理"></a>HashMap死锁形成原理</h2><p>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用线程安全的ConcurrentHashMap。</p>
<p>要理解HashMap死锁形成的原理，我们要对HashMap的resize里的transfer过程有所了解，transfer过程是将旧数组中的元素复制到新数组中，在Java 8之前，复制过程会导致链表倒置，这也是形成死锁的重要原因（Java 8中已经不会倒置），transfer的基本过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 新建节点e指向当前节点，新建节点next指向e.next</span><br><span class="line">2. 将e.next指向新数组中指定位置newTable[i]</span><br><span class="line">3. newTable[i] = e</span><br><span class="line">4. e = next</span><br></pre></td></tr></table></figure></p>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现在有链表1-&gt;2-&gt;3，要将它复制到新数组的newTable[i]位置</span><br><span class="line">1. Node e = 1, next = e.next;</span><br><span class="line">2. e.next = newTable[i];</span><br><span class="line">3. newTable[i] = e;</span><br><span class="line">4. e = next, next = e.next;</span><br><span class="line">执行完后会得到这样的结果：</span><br><span class="line">newTable[i]=3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure></p>
<p>死锁会在这种情况产生：两个线程同时往HashMap里放Entry，同时HashMap正好需要扩容，如果一个线程已经完成了transfer过程，而另一个线程不知道，并且又要进行transfer的时候，死锁就会形成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在Thread1已将完成了transfer，newTable[i]=3-&gt;2-&gt;1</span><br><span class="line">在Thread2中:</span><br><span class="line">Node e = 1, next = e.next;</span><br><span class="line">e.next = newTable[i]    : 1 -&gt; newTable[i]=3</span><br><span class="line">newTable[i] = e         : newTable[i] = 1-&gt;3-&gt;2-&gt;1  //这时候链表换已经形成了</span><br></pre></td></tr></table></figure></p>
<p>在形成链表换以后再对HashMap进行Get操作时，就会形成死循环。</p>
<p>在Java 8中对这里进行了优化，链表复制到新数组时并不会倒置，不会因为多个线程put导致死循环，但是还有很多弊端，比如数据丢失等，因此多线程情况下还是建议使用ConcurrentHashMap。</p>
<h2 id="HashMap和Hashtable有什么区别"><a href="#HashMap和Hashtable有什么区别" class="headerlink" title="HashMap和Hashtable有什么区别"></a>HashMap和Hashtable有什么区别</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
<p><img src="/2019/10/16/ds-hashmap/hashmap-extends-tree.png" alt></p>
<p>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为<strong>ConcurrentHashMap引入了分段锁</strong>。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li>
<li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li>
<li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li>
<li>JDK1.8引入红黑树大程度优化了HashMap的性能。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xinxingastro.github.io/2018/05/11/Java/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">HashMap底层实现原理</a><br><a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">HashMap实现原理及源码分析</a><br><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/android-webview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/android-webview/" itemprop="url">Android WebView 性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-26T09:44:09+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h2><p>这个比较容易，开启webView的缓存功能就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WebSettings settings = webView.getSettings();</span><br><span class="line">settings.setAppCacheEnabled(true);</span><br><span class="line">settings.setDatabaseEnabled(true);</span><br><span class="line">settings.setDomStorageEnabled(true);//开启DOM缓存，关闭的话H5自身的一些操作是无效的</span><br><span class="line">settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">settings.setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure></p>
<p>这边我们通过setCacheMode方法来设置WebView的缓存策略，WebSettings.LOAD_DEFAULT是默认的缓存策略，它在缓存可获取并且没有过期的情况下加载缓存，否则通过网络获取资源。这样的话可以减少页面的网络请求次数，那我们如何在离线的情况下也能打开页面呢，这里我们在加载页面的时候可以通过判断网络状态，<strong>在无网络的情况下更改webview的缓存策略</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">NetworkInfo info = cm.getActiveNetworkInfo();</span><br><span class="line">if(info.isAvailable())</span><br><span class="line">&#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">&#125;else </span><br><span class="line">&#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY);//不使用网络，只加载缓存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以使我们的混合应用在没有网络的情况下也能使用一部分的功能，不至于什么都显示不了了，当然如果我们将缓存做的更好一些，在网络好的时候，比如说在WIFI状态下，去后台加载一些网页缓存起来，这样处理的话，即使在无网络情况下第一次打开某些页面的时候，也能将该页面显示出来。<br>当然缓存资源后随之会带来一个问题，那就是<strong>资源无法及时更新，WebSettings.LOAD_DEFAULT中的页面中的缓存版本好像不是很起作用，所以我们这边可能需要自己做一个缓存版本控制</strong>。这个缓存版本控制可以放在APP版本更新中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (upgrade.cacheControl &gt; cacheControl)</span><br><span class="line">&#123;</span><br><span class="line">    webView.clearCache(true);//删除DOM缓存</span><br><span class="line">    VersionUtils.clearCache(mContext.getCacheDir());//删除APP缓存</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        mContext.deleteDatabase(&quot;webview.db&quot;);//删除数据库缓存</span><br><span class="line">        mContext.deleteDatabase(&quot;webviewCache.db&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>1.可以将 Webview 的 Activity 新起一个进程，结束的时候直接System.exit(0);退出当前进程；<br>启动新进程，主要代码： AndroidManifest.xml 配置文件代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.ui.activity.Html5Activity&quot;</span><br><span class="line">    android:process=&quot;:lyl.boon.process.web&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.lyl.boon.ui.activity.htmlactivity&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>
<p>在新进程中启动 Activity ，里面传了 一个 Url：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.lyl.boon.ui.activity.htmlactivity&quot;);</span><br><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">bundle.putString(&quot;url&quot;, gankDataEntity.getUrl());</span><br><span class="line">intent.putExtra(&quot;bundle&quot;,bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<p>然后在 Html5Activity 的onDestory() 最后加上 System.exit(0); 杀死当前进程。</p>
<p>Android7.0系统以后，WebView相对来说是比较稳定的，无论承载WebView的容器是否在主进程，都不需要担心WebView崩溃导致应用也跟着崩溃。然后7.0以下的系统就没有这么幸运了，特别是低版本的WebView。考虑应用的稳定性，我们可以把7.0以下系统的WebView使用一个独立进程的Activity来包装，这样即使WebView崩溃了，也只是WebView所在的进程发生了崩溃，主进程还是不受影响的。</p>
<p>2.不在xml中定义 Webview ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        mWebView = new WebView(getApplicationContext());</span><br><span class="line">        mWebView.setLayoutParams(params);</span><br><span class="line">        mLayout.addView(mWebView);</span><br></pre></td></tr></table></figure></p>
<p>3.在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        if (mWebView != null) &#123;</span><br><span class="line">            mWebView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);</span><br><span class="line">			mWebView.getSettings().setJavaScriptEnabled(false);</span><br><span class="line">        	mWebView.clearFormData();</span><br><span class="line">            mWebView.clearHistory();</span><br><span class="line">			mWebView.stopLoading();</span><br><span class="line"></span><br><span class="line">            ((ViewGroup) mWebView.getParent()).removeView(mWebView);</span><br><span class="line">            mWebView.destroy();</span><br><span class="line">            mWebView = null;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>有时候一个页面资源比较多，图片，CSS，js比较多，还引用了JQuery这种庞然巨兽，从加载到页面渲染完成需要比较长的时间，有一个解决方案是<strong>将这些资源打包进APK里面，然后当页面加载这些资源的时候让它从本地获取</strong>，这样可以提升加载速度也能减少服务器压力。重写WebClient类中的shouldInterceptRequest方法，再将这个类设置给WebView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(new WebViewClient()</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public WebResourceResponse shouldInterceptRequest(WebView view, String url)</span><br><span class="line">    &#123;</span><br><span class="line">        if (url.contains(&quot;[tag]&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            String localPath = url.replaceFirst(&quot;^http.*[tag]\\]&quot;, &quot;&quot;);</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                InputStream is = getApplicationContext().getAssets().open(localPath);</span><br><span class="line">                Log.d(TAG, &quot;shouldInterceptRequest: localPath &quot; + localPath);</span><br><span class="line">                String mimeType = &quot;text/javascript&quot;;</span><br><span class="line">                if (localPath.endsWith(&quot;css&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                    mimeType = &quot;text/css&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                return new WebResourceResponse(mimeType, &quot;UTF-8&quot;, is);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里我们队页面中带有特殊标记的请求进行过滤替换，也就是上面代码中的[tag]，这个可以跟做后台开发的同事约定好来就行了。对图片资源或者其他资源进行替换也是可以的。补充一个小点<strong>可以通过settings.setLoadsImagesAutomatically(true);来设置在页面装载完成之后再去加载图片。</strong>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">webView.getSettings().setBlockNetworkImage(true);  </span><br><span class="line">webView.setWebChromeClient(new WebChromeClient() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void onProgressChanged(WebView view, int newProgress) &#123;  </span><br><span class="line">                if (newProgress == 100) &#123;  </span><br><span class="line">                    // 网页加载完成  </span><br><span class="line">                    loadDialog.dismiss();  </span><br><span class="line">                    webView.getSettings().setBlockNetworkImage(false);  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    // 网页加载中  </span><br><span class="line">                    loadDialog.show();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h2><h3 id="SSL问题"><a href="#SSL问题" class="headerlink" title="SSL问题"></a>SSL问题</h3><p>通常情况下，通过WebView的loadUrl(String url)方法，可以顺利加载页面。但是，当load通过SSL加密的HTTPS页面时，如果这个页面的安全证书无法得到认证，WebView就会显示成空白页。</p>
<p>解决方式：<br>通过重写WebViewClient的onReceivedSslError方法来接受所有网站的证书，忽略SSL错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123;</span><br><span class="line">    handler.proceed();</span><br><span class="line">    super.onReceivedSslError(view, handler, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="低版本兼容问题"><a href="#低版本兼容问题" class="headerlink" title="低版本兼容问题"></a>低版本兼容问题</h3><p>由于现在h5大部分都是 vue的形式打包，（可能过个一两年就变了，但是万变不离其中），这个时候要注意了， 由于是webv加载的h5，在Android老的机型上  webview 内核可能不支持  最新的h5 框架，这时候 就需要我们找h5 的同学 搞事情了，  对于 vue，想要老机器不出现白屏其实也很简单，让h5的同学 做一下老版本的兼容，具体方法：</p>
<p>虽然vue-cli引入了babel对js语法进行降级，但是还是有些老旧的机型会发生各种各样的问题，这里需要引入一个叫babel-polyfill的包。所以你只需只在你引入import vue之前 import babel-polyfill进来就可以了，主要是为了让es6对个别机型做到兼容。</p>
<h2 id="301-302重定向问题"><a href="#301-302重定向问题" class="headerlink" title="301/302重定向问题"></a>301/302重定向问题</h2><p>WebView的301/302重定向问题，绝对在踩坑排行榜里名列前茅。。。随便搜了几个解决方案，要么不能满足业务需求，要么清一色没有彻底解决问题。</p>
<p><a href="https://stackoverflow.com/questions/4066438/android-webview-how-to-handle-redirects-in-app-instead-of-opening-a-browser" target="_blank" rel="noopener">https://stackoverflow.com/questions/4066438/android-webview-how-to-handle-redirects-in-app-instead-of-opening-a-browser</a><br><a href="http://blog.csdn.net/jdsjlzx/article/details/51698250" target="_blank" rel="noopener">http://blog.csdn.net/jdsjlzx/article/details/51698250</a><br><a href="http://www.cnblogs.com/pedro-neer/p/5318354.html" target="_blank" rel="noopener">http://www.cnblogs.com/pedro-neer/p/5318354.html</a><br><a href="http://www.jianshu.com/p/c01769ababfa" target="_blank" rel="noopener">http://www.jianshu.com/p/c01769ababfa</a></p>
<h3 id="301-302业务场景及白屏问题"><a href="#301-302业务场景及白屏问题" class="headerlink" title="301/302业务场景及白屏问题"></a>301/302业务场景及白屏问题</h3><p>先来分析一下业务场景。对于需要对url进行拦截以及在url中需要拼接特定参数的WebView来说，301和302发生的情景主要有以下几种：</p>
<ul>
<li>首次进入，有重定向，然后直接加载H5页面，如http跳转https</li>
<li>首次进入，有重定向，然后跳转到native页面，如扫一扫短链，然后跳转到native</li>
<li>二次加载，有重定向，跳转到native页面</li>
<li>对于考拉业务来说，还有类似登录后跳转到某个页面的需求。如我的拼团，未登录状态下点击我的拼团跳转到登录页面，登录完成后再加载我的拼团页。</li>
</ul>
<p>第一种情况属于正常情况，暂时没遇到什么坑。</p>
<p>第二种情况，会遇到<strong>WebView空白页问题</strong>，属于原始url不能拦截到native页面，但301/302后的url拦截到native页面的情况，当遇到这种情况时，需要把WebView对应的Activity结束，否则当用户从拦截后的页面返回上一个页面时，是一个WebView空白页。</p>
<p>第三种情况，也会遇到<strong>WebView空白页问题</strong>，原因在于加载的第一个页面发生了重定向到了第二个页面，第二个页面被客户端拦截跳转到native页面，那么WebView就停留在第一个页面的状态了，第一个页面显然是空白页。</p>
<p>第四种情况，会遇到<strong>无限加载登录页面的问题</strong>。考拉的登录链接是类似下面这种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://m.kaola.com/login.html?target=登录后跳转的url</span><br></pre></td></tr></table></figure></p>
<p>如果登录成功后还重新加载这个url，那么就会循环跳转到登录页面。第四点解决起来比较简单，登录成功以后拿到target后的跳转url再重新加载即可。</p>
<h3 id="301-302回退栈问题"><a href="#301-302回退栈问题" class="headerlink" title="301/302回退栈问题"></a>301/302回退栈问题</h3><p>无论是哪种重定向场景，都不可避免地会遇到回退栈的处理问题，如果处理不当，用户按返回键的时候不一定能回到重定向之前的那个页面。很多开发者在覆写WebViewClient.shouldOverrideUrlLoading()方法时，会简单地使用以下方式粗暴处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WebView.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">    	view.loadUrl(url);</span><br><span class="line">    	return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这种方法最致命的弱点就是如果不经过特殊处理，那么按返回键是没有效果的，还会停留在302之前的页面。现有的解决方案无非就几种：</p>
<ol>
<li>手动管理回退栈，遇到重定向时回退两次<a href="https://qbeenslee.com/article/android-webview-302-redirect/" target="_blank" rel="noopener">^6</a>。</li>
<li>通过HitTestResult判断是否是重定向，从而决定是否自己加载url<a href="https://www.cnblogs.com/zimengfang/p/6183869.html" target="_blank" rel="noopener">^7</a>。</li>
<li>通过设置标记位，在onPageStarted和onPageFinished分别标记变量避免重定向<a href="https://blog.csdn.net/dg_summer/article/details/78105582" target="_blank" rel="noopener">^9</a>。</li>
</ol>
<p>可以说，这几种解决方案都不是完美的，都有缺陷。以下给出301/302较优解决方案：</p>
<h3 id="解决301-302回退栈问题"><a href="#解决301-302回退栈问题" class="headerlink" title="解决301/302回退栈问题"></a>解决301/302回退栈问题</h3><p>能否结合上面的几种方案，来更加准确地判断301/302的情况呢？下面说一下本文的解决思路。在提供解决方案之前，我们需要了解一下shouldOverrideUrlLoading方法的返回值代表什么意思。</p>
<blockquote>
<p>Give the host application a chance to take over the control when a new url is about to be loaded in the current WebView. If WebViewClient is not provided, by default WebView will ask Activity Manager to choose the proper handler for the url. If WebViewClient is provided, return true means the host application handles the url, while return false means the current WebView handles the url.</p>
</blockquote>
<p>简单地说，就是返回true，那么url就已经由客户端处理了，WebView就不管了，如果返回false，那么当前的WebView实现就会去处理这个url。</p>
<p>WebView能否知道某个url是不是301/302呢？当然知道，WebView能够拿到url的请求信息和响应信息，根据header里的code很轻松就可以实现，事实正是如此，交给WebView来处理重定向(return false)，这时候按返回键，是可以正常地回到重定向之前的那个页面的。（PS：WebView在5.0以后是一个独立的apk，可以单独升级，新版本的WebView实现肯定处理了重定向问题）</p>
<p>但是，业务对url拦截有需求，肯定不能把所有的情况都交给系统WebView处理。为了解决url拦截问题，本文引入了另一种思想——通过用户的touch事件来判断重定向。下面通过代码来说明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * WebView基础类，处理一些基础的公有操作</span><br><span class="line"> *</span><br><span class="line"> * @author xingli</span><br><span class="line"> * @time 2017-12-06</span><br><span class="line"> */</span><br><span class="line">public class BaseWebView extends WebView &#123;</span><br><span class="line">    private boolean mTouchByUser;</span><br><span class="line">    public BaseWebView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line">    public BaseWebView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    public BaseWebView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void loadUrl(String url, Map&lt;String, String&gt; additionalHttpHeaders) &#123;</span><br><span class="line">        super.loadUrl(url, additionalHttpHeaders);</span><br><span class="line">        resetAllStateInternal(url);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void loadUrl(String url) &#123;</span><br><span class="line">        super.loadUrl(url);</span><br><span class="line">        resetAllStateInternal(url);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void postUrl(String url, byte[] postData) &#123;</span><br><span class="line">        super.postUrl(url, postData);</span><br><span class="line">        resetAllStateInternal(url);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void loadData(String data, String mimeType, String encoding) &#123;</span><br><span class="line">        super.loadData(data, mimeType, encoding);</span><br><span class="line">        resetAllStateInternal(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding,</span><br><span class="line">            String historyUrl) &#123;</span><br><span class="line">        super.loadDataWithBaseURL(baseUrl, data, mimeType, encoding, historyUrl);</span><br><span class="line">        resetAllStateInternal(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void reload() &#123;</span><br><span class="line">        super.reload();</span><br><span class="line">        resetAllStateInternal(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isTouchByUser() &#123;</span><br><span class="line">        return mTouchByUser;</span><br><span class="line">    &#125;</span><br><span class="line">    private void resetAllStateInternal(String url) &#123;</span><br><span class="line">        if (!TextUtils.isEmpty(url) &amp;&amp; url.startsWith(&quot;javascript:&quot;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        resetAllState();</span><br><span class="line">    &#125;</span><br><span class="line">	// 加载url时重置touch状态</span><br><span class="line">    protected void resetAllState() &#123;</span><br><span class="line">        mTouchByUser = false;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">            	//用户按下到下一个链接加载之前，置为true</span><br><span class="line">                mTouchByUser = true;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setWebViewClient(final WebViewClient client) &#123;</span><br><span class="line">        super.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">                boolean handleByChild = null != client &amp;&amp; client.shouldOverrideUrlLoading(view, url);</span><br><span class="line">            	   if (handleByChild) &#123;</span><br><span class="line">             		// 开放client接口给上层业务调用，如果返回true，表示业务已处理。</span><br><span class="line">                    return true;</span><br><span class="line">            	   &#125; else if (!isTouchByUser()) &#123;</span><br><span class="line">             		// 如果业务没有处理，并且在加载过程中用户没有再次触摸屏幕，认为是301/302事件，直接交由系统处理。</span><br><span class="line">                    return super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                	//否则，属于二次加载某个链接的情况，为了解决拼接参数丢失问题，重新调用loadUrl方法添加固有参数。</span><br><span class="line">                    loadUrl(url);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @RequiresApi(api = Build.VERSION_CODES.N)</span><br><span class="line">            @Override</span><br><span class="line">            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123;</span><br><span class="line">                boolean handleByChild = null != client &amp;&amp; client.shouldOverrideUrlLoading(view, request);</span><br><span class="line">                if (handleByChild) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (!isTouchByUser()) &#123;</span><br><span class="line">                    return super.shouldOverrideUrlLoading(view, request);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    loadUrl(request.getUrl().toString());</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码解决了正常情况下的回退栈问题。</p>
<h3 id="解决业务白屏问题"><a href="#解决业务白屏问题" class="headerlink" title="解决业务白屏问题"></a>解决业务白屏问题</h3><p>为了解决白屏问题，考拉目前的解决思路和上面的回退栈问题思路有些类似，通过监听touch事件分发以及onPageFinished事件来判断是否产生白屏，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">public class KaolaWebview extends BaseWebView implements DownloadListener, Lifeful, OnActivityResultListener &#123;</span><br><span class="line">    private boolean mIsBlankPageRedirect;  //是否因重定向导致的空白页面。</span><br><span class="line">    public KaolaWebview(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    public KaolaWebview(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    public KaolaWebview(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    protected void back() &#123;</span><br><span class="line">        if (mBackStep &lt; 1) &#123;</span><br><span class="line">            mJsApi.trigger2(&quot;kaolaGoback&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            realBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            mIsBlankPageRedirect = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    private WebViewClient mWebViewClient = new WebViewClient() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">            url = WebViewUtils.removeBlank(url);</span><br><span class="line">            //允许启动第三方应用客户端</span><br><span class="line">            if (WebViewUtils.canHandleUrl(url)) &#123;</span><br><span class="line">                boolean handleByCaller = false;</span><br><span class="line">                // 如果不是用户触发的操作，就没有必要交给上层处理了，直接走url拦截规则。</span><br><span class="line">                if (null != mIWebViewClient &amp;&amp; isTouchByUser()) &#123;</span><br><span class="line">                    handleByCaller = mIWebViewClient.shouldOverrideUrlLoading(view, url);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!handleByCaller) &#123;</span><br><span class="line">                    handleByCaller = handleOverrideUrl(url);</span><br><span class="line">                &#125;</span><br><span class="line">                return handleByCaller || super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    notifyBeforeLoadUrl(url);</span><br><span class="line">                    Intent intent = Intent.parseUri(url, Intent.URI_INTENT_SCHEME);</span><br><span class="line">                    intent.addCategory(Intent.CATEGORY_BROWSABLE);</span><br><span class="line">                    mContext.startActivity(intent);</span><br><span class="line">                    if (!mIsBlankPageRedirect) &#123;</span><br><span class="line">                    	// 如果遇到白屏问题，手动后退</span><br><span class="line">                        back();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    ExceptionUtils.printExceptionTrace(e);</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @RequiresApi(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">        @Override</span><br><span class="line">        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123;</span><br><span class="line">            return shouldOverrideUrlLoading(view, request.getUrl().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        private boolean handleOverrideUrl(final String url) &#123;</span><br><span class="line">           RouterResult result =  WebActivityRouter.startFromWeb(</span><br><span class="line">                    new IntentBuilder(mContext, url).setRouterActivityResult(new RouterActivityResult() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onActivityFound() &#123;</span><br><span class="line">                            if (!mIsBlankPageRedirect) &#123;</span><br><span class="line">                    			// 路由已经拦截到跳转到native页面，但此时可能发生了</span><br><span class="line">                    			// 301/302跳转，那么执行后退动作，防止白屏。</span><br><span class="line">                                back();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onActivityNotFound() &#123;</span><br><span class="line">                            if (mIWebViewClient != null) &#123;</span><br><span class="line">                                mIWebViewClient.onActivityNotFound();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">            return result.isSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPageFinished(WebView view, String url) &#123;</span><br><span class="line">        mIsBlankPageRedirect = true;</span><br><span class="line">        if (null != mIWebViewClient) &#123;</span><br><span class="line">            mIWebViewClient.onPageReallyFinish(view, url);</span><br><span class="line">        &#125;</span><br><span class="line">        super.onPageFinished(view, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本来上面的两个问题可以用同一个变量控制解决的，但由于历史代码遗留问题，目前还没有时间优化测试，这也是代码暂不公布的原因之一。</p>
<h2 id="loadUrl-url-map-方法加载带hash（带-号）的url导致刷新问题或请求头缓存问题"><a href="#loadUrl-url-map-方法加载带hash（带-号）的url导致刷新问题或请求头缓存问题" class="headerlink" title="loadUrl(url,map)方法加载带hash（带#号）的url导致刷新问题或请求头缓存问题"></a>loadUrl(url,map)方法加载带hash（带#号）的url导致刷新问题或请求头缓存问题</h2><p>1.如果调用loadUrl(url,map)方法去加载资源，那么在此调用loadUrl(ur),reload,loadUrl(url,map)造成无法刷新的问题。这个现象主要出现在Android 8.0的系统中。<br>可尝试调用如下url尝试：</p>
<pre><code>https://baike.baidu.com/item/%E9%83%8E%E5%B9%B3/58857#/
https://baike.baidu.com/item/%E9%83%8E%E5%B9%B3/58857#/?a=123
https://baike.baidu.com/item/%E9%83%8E%E5%B9%B3/58857#3
</code></pre><p>2.loadUrl(url,map) 第二个参数map中传入的数据用于请求头，此外这个请求头数据会被webview缓存下来，刷新时，请求头中的数据还是原来的，因此，不适用传入需要进程变化的“状态”信息。</p>
<p>解决方法：不要使用loadUrl(url,map)，推荐使用loadUrl(url)，如果非要传输参数，还不如在url中添加参数。</p>
<h2 id="是否应该开启硬件加速"><a href="#是否应该开启硬件加速" class="headerlink" title="是否应该开启硬件加速"></a>是否应该开启硬件加速</h2><p>由于碎片化问题太多，建议保持默认状态【默认表示由系统决定，不要手动设置】，否则可能产生问题。</p>
<h2 id="Cookie同步导致的内存泄漏"><a href="#Cookie同步导致的内存泄漏" class="headerlink" title="Cookie同步导致的内存泄漏"></a>Cookie同步导致的内存泄漏</h2><p>使用CookieSyncManager同步时，会永久引用第一个acitivity的的Context，为了避免此种情况，请使用ApplicationContext<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> if (Build.VERSION.SDK_INT &lt; 21) &#123;</span><br><span class="line">        android.webkit.CookieSyncManager.createInstance(context.getApplicationContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Android5-0-WebView中Http和Https混合问题"><a href="#Android5-0-WebView中Http和Https混合问题" class="headerlink" title="Android5.0 WebView中Http和Https混合问题"></a>Android5.0 WebView中Http和Https混合问题</h2><p>在Android 5.0上 Webview 默认不允许加载 Http 与 Https 混合内容：</p>
<p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">     webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数类型说明：<br>MIXED_CONTENT_ALWAYS_ALLOW：允许从任何来源加载内容，即使起源是不安全的；<br>MIXED_CONTENT_NEVER_ALLOW：不允许Https加载Http的内容，即不允许从安全的起源去加载一个不安全的资源；<br>MIXED_CONTENT_COMPATIBILITY_MODE：当涉及到混合式内容时，WebView 会尝试去兼容最新Web浏览器的风格。</p>
<p>在5.0以下 Android 默认是 全允许，但是到了5.0以上，就是不允许，实际情况下很我们很难确定所有的网页都是https的，所以就需要这一步的操作。</p>
<h2 id="onPageFinished被调用多次"><a href="#onPageFinished被调用多次" class="headerlink" title="onPageFinished被调用多次"></a>onPageFinished被调用多次</h2><p>使用onPageProgressChanged代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void  handleProgress(WebView view, int newProgress)&#123;</span><br><span class="line">    if(progressPending.get()!=newProgress)&#123;</span><br><span class="line">        progressPending.set(newProgress);</span><br><span class="line">        onProgressChanged(newProgress);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final void onProgressChanged(WebView view, int newProgress) &#123;</span><br><span class="line">    super.onProgressChanged(view, newProgress);</span><br><span class="line">    handleProgress(view,newProgress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onProgressChanged(int newProgress)&#123;</span><br><span class="line">   Log.i(&quot;WebChromeClient&quot;,&quot;progress=&quot;+newProgress+&quot;%&quot;);</span><br><span class="line">   if(newProgress==100)&#123;</span><br><span class="line">       Log.i(&quot;WebChromeClient&quot;,&quot;加载完成&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="H5优化"><a href="#H5优化" class="headerlink" title="H5优化"></a>H5优化</h2><p>Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使 用JQuery，会在处理完DOM对象，执行完$(document).ready(function() {});事件自会后才会渲染并显示页面。而同样的页面在iPhone上却是载入相当的快，因为iPhone是显示完页面才会触发脚本的执行。所以我们这边的解决方案延迟JS脚本的载入，这个方面的问题是需要Web前端工程师帮忙优化的，网上应该有比较多LazyLoad插件，这里放一个比较老的链接<a href="https://wonko.com/post/painless_javascript_lazy_loading_with_lazyload/" target="_blank" rel="noopener">Painless JavaScript lazy loading with LazyLoad</a>,同样也放上一小段前端代码，仅供参考。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;/css/j/lazyload-min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  loadComplete() &#123;</span><br><span class="line">    //instead of document.read();</span><br><span class="line">  &#125; </span><br><span class="line">  function loadscript() &#123;</span><br><span class="line">    LazyLoad.loadOnce([</span><br><span class="line">      &apos;/css/j/jquery-1.6.2.min.js&apos;,</span><br><span class="line">      &apos;/css/j/flow/jquery.flow.1.1.min.js&apos;,</span><br><span class="line">      &apos;/css/j/min.js?v=2011100852&apos;</span><br><span class="line">      ], loadComplete);</span><br><span class="line">  &#125;</span><br><span class="line">  setTimeout(loadscript,10);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/427600ca2107" target="_blank" rel="noopener">https://www.jianshu.com/p/427600ca2107</a><br><a href="https://my.oschina.net/ososchina/blog/1799575" target="_blank" rel="noopener">https://my.oschina.net/ososchina/blog/1799575</a><br><a href="https://iluhcm.com/2017/12/10/design-an-elegant-and-powerful-android-webview-part-one/" target="_blank" rel="noopener">https://iluhcm.com/2017/12/10/design-an-elegant-and-powerful-android-webview-part-one/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/05/android-listview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/05/android-listview/" itemprop="url">Android ListView原理完全解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-05T13:33:57+08:00">
                2019-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ListView的结构，如下图所示：</p>
<p><img src="/2019/09/05/android-listview/listview.png" alt></p>
<h2 id="Adapter作用"><a href="#Adapter作用" class="headerlink" title="Adapter作用"></a>Adapter作用</h2><p>Adapter是适配器的意思，它在ListView和数据源之间起到了一个桥梁的作用，ListView并不会直接和数据源打交道，而是会借助Adapter这个桥梁来去访问真正的数据源，与之前不同的是，Adapter的接口都是统一的，因此ListView不用再去担心任何适配方面的问题。而Adapter又是一个接口(interface)，它可以去实现各种各样的子类，每个子类都能通过自己的逻辑来去完成特定的功能，以及与特定数据源的适配操作，比如说ArrayAdapter可以用于数组和List类型的数据源适配，SimpleCursorAdapter可以用于游标类型的数据源适配，这样就非常巧妙地把数据源适配困难的问题解决掉了，并且还拥有相当不错的扩展性。简单的原理示意图如下所示：</p>
<p>当然Adapter的作用不仅仅只有<strong>数据源适配</strong>这一点，还有一个非常非常重要的方法也需要我们在Adapter当中去重写，就是getView()方法</p>
<h2 id="RecycleBin机制"><a href="#RecycleBin机制" class="headerlink" title="RecycleBin机制"></a>RecycleBin机制</h2><p>在开始分析ListView的源码之前，还有一个东西是我们提前需要了解的，就是RecycleBin机制，这个机制也是ListView能够实现成百上千条数据都不会OOM最重要的一个原因。其实RecycleBin的代码并不多，它是写在AbsListView中的一个内部类，所以所有继承自AbsListView的子类，也就是ListView和GridView，都可以使用这个机制。那我们来看一下RecycleBin中的主要代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The RecycleBin facilitates reuse of views across layouts. The RecycleBin</span><br><span class="line"> * has two levels of storage: ActiveViews and ScrapViews. ActiveViews are</span><br><span class="line"> * those views which were onscreen at the start of a layout. By</span><br><span class="line"> * construction, they are displaying current information. At the end of</span><br><span class="line"> * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews</span><br><span class="line"> * are old views that could potentially be used by the adapter to avoid</span><br><span class="line"> * allocating views unnecessarily.</span><br><span class="line"> * </span><br><span class="line"> * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener)</span><br><span class="line"> * @see android.widget.AbsListView.RecyclerListener</span><br><span class="line"> */</span><br><span class="line">class RecycleBin &#123;</span><br><span class="line">	private RecyclerListener mRecyclerListener;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * The position of the first view stored in mActiveViews.</span><br><span class="line">	 */</span><br><span class="line">	private int mFirstActivePosition;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Views that were on screen at the start of layout. This array is</span><br><span class="line">	 * populated at the start of layout, and at the end of layout all view</span><br><span class="line">	 * in mActiveViews are moved to mScrapViews. Views in mActiveViews</span><br><span class="line">	 * represent a contiguous range of Views, with position of the first</span><br><span class="line">	 * view store in mFirstActivePosition.</span><br><span class="line">	 */</span><br><span class="line">	private View[] mActiveViews = new View[0];</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Unsorted views that can be used by the adapter as a convert view.</span><br><span class="line">	 */</span><br><span class="line">	private ArrayList&lt;View&gt;[] mScrapViews;</span><br><span class="line"> </span><br><span class="line">	private int mViewTypeCount;</span><br><span class="line"> </span><br><span class="line">	private ArrayList&lt;View&gt; mCurrentScrap;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Fill ActiveViews with all of the children of the AbsListView.</span><br><span class="line">	 * </span><br><span class="line">	 * @param childCount</span><br><span class="line">	 *            The minimum number of views mActiveViews should hold</span><br><span class="line">	 * @param firstActivePosition</span><br><span class="line">	 *            The position of the first view that will be stored in</span><br><span class="line">	 *            mActiveViews</span><br><span class="line">	 */</span><br><span class="line">	void fillActiveViews(int childCount, int firstActivePosition) &#123;</span><br><span class="line">		if (mActiveViews.length &lt; childCount) &#123;</span><br><span class="line">			mActiveViews = new View[childCount];</span><br><span class="line">		&#125;</span><br><span class="line">		mFirstActivePosition = firstActivePosition;</span><br><span class="line">		final View[] activeViews = mActiveViews;</span><br><span class="line">		for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">			View child = getChildAt(i);</span><br><span class="line">			AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">			// Don&apos;t put header or footer views into the scrap heap</span><br><span class="line">			if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">				// Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in</span><br><span class="line">				// active views.</span><br><span class="line">				// However, we will NOT place them into scrap views.</span><br><span class="line">				activeViews[i] = child;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Get the view corresponding to the specified position. The view will</span><br><span class="line">	 * be removed from mActiveViews if it is found.</span><br><span class="line">	 * </span><br><span class="line">	 * @param position</span><br><span class="line">	 *            The position to look up in mActiveViews</span><br><span class="line">	 * @return The view if it is found, null otherwise</span><br><span class="line">	 */</span><br><span class="line">	View getActiveView(int position) &#123;</span><br><span class="line">		int index = position - mFirstActivePosition;</span><br><span class="line">		final View[] activeViews = mActiveViews;</span><br><span class="line">		if (index &gt;= 0 &amp;&amp; index &lt; activeViews.length) &#123;</span><br><span class="line">			final View match = activeViews[index];</span><br><span class="line">			activeViews[index] = null;</span><br><span class="line">			return match;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Put a view into the ScapViews list. These views are unordered.</span><br><span class="line">	 * </span><br><span class="line">	 * @param scrap</span><br><span class="line">	 *            The view to add</span><br><span class="line">	 */</span><br><span class="line">	void addScrapView(View scrap) &#123;</span><br><span class="line">		AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();</span><br><span class="line">		if (lp == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		// Don&apos;t put header or footer views or views that should be ignored</span><br><span class="line">		// into the scrap heap</span><br><span class="line">		int viewType = lp.viewType;</span><br><span class="line">		if (!shouldRecycleViewType(viewType)) &#123;</span><br><span class="line">			if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">				removeDetachedView(scrap, false);</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (mViewTypeCount == 1) &#123;</span><br><span class="line">			dispatchFinishTemporaryDetach(scrap);</span><br><span class="line">			mCurrentScrap.add(scrap);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			dispatchFinishTemporaryDetach(scrap);</span><br><span class="line">			mScrapViews[viewType].add(scrap);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		if (mRecyclerListener != null) &#123;</span><br><span class="line">			mRecyclerListener.onMovedToScrapHeap(scrap);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * @return A view from the ScrapViews collection. These are unordered.</span><br><span class="line">	 */</span><br><span class="line">	View getScrapView(int position) &#123;</span><br><span class="line">		ArrayList&lt;View&gt; scrapViews;</span><br><span class="line">		if (mViewTypeCount == 1) &#123;</span><br><span class="line">			scrapViews = mCurrentScrap;</span><br><span class="line">			int size = scrapViews.size();</span><br><span class="line">			if (size &gt; 0) &#123;</span><br><span class="line">				return scrapViews.remove(size - 1);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			int whichScrap = mAdapter.getItemViewType(position);</span><br><span class="line">			if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) &#123;</span><br><span class="line">				scrapViews = mScrapViews[whichScrap];</span><br><span class="line">				int size = scrapViews.size();</span><br><span class="line">				if (size &gt; 0) &#123;</span><br><span class="line">					return scrapViews.remove(size - 1);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public void setViewTypeCount(int viewTypeCount) &#123;</span><br><span class="line">		if (viewTypeCount &lt; 1) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		// noinspection unchecked</span><br><span class="line">		ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];</span><br><span class="line">		for (int i = 0; i &lt; viewTypeCount; i++) &#123;</span><br><span class="line">			scrapViews[i] = new ArrayList&lt;View&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		mViewTypeCount = viewTypeCount;</span><br><span class="line">		mCurrentScrap = scrapViews[0];</span><br><span class="line">		mScrapViews = scrapViews;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的RecycleBin代码并不全，只是把最主要的几个方法提了出来。那么我们先来对这几个方法进行简单解读，这对后面分析ListView的工作原理将会有很大的帮助:</p>
<ul>
<li><p><strong>fillActiveViews()</strong> 这个方法接收两个参数，第一个参数表示要存储的view的数量，第二个参数表示ListView中第一个可见元素的position值。RecycleBin当中使用mActiveViews这个数组来存储View，调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews数组当中。</p>
</li>
<li><p><strong>getActiveView()</strong> 这个方法和fillActiveViews()是对应的，用于从mActiveViews数组当中获取数据。该方法接收一个position参数，表示元素在ListView当中的位置，方法内部会自动将position值转换成mActiveViews数组对应的下标值。需要注意的是，mActiveViews当中所存储的View，一旦被获取了之后就会从mActiveViews当中移除，下次获取同样位置的View将会返回null，也就是说mActiveViews不能被重复利用。</p>
</li>
<li><p><strong>addScrapView()</strong> 用于将一个废弃的View进行缓存，该方法接收一个View参数，当有某个View确定要废弃掉的时候(比如滚动出了屏幕)，就应该调用这个方法来对View进行缓存，RecycleBin当中使用mScrapViews和mCurrentScrap这两个List来存储废弃View。</p>
</li>
<li><p><strong>getScrapView()</strong> 用于从废弃缓存中取出一个View，这些废弃缓存中的View是没有顺序可言的，因此getScrapView()方法中的算法也非常简单，就是直接从mCurrentScrap当中获取尾部的一个scrap view进行返回。</p>
</li>
<li><p><strong>setViewTypeCount()</strong> 我们都知道Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，而setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。实际上，getViewTypeCount()方法通常情况下使用的并不是很多，所以我们只要知道RecycleBin当中有这样一个功能就行了。</p>
</li>
</ul>
<h2 id="第一次Layout"><a href="#第一次Layout" class="headerlink" title="第一次Layout"></a>第一次Layout</h2><p>不管怎么说，ListView即使再特殊最终还是继承自View的，因此它的执行流程还将会按照View的规则来执行。</p>
<p>View的执行流程无非就分为三步，onMeasure()用于测量View的大小，onLayout()用于确定View的布局，onDraw()用于将View绘制到界面上。而在ListView当中，onMeasure()并没有什么特殊的地方，因为它终归是一个View，占用的空间最多并且通常也就是整个屏幕。onDraw()在ListView当中也没有什么意义，因为ListView本身并不负责绘制，而是由ListView当中的子元素来进行绘制的。那么ListView大部分的神奇功能其实都是在onLayout()方法中进行的了，因此我们本篇文章也是主要分析的这个方法里的内容。</p>
<p>如果你到ListView源码中去找一找，你会发现ListView中是没有onLayout()这个方法的，这是因为这个方法是在ListView的父类AbsListView中实现的，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Subclasses should NOT override this method but &#123;@link #layoutChildren()&#125;</span><br><span class="line"> * instead.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">	super.onLayout(changed, l, t, r, b);</span><br><span class="line">	mInLayout = true;</span><br><span class="line">	if (changed) &#123;</span><br><span class="line">		int childCount = getChildCount();</span><br><span class="line">		for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">			getChildAt(i).forceLayout();</span><br><span class="line">		&#125;</span><br><span class="line">		mRecycler.markChildrenDirty();</span><br><span class="line">	&#125;</span><br><span class="line">	layoutChildren();</span><br><span class="line">	mInLayout = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<strong>onLayout()方法中主要就是一个判断，如果ListView的大小或者位置发生了变化，那么changed变量就会变成true，此时会要求所有的子布局都强制进行重绘</strong>。除此之外倒没有什么难理解的地方了，不过我们注意到，在第16行调用了layoutChildren()这个方法，从方法名上我们就可以猜出这个方法是用来进行子元素布局的。那么进入ListView的layoutChildren()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void layoutChildren() &#123;</span><br><span class="line">    final boolean blockLayoutRequests = mBlockLayoutRequests;</span><br><span class="line">    if (!blockLayoutRequests) &#123;</span><br><span class="line">        mBlockLayoutRequests = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        super.layoutChildren();</span><br><span class="line">        invalidate();</span><br><span class="line">        if (mAdapter == null) &#123;</span><br><span class="line">            resetList();</span><br><span class="line">            invokeOnItemScrollListener();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int childrenTop = mListPadding.top;</span><br><span class="line">        int childrenBottom = getBottom() - getTop() - mListPadding.bottom;</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        int index = 0;</span><br><span class="line">        int delta = 0;</span><br><span class="line">        View sel;</span><br><span class="line">        View oldSel = null;</span><br><span class="line">        View oldFirst = null;</span><br><span class="line">        View newSel = null;</span><br><span class="line">        View focusLayoutRestoreView = null;</span><br><span class="line">        // Remember stuff we will need down below</span><br><span class="line">        switch (mLayoutMode) &#123;</span><br><span class="line">        case LAYOUT_SET_SELECTION:</span><br><span class="line">            index = mNextSelectedPosition - mFirstPosition;</span><br><span class="line">            if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</span><br><span class="line">                newSel = getChildAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_FORCE_TOP:</span><br><span class="line">        case LAYOUT_FORCE_BOTTOM:</span><br><span class="line">        case LAYOUT_SPECIFIC:</span><br><span class="line">        case LAYOUT_SYNC:</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_MOVE_SELECTION:</span><br><span class="line">        default:</span><br><span class="line">            // Remember the previously selected view</span><br><span class="line">            index = mSelectedPosition - mFirstPosition;</span><br><span class="line">            if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</span><br><span class="line">                oldSel = getChildAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            // Remember the previous first child</span><br><span class="line">            oldFirst = getChildAt(0);</span><br><span class="line">            if (mNextSelectedPosition &gt;= 0) &#123;</span><br><span class="line">                delta = mNextSelectedPosition - mSelectedPosition;</span><br><span class="line">            &#125;</span><br><span class="line">            // Caution: newSel might be null</span><br><span class="line">            newSel = getChildAt(index + delta);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean dataChanged = mDataChanged;</span><br><span class="line">        if (dataChanged) &#123;</span><br><span class="line">            handleDataChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        // Handle the empty set by removing all views that are visible</span><br><span class="line">        // and calling it a day</span><br><span class="line">        if (mItemCount == 0) &#123;</span><br><span class="line">            resetList();</span><br><span class="line">            invokeOnItemScrollListener();</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (mItemCount != mAdapter.getCount()) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;</span><br><span class="line">                    + &quot;ListView did not receive a notification. Make sure the content of &quot;</span><br><span class="line">                    + &quot;your adapter is not modified from a background thread, but only &quot;</span><br><span class="line">                    + &quot;from the UI thread. [in ListView(&quot; + getId() + &quot;, &quot; + getClass() </span><br><span class="line">                    + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        setSelectedPositionInt(mNextSelectedPosition);</span><br><span class="line">        // Pull all children into the RecycleBin.</span><br><span class="line">        // These views will be reused if possible</span><br><span class="line">        final int firstPosition = mFirstPosition;</span><br><span class="line">        final RecycleBin recycleBin = mRecycler;</span><br><span class="line">        // reset the focus restoration</span><br><span class="line">        View focusLayoutRestoreDirectChild = null;</span><br><span class="line">        // Don&apos;t put header or footer views into the Recycler. Those are</span><br><span class="line">        // already cached in mHeaderViews;</span><br><span class="line">        if (dataChanged) &#123;</span><br><span class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">                recycleBin.addScrapView(getChildAt(i));</span><br><span class="line">                if (ViewDebug.TRACE_RECYCLER) &#123;</span><br><span class="line">                    ViewDebug.trace(getChildAt(i),</span><br><span class="line">                            ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            recycleBin.fillActiveViews(childCount, firstPosition);</span><br><span class="line">        &#125;</span><br><span class="line">        // take focus back to us temporarily to avoid the eventual</span><br><span class="line">        // call to clear focus when removing the focused child below</span><br><span class="line">        // from messing things up when ViewRoot assigns focus back</span><br><span class="line">        // to someone else</span><br><span class="line">        final View focusedChild = getFocusedChild();</span><br><span class="line">        if (focusedChild != null) &#123;</span><br><span class="line">            // TODO: in some cases focusedChild.getParent() == null</span><br><span class="line">            // we can remember the focused view to restore after relayout if the</span><br><span class="line">            // data hasn&apos;t changed, or if the focused position is a header or footer</span><br><span class="line">            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) &#123;</span><br><span class="line">                focusLayoutRestoreDirectChild = focusedChild;</span><br><span class="line">                // remember the specific view that had focus</span><br><span class="line">                focusLayoutRestoreView = findFocus();</span><br><span class="line">                if (focusLayoutRestoreView != null) &#123;</span><br><span class="line">                    // tell it we are going to mess with it</span><br><span class="line">                    focusLayoutRestoreView.onStartTemporaryDetach();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            requestFocus();</span><br><span class="line">        &#125;</span><br><span class="line">        // Clear out old views</span><br><span class="line">        detachAllViewsFromParent();</span><br><span class="line">        switch (mLayoutMode) &#123;</span><br><span class="line">        case LAYOUT_SET_SELECTION:</span><br><span class="line">            if (newSel != null) &#123;</span><br><span class="line">                sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sel = fillFromMiddle(childrenTop, childrenBottom);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_SYNC:</span><br><span class="line">            sel = fillSpecific(mSyncPosition, mSpecificTop);</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_FORCE_BOTTOM:</span><br><span class="line">            sel = fillUp(mItemCount - 1, childrenBottom);</span><br><span class="line">            adjustViewsUpOrDown();</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_FORCE_TOP:</span><br><span class="line">            mFirstPosition = 0;</span><br><span class="line">            sel = fillFromTop(childrenTop);</span><br><span class="line">            adjustViewsUpOrDown();</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_SPECIFIC:</span><br><span class="line">            sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_MOVE_SELECTION:</span><br><span class="line">            sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            if (childCount == 0) &#123;</span><br><span class="line">                if (!mStackFromBottom) &#123;</span><br><span class="line">                    final int position = lookForSelectablePosition(0, true);</span><br><span class="line">                    setSelectedPositionInt(position);</span><br><span class="line">                    sel = fillFromTop(childrenTop);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final int position = lookForSelectablePosition(mItemCount - 1, false);</span><br><span class="line">                    setSelectedPositionInt(position);</span><br><span class="line">                    sel = fillUp(mItemCount - 1, childrenBottom);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</span><br><span class="line">                    sel = fillSpecific(mSelectedPosition,</span><br><span class="line">                            oldSel == null ? childrenTop : oldSel.getTop());</span><br><span class="line">                &#125; else if (mFirstPosition &lt; mItemCount) &#123;</span><br><span class="line">                    sel = fillSpecific(mFirstPosition,</span><br><span class="line">                            oldFirst == null ? childrenTop : oldFirst.getTop());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sel = fillSpecific(0, childrenTop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // Flush any cached views that did not get reused above</span><br><span class="line">        recycleBin.scrapActiveViews();</span><br><span class="line">        if (sel != null) &#123;</span><br><span class="line">            // the current selected item should get focus if items</span><br><span class="line">            // are focusable</span><br><span class="line">            if (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123;</span><br><span class="line">                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp;</span><br><span class="line">                        focusLayoutRestoreView.requestFocus()) || sel.requestFocus();</span><br><span class="line">                if (!focusWasTaken) &#123;</span><br><span class="line">                    // selected item didn&apos;t take focus, fine, but still want</span><br><span class="line">                    // to make sure something else outside of the selected view</span><br><span class="line">                    // has focus</span><br><span class="line">                    final View focused = getFocusedChild();</span><br><span class="line">                    if (focused != null) &#123;</span><br><span class="line">                        focused.clearFocus();</span><br><span class="line">                    &#125;</span><br><span class="line">                    positionSelector(sel);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sel.setSelected(false);</span><br><span class="line">                    mSelectorRect.setEmpty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                positionSelector(sel);</span><br><span class="line">            &#125;</span><br><span class="line">            mSelectedTop = sel.getTop();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mTouchMode &gt; TOUCH_MODE_DOWN &amp;&amp; mTouchMode &lt; TOUCH_MODE_SCROLL) &#123;</span><br><span class="line">                View child = getChildAt(mMotionPosition - mFirstPosition);</span><br><span class="line">                if (child != null) positionSelector(child);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mSelectedTop = 0;</span><br><span class="line">                mSelectorRect.setEmpty();</span><br><span class="line">            &#125;</span><br><span class="line">            // even if there is not selected position, we may need to restore</span><br><span class="line">            // focus (i.e. something focusable in touch mode)</span><br><span class="line">            if (hasFocus() &amp;&amp; focusLayoutRestoreView != null) &#123;</span><br><span class="line">                focusLayoutRestoreView.requestFocus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // tell focus view we are done mucking with it, if it is still in</span><br><span class="line">        // our view hierarchy.</span><br><span class="line">        if (focusLayoutRestoreView != null</span><br><span class="line">                &amp;&amp; focusLayoutRestoreView.getWindowToken() != null) &#123;</span><br><span class="line">            focusLayoutRestoreView.onFinishTemporaryDetach();</span><br><span class="line">        &#125;</span><br><span class="line">        mLayoutMode = LAYOUT_NORMAL;</span><br><span class="line">        mDataChanged = false;</span><br><span class="line">        mNeedSync = false;</span><br><span class="line">        setNextSelectedPositionInt(mSelectedPosition);</span><br><span class="line">        updateScrollIndicators();</span><br><span class="line">        if (mItemCount &gt; 0) &#123;</span><br><span class="line">            checkSelectionChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        invokeOnItemScrollListener();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!blockLayoutRequests) &#123;</span><br><span class="line">            mBlockLayoutRequests = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码比较长，我们挑重点的看。首先可以确定的是，ListView当中目前还没有任何子View，数据都还是由Adapter管理的，并没有展示到界面上，因此第19行getChildCount()方法得到的值肯定是0。接着在第81行会根据dataChanged这个布尔型的值来判断执行逻辑，dataChanged只有在数据源发生改变的情况下才会变成true，其它情况都是false，因此这里会进入到第90行的执行逻辑，调用RecycleBin的fillActiveViews()方法。按理来说，调用fillActiveViews()方法是为了将ListView的子View进行缓存的，可是目前ListView中还没有任何的子View，因此这一行暂时还起不了任何作用。</p>
<p>接下来在第114行会根据mLayoutMode的值来决定布局模式，默认情况下都是普通模式LAYOUT_NORMAL，因此会进入到第140行的default语句当中。而下面又会紧接着进行两次if判断，childCount目前是等于0的，并且默认的布局顺序是从上往下，因此会进入到第145行的fillFromTop()方法，我们跟进去瞧一瞧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Fills the list from top to bottom, starting with mFirstPosition</span><br><span class="line"> *</span><br><span class="line"> * @param nextTop The location where the top of the first item should be</span><br><span class="line"> *        drawn</span><br><span class="line"> *</span><br><span class="line"> * @return The view that is currently selected</span><br><span class="line"> */</span><br><span class="line">private View fillFromTop(int nextTop) &#123;</span><br><span class="line">    mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);</span><br><span class="line">    mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);</span><br><span class="line">    if (mFirstPosition &lt; 0) &#123;</span><br><span class="line">        mFirstPosition = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return fillDown(mFirstPosition, nextTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个方法的注释中可以看出，它所负责的主要任务就是从mFirstPosition开始，自顶至底去填充ListView。而这个方法本身并没有什么逻辑，就是判断了一下mFirstPosition值的合法性，然后调用fillDown()方法，那么我们就有理由可以猜测，填充ListView的操作是在fillDown()方法中完成的。进入fillDown()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Fills the list from pos down to the end of the list view.</span><br><span class="line"> *</span><br><span class="line"> * @param pos The first position to put in the list</span><br><span class="line"> *</span><br><span class="line"> * @param nextTop The location where the top of the item associated with pos</span><br><span class="line"> *        should be drawn</span><br><span class="line"> *</span><br><span class="line"> * @return The view that is currently selected, if it happens to be in the</span><br><span class="line"> *         range that we draw.</span><br><span class="line"> */</span><br><span class="line">private View fillDown(int pos, int nextTop) &#123;</span><br><span class="line">    View selectedView = null;</span><br><span class="line">    int end = (getBottom() - getTop()) - mListPadding.bottom;</span><br><span class="line">    while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123;</span><br><span class="line">        // is this the selected item?</span><br><span class="line">        boolean selected = pos == mSelectedPosition;</span><br><span class="line">        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);</span><br><span class="line">        nextTop = child.getBottom() + mDividerHeight;</span><br><span class="line">        if (selected) &#123;</span><br><span class="line">            selectedView = child;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    return selectedView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里使用了一个while循环来执行重复逻辑，一开始nextTop的值是第一个子元素顶部距离整个ListView顶部的像素值，pos则是刚刚传入的mFirstPosition的值，而end是ListView底部减去顶部所得的像素值，mItemCount则是Adapter中的元素数量。因此一开始的情况下nextTop必定是小于end值的，并且pos也是小于mItemCount值的。那么每执行一次while循环，pos的值都会加1，并且nextTop也会增加，当nextTop大于等于end时，也就是子元素已经超出当前屏幕了，或者pos大于等于mItemCount时，也就是所有Adapter中的元素都被遍历结束了，就会跳出while循环。</p>
<p>那么while循环当中又做了什么事情呢？值得让人留意的就是第18行调用的makeAndAddView()方法，进入到这个方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Obtain the view and add it to our list of children. The view can be made</span><br><span class="line"> * fresh, converted from an unused view, or used as is if it was in the</span><br><span class="line"> * recycle bin.</span><br><span class="line"> *</span><br><span class="line"> * @param position Logical position in the list</span><br><span class="line"> * @param y Top or bottom edge of the view to add</span><br><span class="line"> * @param flow If flow is true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @return View that was added</span><br><span class="line"> */</span><br><span class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</span><br><span class="line">        boolean selected) &#123;</span><br><span class="line">    View child;</span><br><span class="line">    if (!mDataChanged) &#123;</span><br><span class="line">        // Try to use an exsiting view for this position</span><br><span class="line">        child = mRecycler.getActiveView(position);</span><br><span class="line">        if (child != null) &#123;</span><br><span class="line">            // Found it -- we&apos;re using an existing child</span><br><span class="line">            // This just needs to be positioned</span><br><span class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Make a new view for this position, or convert an unused view if possible</span><br><span class="line">    child = obtainView(position, mIsScrap);</span><br><span class="line">    // This needs to be positioned and measured</span><br><span class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里在第19行尝试从RecycleBin当中快速获取一个active view，不过很遗憾的是目前RecycleBin当中还没有缓存任何的View，所以这里得到的值肯定是null。那么取得了null之后就会继续向下运行，到第28行会调用obtainView()方法来再次尝试获取一个View，这次的obtainView()方法是可以保证一定返回一个View的，于是下面立刻将获取到的View传入到了setupChild()方法当中。那么obtainView()内部到底是怎么工作的呢？我们先进入到这个方法里面看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get a view and have it show the data associated with the specified</span><br><span class="line"> * position. This is called when we have already discovered that the view is</span><br><span class="line"> * not available for reuse in the recycle bin. The only choices left are</span><br><span class="line"> * converting an old view or making a new one.</span><br><span class="line"> * </span><br><span class="line"> * @param position</span><br><span class="line"> *            The position to display</span><br><span class="line"> * @param isScrap</span><br><span class="line"> *            Array of at least 1 boolean, the first entry will become true</span><br><span class="line"> *            if the returned view was taken from the scrap heap, false if</span><br><span class="line"> *            otherwise.</span><br><span class="line"> * </span><br><span class="line"> * @return A view displaying the data associated with the specified position</span><br><span class="line"> */</span><br><span class="line">View obtainView(int position, boolean[] isScrap) &#123;</span><br><span class="line">	isScrap[0] = false;</span><br><span class="line">	View scrapView;</span><br><span class="line">	scrapView = mRecycler.getScrapView(position);</span><br><span class="line">	View child;</span><br><span class="line">	if (scrapView != null) &#123;</span><br><span class="line">		child = mAdapter.getView(position, scrapView, this);</span><br><span class="line">		if (child != scrapView) &#123;</span><br><span class="line">			mRecycler.addScrapView(scrapView);</span><br><span class="line">			if (mCacheColorHint != 0) &#123;</span><br><span class="line">				child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			isScrap[0] = true;</span><br><span class="line">			dispatchFinishTemporaryDetach(child);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		child = mAdapter.getView(position, null, this);</span><br><span class="line">		if (mCacheColorHint != 0) &#123;</span><br><span class="line">			child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>obtainView()方法中的代码并不多，但却包含了非常非常重要的逻辑，不夸张的说，整个ListView中最重要的内容可能就在这个方法里了。那么我们还是按照执行流程来看，在第19行代码中调用了RecycleBin的getScrapView()方法来尝试获取一个废弃缓存中的View，同样的道理，这里肯定是获取不到的，getScrapView()方法会返回一个null。这时该怎么办呢？没有关系，代码会执行到第33行，调用mAdapter的getView()方法来去获取一个View。那么mAdapter是什么呢？当然就是当前ListView关联的适配器了。而getView()方法又是什么呢？还用说吗，这个就是我们平时使用ListView时最最经常重写的一个方法了，这里getView()方法中传入了三个参数，分别是position，null和this。</p>
<p>那么我们平时写ListView的Adapter时，getView()方法通常会怎么写呢？这里我举个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">	Fruit fruit = getItem(position);</span><br><span class="line">	View view;</span><br><span class="line">	if (convertView == null) &#123;</span><br><span class="line">		view = LayoutInflater.from(getContext()).inflate(resourceId, null);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		view = convertView;</span><br><span class="line">	&#125;</span><br><span class="line">	ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">	TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line">	fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">	fruitName.setText(fruit.getName());</span><br><span class="line">	return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getView()方法接受的三个参数，第一个参数position代表当前子元素的的位置，我们可以通过具体的位置来获取与其相关的数据。第二个参数convertView，刚才传入的是null，说明没有convertView可以利用，因此我们会调用LayoutInflater的inflate()方法来去加载一个布局。接下来会对这个view进行一些属性和值的设定，最后将view返回。</p>
<p>那么这个View也会作为obtainView()的结果进行返回，并最终传入到setupChild()方法当中。其实也就是说，第一次layout过程当中，所有的子View都是调用LayoutInflater的inflate()方法加载出来的，这样就会相对比较耗时，但是不用担心，后面就不会再有这种情况了，那么我们继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a view as a child and make sure it is measured (if necessary) and</span><br><span class="line"> * positioned properly.</span><br><span class="line"> *</span><br><span class="line"> * @param child The view to add</span><br><span class="line"> * @param position The position of this child</span><br><span class="line"> * @param y The y position relative to which this view will be positioned</span><br><span class="line"> * @param flowDown If true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @param recycled Has this view been pulled from the recycle bin? If so it</span><br><span class="line"> *        does not need to be remeasured.</span><br><span class="line"> */</span><br><span class="line">private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,</span><br><span class="line">        boolean selected, boolean recycled) &#123;</span><br><span class="line">    final boolean isSelected = selected &amp;&amp; shouldShowSelector();</span><br><span class="line">    final boolean updateChildSelected = isSelected != child.isSelected();</span><br><span class="line">    final int mode = mTouchMode;</span><br><span class="line">    final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp;</span><br><span class="line">            mMotionPosition == position;</span><br><span class="line">    final boolean updateChildPressed = isPressed != child.isPressed();</span><br><span class="line">    final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();</span><br><span class="line">    // Respect layout params that are already in the view. Otherwise make some up...</span><br><span class="line">    // noinspection unchecked</span><br><span class="line">    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">    if (p == null) &#123;</span><br><span class="line">        p = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    p.viewType = mAdapter.getItemViewType(position);</span><br><span class="line">    if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp;</span><br><span class="line">            p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</span><br><span class="line">        attachViewToParent(child, flowDown ? -1 : 0, p);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p.forceAdd = false;</span><br><span class="line">        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">            p.recycledHeaderFooter = true;</span><br><span class="line">        &#125;</span><br><span class="line">        addViewInLayout(child, flowDown ? -1 : 0, p, true);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildSelected) &#123;</span><br><span class="line">        child.setSelected(isSelected);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildPressed) &#123;</span><br><span class="line">        child.setPressed(isPressed);</span><br><span class="line">    &#125;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</span><br><span class="line">                mListPadding.left + mListPadding.right, p.width);</span><br><span class="line">        int lpHeight = p.height;</span><br><span class="line">        int childHeightSpec;</span><br><span class="line">        if (lpHeight &gt; 0) &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        child.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cleanupLayoutState(child);</span><br><span class="line">    &#125;</span><br><span class="line">    final int w = child.getMeasuredWidth();</span><br><span class="line">    final int h = child.getMeasuredHeight();</span><br><span class="line">    final int childTop = flowDown ? y : y - h;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        final int childRight = childrenLeft + w;</span><br><span class="line">        final int childBottom = childTop + h;</span><br><span class="line">        child.layout(childrenLeft, childTop, childRight, childBottom);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        child.offsetLeftAndRight(childrenLeft - child.getLeft());</span><br><span class="line">        child.offsetTopAndBottom(childTop - child.getTop());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</span><br><span class="line">        child.setDrawingCacheEnabled(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>setupChild()方法当中的代码虽然比较多，但是我们只看核心代码的话就非常简单了，刚才调用obtainView()方法获取到的子元素View，这里在第40行调用了addViewInLayout()方法将它添加到了ListView当中。那么根据fillDown()方法中的while循环，会让子元素View将整个ListView控件填满然后就跳出，也就是说即使我们的Adapter中有一千条数据，ListView也只会加载第一屏的数据，剩下的数据反正目前在屏幕上也看不到，所以不会去做多余的加载工作，这样就可以保证ListView中的内容能够迅速展示到屏幕上。</p>
<p>那么到此为止，第一次Layout过程结束。</p>
<h2 id="第二次Layout"><a href="#第二次Layout" class="headerlink" title="第二次Layout"></a>第二次Layout</h2><p>虽然我在源码中并没有找出具体的原因，但如果你自己做一下实验的话就会发现，<strong>即使是一个再简单的View，在展示到界面上之前都会经历至少两次onMeasure()和两次onLayout()的过程</strong>。其实这只是一个很小的细节，平时对我们影响并不大，因为不管是onMeasure()或者onLayout()几次，反正都是执行的相同的逻辑，我们并不需要进行过多关心。但是在ListView中情况就不一样了，因为这就意味着layoutChildren()过程会执行两次，而这个过程当中涉及到向ListView中添加子元素，如果相同的逻辑执行两遍的话，那么ListView中就会存在一份重复的数据了。因此ListView在layoutChildren()过程当中做了第二次Layout的逻辑处理，非常巧妙地解决了这个问题，下面我们就来分析一下第二次Layout的过程。</p>
<p>其实第二次Layout和第一次Layout的基本流程是差不多的，那么我们还是从layoutChildren()方法开始看起：</p>
<p>同样还是在第19行，调用getChildCount()方法来获取子View的数量，只不过现在得到的值不会再是0了，而是ListView中一屏可以显示的子View数量，因为我们刚刚在第一次Layout过程当中向ListView添加了这么多的子View。下面在第90行调用了RecycleBin的fillActiveViews()方法，这次效果可就不一样了，因为目前ListView中已经有子View了，这样所有的子View都会被缓存到RecycleBin的mActiveViews数组当中，后面将会用到它们。</p>
<p>接下来将会是非常非常重要的一个操作，<strong>在第113行调用了detachAllViewsFromParent()方法。这个方法会将所有ListView当中的子View全部清除掉，从而保证第二次Layout过程不会产生一份重复的数据。那有的朋友可能会问了，这样把已经加载好的View又清除掉，待会还要再重新加载一遍，这不是严重影响效率吗？不用担心，还记得我们刚刚调用了RecycleBin的fillActiveViews()方法来缓存子View吗，待会儿将会直接使用这些缓存好的View来进行加载，而并不会重新执行一遍inflate过程，因此效率方面并不会有什么明显的影响。</strong></p>
<p>那么我们接着看，在第141行的判断逻辑当中，由于不再等于0了，因此会进入到else语句当中。而else语句中又有三个逻辑判断，第一个逻辑判断不成立，因为默认情况下我们没有选中任何子元素，mSelectedPosition应该等于-1。第二个逻辑判断通常是成立的，因为mFirstPosition的值一开始是等于0的，只要adapter中的数据大于0条件就成立。那么进入到fillSpecific()方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Put a specific item at a specific location on the screen and then build</span><br><span class="line"> * up and down from there.</span><br><span class="line"> *</span><br><span class="line"> * @param position The reference view to use as the starting point</span><br><span class="line"> * @param top Pixel offset from the top of this view to the top of the</span><br><span class="line"> *        reference view.</span><br><span class="line"> *</span><br><span class="line"> * @return The selected view, or null if the selected view is outside the</span><br><span class="line"> *         visible area.</span><br><span class="line"> */</span><br><span class="line">private View fillSpecific(int position, int top) &#123;</span><br><span class="line">    boolean tempIsSelected = position == mSelectedPosition;</span><br><span class="line">    View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected);</span><br><span class="line">    // Possibly changed again in fillUp if we add rows above this one.</span><br><span class="line">    mFirstPosition = position;</span><br><span class="line">    View above;</span><br><span class="line">    View below;</span><br><span class="line">    final int dividerHeight = mDividerHeight;</span><br><span class="line">    if (!mStackFromBottom) &#123;</span><br><span class="line">        above = fillUp(position - 1, temp.getTop() - dividerHeight);</span><br><span class="line">        // This will correct for the top of the first view not touching the top of the list</span><br><span class="line">        adjustViewsUpOrDown();</span><br><span class="line">        below = fillDown(position + 1, temp.getBottom() + dividerHeight);</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        if (childCount &gt; 0) &#123;</span><br><span class="line">            correctTooHigh(childCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        below = fillDown(position + 1, temp.getBottom() + dividerHeight);</span><br><span class="line">        // This will correct for the bottom of the last view not touching the bottom of the list</span><br><span class="line">        adjustViewsUpOrDown();</span><br><span class="line">        above = fillUp(position - 1, temp.getTop() - dividerHeight);</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        if (childCount &gt; 0) &#123;</span><br><span class="line">             correctTooLow(childCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (tempIsSelected) &#123;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; else if (above != null) &#123;</span><br><span class="line">        return above;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return below;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fillSpecific()这算是一个新方法了，不过其实它和fillUp()、fillDown()方法功能也是差不多的，主要的区别在于，fillSpecific()方法会优先将指定位置的子View先加载到屏幕上，然后再加载该子View往上以及往下的其它子View。那么由于这里我们传入的position就是第一个子View的位置，于是fillSpecific()方法的作用就基本上和fillDown()方法是差不多的了，这里我们就不去关注太多它的细节，而是将精力放在makeAndAddView()方法上面。再次回到makeAndAddView()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Obtain the view and add it to our list of children. The view can be made</span><br><span class="line"> * fresh, converted from an unused view, or used as is if it was in the</span><br><span class="line"> * recycle bin.</span><br><span class="line"> *</span><br><span class="line"> * @param position Logical position in the list</span><br><span class="line"> * @param y Top or bottom edge of the view to add</span><br><span class="line"> * @param flow If flow is true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @return View that was added</span><br><span class="line"> */</span><br><span class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</span><br><span class="line">        boolean selected) &#123;</span><br><span class="line">    View child;</span><br><span class="line">    if (!mDataChanged) &#123;</span><br><span class="line">        // Try to use an exsiting view for this position</span><br><span class="line">        child = mRecycler.getActiveView(position);</span><br><span class="line">        if (child != null) &#123;</span><br><span class="line">            // Found it -- we&apos;re using an existing child</span><br><span class="line">            // This just needs to be positioned</span><br><span class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Make a new view for this position, or convert an unused view if possible</span><br><span class="line">    child = obtainView(position, mIsScrap);</span><br><span class="line">    // This needs to be positioned and measured</span><br><span class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仍然还是在第19行尝试从RecycleBin当中获取Active View，然而这次就一定可以获取到了，因为前面我们调用了RecycleBin的fillActiveViews()方法来缓存子View。那么既然如此，就不会再进入到第28行的obtainView()方法，而是会直接进入setupChild()方法当中，这样也省去了很多时间，因为如果在obtainView()方法中又要去infalte布局的话，那么ListView的初始加载效率就大大降低了。</p>
<p>注意在第23行，setupChild()方法的最后一个参数传入的是true，这个参数表明当前的View是之前被回收过的，那么我们再次回到setupChild()方法当中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a view as a child and make sure it is measured (if necessary) and</span><br><span class="line"> * positioned properly.</span><br><span class="line"> *</span><br><span class="line"> * @param child The view to add</span><br><span class="line"> * @param position The position of this child</span><br><span class="line"> * @param y The y position relative to which this view will be positioned</span><br><span class="line"> * @param flowDown If true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @param recycled Has this view been pulled from the recycle bin? If so it</span><br><span class="line"> *        does not need to be remeasured.</span><br><span class="line"> */</span><br><span class="line">private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,</span><br><span class="line">        boolean selected, boolean recycled) &#123;</span><br><span class="line">    final boolean isSelected = selected &amp;&amp; shouldShowSelector();</span><br><span class="line">    final boolean updateChildSelected = isSelected != child.isSelected();</span><br><span class="line">    final int mode = mTouchMode;</span><br><span class="line">    final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp;</span><br><span class="line">            mMotionPosition == position;</span><br><span class="line">    final boolean updateChildPressed = isPressed != child.isPressed();</span><br><span class="line">    final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();</span><br><span class="line">    // Respect layout params that are already in the view. Otherwise make some up...</span><br><span class="line">    // noinspection unchecked</span><br><span class="line">    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">    if (p == null) &#123;</span><br><span class="line">        p = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    p.viewType = mAdapter.getItemViewType(position);</span><br><span class="line">    if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp;</span><br><span class="line">            p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</span><br><span class="line">        attachViewToParent(child, flowDown ? -1 : 0, p);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p.forceAdd = false;</span><br><span class="line">        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">            p.recycledHeaderFooter = true;</span><br><span class="line">        &#125;</span><br><span class="line">        addViewInLayout(child, flowDown ? -1 : 0, p, true);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildSelected) &#123;</span><br><span class="line">        child.setSelected(isSelected);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildPressed) &#123;</span><br><span class="line">        child.setPressed(isPressed);</span><br><span class="line">    &#125;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</span><br><span class="line">                mListPadding.left + mListPadding.right, p.width);</span><br><span class="line">        int lpHeight = p.height;</span><br><span class="line">        int childHeightSpec;</span><br><span class="line">        if (lpHeight &gt; 0) &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        child.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cleanupLayoutState(child);</span><br><span class="line">    &#125;</span><br><span class="line">    final int w = child.getMeasuredWidth();</span><br><span class="line">    final int h = child.getMeasuredHeight();</span><br><span class="line">    final int childTop = flowDown ? y : y - h;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        final int childRight = childrenLeft + w;</span><br><span class="line">        final int childBottom = childTop + h;</span><br><span class="line">        child.layout(childrenLeft, childTop, childRight, childBottom);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        child.offsetLeftAndRight(childrenLeft - child.getLeft());</span><br><span class="line">        child.offsetTopAndBottom(childTop - child.getTop());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</span><br><span class="line">        child.setDrawingCacheEnabled(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，setupChild()方法的最后一个参数是recycled，然后在第32行会对这个变量进行判断，由于recycled现在是true，所以会执行attachViewToParent()方法，而第一次Layout过程则是执行的else语句中的addViewInLayout()方法。<strong>这两个方法最大的区别在于，如果我们需要向ViewGroup中添加一个新的子View，应该调用addViewInLayout()方法，而如果是想要将一个之前detach的View重新attach到ViewGroup上，就应该调用attachViewToParent()方法。</strong>那么由于前面在layoutChildren()方法当中调用了detachAllViewsFromParent()方法，这样ListView中所有的子View都是处于detach状态的，所以这里attachViewToParent()方法是正确的选择。</p>
<p>经历了这样一个detach又attach的过程，ListView中所有的子View又都可以正常显示出来了，那么第二次Layout过程结束。</p>
<h2 id="滑动加载更多数据"><a href="#滑动加载更多数据" class="headerlink" title="滑动加载更多数据"></a>滑动加载更多数据</h2><p>经历了两次Layout过程，虽说我们已经可以在ListView中看到内容了，然而关于ListView最神奇的部分我们却还没有接触到，因为目前ListView中只是加载并显示了第一屏的数据而已。比如说我们的Adapter当中有1000条数据，但是第一屏只显示了10条，ListView中也只有10个子View而已，那么剩下的990是怎样工作并显示到界面上的呢？这就要看一下ListView滑动部分的源码了，因为我们是通过手指滑动来显示更多数据的。</p>
<p>由于滑动部分的机制是属于通用型的，即ListView和GridView都会使用同样的机制，因此这部分代码就肯定是写在AbsListView当中的了。那么监听触控事件是在onTouchEvent()方法当中进行的，我们就来看一下AbsListView中的这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">	if (!isEnabled()) &#123;</span><br><span class="line">		// A disabled view that is clickable still consumes the touch</span><br><span class="line">		// events, it just doesn&apos;t respond to them.</span><br><span class="line">		return isClickable() || isLongClickable();</span><br><span class="line">	&#125;</span><br><span class="line">	final int action = ev.getAction();</span><br><span class="line">	View v;</span><br><span class="line">	int deltaY;</span><br><span class="line">	if (mVelocityTracker == null) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line">	switch (action &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class="line">	case MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">		mActivePointerId = ev.getPointerId(0);</span><br><span class="line">		final int x = (int) ev.getX();</span><br><span class="line">		final int y = (int) ev.getY();</span><br><span class="line">		int motionPosition = pointToPosition(x, y);</span><br><span class="line">		if (!mDataChanged) &#123;</span><br><span class="line">			if ((mTouchMode != TOUCH_MODE_FLING) &amp;&amp; (motionPosition &gt;= 0)</span><br><span class="line">					&amp;&amp; (getAdapter().isEnabled(motionPosition))) &#123;</span><br><span class="line">				// User clicked on an actual view (and was not stopping a</span><br><span class="line">				// fling). It might be a</span><br><span class="line">				// click or a scroll. Assume it is a click until proven</span><br><span class="line">				// otherwise</span><br><span class="line">				mTouchMode = TOUCH_MODE_DOWN;</span><br><span class="line">				// FIXME Debounce</span><br><span class="line">				if (mPendingCheckForTap == null) &#123;</span><br><span class="line">					mPendingCheckForTap = new CheckForTap();</span><br><span class="line">				&#125;</span><br><span class="line">				postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				if (ev.getEdgeFlags() != 0 &amp;&amp; motionPosition &lt; 0) &#123;</span><br><span class="line">					// If we couldn&apos;t find a view to click on, but the down</span><br><span class="line">					// event was touching</span><br><span class="line">					// the edge, we will bail out and try again. This allows</span><br><span class="line">					// the edge correcting</span><br><span class="line">					// code in ViewRoot to try to find a nearby view to</span><br><span class="line">					// select</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line"> </span><br><span class="line">				if (mTouchMode == TOUCH_MODE_FLING) &#123;</span><br><span class="line">					// Stopped a fling. It is a scroll.</span><br><span class="line">					createScrollingCache();</span><br><span class="line">					mTouchMode = TOUCH_MODE_SCROLL;</span><br><span class="line">					mMotionCorrection = 0;</span><br><span class="line">					motionPosition = findMotionRow(y);</span><br><span class="line">					reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (motionPosition &gt;= 0) &#123;</span><br><span class="line">			// Remember where the motion event started</span><br><span class="line">			v = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">			mMotionViewOriginalTop = v.getTop();</span><br><span class="line">		&#125;</span><br><span class="line">		mMotionX = x;</span><br><span class="line">		mMotionY = y;</span><br><span class="line">		mMotionPosition = motionPosition;</span><br><span class="line">		mLastY = Integer.MIN_VALUE;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">		final int pointerIndex = ev.findPointerIndex(mActivePointerId);</span><br><span class="line">		final int y = (int) ev.getY(pointerIndex);</span><br><span class="line">		deltaY = y - mMotionY;</span><br><span class="line">		switch (mTouchMode) &#123;</span><br><span class="line">		case TOUCH_MODE_DOWN:</span><br><span class="line">		case TOUCH_MODE_TAP:</span><br><span class="line">		case TOUCH_MODE_DONE_WAITING:</span><br><span class="line">			// Check if we have moved far enough that it looks more like a</span><br><span class="line">			// scroll than a tap</span><br><span class="line">			startScrollIfNeeded(deltaY);</span><br><span class="line">			break;</span><br><span class="line">		case TOUCH_MODE_SCROLL:</span><br><span class="line">			if (PROFILE_SCROLLING) &#123;</span><br><span class="line">				if (!mScrollProfilingStarted) &#123;</span><br><span class="line">					Debug.startMethodTracing(&quot;AbsListViewScroll&quot;);</span><br><span class="line">					mScrollProfilingStarted = true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (y != mLastY) &#123;</span><br><span class="line">				deltaY -= mMotionCorrection;</span><br><span class="line">				int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;</span><br><span class="line">				// No need to do all this work if we&apos;re not going to move</span><br><span class="line">				// anyway</span><br><span class="line">				boolean atEdge = false;</span><br><span class="line">				if (incrementalDeltaY != 0) &#123;</span><br><span class="line">					atEdge = trackMotionScroll(deltaY, incrementalDeltaY);</span><br><span class="line">				&#125;</span><br><span class="line">				// Check to see if we have bumped into the scroll limit</span><br><span class="line">				if (atEdge &amp;&amp; getChildCount() &gt; 0) &#123;</span><br><span class="line">					// Treat this like we&apos;re starting a new scroll from the</span><br><span class="line">					// current</span><br><span class="line">					// position. This will let the user start scrolling back</span><br><span class="line">					// into</span><br><span class="line">					// content immediately rather than needing to scroll</span><br><span class="line">					// back to the</span><br><span class="line">					// point where they hit the limit first.</span><br><span class="line">					int motionPosition = findMotionRow(y);</span><br><span class="line">					if (motionPosition &gt;= 0) &#123;</span><br><span class="line">						final View motionView = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">						mMotionViewOriginalTop = motionView.getTop();</span><br><span class="line">					&#125;</span><br><span class="line">					mMotionY = y;</span><br><span class="line">					mMotionPosition = motionPosition;</span><br><span class="line">					invalidate();</span><br><span class="line">				&#125;</span><br><span class="line">				mLastY = y;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case MotionEvent.ACTION_UP: &#123;</span><br><span class="line">		switch (mTouchMode) &#123;</span><br><span class="line">		case TOUCH_MODE_DOWN:</span><br><span class="line">		case TOUCH_MODE_TAP:</span><br><span class="line">		case TOUCH_MODE_DONE_WAITING:</span><br><span class="line">			final int motionPosition = mMotionPosition;</span><br><span class="line">			final View child = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">			if (child != null &amp;&amp; !child.hasFocusable()) &#123;</span><br><span class="line">				if (mTouchMode != TOUCH_MODE_DOWN) &#123;</span><br><span class="line">					child.setPressed(false);</span><br><span class="line">				&#125;</span><br><span class="line">				if (mPerformClick == null) &#123;</span><br><span class="line">					mPerformClick = new PerformClick();</span><br><span class="line">				&#125;</span><br><span class="line">				final AbsListView.PerformClick performClick = mPerformClick;</span><br><span class="line">				performClick.mChild = child;</span><br><span class="line">				performClick.mClickMotionPosition = motionPosition;</span><br><span class="line">				performClick.rememberWindowAttachCount();</span><br><span class="line">				mResurrectToPosition = motionPosition;</span><br><span class="line">				if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) &#123;</span><br><span class="line">					final Handler handler = getHandler();</span><br><span class="line">					if (handler != null) &#123;</span><br><span class="line">						handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap</span><br><span class="line">								: mPendingCheckForLongPress);</span><br><span class="line">					&#125;</span><br><span class="line">					mLayoutMode = LAYOUT_NORMAL;</span><br><span class="line">					if (!mDataChanged &amp;&amp; mAdapter.isEnabled(motionPosition)) &#123;</span><br><span class="line">						mTouchMode = TOUCH_MODE_TAP;</span><br><span class="line">						setSelectedPositionInt(mMotionPosition);</span><br><span class="line">						layoutChildren();</span><br><span class="line">						child.setPressed(true);</span><br><span class="line">						positionSelector(child);</span><br><span class="line">						setPressed(true);</span><br><span class="line">						if (mSelector != null) &#123;</span><br><span class="line">							Drawable d = mSelector.getCurrent();</span><br><span class="line">							if (d != null &amp;&amp; d instanceof TransitionDrawable) &#123;</span><br><span class="line">								((TransitionDrawable) d).resetTransition();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						postDelayed(new Runnable() &#123;</span><br><span class="line">							public void run() &#123;</span><br><span class="line">								child.setPressed(false);</span><br><span class="line">								setPressed(false);</span><br><span class="line">								if (!mDataChanged) &#123;</span><br><span class="line">									post(performClick);</span><br><span class="line">								&#125;</span><br><span class="line">								mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;, ViewConfiguration.getPressedStateDuration());</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">					&#125;</span><br><span class="line">					return true;</span><br><span class="line">				&#125; else if (!mDataChanged &amp;&amp; mAdapter.isEnabled(motionPosition)) &#123;</span><br><span class="line">					post(performClick);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">			break;</span><br><span class="line">		case TOUCH_MODE_SCROLL:</span><br><span class="line">			final int childCount = getChildCount();</span><br><span class="line">			if (childCount &gt; 0) &#123;</span><br><span class="line">				if (mFirstPosition == 0</span><br><span class="line">						&amp;&amp; getChildAt(0).getTop() &gt;= mListPadding.top</span><br><span class="line">						&amp;&amp; mFirstPosition + childCount &lt; mItemCount</span><br><span class="line">						&amp;&amp; getChildAt(childCount - 1).getBottom() &lt;= getHeight()</span><br><span class="line">								- mListPadding.bottom) &#123;</span><br><span class="line">					mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">					reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					final VelocityTracker velocityTracker = mVelocityTracker;</span><br><span class="line">					velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);</span><br><span class="line">					final int initialVelocity = (int) velocityTracker</span><br><span class="line">							.getYVelocity(mActivePointerId);</span><br><span class="line">					if (Math.abs(initialVelocity) &gt; mMinimumVelocity) &#123;</span><br><span class="line">						if (mFlingRunnable == null) &#123;</span><br><span class="line">							mFlingRunnable = new FlingRunnable();</span><br><span class="line">						&#125;</span><br><span class="line">						reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);</span><br><span class="line">						mFlingRunnable.start(-initialVelocity);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">						reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">				reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		setPressed(false);</span><br><span class="line">		// Need to redraw since we probably aren&apos;t drawing the selector</span><br><span class="line">		// anymore</span><br><span class="line">		invalidate();</span><br><span class="line">		final Handler handler = getHandler();</span><br><span class="line">		if (handler != null) &#123;</span><br><span class="line">			handler.removeCallbacks(mPendingCheckForLongPress);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mVelocityTracker != null) &#123;</span><br><span class="line">			mVelocityTracker.recycle();</span><br><span class="line">			mVelocityTracker = null;</span><br><span class="line">		&#125;</span><br><span class="line">		mActivePointerId = INVALID_POINTER;</span><br><span class="line">		if (PROFILE_SCROLLING) &#123;</span><br><span class="line">			if (mScrollProfilingStarted) &#123;</span><br><span class="line">				Debug.stopMethodTracing();</span><br><span class="line">				mScrollProfilingStarted = false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">		mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">		setPressed(false);</span><br><span class="line">		View motionView = this.getChildAt(mMotionPosition - mFirstPosition);</span><br><span class="line">		if (motionView != null) &#123;</span><br><span class="line">			motionView.setPressed(false);</span><br><span class="line">		&#125;</span><br><span class="line">		clearScrollingCache();</span><br><span class="line">		final Handler handler = getHandler();</span><br><span class="line">		if (handler != null) &#123;</span><br><span class="line">			handler.removeCallbacks(mPendingCheckForLongPress);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mVelocityTracker != null) &#123;</span><br><span class="line">			mVelocityTracker.recycle();</span><br><span class="line">			mVelocityTracker = null;</span><br><span class="line">		&#125;</span><br><span class="line">		mActivePointerId = INVALID_POINTER;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case MotionEvent.ACTION_POINTER_UP: &#123;</span><br><span class="line">		onSecondaryPointerUp(ev);</span><br><span class="line">		final int x = mMotionX;</span><br><span class="line">		final int y = mMotionY;</span><br><span class="line">		final int motionPosition = pointToPosition(x, y);</span><br><span class="line">		if (motionPosition &gt;= 0) &#123;</span><br><span class="line">			// Remember where the motion event started</span><br><span class="line">			v = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">			mMotionViewOriginalTop = v.getTop();</span><br><span class="line">			mMotionPosition = motionPosition;</span><br><span class="line">		&#125;</span><br><span class="line">		mLastY = y;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法中的代码就非常多了，因为它所处理的逻辑也非常多，要监听各种各样的触屏事件。但是我们目前所关心的就只有手指在屏幕上滑动这一个事件而已，对应的是ACTION_MOVE这个动作，那么我们就只看这部分代码就可以了。可以看到，ACTION_MOVE这个case里面又嵌套了一个switch语句，是根据当前的TouchMode来选择的。那这里我可以直接告诉大家，当手指在屏幕上滑动时，TouchMode是等于TOUCH_MODE_SCROLL这个值的。</p>
<p>这样的话，代码就应该会走到第78行的这个case里面去了，在这个case当中并没有什么太多需要注意的东西，唯一一点非常重要的就是第92行调用的trackMotionScroll()方法，相当于我们手指只要在屏幕上稍微有一点点移动，这个方法就会被调用，而如果是正常在屏幕上滑动的话，那么这个方法就会被调用很多次。那么我们进入到这个方法中瞧一瞧，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">boolean trackMotionScroll(int deltaY, int incrementalDeltaY) &#123;</span><br><span class="line">	final int childCount = getChildCount();</span><br><span class="line">	if (childCount == 0) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	final int firstTop = getChildAt(0).getTop();</span><br><span class="line">	final int lastBottom = getChildAt(childCount - 1).getBottom();</span><br><span class="line">	final Rect listPadding = mListPadding;</span><br><span class="line">	final int spaceAbove = listPadding.top - firstTop;</span><br><span class="line">	final int end = getHeight() - listPadding.bottom;</span><br><span class="line">	final int spaceBelow = lastBottom - end;</span><br><span class="line">	final int height = getHeight() - getPaddingBottom() - getPaddingTop();</span><br><span class="line">	if (deltaY &lt; 0) &#123;</span><br><span class="line">		deltaY = Math.max(-(height - 1), deltaY);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		deltaY = Math.min(height - 1, deltaY);</span><br><span class="line">	&#125;</span><br><span class="line">	if (incrementalDeltaY &lt; 0) &#123;</span><br><span class="line">		incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);</span><br><span class="line">	&#125;</span><br><span class="line">	final int firstPosition = mFirstPosition;</span><br><span class="line">	if (firstPosition == 0 &amp;&amp; firstTop &gt;= listPadding.top &amp;&amp; deltaY &gt;= 0) &#123;</span><br><span class="line">		// Don&apos;t need to move views down if the top of the first position</span><br><span class="line">		// is already visible</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	if (firstPosition + childCount == mItemCount &amp;&amp; lastBottom &lt;= end &amp;&amp; deltaY &lt;= 0) &#123;</span><br><span class="line">		// Don&apos;t need to move views up if the bottom of the last position</span><br><span class="line">		// is already visible</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	final boolean down = incrementalDeltaY &lt; 0;</span><br><span class="line">	final boolean inTouchMode = isInTouchMode();</span><br><span class="line">	if (inTouchMode) &#123;</span><br><span class="line">		hideSelector();</span><br><span class="line">	&#125;</span><br><span class="line">	final int headerViewsCount = getHeaderViewsCount();</span><br><span class="line">	final int footerViewsStart = mItemCount - getFooterViewsCount();</span><br><span class="line">	int start = 0;</span><br><span class="line">	int count = 0;</span><br><span class="line">	if (down) &#123;</span><br><span class="line">		final int top = listPadding.top - incrementalDeltaY;</span><br><span class="line">		for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">			final View child = getChildAt(i);</span><br><span class="line">			if (child.getBottom() &gt;= top) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				count++;</span><br><span class="line">				int position = firstPosition + i;</span><br><span class="line">				if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</span><br><span class="line">					mRecycler.addScrapView(child);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		final int bottom = getHeight() - listPadding.bottom - incrementalDeltaY;</span><br><span class="line">		for (int i = childCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">			final View child = getChildAt(i);</span><br><span class="line">			if (child.getTop() &lt;= bottom) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				start = i;</span><br><span class="line">				count++;</span><br><span class="line">				int position = firstPosition + i;</span><br><span class="line">				if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</span><br><span class="line">					mRecycler.addScrapView(child);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mMotionViewNewTop = mMotionViewOriginalTop + deltaY;</span><br><span class="line">	mBlockLayoutRequests = true;</span><br><span class="line">	if (count &gt; 0) &#123;</span><br><span class="line">		detachViewsFromParent(start, count);</span><br><span class="line">	&#125;</span><br><span class="line">	offsetChildrenTopAndBottom(incrementalDeltaY);</span><br><span class="line">	if (down) &#123;</span><br><span class="line">		mFirstPosition += count;</span><br><span class="line">	&#125;</span><br><span class="line">	invalidate();</span><br><span class="line">	final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);</span><br><span class="line">	if (spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) &#123;</span><br><span class="line">		fillGap(down);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!inTouchMode &amp;&amp; mSelectedPosition != INVALID_POSITION) &#123;</span><br><span class="line">		final int childIndex = mSelectedPosition - mFirstPosition;</span><br><span class="line">		if (childIndex &gt;= 0 &amp;&amp; childIndex &lt; getChildCount()) &#123;</span><br><span class="line">			positionSelector(getChildAt(childIndex));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mBlockLayoutRequests = false;</span><br><span class="line">	invokeOnItemScrollListener();</span><br><span class="line">	awakenScrollBars();</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法接收两个参数，deltaY表示从手指按下时的位置到当前手指位置的距离，incrementalDeltaY则表示据上次触发event事件手指在Y方向上位置的改变量，那么其实我们就可以通过incrementalDeltaY的正负值情况来判断用户是向上还是向下滑动的了。如第34行代码所示，如果incrementalDeltaY小于0，说明是向下滑动，否则就是向上滑动。</p>
<p>下面将会进行一个边界值检测的过程，可以看到，从第43行开始，当ListView向下滑动的时候，就会进入一个for循环当中，从上往下依次获取子View，第47行当中，如果该子View的bottom值已经小于top值了，就说明这个子View已经移出屏幕了，所以会调用RecycleBin的addScrapView()方法将这个View加入到废弃缓存当中，并将count计数器加1，计数器用于记录有多少个子View被移出了屏幕。那么如果是ListView向上滑动的话，其实过程是基本相同的，只不过变成了从下往上依次获取子View，然后判断该子View的top值是不是大于bottom值了，如果大于的话说明子View已经移出了屏幕，同样把它加入到废弃缓存中，并将计数器加1。</p>
<p>接下来在第76行，会根据当前计数器的值来进行一个detach操作，它的作用就是把所有移出屏幕的子View全部detach掉，在ListView的概念当中，所有看不到的View就没有必要为它进行保存，因为屏幕外还有成百上千条数据等着显示呢，一个好的回收策略才能保证ListView的高性能和高效率。<strong>紧接着在第78行调用了offsetChildrenTopAndBottom()方法，并将incrementalDeltaY作为参数传入，这个方法的作用是让ListView中所有的子View都按照传入的参数值进行相应的偏移，这样就实现了随着手指的拖动，ListView的内容也会随着滚动的效果。</strong></p>
<p>然后在第84行会进行判断，如果ListView中最后一个View的底部已经移入了屏幕，或者ListView中第一个View的顶部移入了屏幕，就会调用fillGap()方法，那么因此我们就可以猜出fillGap()方法是用来加载屏幕外数据的，进入到这个方法中瞧一瞧，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Fills the gap left open by a touch-scroll. During a touch scroll,</span><br><span class="line"> * children that remain on screen are shifted and the other ones are</span><br><span class="line"> * discarded. The role of this method is to fill the gap thus created by</span><br><span class="line"> * performing a partial layout in the empty space.</span><br><span class="line"> * </span><br><span class="line"> * @param down</span><br><span class="line"> *            true if the scroll is going down, false if it is going up</span><br><span class="line"> */</span><br><span class="line">abstract void fillGap(boolean down);</span><br><span class="line">OK，AbsListView中的fillGap()是一个抽象方法，那么我们立刻就能够想到，它的具体实现肯定是在ListView中完成的了。回到ListView当中，fillGap()方法的代码如下所示：</span><br><span class="line">void fillGap(boolean down) &#123;</span><br><span class="line">    final int count = getChildCount();</span><br><span class="line">    if (down) &#123;</span><br><span class="line">        final int startOffset = count &gt; 0 ? getChildAt(count - 1).getBottom() + mDividerHeight :</span><br><span class="line">                getListPaddingTop();</span><br><span class="line">        fillDown(mFirstPosition + count, startOffset);</span><br><span class="line">        correctTooHigh(getChildCount());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final int startOffset = count &gt; 0 ? getChildAt(0).getTop() - mDividerHeight :</span><br><span class="line">                getHeight() - getListPaddingBottom();</span><br><span class="line">        fillUp(mFirstPosition - 1, startOffset);</span><br><span class="line">        correctTooLow(getChildCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>down参数用于表示ListView是向下滑动还是向上滑动的，可以看到，如果是向下滑动的话就会调用fillDown()方法，而如果是向上滑动的话就会调用fillUp()方法。那么这两个方法我们都已经非常熟悉了，内部都是通过一个循环来去对ListView进行填充，所以这两个方法我们就不看了，但是填充ListView会通过调用makeAndAddView()方法来完成，又是makeAndAddView()方法，但这次的逻辑再次不同了，所以我们还是回到这个方法瞧一瞧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Obtain the view and add it to our list of children. The view can be made</span><br><span class="line"> * fresh, converted from an unused view, or used as is if it was in the</span><br><span class="line"> * recycle bin.</span><br><span class="line"> *</span><br><span class="line"> * @param position Logical position in the list</span><br><span class="line"> * @param y Top or bottom edge of the view to add</span><br><span class="line"> * @param flow If flow is true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @return View that was added</span><br><span class="line"> */</span><br><span class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</span><br><span class="line">        boolean selected) &#123;</span><br><span class="line">    View child;</span><br><span class="line">    if (!mDataChanged) &#123;</span><br><span class="line">        // Try to use an exsiting view for this position</span><br><span class="line">        child = mRecycler.getActiveView(position);</span><br><span class="line">        if (child != null) &#123;</span><br><span class="line">            // Found it -- we&apos;re using an existing child</span><br><span class="line">            // This just needs to be positioned</span><br><span class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Make a new view for this position, or convert an unused view if possible</span><br><span class="line">    child = obtainView(position, mIsScrap);</span><br><span class="line">    // This needs to be positioned and measured</span><br><span class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不管怎么说，这里首先仍然是会尝试调用RecycleBin的getActiveView()方法来获取子布局，只不过肯定是获取不到的了，因为在第二次Layout过程中我们已经从mActiveViews中获取过了数据，而根据RecycleBin的机制，mActiveViews是不能够重复利用的，因此这里返回的值肯定是null。</p>
<p>既然getActiveView()方法返回的值是null，那么就还是会走到第28行的obtainView()方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get a view and have it show the data associated with the specified</span><br><span class="line"> * position. This is called when we have already discovered that the view is</span><br><span class="line"> * not available for reuse in the recycle bin. The only choices left are</span><br><span class="line"> * converting an old view or making a new one.</span><br><span class="line"> * </span><br><span class="line"> * @param position</span><br><span class="line"> *            The position to display</span><br><span class="line"> * @param isScrap</span><br><span class="line"> *            Array of at least 1 boolean, the first entry will become true</span><br><span class="line"> *            if the returned view was taken from the scrap heap, false if</span><br><span class="line"> *            otherwise.</span><br><span class="line"> * </span><br><span class="line"> * @return A view displaying the data associated with the specified position</span><br><span class="line"> */</span><br><span class="line">View obtainView(int position, boolean[] isScrap) &#123;</span><br><span class="line">	isScrap[0] = false;</span><br><span class="line">	View scrapView;</span><br><span class="line">	scrapView = mRecycler.getScrapView(position);</span><br><span class="line">	View child;</span><br><span class="line">	if (scrapView != null) &#123;</span><br><span class="line">		child = mAdapter.getView(position, scrapView, this);</span><br><span class="line">		if (child != scrapView) &#123;</span><br><span class="line">			mRecycler.addScrapView(scrapView);</span><br><span class="line">			if (mCacheColorHint != 0) &#123;</span><br><span class="line">				child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			isScrap[0] = true;</span><br><span class="line">			dispatchFinishTemporaryDetach(child);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		child = mAdapter.getView(position, null, this);</span><br><span class="line">		if (mCacheColorHint != 0) &#123;</span><br><span class="line">			child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这里在第19行会调用RecyleBin的getScrapView()方法来尝试从废弃缓存中获取一个View，那么废弃缓存有没有View呢？当然有，因为刚才在trackMotionScroll()方法中我们就已经看到了，一旦有任何子View被移出了屏幕，就会将它加入到废弃缓存中，而从obtainView()方法中的逻辑来看，一旦有新的数据需要显示到屏幕上，就会尝试从废弃缓存中获取View。所以它们之间就形成了一个生产者和消费者的模式，那么ListView神奇的地方也就在这里体现出来了，不管你有任意多条数据需要显示，ListView中的子View其实来来回回就那么几个，移出屏幕的子View会很快被移入屏幕的数据重新利用起来，因而不管我们加载多少数据都不会出现OOM的情况，甚至内存都不会有所增加。</strong></p>
<p>那么另外还有一点是需要大家留意的，这里获取到了一个scrapView，然后我们在第22行将它作为第二个参数传入到了Adapter的getView()方法当中。那么第二个参数是什么意思呢？我们再次看一下一个简单的getView()方法示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">	Fruit fruit = getItem(position);</span><br><span class="line">	View view;</span><br><span class="line">	if (convertView == null) &#123;</span><br><span class="line">		view = LayoutInflater.from(getContext()).inflate(resourceId, null);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		view = convertView;</span><br><span class="line">	&#125;</span><br><span class="line">	ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">	TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line">	fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">	fruitName.setText(fruit.getName());</span><br><span class="line">	return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个参数就是我们最熟悉的convertView呀，难怪平时我们在写getView()方法是要判断一下convertView是不是等于null，如果等于null才调用inflate()方法来加载布局，不等于null就可以直接利用convertView，因为convertView就是我们之间利用过的View，只不过被移出屏幕后进入到了废弃缓存中，现在又重新拿出来使用而已。然后我们只需要把convertView中的数据更新成当前位置上应该显示的数据，那么看起来就好像是全新加载出来的一个布局一样，这背后的道理你是不是已经完全搞明白了？</p>
<p>之后的代码又都是我们熟悉的流程了，从缓存中拿到子View之后再调用setupChild()方法将它重新attach到ListView当中，因为缓存中的View也是之前从ListView中detach掉的，这部分代码就不再重复进行分析了。</p>
<p>为了方便大家理解，这里我再附上一张图解说明：<br><img src="/2019/09/05/android-listview/recycle_bin.png" alt></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/44996879</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/16/android-ndk-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/android-ndk-knowledge/" itemprop="url">NDK之CMake</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T09:42:27+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-NDK/" itemprop="url" rel="index">
                    <span itemprop="name">Android NDK</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>JNI（Java Native Interface），是方便Java调用C、C++等Native代码所封装的一层接口，相当于一座桥梁。通过JNI可以操作一些Java无法完成的与系统相关的特性，尤其在图像和视频处理中大量用到。</p>
<p>NDK（native development kit）提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。NDK集成了<strong>交叉编译器</strong>，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so，该动态库可以兼容各个平台。</p>
<h2 id="2、CMake"><a href="#2、CMake" class="headerlink" title="2、CMake"></a>2、CMake</h2><p>CMake是一个跨平台的安装(编译)工具，通过编写CMakeLists.txt，可以生成对应的makefile或project文件，再调用底层的编译。AS 2.2之后工具中增加了对CMake的支持，官方也推荐用CMake+CMakeLists.txt的方式，代替ndk-build+Android.mk+Application.mk的方式去构建JNI项目.</p>
<h3 id="创建使用CMake构建的项目"><a href="#创建使用CMake构建的项目" class="headerlink" title="创建使用CMake构建的项目"></a>创建使用CMake构建的项目</h3><p>开始前AS要先在SDK Manager中安装SDK Tools-&gt;CMake，只要勾选Include C++ Support。其中会提示配置C++支持的功能.</p>
<p>一般默认就可以了，各个选项的具体含义:</p>
<blockquote>
<p>C++ Standard：指定编译库的环境。<br>Exception Support:当前项目支持C++异常处理<br>Runtime Type Information Support：除异常处理外，还支持动态转类型(dynamic casting) 、模块集成、以及对象I/O</p>
</blockquote>
<h3 id="工程的目录结构"><a href="#工程的目录结构" class="headerlink" title="工程的目录结构"></a>工程的目录结构</h3><p>创建好的工程主Module下直接就有.externalNativeBuild，多出一个CMakeLists.txt，相当于以前的配置文件。并且在src/main目录下多了一个cpp文件夹，里面存放的是C++文件，相当于以前的jni文件夹。这个是工程创建后AS生成的示例JNI方法，返回了一个字符串。后面开发JNI就可以按照这个目录结构。</p>
<p>相应的，build.gradle下也增加了一些配置:</p>
<pre><code>android {
    ...
    defaultConfig {
        ...
        externalNativeBuild {
            cmake {
                cppFlags &quot;-std=c++14 -frtti -fexceptions&quot;
                abiFilters &quot;x86&quot;, &quot;arm64-v8a&quot;, &quot;armeabi-v7a&quot;
            }
        }
    }
    buildTypes {
        ...
    }
    externalNativeBuild {
        cmake {
            path &quot;CMakeLists.txt&quot;
        }
    }
}
</code></pre><p>defaultConfig中的externalNativeBuild各项属性和前面创建项目时的选项配置有关，外部的externalNativeBuild则定义了CMakeLists.txt的存放路径。<br>如果只是在自己的项目中使用，CMake的方式在打包APK的时候会自动将cpp文件编译成so文件拷贝进去。如果要提供给外部使用时，Make Project，之后在libs目录下就可以看到生成的对应配置的相关CPU平台的.so文件。</p>
<h3 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h3><p>CMakeLists.txt可以自定义命令、查找文件、头文件包含、设置变量，具体可见 官方文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 编译本地库时我们需要的最小的cmake版本</span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line">#设置生成的so动态库最后输出的路径，一定要在add_library之前设置，否则不会生效</span><br><span class="line">set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;)</span><br><span class="line"></span><br><span class="line"># 相当于Android.mk。如果是多次使用add_library，则会生成多个so库；</span><br><span class="line"># 如果想将多个本地文件编译到一个so库中，只要最后一个参数添加多个C/C++文件的相对路径就可以</span><br><span class="line">add_library( # Sets the name of the library.设置编译生成本地库的名字</span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             # Sets the library as a shared library.库的类型</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).编译文件的路径</span><br><span class="line">             src/main/cpp/native-lib.cpp )</span><br><span class="line"></span><br><span class="line"># 添加一些我们在编译我们的本地库的时候需要依赖的一些库，这里是用来打log的库。可以写多个find_library</span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"># 关联自己生成的库和一些第三方库或者系统库</span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       # Links the target library to the log library</span><br><span class="line">                       # included in the NDK.</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br><span class="line"></span><br><span class="line">#设置头文件搜索路径（和此txt同个路径的头文件无需设置），可选</span><br><span class="line">#INCLUDE_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/common)</span><br><span class="line"></span><br><span class="line">#指定用到的系统库或者NDK库或者第三方库的搜索路径，可选。</span><br><span class="line">#LINK_DIRECTORIES(/usr/local/lib)</span><br><span class="line"></span><br><span class="line">#添加子目录,将会调用子目录中的CMakeLists.txt</span><br><span class="line">ADD_SUBDIRECTORY(one)</span><br><span class="line">ADD_SUBDIRECTORY(two)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>cmake_minimum_required(VERSION 3.4.1)：指定CMake的最小版本</li>
<li>add_library：创建一个静态或者动态库，并提供其关联的源文件路径，开发者可以定义多个库，CMake会自动去构建它们。Gradle可以自动将它们打包进APK中。<br>第一个参数——native-lib：是库的名称<br>第二个参数——SHARED：是库的类别，是动态的还是静态的<br>第三个参数——src/main/cpp/native-lib.cpp：是库的源文件的路径</li>
<li>find_library：找到一个预编译的库，并作为一个变量保存起来。由于CMake在搜索库路径的时候会包含系统库，并且CMake会检查它自己之前编译的库的名字，所以开发者需要保证开发者自行添加的库的名字的独特性。<br>第一个参数——log-lib：设置路径变量的名称<br>第一个参数—— log：指定NDK库的名子，这样CMake就可以找到这个库</li>
<li>target_link_libraries：指定CMake链接到目标库。开发者可以链接多个库，比如开发者可以在此定义库的构建脚本，并且预编译第三方库或者系统库。<br>第一个参数——native-lib：指定的目标库<br>第一个参数——${log-lib}：将目标库链接到NDK中的日志库，</li>
</ul>
<p>如果想要配置so库的目标CPU平台，可以在build.gradle中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        ndk&#123;</span><br><span class="line">            abiFilters &quot;x86&quot;,&quot;armeabi&quot;,&quot;armeabi-v7a&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="set-target-properties"><a href="#set-target-properties" class="headerlink" title="set_target_properties"></a>set_target_properties</h4><p>设置目标的一些属性来改变它们构建的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(target1 target2 ...</span><br><span class="line">                      PROPERTIES prop1 value1</span><br><span class="line">                      prop2 value2 ...)</span><br></pre></td></tr></table></figure></p>
<p>使用示例为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(cocos2d</span><br><span class="line">    PROPERTIES</span><br><span class="line">    ARCHIVE_OUTPUT_DIRECTORY &quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span><br><span class="line">    LIBRARY_OUTPUT_DIRECTORY &quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span><br><span class="line">    VERSION &quot;$&#123;COCOS2D_X_VERSION&#125;&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>为一个目标设置属性。该命令的语法是列出所有你想要变更的文件，然后提供你想要设置的值。你能够使用任何你想要的属性/值对，并且在随后的代码中调用GET_TARGET_PROPERTY命令取出属性的值。</p>
<p>大家在用cmake时，应该经常会用到第三方so库，导入第三方so库中需要使用到set_target_properties,例如这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(</span><br><span class="line"></span><br><span class="line">Thirdlib</span><br><span class="line"></span><br><span class="line">PROPERTIES IMPORTED_LOCATION</span><br><span class="line"></span><br><span class="line">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/jniLibs/libThirdlib.so</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>CMAKE_CURRENT_SOURCE_DIR 这个变量是系统自定义的，表示CMakeLists.txt文件的绝对路径</p>
<h3 id="包含其他-CMake-项目"><a href="#包含其他-CMake-项目" class="headerlink" title="包含其他 CMake 项目"></a>包含其他 CMake 项目</h3><p>如果想要编译多个 CMake 项目并在 Android 项目中包含它们的输出，您可以使用一个 CMakeLists.txt 文件（即您关联到 Gradle 的那个文件）作为顶级 CMake 编译脚本，并添加其他 CMake 项目作为此编译脚本的依赖项。以下顶级 CMake 编译脚本使用 add_subdirectory() 命令将另一个 CMakeLists.txt 文件指定为编译依赖项，然后关联其输出，就像处理任何其他预编译库一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Sets lib_src_DIR to the path of the target CMake project.</span><br><span class="line">set( lib_src_DIR ../gmath )</span><br><span class="line"></span><br><span class="line"># Sets lib_build_DIR to the path of the desired output directory.</span><br><span class="line">set( lib_build_DIR ../gmath/outputs )</span><br><span class="line">file(MAKE_DIRECTORY $&#123;lib_build_DIR&#125;)</span><br><span class="line"></span><br><span class="line"># Adds the CMakeLists.txt file located in the specified directory</span><br><span class="line"># as a build dependency.</span><br><span class="line">add_subdirectory( # Specifies the directory of the CMakeLists.txt file.</span><br><span class="line">                  $&#123;lib_src_DIR&#125;</span><br><span class="line"></span><br><span class="line">                  # Specifies the directory for the build outputs.</span><br><span class="line">                  $&#123;lib_build_DIR&#125; )</span><br><span class="line"></span><br><span class="line"># Adds the output of the additional CMake build as a prebuilt static</span><br><span class="line"># library and names it lib_gmath.</span><br><span class="line">add_library( lib_gmath STATIC IMPORTED )</span><br><span class="line">set_target_properties( lib_gmath PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       $&#123;lib_build_DIR&#125;/$&#123;ANDROID_ABI&#125;/lib_gmath.a )</span><br><span class="line">include_directories( $&#123;lib_src_DIR&#125;/include )</span><br><span class="line"></span><br><span class="line"># Links the top-level CMake build output against lib_gmath.</span><br><span class="line">target_link_libraries( native-lib ... lib_gmath )</span><br></pre></td></tr></table></figure></p>
<h2 id="3、Android-mk"><a href="#3、Android-mk" class="headerlink" title="3、Android.mk"></a>3、Android.mk</h2><p>Android.mk内容示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE    := ndkdemotest-jni</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := ndkdemotest.c</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>LOCAL_PATH := $(call my-dir)：每个Android.mk文件必须以定义开始。它用于在开发tree中查找源文件。宏my-dir则由Build System 提供。返回包含Android.mk目录路径。</p>
</li>
<li><p>include $(CLEAR_VARS) ：CLEAR_VARS变量由Build System提供。并指向一个指定的GNU Makefile，由它负责清理很多LOCAL_xxx。例如LOCAL_MODULE，LOCAL_SRC_FILES，LOCAL_STATIC_LIBRARIES等等。但不是清理LOCAL_PATH。这个清理是必须的，因为所有的编译控制文件由同一个GNU Make解析和执行，其变量是全局的。所以清理后才能便面相互影响。</p>
</li>
<li><p>LOCAL_MODULE := ndkdemotest-jni：LOCAL_MODULE模块必须定义，以表示Android.mk中的每一个模块。名字必须唯一且不包含空格。Build System 会自动添加适当的前缀和后缀。例如，demo，要生成动态库，则生成libdemo.so。但请注意：如果模块名字被定义为libabd，则生成libabc.so。不再添加前缀。</p>
</li>
<li><p>LOCAL_SRC_FILES := ndkdemotest.c：这行代码表示将要打包的C/C++源码。不必列出头文件，build System 会自动帮我们找出依赖文件。缺省的C++ 源码的扩展名为.cpp。</p>
</li>
<li><p>include $(BUILD_SHARED_LIBRARY)：BUILD_SHARED_LIBRARY是Build System提供的一个变量，指向一个GUN Makefile Script。它负责收集自从上次调用include $(CLEAR_VARS)后的所有LOCAL_xxxxinx。并决定编译什么类型：<br>1）BUILD_STATIC_LIBRARY：编译为静态库<br>2）BUILD_SHARED_LIBRARY：编译为动态库<br>3）BUILD_EXECUTABLE：编译为Native C 可执行程序<br>4）BUILD_PREBUILT：该模块已经预先编译</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wzhseu/article/details/79683045" target="_blank" rel="noopener">https://blog.csdn.net/wzhseu/article/details/79683045</a><br><a href="https://www.cnblogs.com/alphagl/p/6280061.html" target="_blank" rel="noopener">CMake学习</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/android-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/android-note/" itemprop="url">Android小知识点笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T09:22:55+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>外部类创建匿名内部类后，有可能匿名内部类还在使用，而外部类实例（或者创建内部类的方法）已经被回收了。如果此时匿名内部类用到了外部类的成员变量，那么就会出现匿名内部类要去访问一个不存在的变量的这种荒唐情况，为了延长局部变量的生命周期，于是匿名内部类使用的局部变量会被复制一份，从而使得局部变量的生命周期看起来变长了。但是这样又会引出另一个问题：<strong>数据一致性的问题！为了保证局部变量和 内部类中复制品 的数据一致性，于是要求内部类使用的局部变量是final的</strong>。</p>
<h2 id="λ表达式"><a href="#λ表达式" class="headerlink" title="λ表达式"></a>λ表达式</h2><p>λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。<strong>λ表达式可以被当做是一个Object（注意措辞），λ表达式的目标类型是“函数接口（functional interface）”</strong>。    </p>
<p><strong>λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。</strong>Java8有一个短期目标和一个长期目标。<strong>短期目标是：配合“集合类批处理操作”的内部迭代和并行处理；长期目标是将Java向函数式编程语言这个方向引导</strong>（并不是要完全变成一门函数式编程语言，只是让它有更多的函数式编程语言的特性）。</p>
<p>Java8为集合类引入了另一个重要概念：流（stream）。一个流通常以一个集合类实例为其数据源，然后在其上定义各种操作。流的API设计使用了管道（pipelines）模式。对流的一次操作会返回另一个流。你可能会觉得List 被迭代了好多次，map，filter，distinct都分别是一次循环，效率会不好。实际并非如此。这些返回另一个Stream的方法都是“懒（lazy）”的，而最后返回最终结果的方法则是“急（eager）”的。在遇到eager方法之前，lazy的方法不会执行。</p>
<p><strong>内部类总是持有一个其外部类对象的引用。而λ表达式呢，除非在它内部用到了其外部类（包围类）对象的方法或者成员，否则它就不持有这个对象的引用。</strong>在Java8以前，如果要在内部类访问外部对象的一个本地变量，那么这个变量必须声明为final才行。在Java8中，这种限制被去掉了，代之以一个新的概念，“effectively final”。它的意思是你可以声明为final，也可以不声明final但是按照final来用，也就是一次赋值永不改变。</p>
<p><strong>任何一个λ表达式都可以代表某个函数接口的唯一方法的匿名描述符。我们也可以使用某个类的某个具体方法来代表这个描述符，叫做方法引用。</strong></p>
<h2 id="String-amp-StringBuffer-amp-StringBuilder"><a href="#String-amp-StringBuffer-amp-StringBuilder" class="headerlink" title="String &amp; StringBuffer &amp; StringBuilder"></a>String &amp; StringBuffer &amp; StringBuilder</h2><p>1、长度是否可变<br>String 是被 final 修饰的，他的长度是不可变的，就算调用 String 的concat 方法，那也是把字符串拼接起来并重新创建一个对象，把拼接后的 String 的值赋给新创建的对象<br>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象，StringBuffer 与 StringBuilder 中的方法和功能完全是等价的。调用StringBuffer 的 append 方法，来改变 StringBuffer 的长度，并且，相比较于 StringBuffer，String 一旦发生长度变化，是非常耗费内存的！</p>
<p>2、执行效率<br>三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String</p>
<p>3、应用场景<br>如果要操作少量的数据用 = String<br>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder<br>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p>
<p>StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。</p>
<h2 id="Java中Vector和ArrayList的区别"><a href="#Java中Vector和ArrayList的区别" class="headerlink" title="Java中Vector和ArrayList的区别"></a>Java中Vector和ArrayList的区别</h2><p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p>
<ol>
<li>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li>
<li>Vector与ArrayList一样，<strong>也是通过数组实现的，不同的是它支持线程的同步</strong>，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</li>
<li><strong>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢</strong>。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</li>
</ol>
<h2 id="View绘制与事件"><a href="#View绘制与事件" class="headerlink" title="View绘制与事件"></a>View绘制与事件</h2><p><img src="/2019/08/12/android-note/view.webp" alt title="UI 管理系统的层级"></p>
<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>onMeasure()、onLayout()：<br>measure是测量的意思，那么onMeasure()方法顾名思义就是用于测量视图的大小的。<strong>View系统的绘制流程会从ViewRoot的performTraversals()方法中开始</strong>，在其内部调用View的measure()方法。<br><strong>getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。</strong>另外，getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p>
<p>onDraw()步骤:<br>1.第一步是从第9行代码开始的，这一步的作用是对视图的背景进行绘制<br>2.第三步是在第34行执行的，这一步的作用是对视图的内容进行绘制<br>3.第四步的作用是对当前视图的所有子视图进行绘制<br>4.第六步的作用是对视图的滚动条进行绘制。其实不管是Button也好，TextView也好，任何一个视图都是有滚动条的，只是一般情况下我们都没有让它显示出来而已。<br>部分源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">	if (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">	    ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);</span><br><span class="line">	&#125;</span><br><span class="line">	final int privateFlags = mPrivateFlags;</span><br><span class="line">	final boolean dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">	        (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">	mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN;</span><br><span class="line">	// Step 1, draw the background, if needed</span><br><span class="line">	int saveCount;</span><br><span class="line">	if (!dirtyOpaque) &#123;</span><br><span class="line">	    final Drawable background = mBGDrawable;</span><br><span class="line">	    if (background != null) &#123;</span><br><span class="line">	        final int scrollX = mScrollX;</span><br><span class="line">	        final int scrollY = mScrollY;</span><br><span class="line">	        if (mBackgroundSizeChanged) &#123;</span><br><span class="line">	            background.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);</span><br><span class="line">	            mBackgroundSizeChanged = false;</span><br><span class="line">	        &#125;</span><br><span class="line">	        if ((scrollX | scrollY) == 0) &#123;</span><br><span class="line">	            background.draw(canvas);</span><br><span class="line">	        &#125; else &#123;</span><br><span class="line">	            canvas.translate(scrollX, scrollY);</span><br><span class="line">	            background.draw(canvas);</span><br><span class="line">	            canvas.translate(-scrollX, -scrollY);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	final int viewFlags = mViewFlags;</span><br><span class="line">	boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class="line">	boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class="line">	if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">	    // Step 3, draw the content</span><br><span class="line">	    if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line">	    // Step 4, draw the children</span><br><span class="line">	    dispatchDraw(canvas);</span><br><span class="line">	    // Step 6, draw decorations (scrollbars)</span><br><span class="line">	    onDrawScrollBars(canvas);</span><br><span class="line">	    // we&apos;re done...</span><br><span class="line">	    return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>调用视图的setVisibility()、setEnabled()、setSelected()等方法时都会导致视图重绘，而如果我们想要手动地强制让视图进行重绘，可以调用invalidate()方法来实现。当然了，setVisibility()、setEnabled()、setSelected()等方法的内部其实也是通过调用invalidate()方法来实现的。</p>
<p>invalidate()方法中，当ViewParent不等于空的时候就会一直循环下去。在这个while循环当中会不断地获取当前布局的父布局，并调用它的invalidateChildInParent()方法，<strong>在ViewGroup的invalidateChildInParent()方法中主要是来计算需要重绘的矩形区域</strong>，当循环到最外层的根布局后，就会调用ViewRoot的invalidateChildInParent()方法了, 最终会调用到performTraversals()方法。<br>invalidate()方法虽然最终会调用到performTraversals()方法中，但这时measure和layout流程是不会重新执行的，因为视图没有强制重新测量的标志位，而且大小也没有发生过变化，所以这时只有draw流程可以得到执行。而如果你希望视图的绘制流程可以完完整整地重新走一遍，就不能使用invalidate()方法，而应该调用requestLayout()了。</p>
<p>参考：<a href="https://blog.csdn.net/guolin_blog/article/details/17045157" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/17045157</a></p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>Android中触摸事件传递过程中最重要的是dispatchTouchEvent()、onInterceptTouchEvent()和onTouchEvent()方法。这里记录一下他们的处理过程，以供记忆：<br>1.dispatchTouchEvent是处理触摸事件分发,事件(多数情况)是从Activity的dispatchTouchEvent开始的。执行super.dispatchTouchEvent(ev)，事件向下分发。dispatchTouchEvent()返回true，后续事件（ACTION_MOVE、ACTION_UP）会再传递，如果返回false，dispatchTouchEvent()就接收不到ACTION_UP、ACTION_MOVE。<br>2.onInterceptTouchEvent是ViewGroup提供的方法，默认返回false，返回true表示拦截。<br>3.onTouchEvent是View中提供的方法，ViewGroup也有这个方法，view中不提供onInterceptTouchEvent。view中默认返回true，表示消费了这个事件。</p>
<p>事件传递流程如下：<br>1.ACTION_DOWN首先会传递到onInterceptTouchEvent()方法<br>2.如果该ViewGroup的onInterceptTouchEvent()在接收到down事件处理完成之后return false，那么后续的move, up等事件将继续会先传递给该ViewGroup，之后才和down事件一样传递给最终的目标view的onTouchEvent()处理。<br>3.如果该ViewGroup的onInterceptTouchEvent()在接收到down事件处理完成之后return true，那么后续的move, up等事件将不再传递给onInterceptTouchEvent()，而是和down事件一样传递给该ViewGroup的onTouchEvent()处理，注意，目标view将接收不到任何事件。<br>4.如果最终需要处理事件的view的onTouchEvent()返回了false，那么该事件将被传递至其上一层次的view的onTouchEvent()处理。<br>5.如果最终需要处理事件的view的onTouchEvent()返回了true，那么后续事件将可以继续传递给该view的onTouchEvent()处理。</p>
<p><img src="/2019/08/12/android-note/view-touchevent.jpg" alt><br>当触摸事件ACTION_DOWN发生之后，先调用Activity中的dispatchTouchEvent函数进行处理，紧接着ACTION_DOWN事件传递给ViewGroup中的dispatchTouchEvent函数，接着viewGroup中的dispatchTouchEvent中的ACTION_DOWN事件传递到调用ViewGroup中的onInterceptTouchEvent函数，此函数负责拦截ACTION_DOWN事件。由于viewGroup下还包含子View，所以默认返回值为false，即不拦截此ACTION_DOWN事件。如果返回false，则ACTION_DOWN事件继续传递给其子view。由于子view不是viewGroup的控件，所以ACTION_DOWN事件接着传递到onTouchEvent进行处理事件。此时消息的传递基本上结束。从上可以分析，motionEvent事件的传递是采用隧道方式传递。隧道方式，即从根元素依次往下传递直到最内层子元素或在中间某一元素中由于某一条件停止传递。</p>
<p>参考：<a href="https://blog.csdn.net/qiushuiqifei/article/details/9918527" target="_blank" rel="noopener">https://blog.csdn.net/qiushuiqifei/article/details/9918527</a></p>
<h2 id="Android属性动画优化"><a href="#Android属性动画优化" class="headerlink" title="Android属性动画优化"></a>Android属性动画优化</h2><p>android的三种动画：</p>
<ul>
<li>View Animation（视图动画，平移、缩放、透明等）</li>
<li>Drawable Animation（帧动画）</li>
<li>Property Animation（属性动画）</li>
</ul>
<p>现在项目的动画问题最主要出在动画部分临时变量多，GC触发频繁，内存泄漏。属性动画优化思路：</p>
<ol>
<li>硬件加速<br>在开始动画时调用View.setLayerType(View.LAYER_TYPE_HARDWARE, null)<br>运行动画<br>动画结束时调用View.setLayerType(View.LAYER_TYPE_NONE, null).</li>
<li>减少临时变量,使用PropertyValuesHolder(可以用在多属性动画同时工作管理) ,一个view同时发生多种属性效果时，建议这种写法。</li>
<li>使用Keyframe<br>Keyframe是PropertyValuesHolder的成员，用来管理每一个关键帧的出现时间。一个view的单个属性先后发生一系列变化时，建议使用Keyframe达到效果。<br>总的来说就是：ObjectAnimator把属性值的更新委托给PropertyValuesHolder执行，PropertyValuesHolder再把关键帧的时序性计算委托给Keyframe。<br>最后，不同的view再用不同的ObjectAnimator管理。</li>
<li>内存泄漏: animator.setRepeatCount(ValueAnimator.INFINITE)及时cancel（）</li>
<li>动画卡顿，可以考虑使用自定义控件实现，如果一个自定义不行，那就是两个</li>
</ol>
<h2 id="ART和Dalvik"><a href="#ART和Dalvik" class="headerlink" title="ART和Dalvik"></a>ART和Dalvik</h2><p>Android4.4版本以前是Dalvik虚拟机，4.4版本开始引入ART虚拟机（Android Runtime）。在4.4版本上，两种运行时环境共存，可以相互切换，但是在5.0版本以后，Dalvik虚拟机则被彻底的丢弃，全部采用ART。</p>
<h3 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h3><p>ART 是一种执行效率更高且更省电的运行机制，执行的是本地机器码，这些本地机器码是从dex字节码转换而来。<strong>ART采用的是AOT（Ahead-Of-Time）编译</strong>，应用在第一次安装的时候，字节码就会预先编译成机器码存储在本地。在App运行时，ART模式就较Dalvik模式少了解释字节码的过程，所以App的运行效率会有所提高，占用内存也会相应减少。</p>
<h3 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h3><p>Dalvik 虚拟机采用的是JIT（Just-In-Time）编译模式，意思为即时编译，我们知道apk被安装到手机中时，对应目录会有dex或odex和apk文件，apk文件存储的是资源文件，而dex或odex（经过优化后的dex文件内部存储class文件）内部存储class文件，每次运行app时虚拟机会将dex文件解释翻译成机器码，这样才算是本地可执行代码，之后被系统运行。</p>
<p>Dalvik虚拟机可以看做是一个Java VM，他负责解释dex文件为机器码，如果我们不做处理的话，每次执行代码，都需要Dalvik将dex代码翻译为微处理器指令，然后交给系统处理，这样效率不高。为了解决这个问题，<strong>Google在2.2版本添加了JIT编译器，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。</strong>JIT代表运行时编译策略，也可以理解成一种运行时编译器，是为了加快Dalvik虚拟机解释dex速度提出的一种技术方案，来缓存频繁使用的本地机器码。</p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p><strong>Dalvik每次都要编译再运行，Art只会安装时启动编译</strong><br>Art占用空间比Dalvik大（原生代码占用的存储空间更大），就是用<strong>“空间换时间”</strong><br>Art减少编译，减少了CPU使用频率，使用明显改善电池续航<br>Art应用启动更快、运行更快、体验更流畅、触感反馈更及时</p>
<h2 id="UncaughtExceptionHandler"><a href="#UncaughtExceptionHandler" class="headerlink" title="UncaughtExceptionHandler"></a>UncaughtExceptionHandler</h2><p>如果给一个线程设置了UncaughtExceptionHandler 这个接口：<br>1、这个线程中，所有未处理或者说未捕获的异常都将会由这个接口处理，也就说被这个接口给try…catch了。<br>2、在这个线程中抛出异常时，java虚拟机将会忽略，也就是说，java虚拟机不会让程序崩溃了。<br>3、如果没有设置，那么最终会调用getDefaultUncaughtExceptionHandler 获取默认的UncaughtExceptionHandler 来处理异常。</p>
<h2 id="aar"><a href="#aar" class="headerlink" title="@aar"></a>@aar</h2><p>@aar的方式关闭传递依赖</p>
<pre><code>// 只下载该库，其他所依赖的所有库不下载
compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1@aar&apos;
// 在使用@aar的前提下还能下载其他依赖库，则需要添加transitive=true的条件
compile (&quot;io.reactivex.rxjava2:rxandroid::2.0.1@aar&quot;) {
    transitive=true
}
</code></pre><h2 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h2><p>Groovy语言=<strong>Java语言的扩展+众多脚本语言的语法。运行在JVM虚拟机上。Gradle项目构框架使用groovy语言实现。</strong> 基于Gradle框架为我们实现了一些项目构件框架。</p>
<p>Groovy是一门jvm语言，它最终是要编译成class文件然后在jvm上执行，所以<strong>Java语言的特性Groovy都支持，我们完全可以混写Java和Groovy。</strong></p>
<p>在Groovy中，数据类型有：<br>1) Java中的基本数据类型<br>2) Java中的对象<br>3) Closure（闭包）<br>4) 加强的List、Map等集合类型<br>5) 加强的File、Stream等IO类型</p>
<p>类型可以显示声明，也可以用 def 来声明，用 def 声明的类型Groovy将会进行类型推断。</p>
<h2 id="gradle插件"><a href="#gradle插件" class="headerlink" title="gradle插件"></a>gradle插件</h2><p>插件会扩展项目的功能，帮助我们在项目的构建的过程中做很多事情：</p>
<ul>
<li>可以添加任务到项目中，帮助完成诸如 测试、编译、打包等事情。</li>
<li>可以添加依赖配置到项目中，通过它们来配置我们在构建过程中的依赖。</li>
<li>可以向项目中现有的对象类型添加新的扩展属性、方法等，可以使用它们来配置优化构建。例如：android{}这个配置块就是Android Gradle插件为Project对象添加的一个扩展。</li>
<li>可以对项目进行一些约定，比如应用Java插件后，可以约定src/main/java目录下是我们的源代码的存放地址，在编译的时候也是编译这个目录下的Java源代码文件。</li>
</ul>
<p>这就是插件，我们只需要按照它约定的方式，使用它提供的任务、方法或者扩展，就可以对我们的项目进行构建。</p>
<p>因为是基于groovy开发，所有代码文件要以.groovy结尾</p>
<p>1.定义插件入口： implements Plugin<project></project></p>
<p>2.XXXTask必须要继承DefautTask,并使用@TaskAction来定义Task的入口函数。</p>
<p>3.gradle配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//bulid.gradle</span><br><span class="line">buildscript &#123;</span><br><span class="line">    </span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &apos;file:///Users/xinyu/work/maven-lib/&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.1.2&apos;</span><br><span class="line">        classpath &apos;com.zxy.plugin:plugin:1.0.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//plugin gradle</span><br><span class="line">apply plugin: &apos;groovy&apos;</span><br><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    // gradle sdk</span><br><span class="line">    compile gradleApi()</span><br><span class="line">    // groovy sdk</span><br><span class="line">    compile localGroovy()</span><br><span class="line">    // 可以引用其它库</span><br><span class="line">    compile fileTree(dir: &apos;libs&apos;2 include: [&apos;*.jar&apos;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            //本地的Maven地址</span><br><span class="line">            repository(url: &apos;file:///Users/xinyu/work/maven-lib/&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group=&apos;com.zxy.plugin&apos;</span><br><span class="line">version=&apos;1.0.0&apos;</span><br></pre></td></tr></table></figure></p>
<p>参考资料：<a href="https://www.jianshu.com/p/eda0bfd692e6" target="_blank" rel="noopener">https://www.jianshu.com/p/eda0bfd692e6</a></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect Oriented Programming 面向切面编程）则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</p>
<p><strong>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。能将同一个关注点聚焦到同一个方法中解决。</strong></p>
<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><p>由于AndroidStudio默认是没有ajc编译器的，所以在Android中使用@AspectJ来编写（包括SpringAOP也是如此）。它在代码的编译期间扫描目标程序，根据切点（PointCut）匹配,将开发者编写的Aspect程序编织（Weave）到目标程序的.class文件中，对目标程序作了重构（重构单位是JoinPoint），目的就是建立目标程序与Aspect程序的连接（获得执行的对象、方法、参数等上下文信息），从而达到AOP的目的。</p>
<p>AspectJ是通过对目标工程的.class文件进行代码注入的方式将通知(Advise)插入到目标代码中：<br>第一步：根据pointCut切点规则匹配的joinPoint；<br>第二步：将Advise插入到目标JoinPoint中。<br>这样在程序运行时被重构的连接点将会回调Advise方法，就实现了AspectJ代码与目标代码之间的连接。<br><img src="/2019/08/12/android-note/aspectj.png" alt></p>
<h3 id="Gradle-Transform"><a href="#Gradle-Transform" class="headerlink" title="Gradle Transform"></a>Gradle Transform</h3><p>Gradle Transform是Android官方提供给开发者在项目构建阶段即由class到dex转换期间修改class文件的一套api。目前比较经典的应用是字节码插桩、代码注入技术。Gradle Transform更多的是提供一种可以让开发者参与项目构建的机制，而诸如修改字节码等更加具体的细节则需要开发者去实现。</p>
<h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>代理Hook:如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。</p>
<p>hook，又叫钩子，通常是指对一些方法进行拦截。这样当这些方法被调用时，也能够执行我们自己的代码，这也是面向切面编程的思想（AOP）。</p>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>大致思路：<br>1.找到需要Hook方法的系统类<br>2.利用代理模式来代理系统类的运行拦截我们需要拦截的方法<br>3.使用反射的方法把这个系统类替换成你的代理类</p>
<p>案例可参考：<br><a href="https://blog.csdn.net/yulong0809/article/details/56842027" target="_blank" rel="noopener">https://blog.csdn.net/yulong0809/article/details/56842027</a></p>
<h2 id="应用的启动过程"><a href="#应用的启动过程" class="headerlink" title="应用的启动过程"></a>应用的启动过程</h2><p>1.首先我们要启动的Activity会去ActivityManagerService中去校检是否合法</p>
<p>2.通过回调ActivityThread中内部类ApplicationThread的scheduleLaunchActivity去发送一个消息到ActivityThread中的内部类H中，H继承于Handler</p>
<p>3.然后会通过反射创建Activity对象及Application对象，并回调响应生命周期方法</p>
<p>这里说一点ActivityManagerService和我们应用间沟通几乎都是ActivityThread，ApplicationThread，H这几个类之间来回调用，而且不只是Activity，我们Android的四大组件几乎都用了这种模式</p>
<p>参考：<br><a href="https://blog.csdn.net/yulong0809/article/details/58589715" target="_blank" rel="noopener">https://blog.csdn.net/yulong0809/article/details/58589715</a></p>
<h2 id="Watchdog"><a href="#Watchdog" class="headerlink" title="Watchdog"></a>Watchdog</h2><p>能通过关闭FinalizerWatchdogDaemon来减少TimeoutException的触发。需要注意的是，此种方法并不是去解决问题，而是为了避免上报异常采取的一种 hack 方案，并没有真正的解决引起 finialize() 超时的问题。</p>
<pre><code>// Android P 以后不能反射FinalizerWatchdogDaemon
if (Build.VERSION.SDK_INT &gt;= 28) {
    Log.w(TAG, &quot;stopWatchDog, do not support after Android P, just return&quot;);
    return;
}

try {
    final Class clazz = Class.forName(&quot;java.lang.Daemons$FinalizerWatchdogDaemon&quot;);
    final Field field = clazz.getDeclaredField(&quot;INSTANCE&quot;);
    field.setAccessible(true);
    final Object watchdog = field.get(null);
    try {
        final Field thread = clazz.getSuperclass().getDeclaredField(&quot;thread&quot;);
        thread.setAccessible(true);
        thread.set(watchdog, null);
    } catch (final Throwable t) {
        Log.e(TAG, &quot;stopWatchDog, set null occur error:&quot; + t);

        t.printStackTrace();
        try {
            // 直接调用stop方法，在Android 6.0之前会有线程安全问题
            final Method method = clazz.getSuperclass().getDeclaredMethod(&quot;stop&quot;);
            method.setAccessible(true);
            method.invoke(watchdog);
        } catch (final Throwable e) {
            Log.e(TAG, &quot;stopWatchDog, stop occur error:&quot; + t);
            t.printStackTrace();
        }
    }
} catch (final Throwable t) {
    Log.e(TAG, &quot;stopWatchDog, get object occur error:&quot; + t);
    t.printStackTrace();
}
</code></pre><h2 id="NFC"><a href="#NFC" class="headerlink" title="NFC"></a>NFC</h2><p>Near Field Communication (NFC) 为<strong>一短距离无线通信技术，通常有效通讯距离为4厘米以内。NFC工作频率为13.65 兆赫兹，通信速率为106 kbit/秒到 848kbit/秒</strong>。</p>
<p>NFC支持如下3种工作模式：<br>读卡器模式（Reader/writer mode）、<br>仿真卡模式(Card Emulation Mode)、<br>点对点模式（P2P mode）。</p>
<p>Android SDK API主要支持NFC论坛标准（Forum Standard），这种标准被称为NDEF（NFC Data Exchange Format，NFC数据交换格式），类似传感器。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池使用的好处：<br>1：对多个线程进行统一地管理，避免资源竞争中出现的问题。<br>2：（重点）：对线程进行复用，线程在执行完任务后不会立刻销毁，而会等待另外的任务，这样就不会频繁地创建、销毁线程和调用GC。<br>3：JAVA提供了一套完整的ExecutorService线程池创建的api，可创建多种功能不一的线程池，使用起来很方便。</p>
<p>创建线程池，主要是利用ThreadPoolExecutor这个类，而这个类有几种构造方法，其中参数最多的一种构造方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                             int maximumPoolSize,</span><br><span class="line">                             long keepAliveTime,</span><br><span class="line">                             TimeUnit unit,</span><br><span class="line">                             BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                             ThreadFactory threadFactory) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>corePoolSize: 该线程池中核心线程的数量。<br>maximumPoolSize：该线程池中最大线程数量。(区别于corePoolSize)<br>keepAliveTime:从字面上就可以理解，是非核心线程空闲时要等待下一个任务到来的时间，当任务很多，每个任务执行时间很短的情况下调大该值有助于提高线程利用率。注意：当allowCoreThreadTimeOut属性设为true时，该属性也可用于核心线程。<br>unit:上面时间属性的单位<br>workQueue:任务队列<br>threadFactory:线程工厂，可用于设置线程名字等等，一般无须设置该参数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Shuming Zhao">
            
              <p class="site-author-name" itemprop="name">Shuming Zhao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuming Zhao</span>

  
</div>

<div class="powered-by"><i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人，
<span id="busuanzi_container_site_pv">访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
</span>
</div>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
