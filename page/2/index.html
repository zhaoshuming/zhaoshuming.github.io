<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="1ilOhMWnNE">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/10/android-dex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/10/android-dex/" itemprop="url">类加载器ClassLoader及Dex/Class</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-10T14:41:50+08:00">
                2019-05-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>顾名思义，类加载器用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例，每个这样的实例用来表示一个 Java 类，通过此实例的 newInstance()方法就可以创建出该类的一个对象。</p>
<p>类加载器是 Java 语言的一个创新。<strong>它使得动态安装和更新软件组件成为可能</strong>。</p>
<p><strong>Java 虚拟机是如何判定两个Java类是相同的：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样</strong>。只有两者都相同的情况，才认为两个类是相同的。</p>
<h4 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h4><p>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。</p>
<p>代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。</p>
<p><strong>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</strong></p>
<p>ClassLoader特点：<strong>遵循双亲委派模型</strong></p>
<blockquote>
<p>ClassLoader在加载一个class文件时：会询问当前ClassLoader是否已经加载过此类，如果已经加载过则直接返回，不再重复加载。如果没有加载过，会去查询当前ClassLoader的parent是否已经加载过。</p>
</blockquote>
<p>因为遵循双亲委派模型，Android中的classLoader具有两个特点：</p>
<ul>
<li>类加载共享<br>当一个class文件被任何一个ClassLoader加载过，就不会再被其他ClassLoader加载。</li>
<li>类加载隔离<br>不同ClassLoader加载的class文件肯定不是一个。举个栗子，一些系统层级的class文件在系统初始化的时候被加载，比如java.net.String，这个是在应用启动前就被系统加载好的。如果在一个应用里能简单地用一个自定义的String类把这个String类替换掉的话，将有严重的安全问题。</li>
</ul>
<h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。</p>
<h4 id="类加载器与-OSGi"><a href="#类加载器与-OSGi" class="headerlink" title="类加载器与 OSGi"></a>类加载器与 OSGi</h4><p>OSGi™是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse 就是基于 OSGi 技术来构建的。</p>
<p>OSGi 中的每个模块（bundle）都包含 Java 包和类。模块可以声明它所依赖的需要导入（import）的其它模块的 Java 包和类（通过 Import-Package），也可以声明导出（export）自己的包和类，供其它模块使用（通过 Export-Package）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。<strong>OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。</strong>模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性 org.osgi.framework.bootdelegation的值即可。</p>
<p>OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。下面提供几条比较好的建议：</p>
<ul>
<li>如果一个类库只有一个模块使用，把该类库的 jar 包放在模块中，在 Bundle-ClassPath中指明即可。</li>
<li>如果一个类库被多个模块共用，可以为这个类库单独的创建一个模块，把其它模块需要用到的 Java 包声明为导出的。其它模块声明导入这些类。</li>
<li>如果类库提供了 SPI 接口，并且利用线程上下文类加载器来加载 SPI 实现的 Java 类，有可能会找不到 Java 类。如果出现了 NoClassDefFoundError异常，首先检查当前线程的上下文类加载器是否正确。通过 Thread.currentThread().getContextClassLoader()就可以得到该类加载器。该类加载器应该是该模块对应的类加载器。如果不是的话，可以首先通过 class.getClassLoader()来得到模块对应的类加载器，再通过 Thread.currentThread().setContextClassLoader()来设置当前线程的上下文类加载器。</li>
</ul>
<h4 id="ClassLoader种类"><a href="#ClassLoader种类" class="headerlink" title="ClassLoader种类"></a>ClassLoader种类</h4><ul>
<li>BootClassLoader（Java的BootStrap ClassLoader）<br>用于加载Android Framework层class文件。</li>
<li>PathClassLoader（Java的App ClassLoader）<br>用于加载已经安装到系统中的apk中的class文件（要传入系统中apk的存放Path，所以只能加载已经安装的apk文件）。</li>
<li>DexClassLoader（Java的Custom ClassLoader）<br>用于加载指定目录中的class文件(可以加载jar/apk/dex，可以从SD卡中加载未安装的apk)。</li>
<li>BaseDexClassLoader<br>是PathClassLoader和DexClassLoader的父类。<br><img src="/2019/05/10/android-dex/class_loader.png" alt></li>
</ul>
<h4 id="PathClassLoader加载已安装的apk插件"><a href="#PathClassLoader加载已安装的apk插件" class="headerlink" title="PathClassLoader加载已安装的apk插件"></a>PathClassLoader加载已安装的apk插件</h4><p>使用PathClassLoader加载已安装的apk插件。sharedUserId要一致，简单的说，应用从一开始安装在Android系统上时，系统都会给它分配一个linux user id，之<br>后该应用在今后都将运行在独立的一个进程中，其它应用程序不能访问它的资源，那么如果两个应用的sharedUserId相同，那么它们将共同运行在相同的linux进程中，从而便可以数据共享、资源访问了。所以我们在宿主app和插件app的manifest上都定义一个相同的sharedUserId。</p>
<p>下面看一个样例：加载包名为packageName的插件，然后获得插件内名为one.png的图片的资源id，进而供宿主app使用该图片</p>
<pre><code>/**
 * 加载已安装的apk
 * @param packageName 应用的包名
 * @param pluginContext 插件app的上下文
 * @return 对应资源的id
 */
private int dynamicLoadApk(String packageName, Context pluginContext) throws Exception {
    //第一个参数为包含dex的apk或者jar的路径，第二个参数为父加载器
    PathClassLoader pathClassLoader = new PathClassLoader(pluginContext.getPackageResourcePath(),ClassLoader.getSystemClassLoader());
    //Class&lt;?&gt; clazz = pathClassLoader.loadClass(packageName + &quot;.R$mipmap&quot;);//通过使用自身的加载器反射出mipmap类进而使用该类的功能
    //参数：1、类的全名，2、是否初始化类，3、加载时使用的类加载器
    Class&lt;?&gt; clazz = Class.forName(packageName + &quot;.R$mipmap&quot;, true, pathClassLoader);
    //使用上述两种方式都可以，这里我们得到R类中的内部类mipmap，通过它得到对应的图片id，进而给我们使用
    Field field = clazz.getDeclaredField(&quot;one&quot;);
    int resourceId = field.getInt(R.mipmap.class);
    return resourceId;
}
</code></pre><ul>
<li>首先就是new出一个PathClassLoader对象，它的构造方法为：public PathClassLoader(String dexPath, ClassLoader parent)。其中第一个参数是通过插件的上下文来获取插件apk的路径，其实获取到的就是/data/app/apkthemeplugin.apk，那么插件的上下文怎么获取呢？在宿主app中我们只有本app的上下文啊，答案就是为插件app创建一个上下文：Context plugnContext = this.createPackageContext(packageName, CONTEXT_IGNORE_SECURITY | CONTEXT_INCLUDE_CODE。<strong> 通过插件的包名来创建上下文，不过这种方法只适合获取已安装的app上下文</strong>。或者不需要通过反射直接通过插件上下文getResource().getxxx(R.<em>.</em>);也行，而这里用的是反射方法。第二个参数是父加载器，都是ClassLoader.getSystemClassLoader()。</li>
</ul>
<h4 id="DexClassLoader加载已安装的apk插件"><a href="#DexClassLoader加载已安装的apk插件" class="headerlink" title="DexClassLoader加载已安装的apk插件"></a>DexClassLoader加载已安装的apk插件</h4><p>关于动态加载未安装的apk，先描述下思路：首先我们得到事先知道我们的插件apk存放在哪个目录下，然后分别得到插件apk的信息（名称、包名等），然后显示可用的插件，最后动态加载apk获得资源。</p>
<p>按照上面这个思路，我们需要解决几个问题：<br>1、怎么得到未安装的apk的信息<br>2、怎么得到插件的context或者Resource，因为它是未安装的不可能通过createPackageContext(…);方法来构建出一个context，所以这时只有在Resource上下功夫。</p>
<p>现在我们就一一来解答这些问题吧：<br>1、得到未安装的apk信息可以通过mPackageManager.getPackageArchiveInfo()方法获得</p>
<pre><code>/**
 * 获取未安装apk的信息
 * @param context
 * @param archiveFilePath apk文件的path
 * @return
 */
private String[] getUninstallApkInfo(Context context, String archiveFilePath) {
    String[] info = new String[2];
    PackageManager pm = context.getPackageManager();
    PackageInfo pkgInfo = pm.getPackageArchiveInfo(archiveFilePath, PackageManager.GET_ACTIVITIES);
    if (pkgInfo != null) {
        ApplicationInfo appInfo = pkgInfo.applicationInfo;
        String versionName = pkgInfo.versionName;//版本号
        Drawable icon = pm.getApplicationIcon(appInfo);//图标
        String appName = pm.getApplicationLabel(appInfo).toString();//app名称
        String pkgName = appInfo.packageName;//包名
        info[0] = appName;
        info[1] = pkgName;
    }
    return info;
}
</code></pre><p>2、得到对应未安装apk的Resource对象，我们需要通过反射来获得：</p>
<pre><code>/**
 * @param apkName 
 * @return 得到对应插件的Resource对象
 */
private Resources getPluginResources(String apkName) {
    try {
        AssetManager assetManager = AssetManager.class.newInstance();
        Method addAssetPath = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class);//反射调用方法addAssetPath(String path)
        //第二个参数是apk的路径：Environment.getExternalStorageDirectory().getPath()+File.separator+&quot;plugin&quot;+File.separator+&quot;apkplugin.apk&quot;
        addAssetPath.invoke(assetManager, apkDir+File.separator+apkName);//将未安装的Apk文件的添加进AssetManager中，第二个参数为apk文件的路径带apk名
        Resources superRes = this.getResources();
        Resources mResources = new Resources(assetManager, superRes.getDisplayMetrics(),
                superRes.getConfiguration());
        return mResources;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
</code></pre><p>通过得到AssetManager中的内部的方法addAssetPath，将未安装的apk路径传入从而添加进assetManager中，然后通过new Resource把assetManager传入构造方法中，进而得到未安装apk对应的Resource对象。</p>
<p>3、接下来就是加载未安装的apk获得它的内部资源</p>
<pre><code>/**
 * 加载apk获得内部资源
 * @param apkDir apk目录
 * @param apkName apk名字,带.apk
 * @throws Exception
 */
private void dynamicLoadApk(String apkDir, String apkName, String apkPackageName) throws Exception {
    File optimizedDirectoryFile = getDir(&quot;dex&quot;, Context.MODE_PRIVATE);//在应用安装目录下创建一个名为app_dex文件夹目录,如果已经存在则不创建
    Log.v(&quot;zxy&quot;, optimizedDirectoryFile.getPath().toString());// /data/data/com.example.dynamicloadapk/app_dex
    //参数：1、包含dex的apk文件或jar文件的路径，2、apk、jar解压缩生成dex存储的目录，3、本地library库目录，一般为null，4、父ClassLoader
    DexClassLoader dexClassLoader = new DexClassLoader(apkDir+File.separator+apkName, optimizedDirectoryFile.getPath(), null, ClassLoader.getSystemClassLoader());
    Class&lt;?&gt; clazz = dexClassLoader.loadClass(apkPackageName + &quot;.R$mipmap&quot;);//通过使用apk自己的类加载器，反射出R类中相应的内部类进而获取我们需要的资源id
    Field field = clazz.getDeclaredField(&quot;one&quot;);//得到名为one的这张图片字段
    int resId = field.getInt(R.id.class);//得到图片id
    Resources mResources = getPluginResources(apkName);//得到插件apk中的Resource
    if (mResources != null) {
        //通过插件apk中的Resource得到resId对应的资源
        findViewById(R.id.background).setBackgroundDrawable(mResources.getDrawable(resId));
    }
}
</code></pre><p>其中通过new DexClassLoader()来创建未安装apk的类加载器，我们来看看它的参数：</p>
<pre><code>public class DexClassLoader extends BaseDexClassLoader {
    public DexClassLoader(String dexPath, String optimizedDirectory,
            String libraryPath, ClassLoader parent) {
        super(dexPath, new File(optimizedDirectory), libraryPath, parent);
    }
}
</code></pre><p>可以看到DexClassLoader的源码非常简单，只有一个构造方法。我们来看下其四个参数都是什么含义：</p>
<ul>
<li>dexPath：要加载的dex文件路径。</li>
<li>optimizedDirectory：dex文件要被copy到的目录路径。此位置一定要是可读写且仅该应用可读写（安全性考虑），所以只能放在data/data下。看官方文档：<br>This class loader requires an application-private, writable directory to cache optimized classes. Use Context.getDir(String, int) to create such a directory: File dexOutputDir = context.getDir(“dex”, 0);</li>
<li>libraryPath：apk文件中类要使用的c/c++代码，指向包含本地库(so)的文件夹路径，可以设为null。</li>
<li>parent：父装载器，也就是真正loadclass的装载器，一般可以通过Context.getClassLoader获取到，也可以通过ClassLoader.getSystemClassLoader()取到。<br>在Android中加载class，其实最终是通过DexPathList的findClass来加载的。</li>
</ul>
<h3 id="Dex文件"><a href="#Dex文件" class="headerlink" title="Dex文件"></a>Dex文件</h3><p>定义：能够被DVM或者Art虚拟机执行并且加载的文件格式。</p>
<p>作用：<strong>dex文件的作用是记录整个工程（通常是一个Android工程）的所有类文件的信息</strong>。</p>
<p>Android支持动态加载的两种方式是：DexClassLoader和PathClassLoader。DexClassLoader可加载jar/apk/dex，且支持从SD卡加载；PathClassLoader据说只能加载已经安装在Android系统内APK文件,以下这一段是摘录：PathClassLoader 的限制要更多一些，它只能加载已经安装到 Android 系统中的 apk 文件，也就是 /data/app 目录下的 apk 文件。其它位置的文件加载的时候都会出现 ClassNotFoundException。</p>
<p>dex文件的生成：</p>
<pre><code>先生成class文件（注意执行低版本的JDK版本，否则手机无法运行），然后执行：
dx --dex --output Test.dex Test.class
然后把生成的dex文件拷贝到手机：
adb push C:\Users\Administrator\Desktop\Test.dex /storage/emulated/0
adb shell
dalvikvm -cp /sdcard/Test.dex Test
</code></pre><p>dex文件的结构：</p>
<pre><code>8位字节的二进制流文件
各个数据紧密排列，无间隙，减少了文件体积，加快加载速度
整个工程的类信息都存放在一个dex文件中（不考虑dex分包的情况下）
</code></pre><p><img src="/2019/05/10/android-dex/dex.webp" alt><br>注意：<br>文件头包含了dex文件的信息，所有数据的大致分布情况<br>链接数据区：主要是指so库</p>
<h4 id="Dex文件头格式"><a href="#Dex文件头格式" class="headerlink" title="Dex文件头格式"></a>Dex文件头格式</h4><p><img src="/2019/05/10/android-dex/dex_data.png" alt title="数据格式"><br><img src="/2019/05/10/android-dex/dex_data_des.png" alt><br>上图和上表就是dex的文件头的结构和各个位置的意思。其中最开始的64 65 78 0A 30 33 3500（dex.035.）表示这是按照dex解析的。</p>
<h3 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h3><p>定义：能够被JVM识别，加载并执行的文件格式。</p>
<p>作用：记录一个类文件的所有信息，记住所有。例如记住了当前类的引用this、父类super等等。class文件记录的信息往往比java文件多。</p>
<p>class文件的结构:</p>
<pre><code>8位字节的二进制流文件
各个数据紧密排列，无间隙，减少了文件体积，加快加载速度
每个类或者接口单独占据一个class文件，每个类单独管理，没有交叉
</code></pre><p>class文件中的字段如下所示：</p>
<pre><code>magic 加密字段，虚拟机判断当前的class文件是否被篡改过
minor_version 支持最低版本的jdk
major_version 编译使用的jdk版本
constant_pool_count 常量池的数量，一般为一个
cp_info constant_pool 常量池的结构体，数量不定（类型是cp_info结构体）
access_flags 访问级别，例如public等
this_class 当前类
super_class 父类
interfaces_count 类实现接口的数量
fields_count 类成员变量的数量
methods_count 类方法的数量
method_info methods 类方法的结构体
attributes_count 类属性的数量
attribute_info attributes 类属性的结构体
</code></pre><p>constant_pool包括：</p>
<pre><code>CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_String_info等等 
CONSTANT_Class_info：类的相关信息，包括当前类、引用到的类的信息 
CONSTANT_Fieldref_info：类的域信息 
CONSTANT_Methodref_info：类的方法信息
</code></pre><p>class文件的弊端：</p>
<pre><code>内存占用大，不适合移动端
堆栈的加栈模式，加载速度慢。
文件IO操作多，类加载慢。
</code></pre><h3 id="Class文件与Dex文件的比较"><a href="#Class文件与Dex文件的比较" class="headerlink" title="Class文件与Dex文件的比较"></a>Class文件与Dex文件的比较</h3><p>本质上都是一样的，都是二进制流文件格式，dex文件是从class文件演变而来的。<br><strong>class文件存在冗余信息，dex文件则去掉了冗余，并且整合了整个工程的类信息。</strong><br><img src="/2019/05/10/android-dex/dex_class.png" alt></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/" target="_blank" rel="noopener">深入探讨 Java 类加载器</a><br><a href="https://blog.csdn.net/u010687392/article/details/47121729?hmsr=toutiao.io" target="_blank" rel="noopener">插件化开发—动态加载技术加载已安装和未安装的apk</a><br><a href="https://blog.csdn.net/ll458524906/article/details/78303557" target="_blank" rel="noopener">Android_dex详解</a><br><a href="https://blog.csdn.net/colinandroid/article/details/80712045" target="_blank" rel="noopener">ClassLoader详解</a><br><a href="https://blog.csdn.net/developandroid/article/details/81780477" target="_blank" rel="noopener">class文件和dex文件</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/architecture-extensible/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/architecture-extensible/" itemprop="url">可扩展架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T09:42:14+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>可扩展架构的基本思想是：拆</p>
<p>不同的拆分方式，本质上决定了系统的可扩展性。常见的拆分思路有三种：</p>
<p>1）面向流程拆分：分层架构<br>分层架构的本质：固定的内核，移动的数据。<br>扩展时大部分情况只需要修改其一层，少部分情况可能修改关联的两层，不会出现所有层都同时要修改。<br>以简单的学生信息管理系统为例：展示层–&gt;业务层–&gt;数据层–&gt;存储层</p>
<p>2）面向服务拆分：SOA、微服务<br>服务是一组相似功能的集合。<br>对于某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可。<br>以简单的学生信息管理系统为例：将系统拆分为注册、登录、信息管理、安全设置等服务</p>
<p>3）面向功能拆分:微内核架构<br>以简单的学生信息管理系统为例：每个服务都可以拆分为更多细粒度的功能</p>
<p>当然，这几个系统架构并不是非彼既此的，而是可以组合使用。</p>
<h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>分层架构也叫N层架构，通常情况下，N至少是两层。</p>
<p>分层架构的本质在于<strong>隔离关注点</strong>（separation of concerns），即每个层中的组件只会处理本层的逻辑，核心就是需要<strong>保证各层之间的差异足够清晰，边界足够明显，</strong>让人看到架构图后就能看懂整个架构。</p>
<p>根据不同的划分维度和对象，可以得到多种不同的分层架构：<br>1）C/S、B/S架构<br>2）MVC、MVP架构<br>3）逻辑分层架构<br>逻辑分层架构中的层是自顶向下依赖的，如andoid操作系统的架构</p>
<h3 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h3><p>SOA(Service Oriented Architecture)提出来三个关键概念：</p>
<p>1）服务<br>所有业务功能都是一项服务，服务意味着要对外提供开发的能力，当其他系统需要使用这项功能时，无须定制化开发。</p>
<p>2）ESB(Enterprise Service Bus)<br>ESB是将企业中各个不同的服务连接到一起。SOA使用ESB来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。</p>
<p>3）松耦合<br>目的是减少各个服务间的依赖和相互影响。</p>
<p>SOA架构是集成的思想，是解决服务孤岛打通链条，是无奈之举。ESB集中化的管理带来了性能不佳、厚重等问题，也无法快速扩展。所以不适合互联网的业务特点。</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务是一种和SOA相似但本质上不同的架构理念。两者都关注于“服务”，都是通过服务的拆分来解决可扩展性问题。本质上不同在于几个核心理念的差异：是否有ESB、服务的粒度、架构设计的目标（<strong>small、lightweight、automated</strong>）等。</p>
<p>微服务架构其实相当复杂，可以分成几个阶段理解：<br>1）第一阶段，微服务架构就是去掉了ESB的SOA架构，只不过是通信的方式和结构变了。对于初级的使用者而言，这样理解没有太大问题。<br>2）第二阶段，没有了ESB，原本很多由ESB组件做的事儿，转到服务的提供者和调用者这里了。他们需要考虑服务的拆分粒。大体仍然算是SOA架构。<br>3）第三阶段，随着服务的数量大幅增加，服务的管理越来越困难，此时DevOps出现了。这个阶段的微服务架构，已经是跟SOA架构完全不同的东西了。<br>要逐步演进和迭代，不要过于激进，更不要拆分过细，拆分的粒度，要与团队的架构相互匹配。（康威定律）</p>
<p>SOA和微服务的区别：<br>1）服务粒度<br>2）服务通讯<br>微服务推荐使用统一的协议和格式。<br>3）服务交付<br>SOA更多的是考虑兼容已有的系统；微服务的架构理念要求“快速交付”，相应的要求自动化测试、持续集成、自动化部署等敏捷开发相关的最佳实践。<br>4）应用场景<br>SOA更适合庞大、复杂、异构的企业级系统，这也是SOA诞生的背景。<br>微服务更适合快速、轻量级、基于Web的物联网系统。</p>
<h4 id="微服务的陷阱及问题"><a href="#微服务的陷阱及问题" class="headerlink" title="微服务的陷阱及问题"></a>微服务的陷阱及问题</h4><p>1）服务划分过细，服务间关系复杂<br>2）服务数量太多，团队效率急剧下降<br>3）调用链太长，性能下降<br>4）调用链太长，问题定位困难<br>5）没有自动化支撑，无法快速交付<br>6）没有服务治理，数量多了之后管理混乱</p>
<h4 id="微服务架构实践"><a href="#微服务架构实践" class="headerlink" title="微服务架构实践"></a>微服务架构实践</h4><p>1.服务粒度<br>三个火枪手原则。亚马逊CEO Jeff Bezos有个一个经验法则：如果两个披萨对于一个团队来说不够，那么这个团队就太大了。</p>
<p>2.拆分方法<br>1）基于业务逻辑拆分</p>
<p>2）基于可扩展拆分：区分稳定服务、可变服务</p>
<p>3）基于可靠性拆分<br>好处：避免非核心业务故障影响核心业务；核心服务高可用方案可以更简单；能够降低高可用成本</p>
<p>4）基于性能拆分<br>将性能要求高或者性能压力大的模块拆分出来，避免性能压力大的服务影响其他服务。</p>
<p>以上方案可自由排列组合。</p>
<p>3.基础设施<br>1）服务发现、服务路由、服务容错：这是最基本的微服务基础设施</p>
<p>2）接口框架、API网关：主要是为了提升开发效率</p>
<p>3）自动化部署、自动化测试、配置中心：主要为了提升测试和运维效率</p>
<p>4）服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率</p>
<p>以上3、4会随着微服务节点数量增加而越来越重要，当节点较少时，可以通过人工支撑，虽然效率不高，但也基本能够顶得住。</p>
<h3 id="微内核架构"><a href="#微内核架构" class="headerlink" title="微内核架构"></a>微内核架构</h3><p>微内核架构也被称为插件化架构，是一种面向功能进行拆分的可扩展性架构。</p>
<p>微内核架构包含两类组件：核心系统和插件模块。核心模块负责和具体业务功能无关的通用功能，如模块加载、模块间通信等；插件模块负责实现具体的业务逻辑。</p>
<p>微内核的核心系统设计的关键技术有：插件管理、插件链接和插件通信。</p>
<p>常见架构有：OSGI、规则引擎架构、Atlas容器化框架等。</p>
<p>android架构模式参考：<br>1.<a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247488375&amp;idx=1&amp;sn=3af36be489393783a95d5c5e3fc73b65&amp;source=41#wechat_redirect" target="_blank" rel="noopener">Atlas：手淘Native容器化框架和思考</a><br>2.<a href="https://www.infoq.cn/article/wechat-android-app-architecture" target="_blank" rel="noopener">微信 Android 客户端架构演进之路</a></p>
<h3 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h3><p>微服务很多核心理念其实在半个世纪前的一篇文章中就被阐述过了，而且这篇文章中的很多论点在软件开发飞速发展的这半个世纪中竟然一再被验证，这就是康威定律（Conway’s Law）。</p>
<p>在康威的这篇文章中，最有名的一句话就是：</p>
<blockquote>
<p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations. - Melvin Conway(1967)</p>
</blockquote>
<p>中文直译大概的意思就是：<strong>设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。</strong></p>
<p>Mike从他的角度归纳这篇论文中的其他一些核心观点，如下：</p>
<ul>
<li>第一定律：企业沟通方式会通过系统设计表达出来——Communication dictates design</li>
<li>第二定律：再多的时间也没办法让任务完美至极，但总有时间能将它完成——There is never enough time to do something right, but there is always enough time to do it over</li>
<li>第三定律：线型系统和线型组织架构间有潜在的异质同态特性——There is a homomorphism from the linear graph of a system to the linear graph of its design organization</li>
<li>第四定律：大系统比小系统更适用于任务分解——The structures of large systems tend to disintegrate during development, qualitatively more so than with small systems</li>
</ul>
<h4 id="康威第一定律"><a href="#康威第一定律" class="headerlink" title="康威第一定律"></a>康威第一定律</h4><p>“人类是复杂的社会动物。”</p>
<p>《The Mythical Man-Month》 这本书里有一句令人难忘的话：在应用项目后期加大人员的投资，会更加拖慢它的速度。——Fred Brooks（1975）</p>
<p>沟通的问题会影响系统设计，进而影响整个系统的开发效率以及最终结果。</p>
<h4 id="康威第二定律"><a href="#康威第二定律" class="headerlink" title="康威第二定律"></a>康威第二定律</h4><p>罗马不是一天建成的，学会先解决首要问题。</p>
<p>敏捷开发巨头之一Erik Hollnagel 在他的书中阐述了类似的观点：</p>
<blockquote>
<p>问题太复杂？那么不妨忽略不必要的细节。<br>没有足够的资源？放弃无用的功能。<br>——Erik Hollnagel（2009）</p>
</blockquote>
<p>系统的复杂性、功能数量、市场竞争以及投资人的期望值都在增加，而人的智力是有上限的，没有企业能说一定能找到合适的人，对于一个极其复杂的系统，总会有考虑不周全的地方，Erik认为这个问题最好的解决办法就是：不去管它。</p>
<p>最佳解决方案不是消除所有问题，而是允许它们存在，在发生故障时实现自动恢复。<br>在由微服务组成的系统中，每个微服务都可能停止响应，这是完全正常的，只需要确保足够的冗余和备份，这就是弹性或高可用性设计。</p>
<h4 id="康威第三定律"><a href="#康威第三定律" class="headerlink" title="康威第三定律"></a>康威第三定律</h4><p>创建独立的子系统，减少沟通成本。</p>
<p>团队中微服务的理念应是Inter-Operate，而不是Integrate ，Inter-Operate是指定义系统边界和接口，并为整个团队提供完整的堆栈，实现完全的自制。如此就能降低系统间的依赖性，减少通信成本。</p>
<h4 id="康威第四定律"><a href="#康威第四定律" class="headerlink" title="康威第四定律"></a>康威第四定律</h4><p>前面提到，人类是复杂的社会动物，人与人之间的交流是非常复杂的，当涉及到一个系统时，人们经常选择增加人力去减少复杂性，对于企业来说，该如何处理这样的沟通问题？答案是：分而治之。</p>
<h4 id="康威定律与微服务"><a href="#康威定律与微服务" class="headerlink" title="康威定律与微服务"></a>康威定律与微服务</h4><p>再来看一下康威定律是如何在半个世纪前就奠定了微服务理论基础的。</p>
<ul>
<li>人与人之间的交流很复杂，每个人的精力是有限的，因此当问题很复杂，需要协调地去解决时，需要将组织划分进而提高沟通效率。</li>
<li>团队成员工作的系统设计依赖于成员之间的沟通，管理人员可以调整划分模式，实现团队之间的不同沟通方式，这也会影响系统的设计。</li>
<li>如果子系统有清晰的外部通信便捷，那么就可以有效地降低通信成本，响应地设计将更加适合和有效。</li>
<li>需要不断优化一个复杂的系统，并容错性和故障恢复率的帮助下进行优化，不要期望大而全面的设计或架构，因为它们的开发以迭代的方式发生。</li>
</ul>
<p>以下是一些具体的实践建议：</p>
<ul>
<li>利用一切手段提高通信效率，如Slack、Github和Wiki，且只与相关人员进行沟通，每个人和每个系统必须有明确的职责，在遇到问题时，知道该找谁去解决。</li>
<li>在MVP模式下设计一套系统，以迭代的方式优化及验证，并确保系统的弹性。</li>
<li>采用与系统设计相一致的团队，以扁平化和以业务为基准的方式去简化团队，每个小团队之间必须有对应负责的模块，避免模糊的界限，以免在发生问题时互相推卸责任。</li>
<li>要做小而美的团队，人员数量的增加会降低效率以及加大成本，亚马逊CEO Jeff Bezos有个一个经验法则：如果两个披萨对于一个团队来说不够，那么这个团队就太大了。一般来说，一家互联网公司的产品团队由7到8个人组成（包括前端和后端测试、交互和用户体验师，一些人可能身兼数职）。</li>
</ul>
<p>在查看以下微服务标准时，我们可以很容易地看到微服务与康威定律之间的密切关系：</p>
<ul>
<li>由分布式服务组成的系统</li>
<li>企业部门的业务线</li>
<li>开发优秀的产品</li>
<li>Smart endpoints and dumb pipes</li>
<li>DevOps</li>
<li>容错</li>
<li>快速发展</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://segmentfault.com/a/1190000011118897" target="_blank" rel="noopener">康威定律</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/29/architecture-high-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/29/architecture-high-performance/" itemprop="url">数据库高性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-29T18:02:13+08:00">
                2019-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读写分离的基本原理是将数据库读写操作分散到不同的节点上。</p>
<p>读写分离适用单机并发无法支撑并且读的请求更多的情形。在单机数据库情况下，表上加索引一般对查询有优化作用却影响写入速度，读写分离后可以单独对读库进行优化，写库上减少索引，对读写的能力都有提升，且读的提升更多一些。<br>不适用的情况:<br>1）如果并发写入特别高，单机写入无法支撑，就不适合这种模式。<br>2）通过缓存技术或者程序优化能够满足要求</p>
<p>读写分离的基本实现是：<br>1）数据库服务器搭建主从集群，一主一从，一主多从都可以<br>2）数据库主机负责写操作，从机负责读操作<br>3）数据库主机通过复制将数据同步到数据库从机，每台数据库服务器都存储了所有的业务数据<br>4）业务服务器将写操作发给数据库主机，将读操作发给数据库从机</p>
<p>但有两个细节点引入了复杂度：<strong>主从复制延时</strong>和<strong>分配机制</strong>，以下为解决方案</p>
<p>复制延时：<br>1）写操作后的读操作指定发给数据库主机<br>2）读从机失败后再度一次主机<br>3）关键业务读写操作全部指向主机，非关键业务采用读写分离</p>
<p>分配机制：<br>将读写操作区分开来，然后访问不同的数据库，一般有两种方式：<strong>程序代码封装</strong>和<strong>中间件封装</strong></p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>分库分表会带来很多复杂度。在引入分库分表之前，应该是这些操作依次尝试：<br>1.做硬件优化，例如从机械硬盘改成使用固态硬盘，当然固态硬盘不适合服务器使用，只是举个例子<br>2.先做数据库服务器的调优操作，例如增加索引，oracle有很多的参数调整;<br>3.引入缓存技术，例如Redis，减少数据库压力<br>4.程序与数据库表优化，重构，例如根据业务逻辑对程序逻辑做优化，减少不必要的查询;<br>5.在这些操作都不能大幅度优化性能的情况下，不能满足将来的发展，再考虑分库分表，也要有预估性</p>
<h4 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h4><p>业务分库是指按照业务模块将数据分散到不同的数据库服务器。</p>
<p>存在问题：<br>1）join问题<br>2）事务问题<br>3）成本问题</p>
<h4 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h4><p>分两种方式：垂直分表、水平分表</p>
<p>水平分表：<br>水平分表后，某条数据具体属于哪个子表，需要增加路由算法进行计算，这个算法会引入一定的复杂性。<br>常见的路由算法有：<br>1）范围路由<br>2）hash路由<br>3）配置路由</p>
<p>其他常见的复杂性问题：join，count，order by等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/architecture-design-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/architecture-design-flow/" itemprop="url">架构设计流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-28T17:55:33+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="如何识别复杂度"><a href="#如何识别复杂度" class="headerlink" title="如何识别复杂度"></a>如何识别复杂度</h3><p>架构设计由需求所驱动，本质目的是为了解决软件系统的复杂性；为此，我们在进行架构设计时，需要以理解需求为前提，首要进行系统复杂性的分析。具体做法是：</p>
<p>（1）构建复杂度的来源清单——高性能、可用性、扩展性、安全、低成本、规模等。</p>
<p>（2）结合需求、技术、团队、资源等对上述复杂度逐一分析是否需要？是否关键？</p>
<p>“高性能”主要从软件系统未来的TPS、响应时间、服务器资源利用率等客观指标，也可以从用户的主观感受方面去考虑。</p>
<p>“可用性”主要从服务不中断等质量属性，符合行业政策、国家法规等方面去考虑。</p>
<p>“扩展性”则主要从功能需求的未来变更幅度等方面去考虑。</p>
<p>（3）按照上述的分析结论，得到复杂度按照优先级的排序清单，越是排在前面的复杂度，就越关键，就越优先解决。</p>
<p>需要特别注意的是：随着所处的业务阶段不同、外部的技术条件和环境的不同，得到的复杂度问题的优先级排序就会有所不同。一切皆变化。</p>
<h3 id="备选方案设计"><a href="#备选方案设计" class="headerlink" title="备选方案设计"></a>备选方案设计</h3><p>经过架构设计流程第 1 步——识别复杂度，确定了系统面临的主要复杂度问题，进而明确了设计方案的目标，就可以开展架构设计流程第 2 步——设计备选方案。架构设计备选方案的工作更多的是从需求、团队、技术、资源等综合情况出发，对主流、成熟的架构模式进行选择、组合、调整、创新。</p>
<p>1.几种常见的架构设计误区</p>
<p>（1）设计最优秀的方案。不要面向“简历”进行架构设计，而是要根据“合适”、“简单”、“演进”的架构设计原则，决策出与需求、团队、技术能力相匹配的合适方案。</p>
<p>（2）只做一个方案。一个方案容易陷入思考问题片面、自我坚持的认知陷阱。</p>
<p>2.备选方案设计的注意事项</p>
<p>（1）备选方案不要过于详细。备选阶段解决的是技术选型问题，而不是技术细节。</p>
<p>（2）备选方案的数量以 3~5个为最佳。</p>
<p>（3）备选方案的技术差异要明显。</p>
<p>（4）备选方案不要只局限于已经熟悉的技术。</p>
<p>3.问题思考</p>
<p>可以从开源、自研的角度提出架构设计方案</p>
<p>如果是创业公司的业务早、中期阶段，可直接考虑采用阿里云/腾讯云，性能、HA、伸缩性都有保证。</p>
<p>最大的感悟是：做事情永远都要有B方案。</p>
<h3 id="评估和选择备选方案"><a href="#评估和选择备选方案" class="headerlink" title="评估和选择备选方案"></a>评估和选择备选方案</h3><p>1 评估和选择备选方案的方法<br><strong>列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。</strong>常见的质量属性点有：性能、可用性、硬件成本、项目投入、复杂度、安全性、可扩展性。<br>按优先级选择，即架构师综合当前的业务发展情况、团队人员规模和技能、业务发展预测等因素，将质量属性按照优先级排序，首先挑选满足第一优先级的，如果方案都满足，那就再看第二优先级……以此类推。</p>
<p>2 RocketMQ 和 Kafka 有什么区别？</p>
<p>（1） 适用场景<br>Kafka适合日志处理；RocketMQ适合业务处理。</p>
<p>（2） 性能<br>Kafka单机写入TPS号称在百万条/秒；RocketMQ大约在10万条/秒。Kafka单机性能更高。</p>
<p>（3） 可靠性<br>RocketMQ支持异步/同步刷盘;异步/同步Replication；Kafka使用异步刷盘方式，异步Replication。RocketMQ所支持的同步方式提升了数据的可靠性。</p>
<p>（4） 实时性<br>均支持pull长轮询，RocketMQ消息实时性更好</p>
<p>（5） 支持的队列数<br>Kafka单机超过64个队列/分区，消息发送性能降低严重；RocketMQ单机支持最高5万个队列，性能稳定（这也是适合业务处理的原因之一）</p>
<p>3 为什么阿里会自研RocketMQ？</p>
<p>（1） Kafka的业务应用场景主要定位于日志传输；对于复杂业务支持不够<br>（2） 阿里很多业务场景对数据可靠性、数据实时性、消息队列的个数等方面的要求很高<br>（3）当业务成长到一定规模，采用开源方案的技术成本会变高（开源方案无法满足业务的需要；旧版本、自开发代码与新版本的兼容等）<br>（4） 阿里在团队、成本、资源投入等方面约束性条件几乎没有</p>
<h3 id="详细设计方案"><a href="#详细设计方案" class="headerlink" title="详细设计方案"></a>详细设计方案</h3><p>完成备选方案的设计和选择后，接下来需要将确定的备选方案细化，使得备选方案变成一个可以落地的设计方案。</p>
<p>1）架构师不但要进行备选方案的设计和选型，还需要对备选方案的关键细节有较深入的理解。<br>2）通过分步骤、分阶段、分系统等方式，尽量减低方案复杂度，方案本身的复杂度越高，某个细节推翻整个方案的可能性就越大，适当降低复杂度，可以降低这种风险。<br>3）如果方案本身就很复杂，那就采取设计团队的方式来进行设计，博采众长，防止可能出现的盲点或经验误区。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/26/flutter-package-size/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/26/flutter-package-size/" itemprop="url">Flutter APP体积为何比较大</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-26T11:11:39+08:00">
                2019-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hybrid-Develop/" itemprop="url" rel="index">
                    <span itemprop="name">Hybrid Develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>flutter构建的App体积比native的大一些，是什么原因造成App体积大呢？</p>
<p>其实flutter 在release时App体积和native的大小差不多，而debug时体积通常会大。debug版本体积较大是为了Hot reload和快速编译。如果有flutter开发经验的朋友都体验过，如果您修改一下App的背景颜色，只需save一下就可以立刻看到修改后效果。我称之为“像艺术家一样在创造App”，因此为了实现这些目标，提高开发的效率，debug将占用全部资源。而当我们构建release版时，flutter又会采用AOT策略，提高App运行效率，release版只打包必需的资源，因而体积又会减少。</p>
<p>另外，flutter团队也一直在寻找减小程序大小的方法。</p>
<p>现在开发 App 的方式非常多，原生、ReactNative、Flutter 都是不错的选择。那你有没有关注过，使用不同的方式，编译生成的 Apk ，大小是否会有什么影响呢？本文就以一个最简单的 Hello World App，来看看不同的框架，编译出来的 Apk 大小，有什么区别。</p>
<h3 id="Java（539-KB）"><a href="#Java（539-KB）" class="headerlink" title="Java（539 KB）"></a>Java（539 KB）</h3><p>首先使用 Java 来开始这次实验，使用 Java 开发 Android 算是最常规也是最简单的一种方式。正如前面描述的那样，由于我们仅仅使用了 Java 和 Android 框架来创建这个应用程序，所以它将是最小的，唯一的依赖是 Android 支持库，它占用了整个 Apk 内相当多的空间。</p>
<h3 id="Flutter（7-5MB）"><a href="#Flutter（7-5MB）" class="headerlink" title="Flutter（7.5MB）"></a>Flutter（7.5MB）</h3><p>由 Flutter 的 cli 生成的 Release 版本的应用程序中，包含 C / C ++ 引擎和 Dart VM，它们构成了 Apk 的几乎所有部分。该应用程序直接使用本机指令集运行，不涉及任何解释器。<br><img src="/2019/04/26/flutter-package-size/flutter_app_size.jpg" alt><br>本文里介绍的几种编写 App 的方法，都存在优缺点，在实际工作中，应该根据需求选择适合的方式。你还可以混合搭配这些框架，仅仅用它们的优点来开发 App 的部分功能。</p>
<h3 id="React-Native（7MB）"><a href="#React-Native（7MB）" class="headerlink" title="React Native（7MB）"></a>React Native（7MB）</h3><p>如果你有前端（Web）的开发经验，并希望使用 JavaScript 来开发 App，那么 React Native 是一个不错的选择。</p>
<p>如果你希望在已发布的 App 上，进行更快的功能迭代，使用 React Native 也可以让你不必为每个小改动都发布应用市场。</p>
<p>由 React Native 生成的 Release apk 在 classes.dex 文件中有几个类，这些类有 12193 个针对此应用程序的引用方法。<br>它还在 x86 和 armeabi-v7a 的 lib 目录中添加了一些 so 库。总共添加了大约 6.4 MB 的空间。</p>
<hr>
<p>ReactNative 和 Flutter 因为其内部还需要包含一些解析器和引擎，本身就会有一些基础库在其内，所以变大也是符合预期的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/0e223b472f41" target="_blank" rel="noopener">https://www.jianshu.com/p/0e223b472f41</a><br><a href="https://www.cnblogs.com/plokmju/p/release_apk.html" target="_blank" rel="noopener">https://www.cnblogs.com/plokmju/p/release_apk.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/architecture-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/25/architecture-basics/" itemprop="url">架构的概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-25T11:26:13+08:00">
                2019-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>架构设计的主要目的是为了解决软件系统复杂度带来的问题。</strong>个人感悟是：架构及（重要）决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体（人、财、时间等）。架构无优劣，但是存在恰当的架构用在合适的系统中，而这些就是决策的结果。不要过分设计。</p>
<h3 id="架构概念"><a href="#架构概念" class="headerlink" title="架构概念"></a>架构概念</h3><p>软件架构指软件系统的顶层结构；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。</p>
<p>软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。</p>
<p>软件模块（Module）是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。现代软件开发往往利用模块作为合成的单位。模块的接口表达了由该模块提供的功能和调用它时所需的元素。模块是可能分开被编写的单位。这使它们可再用和允许人员同时协作、编写及研究不同的模块。</p>
<p>软件组件定义为自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>性能是软件的一个重要质量属性。衡量软件性能包括了响应时间、TPS、服务器资源利用率等客观指标，也可以是用户的主观感受（从程序员、业务用户、终端用户/客户不同的视角，可能会得出不同的结论）。</p>
<p>在说性能的时候，有一个概念与之紧密相关—伸缩性，这是两个有区别的概念。性能更多的是衡量软件系统处理一个请求或执行一个任务需要耗费的时间长短；而伸缩性则更加关注软件系统在不影响用户体验的前提下，能够随着请求数量或执行任务数量的增加（减少）而相应地拥有相适应的处理能力。</p>
<p>但是，什么是“高”性能？这可能是一个动态概念，与当前的技术发展状况与业务所处的阶段紧密相关。比如，现在在行业/企业内部认为的高性能，站在5年后来看，未必是高性能。因此，站在架构师、设计师的角度，高性能需要和业务所处的阶段来衡量。高到什么程度才能与当前或可预见的未来业务增长相匹配。一味去追求绝对意义上的高，没有太大的实际意义。因为，伴随性能越来越高，相应的方法和系统复杂度也是越来越高，而这可能会与当前团队的人力、技术、资源等不相匹配。但是什么才合适的高性能了？这可能需要从国、内外的同行业规模相当、比自己强的竞争者、终端用户使用反馈中获取答案并不断迭代发展。</p>
<p>软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度。</p>
<p>2 WHY 为什么需要高性能？<br>追求良好的用户体验；<br>满足业务增长的需要。</p>
<p>3 HOW 如何做好高性能？<br>可以从垂直与水平两个维度来考虑。垂直维度主要是针对单台计算机，通过升级软、硬件能力实现性能提升；水平维度则主要针对集群系统，利用合理的任务分配与任务分解实现性能的提升。</p>
<p>垂直维度可包括以下措施：<br>增大内存减少I/O操作<br>更换为固态硬盘（SSD）提升I/O访问速度<br>使用RAID增加I/O吞吐能力<br>置换服务器获得更多的处理器或分配更多的虚拟核<br>升级网络接口或增加网络接口</p>
<p>水平维度可包括以下措施：<br>功能分解：基于功能将系统分解为更小的子系统<br>多实例副本：同一组件重复部署到多台不同的服务器<br>数据分割：在每台机器上都只部署一部分数据</p>
<p>垂直维度方案比较适合业务阶段早期和成本可接受的阶段，该方案是提升性能最简单直接的方式，但是受成本与硬件能力天花板的限制。</p>
<p>水平维度方案所带来的好处要在业务发展的后期才能体现出来。起初，该方案会花费更多的硬件成本，另外一方面对技术团队也提出了更高的要求；但是，没有垂直方案的天花板问题。一旦达到一定的业务阶段，水平维度是技术发展的必由之路。因此，作为技术部门，需要提前布局 ，未雨绸缪，不要被业务抛的太远。</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p><strong>高可用基础是“状态决策”。本质上是通过“冗余”来实现高可用。</strong></p>
<p>高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。保证系统高可用，架构设计的核心准则是：冗余。有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p><strong>核心是：封装变化，隔离可变性。</strong></p>
<p>应对变化方案：<br>1）将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”<br>2）提炼出一个“抽象层”和一个“实现层”。抽象层是稳定的，而实现层是根据业务进行定制的，当加入新功能时，只需要更改实现层，无须修改抽象层。</p>
<h3 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h3><p>当前大型互联网网站需要面对大量用户高并发访问、存储更多数据、处理更高频次的用户交互。网站系统一般通过多种分布式技术将多台服务器组成集群对外提供服务。<strong>伸缩性一般是系统可以根据需求和成本调整自身处理能力的一种能力</strong>。伸缩性常意味着系统可以通过低成本并能够快速改变自身的处理能力以满足更多用户访问、处理更多数据而不会对用户体验造成任何影响。</p>
<p>伸缩性度量指标包括（1）处理更高并发；（2）处理更多数据；（3）处理更高频次的用户交互。</p>
<p>其复杂度体现在（1）伸——增强系统在上述三个方面的处理能力；（2）缩——缩减系统处理能力；（3）上述伸缩过程还必须相对低成本和快速。</p>
<h3 id="成本、安全、规模"><a href="#成本、安全、规模" class="headerlink" title="成本、安全、规模"></a>成本、安全、规模</h3><p>低成本是架构设计中需要考虑一个约束条件，但不会是首要目标。低成本本质上是与高性能和高可用冲突的，当无法设计出满足成本要求的方案，就只能协调并调整成本目标。<br>往往只有“创新”才能达到低成本目标。1）引入新技术。主要复杂度在于需要去熟悉新技术，并且将新技术与已有技术结合；一般中小型公司基本采用该方式达到目标。2）开创一个全新技术领域。主要复杂度在于需要去创造全新的理念和技术，并且与旧技术相比，需要有质的飞跃，复杂度更高；一般大公司拥有更多的资源、技术实力会采用该方式来达到低成本的目标。</p>
<p>安全在技术角度上将包括功能安全和架构安全。1）功能安全-“防小偷”，减少系统潜在的缺陷（是一个逐步完善的过程，而且往往都是在问题出现后才能有针对性的提出解决方案，与编码实现有关），阻止黑客的破坏行为。2）架构安全-“防强盗”，保护系统不受恶意访问与攻击，保护系统的重要数据不被窃取（传统企业主要通过防火墙实现不同区域的访问控制，功能强大、性能一般，但是成本更高；互联网企业更多的是依靠运营商或者云服务商强大的带宽和流量清洗的能力，较少自己来设计和实现）。</p>
<p>规模带来复杂度的主要原因是“量变引起质变”。1）功能越来越多，调用逻辑越来越复杂，会导致系统复杂度指数级上升。2）数据容量、类型、关联关系越来越多。<br>规模问题需要与高性能、高可用、高扩展、高伸缩性统一考虑。常采用“分而治之，各个击破”的方法策略。</p>
<h3 id="架构设计三原则"><a href="#架构设计三原则" class="headerlink" title="架构设计三原则"></a>架构设计三原则</h3><p><strong>不断演化是架构发展的主旋律，而满足适合、追求简单是架构决策的重要依据。</strong>需求驱动技术的创新演化；技术反哺业务的发展升级。<br>1）合适原则<br>合适原则宣言：合适优于业界领先<br>失败原因：没有那么多人，却想干那么多活；没有那么多积累，却想一步登天；没有卓越的业务场景，却幻想灵光一闪成为天才。设计的目的不是为了证明自己，而是更快更好的满足业务需求。</p>
<p>2）简单原则<br>简单原则宣言：简单优于复杂<br>定位一个复杂系统中的问题总是比简单系统更为复杂</p>
<p>3）演化原则<br>演化原则宣言：演化优于一步到位<br><strong>对于软件来说，变化才是主题</strong>。罗马不是一天建成的，架构也不是一开始就设计成完美的样子，然后可以一劳永逸的用下去。</p>
<p>各个公司的架构都是逐渐演进成当前的样子，在达到同样目的的过程中实现手段确并不完全相同，蚂蚁和阿里都进行了多地多中心部署的架构改造，但二者在诸如配置中心、跨ldc访问管控等方面都不尽相同，即使在蚂蚁内部也出现了后续实现推翻原始规划的情况。在多地多中心部署架构改造完成后，为进一步降低成本，避免大促活动中机器的浪费，又开始了弹性部署的改造，希望能够在大促高峰来临的前几个小时再临时增加服务器，等活动结束服务器就立即回收。等这个搞定，又开始在线离线混布的改造，进一步降低整体成本。<br>这些改造之所以一个接一个的能够实现，也在于使用的主要中间件和框架都是自研的，知根知底，可以快速迭代修改，如果是使用第三方的或者购买的，一方面可能非常贵，另一方面可能根本不支持，要重新设计改造部署所需的时间要远远大于自研的成本。</p>
<h3 id="软件活动中没有“银弹”"><a href="#软件活动中没有“银弹”" class="headerlink" title="软件活动中没有“银弹”"></a>软件活动中没有“银弹”</h3><p>在古代的狼人传说中，只有用银质子弹（银弹）才能制服这些异常凶残的怪兽。在软件开发活动中，“银弹”特指人们渴望找到用于制服软件项目这头难缠的“怪兽”的“万能钥匙”。</p>
<p>软件开发过程包括了分析、设计、实现、测试、验证、部署、运维等多个环节。从IT技术的发展历程来看，先辈们在上述不同的环节中提出过很多在当时看来很先进的方法与理念。但是，这些方法、理念在摩尔定律、业务创新、技术发展面前都被一一验证了以下观点：我们可以通过诸多方式去接近“银弹”，但很遗憾，软件活动中没有“银弹”。</p>
<p>布鲁克斯发表《人月神话》三十年后，又写了《设计原本》。他认为一个成功的软件项目的最重要因素就是设计，架构师、设计师需要在业务需求和IT技术中寻找到一个平衡点。个人觉得，对这个平衡点的把握，就是架构设计中的取舍问题。而这种决策大部分是靠技术，但是一定程度上也依赖于架构师的“艺术”，技术可以依靠新工具、方法论、管理模式去提升，但是“艺术”无法量化 ，是一种权衡。</p>
<p><strong>软件设计过程中，模块、对象、组件本质上是对一定规模软件在不同粒度和层次上的“拆分”方法论，软件架构是一种对软件的“组织”方法论。一分一合，其目的是为了软件研发过程中的成本、进度、质量得到有效控制</strong>。但是，一个成功的软件设计是要适应并满足业务需求，同时不断“演化”的。设计需要根据业务的变化、技术的发展不断进行“演进”，这就决定了这是一个动态活动，出现新问题，解决新问题，没有所谓的“一招鲜”。</p>
<p>以上只是针对设计领域的银弹讨论，放眼到软件全生命周期，银弹问题会更加突出。</p>
<p>小到一个软件开发团队，大到一个行业，没有银弹，但是“行业最佳实践”可以作为指路明灯，这个可以有。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/11/android-retrofit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/11/android-retrofit/" itemprop="url">Android Retrofit 2详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-11T13:28:01+08:00">
                2019-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>以下就是实现一个登录Login接口的小功能 ，先了解一下Retrofit的基本用法:</p>
<pre><code>private  void getLogin() {
Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(&quot;//localhost:8080/&quot;)
        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())
        .addConverterFactory(GsonConverterFactory.create())
        .build();
ApiManager apiService = retrofit.create(ApiManager.class);

Call&lt;LoginResult&gt; call = apiService.getData(&quot;lyk&quot;, &quot;1234&quot;);
call.enqueue(new Callback&lt;LoginResult&gt;() {
   @Override
   public void onResponse(Call&lt;LoginResult&gt; call, Response&lt;LoginResult&gt; response) {
       if (response.isSuccess()) {
           // 请求成功
       } else {
          //直接操作UI 或弹框提示请求失败
       }
   }

   @Override
   public void onFailure(Call&lt;LoginResult&gt; call, Throwable t) {
       //错误处理代码
   }
   });
}
</code></pre><p>ApiManager接口:</p>
<pre><code>public interface ApiManager {
 @GET(&quot;login/&quot;)
 Call&lt;LoginResult&gt; getData(@Query(&quot;name&quot;) String name, @Query(&quot;password&quot;) String pw);
}
</code></pre><h2 id="Retrofit支持异步和同步"><a href="#Retrofit支持异步和同步" class="headerlink" title="Retrofit支持异步和同步"></a>Retrofit支持异步和同步</h2><p>call.enqueue(new Callback<loginresult>）采用异步请求；<br>call.execute() 采用同步方式。</loginresult></p>
<p>call.cancel() 取消请求</p>
<h2 id="CallAdapterFactory"><a href="#CallAdapterFactory" class="headerlink" title="CallAdapterFactory"></a>CallAdapterFactory</h2><p>.addCallAdapterFactory(RxJava2CallAdapterFactory.create())这个是用来决定你的返回值是Observable还是Call。</p>
<pre><code>// 使用call的情况
Call&lt;String&gt; login();  
// 使用Observable的情况
Observable&lt;String&gt; login();  
</code></pre><p>如果返回为Call那么可以不添加这个配置。如果使用Observable那就必须添加这个配置。否则就会请求的时候就会报错！</p>
<p>Retrofit中使用RxJava：由于Retrofit设计的扩展性非常强，你只需要添加一个 CallAdapter 就可以了</p>
<h2 id="ConverterFactory"><a href="#ConverterFactory" class="headerlink" title="ConverterFactory"></a>ConverterFactory</h2><p>addConverterFactory <strong>制定数据解析器</strong>，上面添加依赖的gson就是用在这里做默认数据返回的， 之后通过build()创建出来。</p>
<p>Retrofit内部自带如下格式：</p>
<blockquote>
<p>Gson: com.squareup.retrofit2:converter-gson<br>Jackson: com.squareup.retrofit2:converter-jackson<br>Moshi: com.squareup.retrofit2:converter-moshi<br>Protobuf: com.squareup.retrofit2:converter-protobuf<br>Wire: com.squareup.retrofit2:converter-wire<br>Simple XML: com.squareup.retrofit2:converter-simplexml<br>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</p>
</blockquote>
<h2 id="网络请求参数"><a href="#网络请求参数" class="headerlink" title="网络请求参数"></a>网络请求参数</h2><p>@Path:所有在网址中的参数(URL的问号前面),如://192.168.1.1/api/Accounts/{accountId}</p>
<p>@Query:URL问号后面的参数,如://192.168.1.1/api/Comments?access_token={access_token}</p>
<p>@QueryMap:相当于多个@Query</p>
<p>@Field:用于POST请求,提交单个数据</p>
<p>@FieldMap:以map形式提交多个Field(Retrofit2.0之后添加)</p>
<p>@Body:相当于多个@Field,以对象的形式提交</p>
<p>注意：</p>
<ol>
<li><p>使用@Field时记得添加@FormUrlEncoded</p>
</li>
<li><p>若需要重新定义接口地址,可以使用@Url,将地址以参数的形式传入即可。</p>
</li>
<li><p>@Path 和@Query的区别<br>相同点:都是请求头中的带有的数据<br>不同点:前者是请求头中问号之前用于替换URL中变量的字段,后者是请求头问号之后用于查询数据的字段,作用和应用场景都不同</p>
</li>
</ol>
<h2 id="进阶功能"><a href="#进阶功能" class="headerlink" title="进阶功能"></a>进阶功能</h2><h3 id="开启Log"><a href="#开启Log" class="headerlink" title="开启Log"></a>开启Log</h3><p>用拦截器实现， retrofit已经提供了 HttpLoggingInterceptor 里面有四种级别，输出的格式，可以看下面介绍：</p>
<pre><code>public enum Level {
/** No logs. */
NONE,
/**
 * Logs request and response lines.
 *
 * &lt;p&gt;Example:
 * &lt;pre&gt;{@code
 * --&gt; POST /greeting 
 * 
 * 
 * /1.1 (3-byte body)
 *
 * &lt;-- 200 OK (22ms, 6-byte body)
 * }&lt;/pre&gt;
 */
BASIC,
/**
 * Logs request and response lines and their respective headers.
 *
 * &lt;p&gt;Example:
 * &lt;pre&gt;{@code
 * --&gt; POST /greeting http/1.1
 * Host: example.com
 * Content-Type: plain/text
 * Content-Length: 3
 * --&gt; END POST
 *
 * &lt;-- 200 OK (22ms)
 * Content-Type: plain/text
 * Content-Length: 6
 * &lt;-- END HTTP
 * }&lt;/pre&gt;
 */
HEADERS,
/**
 * Logs request and response lines and their respective headers and bodies (if present).
 *
 * &lt;p&gt;Example:
 * &lt;pre&gt;{@code
 * --&gt; POST /greeting http/1.1
 * Host: example.com
 * Content-Type: plain/text
 * Content-Length: 3
 *
 * Hi?
 * --&gt; END GET
 *
 * &lt;-- 200 OK (22ms)
 * Content-Type: plain/text
 * Content-Length: 6
 *
 * Hello!
 * &lt;-- END HTTP
 * }&lt;/pre&gt;
 */
BODY
}
</code></pre><p>例如，开启请求头添加拦截器:</p>
<pre><code>Retrofit retrofit = new Retrofit.Builder().client(new OkHttpClient.Builder()
                         .addNetworkInterceptor(new  HttpLoggingInterceptor().setLevel(HttpLoggingInterceptor.Level.HEADERS))       
                         .build())
</code></pre><h3 id="增加头部信息"><a href="#增加头部信息" class="headerlink" title="增加头部信息"></a>增加头部信息</h3><pre><code>new Retrofit.Builder()
       .addConverterFactory(GsonConverterFactory.create())
       .client(new OkHttpClient.Builder()
               .addInterceptor(new Interceptor() {
                   @Override
                   public Response intercept(Chain chain) throws IOException {
                       Request request = chain.request()
                               .newBuilder()
                               .addHeader(&quot;mac&quot;, &quot;f8:00:ea:10:45&quot;)
                               .addHeader(&quot;uuid&quot;, &quot;gdeflatfgfg5454545e&quot;)
                               .addHeader(&quot;userId&quot;, &quot;Fea2405144&quot;)
                               .addHeader(&quot;netWork&quot;, &quot;wifi&quot;)
                               .build();
                       return chain.proceed(request);
                   }
               })
               .build()
</code></pre><p>特殊API接口单独加入,方法上注释@Headers:</p>
<pre><code>@Headers({ &quot;Accept: application/vnd.github.v3.full+json&quot;, &quot;User-Agent: Retrofit-your-App&quot;})
@get(&quot;users/{username}&quot;)
Call&lt;User&gt;   getUser(@Path(&quot;username&quot;) String username);
</code></pre><h3 id="添加证书Pinning"><a href="#添加证书Pinning" class="headerlink" title="添加证书Pinning"></a>添加证书Pinning</h3><p>证书可以在自定义的OkHttpClient加入certificatePinner 实现：</p>
<pre><code>OkHttpClient client = new OkHttpClient.Builder()
.certificatePinner(new CertificatePinner.Builder()
        .add(&quot;YOU API.com&quot;, &quot;sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=&quot;)
        .add(&quot;YOU API..com&quot;, &quot;sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=&quot;)
        .add(&quot;YOU API..com&quot;, &quot;sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=&quot;)
        .add(&quot;YOU API..com&quot;, &quot;sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=&quot;)
        .build())
</code></pre><h3 id="支持https"><a href="#支持https" class="headerlink" title="支持https"></a>支持https</h3><p>加密和普通http客户端请求支持https一样，证书同样可以设置到okhttpclient中.详细可以参考我之前的文章：<a href="https://zhaoshuming.github.io/2019/03/18/android-https/" target="_blank" rel="noopener">android中使用https</a></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="url被转义"><a href="#url被转义" class="headerlink" title="url被转义"></a>url被转义</h3><pre><code>https://api.myapi.com/http%3A%2F%2Fapi.mysite.com%2Fuser%2Flist
</code></pre><p>请将@path改成@url</p>
<pre><code>public interface APIService { 
@GET Call&lt;Users&gt; getUsers(@Url String url);}
</code></pre><p>或者：</p>
<pre><code>public interface APIService {
    @GET(&quot;{fullUrl}&quot;)
    Call&lt;Users&gt; getUsers(@Path(value = &quot;fullUrl&quot;, encoded = true) String fullUrl);
}
</code></pre><h3 id="Method方法找不到"><a href="#Method方法找不到" class="headerlink" title="Method方法找不到"></a>Method方法找不到</h3><pre><code>java.lang.IllegalArgumentException: Method must not be null
</code></pre><p>请指定具体请求类型@get @post等</p>
<pre><code>public interface APIService { 
   @GET Call&lt;Users&gt; getUsers(@Url String url);
}
</code></pre><h3 id="Url编码不对，-fieldMap-parameters-must-be-use-FormUrlEncoded"><a href="#Url编码不对，-fieldMap-parameters-must-be-use-FormUrlEncoded" class="headerlink" title="Url编码不对，@fieldMap parameters must be use FormUrlEncoded"></a>Url编码不对，@fieldMap parameters must be use FormUrlEncoded</h3><p>如果用fieldMap加上FormUrlEncoded编码</p>
<pre><code>@POST()
@FormUrlEncoded
Observable&lt;ResponseBody&gt; executePost(@FieldMap Map&lt;String, Object&gt; maps);
</code></pre><p>上层需要转换将自己的map转换为FieldMap</p>
<pre><code>@FieldMap(encoded = true) Map&lt;String, Object&gt; parameters,
</code></pre><h3 id="path和url一起使用"><a href="#path和url一起使用" class="headerlink" title="path和url一起使用"></a>path和url一起使用</h3><pre><code>Using @Path and @Url paramers together with retrofit2 
java.lang.IllegalArgumentException: @Path parameters may not be used with @Url. (parameter #4
</code></pre><p>如果你是这样的：</p>
<pre><code>@GET
Call&lt;DataResponse&gt; getOrder(@Url String url, @Path(&quot;id&quot;) int id);
</code></pre><p>请在你的url指定占位符.url:</p>
<pre><code>www.myAPi.com/{Id}
</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Retrofit就像一个适配器（Adapter）的角色，将一个Java接口转换成一个Http请求并返回一个Call对象，简单的调用接口方法就可以发送API请求，Retrofit完全隐藏了Request 的请求体，并使用okhttp执行请求。</p>
<p>Retrofit 是怎么实现的呢？答案就是：Java的动态代理。<strong>Java动态代理，是一种结构性设计模式，可以在要调用的Class方法前或后，插入想要执行的代码进行改造。</strong></p>
<p>案例中关键两行代码：</p>
<pre><code>ApiManager apiService = retrofit.create(ApiManager.class); //2、retrofit对象创建一个API接口对象

Call&lt;LoginResult&gt; call = apiService.getData(&quot;lyk&quot;, &quot;1234&quot;); //返回响应接口回调
</code></pre><p>这简短的两行代码，隐藏了Request请求体并拿到Response返回Call对象。看下源码，这几行代码才是 Retrofit 精妙之处：</p>
<pre><code>/** Create an implementation of the API defined by the {@code service} interface. */
public &lt;T&gt; T create(final Class&lt;T&gt; service) {
  Utils.validateServiceInterface(service);
  if (validateEagerly) {
     eagerlyValidateMethods(service);
  }
  return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service },
    new InvocationHandler() {
      private final Platform platform = Platform.get();
      @Override public Object invoke(Object proxy, Method method, Object... args)
          throws Throwable {
        // If the method is a method from Object then defer to normal invocation.
        if (method.getDeclaringClass() == Object.class) {
          return method.invoke(this, args);
        }
        if (platform.isDefaultMethod(method)) {
          return platform.invokeDefaultMethod(method, service, proxy, args);
        }
        ServiceMethod serviceMethod = loadServiceMethod(method);
        OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
        return serviceMethod.callAdapter.adapt(okHttpCall);
      }
    });
}
</code></pre><p>源码分析：<br>当 apiService 对象调用 getData方法时，就会被这个动态代理拦截并在内部做些小动作，它会调用 Proxy.newProxyInstance方法 中的 InvocationHandler 对象，它的 invoke方法 会传入3个参数：</p>
<blockquote>
<p>Object proxy     ：代理对象 ，即APIManner.class<br>Method method ：调用方法，即getData方法<br>Object… args    ： 参数对象，即 “lyk”,”1234”</p>
</blockquote>
<p>Retrofit 得到了 method 和 参数args 。接下去 Retrofit 就会用 Java反射 获取到 getData方法 的注解信息，配合args参数，创建一个ServiceMethod对象。</p>
<p>ServiceMethod 是服务于请求方法的，服务于传入Retrofit的proxy对象的method方法，即getData方法。如何服务呢？它可以将method通过各种内部接口解析器进行组装拼凑，最终生成一个Request请求体。这个Request 包含 api域名、path、http请求方法、请求头、是否有body、是否是multipart等等。最后返回一个Call对象，Retrofit2中Call接口的默认实现是OkHttpCall，它默认使用OkHttp3作为底层http请求client。一句话就是：<strong>Retrofit 使用Java动态代理就是要拦截被调用的Java方法，然后解析这个Java方法的注解，最后生成Request由OkHttp发送Http请求。</strong></p>
<p>想要弄清楚Retrofit的细节，先来简单了解一下Retrofit源码组成结构：</p>
<p><img src="/2019/04/11/android-retrofit/retrofit2_dir.png" alt><br>一个retrofit2.http包，里面全部是定义HTTP请求的Java注解，比如GET、POST、PUT、DELETE、Headers、Path、Query等；</p>
<p>余下的retrofit2包中，几个类和接口retrofit的代码真的很少很简单，因为retrofit把网络请求这部分功能全部交给了OkHttp。</p>
<h3 id="Retrofit接口"><a href="#Retrofit接口" class="headerlink" title="Retrofit接口"></a>Retrofit接口</h3><p>Retrofit的设计使用插件化而且轻量级，高内聚而且低耦合，这都和它的接口设计有关。Retrofit中定义了四个接口：</p>
<ul>
<li>Callback<t></t></li>
<li>Converter&lt;F, T&gt;</li>
<li>Call<t></t></li>
<li>CallAdapter<t></t></li>
</ul>
<p>1、Callback<t><br>这个接口就是retrofit请求数据返回的接口，只有两个方法：</t></p>
<pre><code>void onResponse(Response&lt;T&gt; response);
void onFailure(Throwable t);
</code></pre><p>2、Converter&lt;F, T&gt;<br>这个接口主要的作用就是将HTTP返回的数据解析成Java对象，主要有Xml、Gson、protobuf等。你可以在创建Retrofit对象时添加你需要使用的Converter实现。</p>
<p>3、Call<t><br>这个接口主要的作用就是发送一个HTTP请求，Retrofit默认的实现是OkHttpCall<t>，你可以根据实际情况实现你自己的Call类。这个设计和Volley的HttpStack接口设计的思想非常相似，子类可以实现基于HttpClient或HttpUrlConnetction的HTTP请求工具。</t></t></p>
<p>4、CallAdapter<t><br>这个借口的属性只有responseType一个；这个接口的实现类也只有DefaultCallAdapter一个。这个方法的主要作用就是将Call对象转换成另一个对象，为了支持RxJava才设计这个类的吧。</t></p>
<h3 id="Retrofit的运行过程"><a href="#Retrofit的运行过程" class="headerlink" title="Retrofit的运行过程"></a>Retrofit的运行过程</h3><p>上面讲的案例代码，返回了一个动态代理对象。而执行这段代码时，返回了一个OkHttpCall对象，拿到这个 Call 对象才能真正执行 HTTP 请求。</p>
<pre><code>ApiManager apiService = retrofit.create(ApiManager.class); //2、retrofit对象创建一个API接口对象
Call&lt;LoginResult&gt; call = apiService.getData(&quot;lyk&quot;, &quot;1234&quot;); //返回响应接口回调
</code></pre><p>上面代码中 apiService 对象其实是一个动态代理对象。当 apiService 对象调用 getData方法 时会被动态代理拦截，然后调用 Proxy.newProxyInstance 方法中的 InvocationHandler 对象， 创建一个  ServiceMethod对象：</p>
<pre><code>ServiceMethod serviceMethod = loadServiceMethod(method);
OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);
return serviceMethod.callAdapter.adapt(okHttpCall);
</code></pre><h3 id="创建ServiceMethod"><a href="#创建ServiceMethod" class="headerlink" title="创建ServiceMethod"></a>创建ServiceMethod</h3><p>刚才说到 ServiceMethod 是服务于方法的，具体来看一下创建这个ServiceMethod的过程是怎么样的：<br>首先，获取到上面说到的 Retrofit的接口：</p>
<pre><code>callAdapter = createCallAdapter();
responseType = callAdapter.responseType();
responseConverter = createResponseConverter();
</code></pre><p>然后，解析Method方法的注解，其实就是想获取Http请求的方法。比如请求方法是GET还是POST形式，如果没有程序就会报错。还会做一系列的检查，比如在方法上注解了@Multipart，但是Http请求方法是GET，同样也会报错。</p>
<pre><code>for (Annotation annotation : methodAnnotations) {
    parseMethodAnnotation(annotation);
}

if (httpMethod == null) {
   throw methodError(&quot;HTTP method annotation is required (e.g., @GET, @POST, etc.).&quot;);
}
</code></pre><p>其次，比如上面 apiService 接口的方法中带有参数{name,password}，这都占位符，而参数值是在Java方法调用中传入的。那么 Retrofit 会使用一个 ParameterHandler 来进行替换：</p>
<pre><code>int parameterCount = parameterAnnotationsArray.length;
parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount];
</code></pre><p>最后，ServiceMethod 还会做其他的检查。比如用了 @FormUrlEncoded 注解，那么方法参数中必须至少有一个 @Field 或 @FieldMap。</p>
<h3 id="执行Http请求"><a href="#执行Http请求" class="headerlink" title="执行Http请求"></a>执行Http请求</h3><p>之前讲到，OkHttpCall是实现了Call接口的，并且是真正调用 OkHttp3 发送Http请求的类。OkHttp3发送一个Http请求需要一个Request对象，而这个Request对象就是从 ServiceMethod 的 toRequest 返回的。</p>
<p>总之，OkHttpCall 就是调用 ServiceMethod 获得一个可以执行的 Request 对象，然后等到 Http 请求返回后，再将 response body 传入 ServiceMethod 中，ServiceMethod 就可以调用 Converter 接口将 response body 转成一个Java对象。</p>
<p>综上所述，<strong>ServiceMethod 中几乎保存了一个api请求所有需要的数据，OkHttpCall需要从ServiceMethod中获得一个Request对象，然后得到response后，还需要传入 ServiceMethod 用 Converter 转换成Java对象。</strong></p>
<p>你可能会觉得我只要发送一个HTTP请求，你要做这么多事情不会很“慢”吗？不会很浪费性能吗？<br>我觉得，首先现在手机处理器主频非常高了，解析这个接口可能就花1ms可能更少的时间（我没有测试过），面对一个HTTP本来就需要几百ms，甚至几千ms来说不值得一提；而且Retrofit会对解析过的请求进行缓存，就在Map&lt;Method, ServiceMethod&gt; serviceMethodCache = new LinkedHashMap&lt;&gt;()这个对象中</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Retrofit非常巧妙的用注解来描述一个HTTP请求，将一个HTTP请求抽象成一个Java接口，然后用了Java动态代理的方式，动态的将这个接口的注解“翻译”成一个HTTP请求，最后再执行这个HTTP请求</strong></p>
<p>Retrofit的功能非常多的依赖Java反射，代码中其实还有很多细节，比如异常的捕获、抛出和处理，大量的Factory设计模式（为什么要这么多使用Factory模式？）</p>
<p>Retrofit中接口设计的恰到好处，在你创建Retrofit对象时，让你有更多更灵活的方式去处理你的需求，比如使用不同的Converter、使用不同的CallAdapter，这也就提供了你使用RxJava来调用Retrofit的可能</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/csdn_aiyang/article/details/72303367" target="_blank" rel="noopener">Android Retrofit 2.0</a><br><a href="https://blog.csdn.net/jiankeufo/article/details/73186929" target="_blank" rel="noopener">https://blog.csdn.net/jiankeufo/article/details/73186929</a><br><a href="https://www.jianshu.com/p/2e8b400909b7" target="_blank" rel="noopener">https://www.jianshu.com/p/2e8b400909b7</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/29/java-cas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/29/java-cas/" itemprop="url">JAVA中的CAS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T18:22:44+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/同步/" itemprop="url" rel="index">
                    <span itemprop="name">同步</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="无锁的概念"><a href="#无锁的概念" class="headerlink" title="无锁的概念"></a>无锁的概念</h4><p>加锁是一种悲观策略，无锁是一种乐观策略，因为对于加锁的并发程序来说，它们总是认为每次访问共享资源时总会发生冲突，因此必须对每一次数据操作实施加锁策略。而无锁则总是假设对共享资源的访问没有冲突，线程可以不停执行，无需加锁，无需等待，一旦发现冲突，<strong>无锁策略则采用一种称为CAS的技术来保证线程执行的安全性</strong>，这项CAS技术就是无锁策略实现的关键。</p>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下:</p>
<blockquote>
<p>执行函数：CAS(V,E,N)</p>
</blockquote>
<p>其包含3个参数:<br>V表示要更新的变量<br>E表示预期值<br>N表示新值<br>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，<strong>当期望值与当前线程的变量值相同时，说明还没线程修改该值，当前线程可以进行修改，也就是执行CAS操作</strong>，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作，原理图如下:<br><img src="/2019/03/29/java-cas/cas.png" alt><br>示例如下：</p>
<pre><code>//加一并返回值
public final int incrementAndGet() {
        for (;;) {
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next))
                return next;
        }
   }

//返回CAS操作成功与否
public final boolean compareAndSet(int expect, int update) {
        //根据变量在内存中的偏移地址valueOffset获取原值，然后和预期值except进行比，如果符合，用update值进行更新，这个过程是原子操作
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }
</code></pre><p>如果此时有两个线程，线程A得到current值为1，线程B得到current值也为2，此时线程A执行CAS操作，成功将值改为2，而此时线程B执行CAS操作，发现此时内存中的值并不是读到current值1，所以返回false，此时线程B继续进行循环，最后成功加1</p>
<h4 id="CAS的原子性"><a href="#CAS的原子性" class="headerlink" title="CAS的原子性"></a>CAS的原子性</h4><p>或许我们可能会有这样的疑问，假设存在多个线程执行CAS操作并且CAS的步骤很多，有没有可能在判断V和E相同后，正要赋值时，切换了线程，更改了值。造成了数据不一致呢？答案是否定的，因为<strong>CAS是一种系统原语</strong>，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说<strong>CAS是一条CPU的原子指令</strong>，不会造成所谓的数据不一致问题。</p>
<h4 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h4><p>Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，单从名称看来就可以知道该类是非安全的，毕竟Unsafe拥有着类似于C的指针操作，因此总是不应该首先使用Unsafe类，Java官方也不建议直接使用的Unsafe类，但我们还是很有必要了解该类，因为Java中CAS操作的执行依赖于Unsafe类的方法，注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务<br>CAS是一些CPU直接支持的指令，也就是我们前面分析的无锁操作，在Java中无锁操作CAS基于以下3个方法实现：</p>
<pre><code>//第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，
//expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。
public final native boolean compareAndSwapObject(Object o, long offset,Object expected, Object x);                                                                                                  

public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x);

public final native boolean compareAndSwapLong(Object o, long offset,long expected,long x);
</code></pre><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://blog.csdn.net/mmoren/article/details/79185862" target="_blank" rel="noopener">JAVA中的CAS</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/29/java-rsa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/29/java-rsa/" itemprop="url">Java中使用RSA/AES加解密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-29T16:30:46+08:00">
                2019-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>RSA加密明文最大长度245字节，解密要求密文最大长度为256字节，所以在加密和解密的过程中需要分块进行</strong>。(RSA密钥长度随着保密级别提高，增加很快)<br>RSA加密对明文的长度是有限制的，如果加密数据过大会抛出如下异常：</p>
<pre><code>Exception in thread &quot;main&quot; javax.crypto.IllegalBlockSizeException: Data must not be longer than 117 bytes  
at com.sun.crypto.provider.RSACipher.a(DashoA13*..)  
at com.sun.crypto.provider.RSACipher.engineDoFinal(DashoA13*..)  
at javax.crypto.Cipher.doFinal(DashoA13*..) 
</code></pre><p>1.密钥长度<br>rsa算法初始化的时候一般要填入密钥长度,在96-2048bits间<br>(1)为啥下限是96bits(12bytes)?因为加密1byte的明文,需要至少1+11=12bytes的密钥(不懂?看下面的明文长度),低于下限96bits时,一个byte都加密不了,当然没意义啦<br>(2)为啥上限是2048(256bytes)?这是算法本身决定的。另RSA密钥长度随着保密级别提高，增加很快</p>
<p>2.明文长度<br>明文长度(bytes) &lt;= 密钥长度(bytes)-11.这样的话,对于上限密钥长度1024bits能加密的明文上限就是117bytes了.<br>所以就出现了分片加密,网上很流行这个版本.很简单,如果明文长度大于那个最大明文长度了,我就分片吧,保证每片都别超过那个值就是了.<br>片数=(明文长度(bytes)/(密钥长度(bytes)-11))的整数部分+1,就是不满一片的按一片算</p>
<p>3.密文长度<br>密文长度等于密钥长度.当然这是不分片情况下的.<br>分片后,密文长度=密钥长度*片数</p>
<p>例如96bits的密钥,明文4bytes<br>每片明文长度=96/8-11=1byte,片数=4,密文长度=96/8*4=48bytes</p>
<p>又例如128bits的密钥,明文8bytes<br>每片明文长度=128/8-11=5bytes,片数=8/5取整+1=2,密文长度=128/8*2=32</p>
<p>注意,对于指定长度的明文,其密文长度与密钥长度非正比关系.如4bytes的明文,在最短密钥96bites是,密文长度48bytes,128bits米密钥时,密文长度为16bytes,1024bits密钥时,密文长度128bytes.<br>因为分片越多,密文长度显然会变大,所以有人说,那就一直用1024bits的密钥吧…拜托,现在的机器算1024bits的密钥还是要点时间滴,别以为你的cpu很牛逼…那么选个什么值比较合适呢?个人认为是600bits,因为我们对于一个字符串的加密,一般不是直接加密,而是将字符串hash 后,对hash值加密.现在的hash值一般都是4bytes,很少有8bytes,几十年内应该也不会超过64bytes.那就用64bytes算吧, 密钥长度就是(64+11)*8=600bits了.</p>
<p>RSAUtils.java</p>
<pre><code>package security;

import java.io.ByteArrayOutputStream;
import java.security.Key;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.HashMap;
import java.util.Map;

import javax.crypto.Cipher;

/** *//**
 * RSA公钥/私钥/签名工具包
 * 
 * 罗纳德·李维斯特（Ron [R]ivest）、阿迪·萨莫尔（Adi [S]hamir）和伦纳德·阿德曼（Leonard [A]dleman）
 * 
 * 字符串格式的密钥在未在特殊说明情况下都为BASE64编码格式&lt;br/&gt;
 * 由于非对称加密速度极其缓慢，一般文件不使用它来加密而是使用对称加密，&lt;br/&gt;
 * 非对称加密算法可以用来对对称加密的密钥加密，这样保证密钥的安全也就保证了数据的安全
 * 
 * @author IceWee
 * @date 2012-4-26
 * @version 1.0
 */
public class RSAUtils {

    /** *//**
     * 加密算法RSA
     */
    public static final String KEY_ALGORITHM = &quot;RSA&quot;;

    /** *//**
     * 签名算法
     */
    public static final String SIGNATURE_ALGORITHM = &quot;MD5withRSA&quot;;

    /** *//**
     * 获取公钥的key
     */
    private static final String PUBLIC_KEY = &quot;RSAPublicKey&quot;;

    /** *//**
     * 获取私钥的key
     */
    private static final String PRIVATE_KEY = &quot;RSAPrivateKey&quot;;

    /** *//**
     * RSA最大加密明文大小
     */
    private static final int MAX_ENCRYPT_BLOCK = 117;

    /** *//**
     * RSA最大解密密文大小
     */
    private static final int MAX_DECRYPT_BLOCK = 128;

    /** *//**
     * 生成密钥对(公钥和私钥)
     * 
     * @return
     * @throws Exception
     */
    public static Map&lt;String, Object&gt; genKeyPair() throws Exception {
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM);
        keyPairGen.initialize(1024);
        KeyPair keyPair = keyPairGen.generateKeyPair();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
        Map&lt;String, Object&gt; keyMap = new HashMap&lt;String, Object&gt;(2);
        keyMap.put(PUBLIC_KEY, publicKey);
        keyMap.put(PRIVATE_KEY, privateKey);
        return keyMap;
    }

    /** *//**
     * 用私钥对信息生成数字签名
     * 
     * @param data 已加密数据
     * @param privateKey 私钥(BASE64编码)
     * 
     * @return
     * @throws Exception
     */
    public static String sign(byte[] data, String privateKey) throws Exception {
        byte[] keyBytes = Base64Utils.decode(privateKey);
        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
        PrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec);
        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);
        signature.initSign(privateK);
        signature.update(data);
        return Base64Utils.encode(signature.sign());
    }

    /** *//**
     * 校验数字签名
     * 
     * @param data 已加密数据
     * @param publicKey 公钥(BASE64编码)
     * @param sign 数字签名
     * 
     * @return
     * @throws Exception
     * 
     */
    public static boolean verify(byte[] data, String publicKey, String sign)
            throws Exception {
        byte[] keyBytes = Base64Utils.decode(publicKey);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
        PublicKey publicK = keyFactory.generatePublic(keySpec);
        Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM);
        signature.initVerify(publicK);
        signature.update(data);
        return signature.verify(Base64Utils.decode(sign));
    }

    /** *//**
     * &lt;P&gt;
     * 私钥解密
     * &lt;/p&gt;
     * 
     * @param encryptedData 已加密数据
     * @param privateKey 私钥(BASE64编码)
     * @return
     * @throws Exception
     */
    public static byte[] decryptByPrivateKey(byte[] encryptedData, String privateKey)
            throws Exception {
        byte[] keyBytes = Base64Utils.decode(privateKey);
        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
        Key privateK = keyFactory.generatePrivate(pkcs8KeySpec);
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, privateK);
        int inputLen = encryptedData.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段解密
        while (inputLen - offSet &gt; 0) {
            if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) {
                cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_DECRYPT_BLOCK;
        }
        byte[] decryptedData = out.toByteArray();
        out.close();
        return decryptedData;
    }

    /** *//**
     * &lt;p&gt;
     * 公钥解密
     * &lt;/p&gt;
     * 
     * @param encryptedData 已加密数据
     * @param publicKey 公钥(BASE64编码)
     * @return
     * @throws Exception
     */
    public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey)
            throws Exception {
        byte[] keyBytes = Base64Utils.decode(publicKey);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
        Key publicK = keyFactory.generatePublic(x509KeySpec);
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.DECRYPT_MODE, publicK);
        int inputLen = encryptedData.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段解密
        while (inputLen - offSet &gt; 0) {
            if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) {
                cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_DECRYPT_BLOCK;
        }
        byte[] decryptedData = out.toByteArray();
        out.close();
        return decryptedData;
    }

    /** *//**
     * &lt;p&gt;
     * 公钥加密
     * &lt;/p&gt;
     * 
     * @param data 源数据
     * @param publicKey 公钥(BASE64编码)
     * @return
     * @throws Exception
     */
    public static byte[] encryptByPublicKey(byte[] data, String publicKey)
            throws Exception {
        byte[] keyBytes = Base64Utils.decode(publicKey);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
        Key publicK = keyFactory.generatePublic(x509KeySpec);
        // 对数据加密
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE, publicK);
        int inputLen = data.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段加密
        while (inputLen - offSet &gt; 0) {
            if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) {
                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(data, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_ENCRYPT_BLOCK;
        }
        byte[] encryptedData = out.toByteArray();
        out.close();
        return encryptedData;
    }

    /** *//**
     * &lt;p&gt;
     * 私钥加密
     * &lt;/p&gt;
     * 
     * @param data 源数据
     * @param privateKey 私钥(BASE64编码)
     * @return
     * @throws Exception
     */
    public static byte[] encryptByPrivateKey(byte[] data, String privateKey)
            throws Exception {
        byte[] keyBytes = Base64Utils.decode(privateKey);
        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);
        Key privateK = keyFactory.generatePrivate(pkcs8KeySpec);
        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());
        cipher.init(Cipher.ENCRYPT_MODE, privateK);
        int inputLen = data.length;
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int offSet = 0;
        byte[] cache;
        int i = 0;
        // 对数据分段加密
        while (inputLen - offSet &gt; 0) {
            if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) {
                cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK);
            } else {
                cache = cipher.doFinal(data, offSet, inputLen - offSet);
            }
            out.write(cache, 0, cache.length);
            i++;
            offSet = i * MAX_ENCRYPT_BLOCK;
        }
        byte[] encryptedData = out.toByteArray();
        out.close();
        return encryptedData;
    }

    /** *//**
     * &lt;p&gt;
     * 获取私钥
     * &lt;/p&gt;
     * 
     * @param keyMap 密钥对
     * @return
     * @throws Exception
     */
    public static String getPrivateKey(Map&lt;String, Object&gt; keyMap)
            throws Exception {
        Key key = (Key) keyMap.get(PRIVATE_KEY);
        return Base64Utils.encode(key.getEncoded());
    }

    /** *//**
     * &lt;p&gt;
     * 获取公钥
     * &lt;/p&gt;
     * 
     * @param keyMap 密钥对
     * @return
     * @throws Exception
     */
    public static String getPublicKey(Map&lt;String, Object&gt; keyMap)
            throws Exception {
        Key key = (Key) keyMap.get(PUBLIC_KEY);
        return Base64Utils.encode(key.getEncoded());
    }

}
</code></pre><p>Base64Utils.java</p>
<pre><code>package security;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;

import it.sauronsoftware.base64.Base64;

/** *//**
 * &lt;p&gt;
 * BASE64编码解码工具包
 * &lt;/p&gt;
 * &lt;p&gt;
 * 依赖javabase64-1.3.1.jar
 * &lt;/p&gt;
 * 
 * @author IceWee
 * @date 2012-5-19
 * @version 1.0
 */
public class Base64Utils {

    /** *//**
     * 文件读取缓冲区大小
     */
    private static final int CACHE_SIZE = 1024;

    /** *//**
     * &lt;p&gt;
     * BASE64字符串解码为二进制数据
     * &lt;/p&gt;
     * 
     * @param base64
     * @return
     * @throws Exception
     */
    public static byte[] decode(String base64) throws Exception {
        return Base64.decode(base64.getBytes());
    }

    /** *//**
     * &lt;p&gt;
     * 二进制数据编码为BASE64字符串
     * &lt;/p&gt;
     * 
     * @param bytes
     * @return
     * @throws Exception
     */
    public static String encode(byte[] bytes) throws Exception {
        return new String(Base64.encode(bytes));
    }

    /** *//**
     * &lt;p&gt;
     * 将文件编码为BASE64字符串
     * &lt;/p&gt;
     * &lt;p&gt;
     * 大文件慎用，可能会导致内存溢出
     * &lt;/p&gt;
     * 
     * @param filePath 文件绝对路径
     * @return
     * @throws Exception
     */
    public static String encodeFile(String filePath) throws Exception {
        byte[] bytes = fileToByte(filePath);
        return encode(bytes);
    }

    /** *//**
     * &lt;p&gt;
     * BASE64字符串转回文件
     * &lt;/p&gt;
     * 
     * @param filePath 文件绝对路径
     * @param base64 编码字符串
     * @throws Exception
     */
    public static void decodeToFile(String filePath, String base64) throws Exception {
        byte[] bytes = decode(base64);
        byteArrayToFile(bytes, filePath);
    }

    /** *//**
     * &lt;p&gt;
     * 文件转换为二进制数组
     * &lt;/p&gt;
     * 
     * @param filePath 文件路径
     * @return
     * @throws Exception
     */
    public static byte[] fileToByte(String filePath) throws Exception {
        byte[] data = new byte[0];
        File file = new File(filePath);
        if (file.exists()) {
            FileInputStream in = new FileInputStream(file);
            ByteArrayOutputStream out = new ByteArrayOutputStream(2048);
            byte[] cache = new byte[CACHE_SIZE];
            int nRead = 0;
            while ((nRead = in.read(cache)) != -1) {
                out.write(cache, 0, nRead);
                out.flush();
            }
            out.close();
            in.close();
            data = out.toByteArray();
         }
        return data;
    }

    /** *//**
     * &lt;p&gt;
     * 二进制数据写文件
     * &lt;/p&gt;
     * 
     * @param bytes 二进制数据
     * @param filePath 文件生成目录
     */
    public static void byteArrayToFile(byte[] bytes, String filePath) throws Exception {
        InputStream in = new ByteArrayInputStream(bytes);   
        File destFile = new File(filePath);
        if (!destFile.getParentFile().exists()) {
            destFile.getParentFile().mkdirs();
        }
        destFile.createNewFile();
        OutputStream out = new FileOutputStream(destFile);
        byte[] cache = new byte[CACHE_SIZE];
        int nRead = 0;
        while ((nRead = in.read(cache)) != -1) {   
            out.write(cache, 0, nRead);
            out.flush();
        }
        out.close();
        in.close();
    }


}
</code></pre><p>RSATester.java</p>
<pre><code>package security;

import java.util.Map;

public class RSATester {

    static String publicKey;
    static String privateKey;

    static {
        try {
            Map&lt;String, Object&gt; keyMap = RSAUtils.genKeyPair();
            publicKey = RSAUtils.getPublicKey(keyMap);
            privateKey = RSAUtils.getPrivateKey(keyMap);
            System.err.println(&quot;公钥: \n\r&quot; + publicKey);
            System.err.println(&quot;私钥： \n\r&quot; + privateKey);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {
        test();
        testSign();
    }

    static void test() throws Exception {
        System.err.println(&quot;公钥加密——私钥解密&quot;);
        String source = &quot;这是一行没有任何意义的文字，你看完了等于没看，不是吗？&quot;;
        System.out.println(&quot;\r加密前文字：\r\n&quot; + source);
        byte[] data = source.getBytes();
        byte[] encodedData = RSAUtils.encryptByPublicKey(data, publicKey);
        System.out.println(&quot;加密后文字：\r\n&quot; + new String(encodedData));
        byte[] decodedData = RSAUtils.decryptByPrivateKey(encodedData, privateKey);
        String target = new String(decodedData);
        System.out.println(&quot;解密后文字: \r\n&quot; + target);
    }

    static void testSign() throws Exception {
        System.err.println(&quot;私钥加密——公钥解密&quot;);
        String source = &quot;这是一行测试RSA数字签名的无意义文字&quot;;
        System.out.println(&quot;原文字：\r\n&quot; + source);
        byte[] data = source.getBytes();
        byte[] encodedData = RSAUtils.encryptByPrivateKey(data, privateKey);
        System.out.println(&quot;加密后：\r\n&quot; + new String(encodedData));
        byte[] decodedData = RSAUtils.decryptByPublicKey(encodedData, publicKey);
        String target = new String(decodedData);
        System.out.println(&quot;解密后: \r\n&quot; + target);
        System.err.println(&quot;私钥签名——公钥验证签名&quot;);
        String sign = RSAUtils.sign(encodedData, privateKey);
        System.err.println(&quot;签名:\r&quot; + sign);
        boolean status = RSAUtils.verify(encodedData, publicKey, sign);
        System.err.println(&quot;验证结果:\r&quot; + status);
    }

}
</code></pre><h4 id="AES对称加密和解密"><a href="#AES对称加密和解密" class="headerlink" title="AES对称加密和解密"></a>AES对称加密和解密</h4><pre><code>package demo.security;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.Scanner;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import sun.misc.BASE64Decoder;
import sun.misc.BASE64Encoder;

/*
 * AES对称加密和解密
 */
public class SymmetricEncoder {
  /*
   * 加密
   * 1.构造密钥生成器
   * 2.根据ecnodeRules规则初始化密钥生成器
   * 3.产生密钥
   * 4.创建和初始化密码器
   * 5.内容加密
   * 6.返回字符串
   */
    public static String AESEncode(String encodeRules,String content){
        try {
            //1.构造密钥生成器，指定为AES算法,不区分大小写
            KeyGenerator keygen=KeyGenerator.getInstance(&quot;AES&quot;);
            //2.根据ecnodeRules规则初始化密钥生成器
            //生成一个128位的随机源,根据传入的字节数组
            keygen.init(128, new SecureRandom(encodeRules.getBytes()));
              //3.产生原始对称密钥
            SecretKey original_key=keygen.generateKey();
              //4.获得原始对称密钥的字节数组
            byte [] raw=original_key.getEncoded();
            //5.根据字节数组生成AES密钥
            SecretKey key=new SecretKeySpec(raw, &quot;AES&quot;);
              //6.根据指定算法AES自成密码器
            Cipher cipher=Cipher.getInstance(&quot;AES&quot;);
              //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密解密(Decrypt_mode)操作，第二个参数为使用的KEY
            cipher.init(Cipher.ENCRYPT_MODE, key);
            //8.获取加密内容的字节数组(这里要设置为utf-8)不然内容中如果有中文和英文混合中文就会解密为乱码
            byte [] byte_encode=content.getBytes(&quot;utf-8&quot;);
            //9.根据密码器的初始化方式--加密：将数据加密
            byte [] byte_AES=cipher.doFinal(byte_encode);
          //10.将加密后的数据转换为字符串
            //这里用Base64Encoder中会找不到包
            //解决办法：
            //在项目的Build path中先移除JRE System Library，再添加库JRE System Library，重新编译后就一切正常了。
            String AES_encode=new String(new BASE64Encoder().encode(byte_AES));
          //11.将字符串返回
            return AES_encode;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        //如果有错就返加nulll
        return null;         
    }
    /*
     * 解密
     * 解密过程：
     * 1.同加密1-4步
     * 2.将加密后的字符串反纺成byte[]数组
     * 3.将加密内容解密
     */
    public static String AESDncode(String encodeRules,String content){
        try {
            //1.构造密钥生成器，指定为AES算法,不区分大小写
            KeyGenerator keygen=KeyGenerator.getInstance(&quot;AES&quot;);
            //2.根据ecnodeRules规则初始化密钥生成器
            //生成一个128位的随机源,根据传入的字节数组
            keygen.init(128, new SecureRandom(encodeRules.getBytes()));
              //3.产生原始对称密钥
            SecretKey original_key=keygen.generateKey();
              //4.获得原始对称密钥的字节数组
            byte [] raw=original_key.getEncoded();
            //5.根据字节数组生成AES密钥
            SecretKey key=new SecretKeySpec(raw, &quot;AES&quot;);
              //6.根据指定算法AES自成密码器
            Cipher cipher=Cipher.getInstance(&quot;AES&quot;);
              //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密(Decrypt_mode)操作，第二个参数为使用的KEY
            cipher.init(Cipher.DECRYPT_MODE, key);
            //8.将加密并编码后的内容解码成字节数组
            byte [] byte_content= new BASE64Decoder().decodeBuffer(content);
            /*
             * 解密
             */
            byte [] byte_decode=cipher.doFinal(byte_content);
            String AES_decode=new String(byte_decode,&quot;utf-8&quot;);
            return AES_decode;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        }

        //如果有错就返加nulll
        return null;         
    }

    public static void main(String[] args) {
        SymmetricEncoder se=new SymmetricEncoder();
        Scanner scanner=new Scanner(System.in);
        /*
         * 加密
         */
        System.out.println(&quot;使用AES对称加密，请输入加密的规则&quot;);
        String encodeRules=scanner.next();
        System.out.println(&quot;请输入要加密的内容:&quot;);
        String content = scanner.next();
        System.out.println(&quot;根据输入的规则&quot;+encodeRules+&quot;加密后的密文是:&quot;+se.AESEncode(encodeRules, content));

        /*
         * 解密
         */
        System.out.println(&quot;使用AES对称解密，请输入加密的规则：(须与加密相同)&quot;);
         encodeRules=scanner.next();
        System.out.println(&quot;请输入要解密的内容（密文）:&quot;);
         content = scanner.next();
        System.out.println(&quot;根据输入的规则&quot;+encodeRules+&quot;解密后的明文是:&quot;+se.AESDncode(encodeRules, content));
    }

}
</code></pre><p>测试结果：</p>
<pre><code>使用AES对称加密，请输入加密的规则
使用AES对称加密
请输入要加密的内容:
使用AES对称加密
根据输入的规则使用AES对称加密加密后的密文是:Z0NwrNPHghgXHN0CqjLS58YCjhMcBfeR33RWs7Lw+AY=
使用AES对称解密，请输入加密的规则：(须与加密相同)
使用AES对称加密
请输入要解密的内容（密文）:
Z0NwrNPHghgXHN0CqjLS58YCjhMcBfeR33RWs7Lw+AY=
根据输入的规则使用AES对称加密解密后的明文是:使用AES对称加密
</code></pre><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.cnblogs.com/jiafuwei/p/7054500.html" target="_blank" rel="noopener">java RSA加密解密实现（含分段加密）</a><br><a href="https://www.cnblogs.com/liunanjava/p/4297854.html" target="_blank" rel="noopener">AES对称加密和解密</a><br><a href="https://blog.csdn.net/huangxiaoguo1/article/details/78237359" target="_blank" rel="noopener">Android: AndroidKeyStore 非对称RSA加密解密</a><br><a href="https://www.cnblogs.com/zuge/p/5430362.html" target="_blank" rel="noopener">https://www.cnblogs.com/zuge/p/5430362.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/22/android-dagger2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/22/android-dagger2/" itemprop="url">android dagger2使用心得</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T16:04:50+08:00">
                2019-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>Scope 是用来确定注入的实例的生命周期的，如果没有使用 Scope 注解，Component 每次调用 Module 中的 provide 方法或 Inject 构造函数生成的工厂时都会创建一个新的实例，而使用 Scope 后可以复用之前的依赖实例。</p>
<p>在Dagger 2中<br>1、@Singleton可以保持类的单例。<br>2、@ApplicationScope注解的Component类与Applicaiton对象的生命周期一致。<br>3、@ActivityScope注解的Component类与Activity的生命周期一致<br>scope可以给我们带来“<strong>局部单例</strong>”，生命周期取决于scope自己。</p>
<p>在 Dagger 2 官方文档中我找到一句话，非常清楚地描述了@Scope的原理：<br>When a binding uses a scope annotation, that means that the component object holds a reference to the bound object until the component object itself is garbage-collected.<br>Scope 作用域的本质：Component 间接持有依赖实例的引用，把实例的作用域与 Component 绑定，它们不是同年同月同日生，但是同年同月死。</p>
<h4 id="自定义-Scope"><a href="#自定义-Scope" class="headerlink" title="自定义@Scope"></a>自定义@Scope</h4><p>对于Android，我们通常会定义一个针对整个Activity的注解,通过仿照@Singleton</p>
<pre><code>@Scope
@Documented
@Retention(RUNTIME)
public @interface ActivityScope {}
</code></pre><p>你可能会发现，这个自定义的@Scope和@Singleton代码完全一样，具有实现单例模式的功能。那干嘛还自定义@Scope，好处如下：</p>
<blockquote>
<p>更好的管理ApplicationComponent和Module之间的关系，Component和Component之间的依赖和继承关系。如果关系不匹配，在编译期间会报错，详细下面会介绍。<br>代码可读性，让程序猿更好的了解Module中创建的类实例的使用范围。</p>
</blockquote>
<h4 id="使用-Scope的一些经验："><a href="#使用-Scope的一些经验：" class="headerlink" title="使用@Scope的一些经验："></a>使用@Scope的一些经验：</h4><p>1、<strong>@Component关联的@Module中的任何一个@Provides有@scope，则该整个@Component要加上这个scope</strong>。否则在暴露或者注入时（不暴露且不注入时，既不使用它构造对象时，不报错），会有如下错误:</p>
<pre><code>Error:(13, 1) 错误: cn.xuexuan.newui.di.component.ActivityComponent (unscoped) may not reference scoped bindings:
@Singleton @Provides android.app.Activity cn.xuexuan.newui.di.module.ActivityModule.getActivity()
</code></pre><p>2、@Component的dependencies与@Component自身的scope不能相同，即<strong>dependencies组件之间的scope不能相同</strong>,否则出现下面错误<br>3、<strong>@Singleton的组件不能依赖其他scope的组件</strong>，但是其他scope的组件可以依赖@Singleton组件。否则出现下面错误<br>4、<strong>没有scope的不能依赖有scope的组件</strong>。否则出现下面错误:</p>
<pre><code>Error:(21, 1) 错误: com.android.example.devsummit.archdemo.di.component.MyTestComponent (unscoped) cannot depend on scoped components:
@com.android.example.devsummit.archdemo.di.scope.ActivityScope com.android.example.devsummit.archdemo.di.component.MyTestComponentX
</code></pre><p>5、<strong>一个component不能同时有多个scope(Subcomponent除外)</strong>，否则出现下面的错误</p>
<pre><code>Error:Execution failed for task ‘:app:compileDebugJavaWithJavac’.
java.lang.IllegalArgumentException: com.android.example.devsummit.archdemo.di.component.MyTestComponent was annotated with more than one @Scope annotation
</code></pre><h2 id="Binds"><a href="#Binds" class="headerlink" title="@Binds"></a>@Binds</h2><p>@Binds：可以理解为关联，首先它是跟@Provides使用地方是一样的，不同的在于<strong>@Provides 注解的方法都是有具体实现的，而@Binds修饰的只有方法定义，并没有具体的实现的，在方法定义中方法参数必须是 返回值的实现类</strong>。这样创建实体类的地方就不用在Modules 中实现了，例如：</p>
<pre><code>@Binds
@Singleton
abstract AccountManagerDelegate accountManagerDelegate(AccountManagerDelegateImpl delegate);
</code></pre><p>Module 中不一定要具体实现，可以用@Binds关联实体，这样在编译过程中会自动创建Fractory 以及实现的，AccountManagerDelegate中还可以使用该Module中 @Provides 提供的实体类</p>
<h2 id="BindsInstance"><a href="#BindsInstance" class="headerlink" title="@BindsInstance"></a>@BindsInstance</h2><p>Component 可以在<strong>创建 Component 的时候绑定依赖实例</strong>，用以注入。这就是@BindsInstance注解的作用，只能在 Component.Builder 中使用。</p>
<pre><code>@Module
public final class HomeActivityModule {
    private final HomeActivity activity;

    public HomeActivityModule(HomeActivity activity) {
        this.activity = activity;
    }

    @Provides
    @ActivityScope  // 自定义作用域
    Activity provideActivity() {
        return activity;
    }
}
</code></pre><p>而使用@BindsInstance的话会更加简单:</p>
<pre><code>@ActivityScope
@Component
public interface HomeActivityComponent {
    @Component.Builder
    interface Builder {
        @BindsInstance
        Builder activity(Activity activity);
        HomeActivityComponent build();
    }
}
</code></pre><p>注意在调用build()创建 Component 之前，所有@BindsInstance方法必须先调用。上面例子中 HomeActivityComponent 还可以注入 Activity 类型的依赖，但是不能注入 HomeActivity，因为 <strong>Dagger 2 是使用具体类型作为依据的</strong>（也就是只能使用@Inject Activity activity而不是@Inject HomeActivity activity）。</p>
<p>如果@BindsInstance方法的参数可能为 null，需要再用@Nullable标记，同时标注 Inject 的地方也需要用@Nullable标记。这时 Builder 也可以不调用@BindsInstance方法，这样 Component 会默认设置 instance 为 null</p>
<p>注意：<strong>dagger.android</strong> 扩展库可以极大地简化在 Android 项目中使用 Dagger 2 的过程，但是还是有些限制，<strong>SubComponent.Builder 不能自定义 @BindsInstance 方法，SubCompoennt 的 Module 不能有含参数的构造函数</strong>，否则AndroidInjection.inject(this)在创建 SubComponent 时无法成功。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/9703a931c7e7" target="_blank" rel="noopener">Dagger 2 完全解析</a><br><a href="https://blog.csdn.net/mq2553299/article/details/77485800" target="_blank" rel="noopener">打破Dagger2使用窘境：Dagger-Android详解</a>（<a href="https://github.com/qingmei2/Sample_dagger2）" target="_blank" rel="noopener">https://github.com/qingmei2/Sample_dagger2）</a><br><a href="https://github.com/AnyLifeZLB/MVP-Dagger2-Rxjava2" target="_blank" rel="noopener">dagger组件化</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Shuming Zhao">
            
              <p class="site-author-name" itemprop="name">Shuming Zhao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuming Zhao</span>

  
</div>

<div class="powered-by"><i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人，
<span id="busuanzi_container_site_pv">访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
</span>
</div>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
