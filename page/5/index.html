<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<meta name="baidu-site-verification" content="1ilOhMWnNE">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/">





  <title>Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
	

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/ds-hashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/16/ds-hashmap/" itemprop="url">HashMap实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-16T15:26:44+08:00">
                2019-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK8的HashMap源码进行分析。</p>
<h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><p>　　在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能</p>
<p>　　 <strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)<br>　　<strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)<br>　　<strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。<br>　　<strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。</p>
<p>　　我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构和链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。</p>
<p>　　比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。</p>
<p>　　　　　　　　<strong>存储位置 = f(关键字)</strong></p>
<p>　　其中，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：</p>
<p><img src="/2019/10/16/ds-hashmap/hash-insert.png" alt></p>
<p>　　查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，<strong>当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞</strong>。哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而<strong>HashMap即是采用了链地址法，也就是数组+链表+红黑树的方式</strong>。</p>
<h2 id="HashMap底层存储结构"><a href="#HashMap底层存储结构" class="headerlink" title="HashMap底层存储结构"></a>HashMap底层存储结构</h2><p>HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做一个Entry。这些Entry分散存储在一个数组当中，这个数组就是HashMap的主干。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The table, initialized on first use, and resized as</span><br><span class="line"> * necessary. When allocated, length is always a power of two.</span><br><span class="line"> * (We also tolerate length zero in some operations to allow</span><br><span class="line"> * bootstrapping mechanics that are currently not needed.)</span><br><span class="line"> */</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Basic hash bin node, used for most entries.  (See below for</span><br><span class="line"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span><br><span class="line"> */</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line">    public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125;</span><br><span class="line">    public final V setValue(V newValue) &#123; ... &#125;</span><br><span class="line">    public final boolean equals(Object o) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为table数组的长度是有限的，再好的hash函数也会出现index冲突的情况，所以我们用<strong>链表</strong>来解决这个问题，table数组的每一个元素不只是一个Entry对象，也是一个链表的头节点，每一个Entry对象通过Next指针指向下一个Entry节点。当新来的Entry映射到冲突数组位置时，只需要插入对应的链表即可。</p>
<p>需要注意的是：新来的Entry节点插入链表时，会插在链表的头部，因为HashMap的发明者认为，后插入的Entry被查找的可能性更大。</p>
<p>HashMap中的table数组如下所示：</p>
<p><img src="/2019/10/16/ds-hashmap/hashmap-table.png" alt></p>
<p>所以，HashMap是<strong>数组+链表+红黑树</strong>（在Java 8中为了优化Entry的查找性能，新加了红黑树部分）实现的。</p>
<h2 id="Put方法原理"><a href="#Put方法原理" class="headerlink" title="Put方法原理"></a>Put方法原理</h2><p>调用hashMap.put(“str”, 1)，将会在HashMap的table数组中插入一个Key为“str”的元素，这时候需要我们用一个hash()函数来确定Entry的插入位置，而每种数据类型有自己的hashCode()函数，比如String类型的hashCode()函数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static int hashCode(byte[] value) &#123;</span><br><span class="line">    int h = 0;</span><br><span class="line">    for (byte v : value) &#123;</span><br><span class="line">        h = 31 * h + (v &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">    return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，put()函数的执行路径是这样的：</p>
<ol>
<li>首先put(“str”, 1)会调用HashMap的hash(“str”)方法。</li>
<li>在hash()内部，会调用String(Latin1)内部的hashcode()获取字符串”str”的hashcode。</li>
<li>“str”的hashcode被返回给put()，put()通过一定计算得到最终的插入位置index。</li>
<li>最后将这个Entry插入到table的index位置。</li>
</ol>
<p>这里就出现了两个问题，问题1: 在put()里怎样得到插入位置index？问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？</p>
<h3 id="问题1-在put-里怎样得到插入位置index？"><a href="#问题1-在put-里怎样得到插入位置index？" class="headerlink" title="问题1: 在put()里怎样得到插入位置index？"></a>问题1: 在put()里怎样得到插入位置index？</h3><p>对于不同的hash码我们希望它被插入到不同的位置，所以我们首先会想到对数组长度的取模运算，但是由于取模运算的效率很低，所以HashMap的发明者用<strong>位运算</strong>替代了取模运算。</p>
<p>在put()里是通过如下的语句得到插入位置的(<strong>key的哈希值与map长度-1相与</strong>)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash(key) &amp; (Length - 1)</span><br></pre></td></tr></table></figure></p>
<p>其中Length是table数组的长度。为了实现和取模运算相同的功能，这里要求(Length - 1)这部分的二进制表示全为1，我们用HashMap的默认初始长度16举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设&quot;str&quot;的hash吗为: 1001 0110 1011 1110 1101 0010 1001 0101</span><br><span class="line"></span><br><span class="line">Length - 1 = 15 : 1111</span><br><span class="line"></span><br><span class="line">hash(&quot;str&quot;) &amp; (Length - 1) = 0101</span><br></pre></td></tr></table></figure>
<p>如果(Length - 1)这部分不全为1，假如Length是10，那么Length - 1 = 9 ：1001 那么无论再和任何hash码做与操作，中间两位数都会是0，这样就会出现大量不同的hash码被映射到相同位置的情况。</p>
<p>所以，<strong>在HashMap中table数组的默认长度是16，并且要求每次自动扩容或者手动扩容时，长度都必须是2的幂。</strong></p>
<h3 id="问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？"><a href="#问题2-为什么会调用HashMap的hash-函数，直接调用String的hashcode-不好吗？" class="headerlink" title="问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？"></a>问题2: 为什么会调用HashMap的hash()函数，直接调用String的hashcode()不好吗？</h3><p>HashMap中的hash()函数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>HashMap中的hash()函数是将得到hashcode做进一步处理，它将hashcode的高16位和低16位进行异或操作</strong>，这样做的目的是：在table的长度比较小的情况下，也能保证hashcode的高位参与到地址映射的计算当中，同时不会有太大的开销。</p>
<p>综上所述：从hashcode计算得到table索引的计算过程如下所示：</p>
<p><img src="/2019/10/16/ds-hashmap/hash-process.png" alt></p>
<p>put()方法的执行过程如下所示：</p>
<p><img src="/2019/10/16/ds-hashmap/hash-put.png" alt></p>
<h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><p>在HashMap中有一下两个属性和扩容相关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int threshold;</span><br><span class="line">final float loadFactor;</span><br></pre></td></tr></table></figure></p>
<p>其中threshold = Length * loadFactor，Length表示table数组的长度（默认值是16），<strong>loadFactor为负载因子（默认值是0.75）</strong>，阀值threshold表示当table数组中存储的元素超过这个阀值的时候，就需要扩容了。以默认长度16，和默认负载因子0.75为例，threshold = 16 * 0.75 = 12，即当table数组中存储的元素个数超过12个的时候，table数组就该扩容了。</p>
<p>当然Java中的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，然后将旧数组中的元素经过重新计算放到新数组中，那么怎样对旧元素进行重新映射呢？</p>
<p>其实很简单，由于我们在扩容时，是使用2的幂扩展，即数组的长度扩大到原来的2倍, 4倍, 8倍…，因此<strong>在resize时(Length - 1)这部分相当于在高位新增一个或多个1bit</strong>，我们以扩大到原来的两倍为例说明：</p>
<p><img src="/2019/10/16/ds-hashmap/rehash1.png" alt></p>
<p>(a)中n为16，(b)中n扩大到两倍为32，相当于(n - 1)这部分的高位多了一个1, 然后和原hash码作与操作，<strong>这样元素在数组中映射的位置要么不变，要不向后移动16个位置</strong>：</p>
<p><img src="/2019/10/16/ds-hashmap/rehash2.png" alt></p>
<p>因此，我们在扩充HashMap的时候，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="/2019/10/16/ds-hashmap/rehash3.png" alt></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中resize的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<p>JDK 1.8 以后哈希表的 添加、删除、查找、扩容方法都增加了一种 节点为 TreeNode 的情况：</p>
<ul>
<li>添加时，当桶中链表个数超过 8 时会转换成红黑树；</li>
<li>删除、扩容时，如果桶中结构为红黑树，并且树中元素个数太少的话，会进行修剪或者直接还原成链表结构；</li>
<li>查找时即使哈希函数不优，大量元素集中在一个桶中，由于有红黑树结构，性能也不会差。</li>
</ul>
<h2 id="HashMap死锁形成原理"><a href="#HashMap死锁形成原理" class="headerlink" title="HashMap死锁形成原理"></a>HashMap死锁形成原理</h2><p>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用线程安全的ConcurrentHashMap。</p>
<p>要理解HashMap死锁形成的原理，我们要对HashMap的resize里的transfer过程有所了解，transfer过程是将旧数组中的元素复制到新数组中，在Java 8之前，复制过程会导致链表倒置，这也是形成死锁的重要原因（Java 8中已经不会倒置），transfer的基本过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 新建节点e指向当前节点，新建节点next指向e.next</span><br><span class="line">2. 将e.next指向新数组中指定位置newTable[i]</span><br><span class="line">3. newTable[i] = e</span><br><span class="line">4. e = next</span><br></pre></td></tr></table></figure></p>
<p>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现在有链表1-&gt;2-&gt;3，要将它复制到新数组的newTable[i]位置</span><br><span class="line">1. Node e = 1, next = e.next;</span><br><span class="line">2. e.next = newTable[i];</span><br><span class="line">3. newTable[i] = e;</span><br><span class="line">4. e = next, next = e.next;</span><br><span class="line">执行完后会得到这样的结果：</span><br><span class="line">newTable[i]=3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure></p>
<p>死锁会在这种情况产生：两个线程同时往HashMap里放Entry，同时HashMap正好需要扩容，如果一个线程已经完成了transfer过程，而另一个线程不知道，并且又要进行transfer的时候，死锁就会形成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在Thread1已将完成了transfer，newTable[i]=3-&gt;2-&gt;1</span><br><span class="line">在Thread2中:</span><br><span class="line">Node e = 1, next = e.next;</span><br><span class="line">e.next = newTable[i]    : 1 -&gt; newTable[i]=3</span><br><span class="line">newTable[i] = e         : newTable[i] = 1-&gt;3-&gt;2-&gt;1  //这时候链表换已经形成了</span><br></pre></td></tr></table></figure></p>
<p>在形成链表换以后再对HashMap进行Get操作时，就会形成死循环。</p>
<p>在Java 8中对这里进行了优化，链表复制到新数组时并不会倒置，不会因为多个线程put导致死循环，但是还有很多弊端，比如数据丢失等，因此多线程情况下还是建议使用ConcurrentHashMap。</p>
<h2 id="HashMap和Hashtable有什么区别"><a href="#HashMap和Hashtable有什么区别" class="headerlink" title="HashMap和Hashtable有什么区别"></a>HashMap和Hashtable有什么区别</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
<p><img src="/2019/10/16/ds-hashmap/hashmap-extends-tree.png" alt></p>
<p>Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为<strong>ConcurrentHashMap引入了分段锁</strong>。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li>
<li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li>
<li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li>
<li>JDK1.8引入红黑树大程度优化了HashMap的性能。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xinxingastro.github.io/2018/05/11/Java/HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">HashMap底层实现原理</a><br><a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">HashMap实现原理及源码分析</a><br><a href="https://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">ConcurrentHashMap实现原理及源码分析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/android-webview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/android-webview/" itemprop="url">Android WebView 性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-26T09:44:09+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="离线缓存"><a href="#离线缓存" class="headerlink" title="离线缓存"></a>离线缓存</h2><p>这个比较容易，开启webView的缓存功能就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WebSettings settings = webView.getSettings();</span><br><span class="line">settings.setAppCacheEnabled(true);</span><br><span class="line">settings.setDatabaseEnabled(true);</span><br><span class="line">settings.setDomStorageEnabled(true);//开启DOM缓存，关闭的话H5自身的一些操作是无效的</span><br><span class="line">settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">settings.setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure></p>
<p>这边我们通过setCacheMode方法来设置WebView的缓存策略，WebSettings.LOAD_DEFAULT是默认的缓存策略，它在缓存可获取并且没有过期的情况下加载缓存，否则通过网络获取资源。这样的话可以减少页面的网络请求次数，那我们如何在离线的情况下也能打开页面呢，这里我们在加载页面的时候可以通过判断网络状态，<strong>在无网络的情况下更改webview的缓存策略</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectivityManager cm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">NetworkInfo info = cm.getActiveNetworkInfo();</span><br><span class="line">if(info.isAvailable())</span><br><span class="line">&#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_DEFAULT);</span><br><span class="line">&#125;else </span><br><span class="line">&#123;</span><br><span class="line">    settings.setCacheMode(WebSettings.LOAD_CACHE_ONLY);//不使用网络，只加载缓存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以使我们的混合应用在没有网络的情况下也能使用一部分的功能，不至于什么都显示不了了，当然如果我们将缓存做的更好一些，在网络好的时候，比如说在WIFI状态下，去后台加载一些网页缓存起来，这样处理的话，即使在无网络情况下第一次打开某些页面的时候，也能将该页面显示出来。<br>当然缓存资源后随之会带来一个问题，那就是<strong>资源无法及时更新，WebSettings.LOAD_DEFAULT中的页面中的缓存版本好像不是很起作用，所以我们这边可能需要自己做一个缓存版本控制</strong>。这个缓存版本控制可以放在APP版本更新中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (upgrade.cacheControl &gt; cacheControl)</span><br><span class="line">&#123;</span><br><span class="line">    webView.clearCache(true);//删除DOM缓存</span><br><span class="line">    VersionUtils.clearCache(mContext.getCacheDir());//删除APP缓存</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        mContext.deleteDatabase(&quot;webview.db&quot;);//删除数据库缓存</span><br><span class="line">        mContext.deleteDatabase(&quot;webviewCache.db&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>1.可以将 Webview 的 Activity 新起一个进程，结束的时候直接System.exit(0);退出当前进程；<br>启动新进程，主要代码： AndroidManifest.xml 配置文件代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.ui.activity.Html5Activity&quot;</span><br><span class="line">    android:process=&quot;:lyl.boon.process.web&quot;&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;com.lyl.boon.ui.activity.htmlactivity&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></p>
<p>在新进程中启动 Activity ，里面传了 一个 Url：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = new Intent(&quot;com.lyl.boon.ui.activity.htmlactivity&quot;);</span><br><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">bundle.putString(&quot;url&quot;, gankDataEntity.getUrl());</span><br><span class="line">intent.putExtra(&quot;bundle&quot;,bundle);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></p>
<p>然后在 Html5Activity 的onDestory() 最后加上 System.exit(0); 杀死当前进程。</p>
<p>Android7.0系统以后，WebView相对来说是比较稳定的，无论承载WebView的容器是否在主进程，都不需要担心WebView崩溃导致应用也跟着崩溃。然后7.0以下的系统就没有这么幸运了，特别是低版本的WebView。考虑应用的稳定性，我们可以把7.0以下系统的WebView使用一个独立进程的Activity来包装，这样即使WebView崩溃了，也只是WebView所在的进程发生了崩溃，主进程还是不受影响的。</p>
<p>2.不在xml中定义 Webview ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);</span><br><span class="line">        mWebView = new WebView(getApplicationContext());</span><br><span class="line">        mWebView.setLayoutParams(params);</span><br><span class="line">        mLayout.addView(mWebView);</span><br></pre></td></tr></table></figure></p>
<p>3.在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        if (mWebView != null) &#123;</span><br><span class="line">            mWebView.loadDataWithBaseURL(null, &quot;&quot;, &quot;text/html&quot;, &quot;utf-8&quot;, null);</span><br><span class="line">			mWebView.getSettings().setJavaScriptEnabled(false);</span><br><span class="line">        	mWebView.clearFormData();</span><br><span class="line">            mWebView.clearHistory();</span><br><span class="line">			mWebView.stopLoading();</span><br><span class="line"></span><br><span class="line">            ((ViewGroup) mWebView.getParent()).removeView(mWebView);</span><br><span class="line">            mWebView.destroy();</span><br><span class="line">            mWebView = null;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>有时候一个页面资源比较多，图片，CSS，js比较多，还引用了JQuery这种庞然巨兽，从加载到页面渲染完成需要比较长的时间，有一个解决方案是<strong>将这些资源打包进APK里面，然后当页面加载这些资源的时候让它从本地获取</strong>，这样可以提升加载速度也能减少服务器压力。重写WebClient类中的shouldInterceptRequest方法，再将这个类设置给WebView。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">webView.setWebViewClient(new WebViewClient()</span><br><span class="line">&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public WebResourceResponse shouldInterceptRequest(WebView view, String url)</span><br><span class="line">    &#123;</span><br><span class="line">        if (url.contains(&quot;[tag]&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            String localPath = url.replaceFirst(&quot;^http.*[tag]\\]&quot;, &quot;&quot;);</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                InputStream is = getApplicationContext().getAssets().open(localPath);</span><br><span class="line">                Log.d(TAG, &quot;shouldInterceptRequest: localPath &quot; + localPath);</span><br><span class="line">                String mimeType = &quot;text/javascript&quot;;</span><br><span class="line">                if (localPath.endsWith(&quot;css&quot;))</span><br><span class="line">                &#123;</span><br><span class="line">                    mimeType = &quot;text/css&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                return new WebResourceResponse(mimeType, &quot;UTF-8&quot;, is);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里我们队页面中带有特殊标记的请求进行过滤替换，也就是上面代码中的[tag]，这个可以跟做后台开发的同事约定好来就行了。对图片资源或者其他资源进行替换也是可以的。补充一个小点<strong>可以通过settings.setLoadsImagesAutomatically(true);来设置在页面装载完成之后再去加载图片。</strong>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">webView.getSettings().setBlockNetworkImage(true);  </span><br><span class="line">webView.setWebChromeClient(new WebChromeClient() &#123;  </span><br><span class="line">            @Override  </span><br><span class="line">            public void onProgressChanged(WebView view, int newProgress) &#123;  </span><br><span class="line">                if (newProgress == 100) &#123;  </span><br><span class="line">                    // 网页加载完成  </span><br><span class="line">                    loadDialog.dismiss();  </span><br><span class="line">                    webView.getSettings().setBlockNetworkImage(false);  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    // 网页加载中  </span><br><span class="line">                    loadDialog.show();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h2><h3 id="SSL问题"><a href="#SSL问题" class="headerlink" title="SSL问题"></a>SSL问题</h3><p>通常情况下，通过WebView的loadUrl(String url)方法，可以顺利加载页面。但是，当load通过SSL加密的HTTPS页面时，如果这个页面的安全证书无法得到认证，WebView就会显示成空白页。</p>
<p>解决方式：<br>通过重写WebViewClient的onReceivedSslError方法来接受所有网站的证书，忽略SSL错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123;</span><br><span class="line">    handler.proceed();</span><br><span class="line">    super.onReceivedSslError(view, handler, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="低版本兼容问题"><a href="#低版本兼容问题" class="headerlink" title="低版本兼容问题"></a>低版本兼容问题</h3><p>由于现在h5大部分都是 vue的形式打包，（可能过个一两年就变了，但是万变不离其中），这个时候要注意了， 由于是webv加载的h5，在Android老的机型上  webview 内核可能不支持  最新的h5 框架，这时候 就需要我们找h5 的同学 搞事情了，  对于 vue，想要老机器不出现白屏其实也很简单，让h5的同学 做一下老版本的兼容，具体方法：</p>
<p>虽然vue-cli引入了babel对js语法进行降级，但是还是有些老旧的机型会发生各种各样的问题，这里需要引入一个叫babel-polyfill的包。所以你只需只在你引入import vue之前 import babel-polyfill进来就可以了，主要是为了让es6对个别机型做到兼容。</p>
<h2 id="301-302重定向问题"><a href="#301-302重定向问题" class="headerlink" title="301/302重定向问题"></a>301/302重定向问题</h2><p>WebView的301/302重定向问题，绝对在踩坑排行榜里名列前茅。。。随便搜了几个解决方案，要么不能满足业务需求，要么清一色没有彻底解决问题。</p>
<p><a href="https://stackoverflow.com/questions/4066438/android-webview-how-to-handle-redirects-in-app-instead-of-opening-a-browser" target="_blank" rel="noopener">https://stackoverflow.com/questions/4066438/android-webview-how-to-handle-redirects-in-app-instead-of-opening-a-browser</a><br><a href="http://blog.csdn.net/jdsjlzx/article/details/51698250" target="_blank" rel="noopener">http://blog.csdn.net/jdsjlzx/article/details/51698250</a><br><a href="http://www.cnblogs.com/pedro-neer/p/5318354.html" target="_blank" rel="noopener">http://www.cnblogs.com/pedro-neer/p/5318354.html</a><br><a href="http://www.jianshu.com/p/c01769ababfa" target="_blank" rel="noopener">http://www.jianshu.com/p/c01769ababfa</a></p>
<h3 id="301-302业务场景及白屏问题"><a href="#301-302业务场景及白屏问题" class="headerlink" title="301/302业务场景及白屏问题"></a>301/302业务场景及白屏问题</h3><p>先来分析一下业务场景。对于需要对url进行拦截以及在url中需要拼接特定参数的WebView来说，301和302发生的情景主要有以下几种：</p>
<ul>
<li>首次进入，有重定向，然后直接加载H5页面，如http跳转https</li>
<li>首次进入，有重定向，然后跳转到native页面，如扫一扫短链，然后跳转到native</li>
<li>二次加载，有重定向，跳转到native页面</li>
<li>对于考拉业务来说，还有类似登录后跳转到某个页面的需求。如我的拼团，未登录状态下点击我的拼团跳转到登录页面，登录完成后再加载我的拼团页。</li>
</ul>
<p>第一种情况属于正常情况，暂时没遇到什么坑。</p>
<p>第二种情况，会遇到<strong>WebView空白页问题</strong>，属于原始url不能拦截到native页面，但301/302后的url拦截到native页面的情况，当遇到这种情况时，需要把WebView对应的Activity结束，否则当用户从拦截后的页面返回上一个页面时，是一个WebView空白页。</p>
<p>第三种情况，也会遇到<strong>WebView空白页问题</strong>，原因在于加载的第一个页面发生了重定向到了第二个页面，第二个页面被客户端拦截跳转到native页面，那么WebView就停留在第一个页面的状态了，第一个页面显然是空白页。</p>
<p>第四种情况，会遇到<strong>无限加载登录页面的问题</strong>。考拉的登录链接是类似下面这种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://m.kaola.com/login.html?target=登录后跳转的url</span><br></pre></td></tr></table></figure></p>
<p>如果登录成功后还重新加载这个url，那么就会循环跳转到登录页面。第四点解决起来比较简单，登录成功以后拿到target后的跳转url再重新加载即可。</p>
<h3 id="301-302回退栈问题"><a href="#301-302回退栈问题" class="headerlink" title="301/302回退栈问题"></a>301/302回退栈问题</h3><p>无论是哪种重定向场景，都不可避免地会遇到回退栈的处理问题，如果处理不当，用户按返回键的时候不一定能回到重定向之前的那个页面。很多开发者在覆写WebViewClient.shouldOverrideUrlLoading()方法时，会简单地使用以下方式粗暴处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WebView.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">    	view.loadUrl(url);</span><br><span class="line">    	return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这种方法最致命的弱点就是如果不经过特殊处理，那么按返回键是没有效果的，还会停留在302之前的页面。现有的解决方案无非就几种：</p>
<ol>
<li>手动管理回退栈，遇到重定向时回退两次<a href="https://qbeenslee.com/article/android-webview-302-redirect/" target="_blank" rel="noopener">^6</a>。</li>
<li>通过HitTestResult判断是否是重定向，从而决定是否自己加载url<a href="https://www.cnblogs.com/zimengfang/p/6183869.html" target="_blank" rel="noopener">^7</a>。</li>
<li>通过设置标记位，在onPageStarted和onPageFinished分别标记变量避免重定向<a href="https://blog.csdn.net/dg_summer/article/details/78105582" target="_blank" rel="noopener">^9</a>。</li>
</ol>
<p>可以说，这几种解决方案都不是完美的，都有缺陷。以下给出301/302较优解决方案：</p>
<h3 id="解决301-302回退栈问题"><a href="#解决301-302回退栈问题" class="headerlink" title="解决301/302回退栈问题"></a>解决301/302回退栈问题</h3><p>能否结合上面的几种方案，来更加准确地判断301/302的情况呢？下面说一下本文的解决思路。在提供解决方案之前，我们需要了解一下shouldOverrideUrlLoading方法的返回值代表什么意思。</p>
<blockquote>
<p>Give the host application a chance to take over the control when a new url is about to be loaded in the current WebView. If WebViewClient is not provided, by default WebView will ask Activity Manager to choose the proper handler for the url. If WebViewClient is provided, return true means the host application handles the url, while return false means the current WebView handles the url.</p>
</blockquote>
<p>简单地说，就是返回true，那么url就已经由客户端处理了，WebView就不管了，如果返回false，那么当前的WebView实现就会去处理这个url。</p>
<p>WebView能否知道某个url是不是301/302呢？当然知道，WebView能够拿到url的请求信息和响应信息，根据header里的code很轻松就可以实现，事实正是如此，交给WebView来处理重定向(return false)，这时候按返回键，是可以正常地回到重定向之前的那个页面的。（PS：WebView在5.0以后是一个独立的apk，可以单独升级，新版本的WebView实现肯定处理了重定向问题）</p>
<p>但是，业务对url拦截有需求，肯定不能把所有的情况都交给系统WebView处理。为了解决url拦截问题，本文引入了另一种思想——通过用户的touch事件来判断重定向。下面通过代码来说明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * WebView基础类，处理一些基础的公有操作</span><br><span class="line"> *</span><br><span class="line"> * @author xingli</span><br><span class="line"> * @time 2017-12-06</span><br><span class="line"> */</span><br><span class="line">public class BaseWebView extends WebView &#123;</span><br><span class="line">    private boolean mTouchByUser;</span><br><span class="line">    public BaseWebView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line">    public BaseWebView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    public BaseWebView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void loadUrl(String url, Map&lt;String, String&gt; additionalHttpHeaders) &#123;</span><br><span class="line">        super.loadUrl(url, additionalHttpHeaders);</span><br><span class="line">        resetAllStateInternal(url);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void loadUrl(String url) &#123;</span><br><span class="line">        super.loadUrl(url);</span><br><span class="line">        resetAllStateInternal(url);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void postUrl(String url, byte[] postData) &#123;</span><br><span class="line">        super.postUrl(url, postData);</span><br><span class="line">        resetAllStateInternal(url);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void loadData(String data, String mimeType, String encoding) &#123;</span><br><span class="line">        super.loadData(data, mimeType, encoding);</span><br><span class="line">        resetAllStateInternal(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public final void loadDataWithBaseURL(String baseUrl, String data, String mimeType, String encoding,</span><br><span class="line">            String historyUrl) &#123;</span><br><span class="line">        super.loadDataWithBaseURL(baseUrl, data, mimeType, encoding, historyUrl);</span><br><span class="line">        resetAllStateInternal(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void reload() &#123;</span><br><span class="line">        super.reload();</span><br><span class="line">        resetAllStateInternal(getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isTouchByUser() &#123;</span><br><span class="line">        return mTouchByUser;</span><br><span class="line">    &#125;</span><br><span class="line">    private void resetAllStateInternal(String url) &#123;</span><br><span class="line">        if (!TextUtils.isEmpty(url) &amp;&amp; url.startsWith(&quot;javascript:&quot;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        resetAllState();</span><br><span class="line">    &#125;</span><br><span class="line">	// 加载url时重置touch状态</span><br><span class="line">    protected void resetAllState() &#123;</span><br><span class="line">        mTouchByUser = false;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">            	//用户按下到下一个链接加载之前，置为true</span><br><span class="line">                mTouchByUser = true;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void setWebViewClient(final WebViewClient client) &#123;</span><br><span class="line">        super.setWebViewClient(new WebViewClient() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">                boolean handleByChild = null != client &amp;&amp; client.shouldOverrideUrlLoading(view, url);</span><br><span class="line">            	   if (handleByChild) &#123;</span><br><span class="line">             		// 开放client接口给上层业务调用，如果返回true，表示业务已处理。</span><br><span class="line">                    return true;</span><br><span class="line">            	   &#125; else if (!isTouchByUser()) &#123;</span><br><span class="line">             		// 如果业务没有处理，并且在加载过程中用户没有再次触摸屏幕，认为是301/302事件，直接交由系统处理。</span><br><span class="line">                    return super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                	//否则，属于二次加载某个链接的情况，为了解决拼接参数丢失问题，重新调用loadUrl方法添加固有参数。</span><br><span class="line">                    loadUrl(url);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @RequiresApi(api = Build.VERSION_CODES.N)</span><br><span class="line">            @Override</span><br><span class="line">            public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123;</span><br><span class="line">                boolean handleByChild = null != client &amp;&amp; client.shouldOverrideUrlLoading(view, request);</span><br><span class="line">                if (handleByChild) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else if (!isTouchByUser()) &#123;</span><br><span class="line">                    return super.shouldOverrideUrlLoading(view, request);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    loadUrl(request.getUrl().toString());</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码解决了正常情况下的回退栈问题。</p>
<h3 id="解决业务白屏问题"><a href="#解决业务白屏问题" class="headerlink" title="解决业务白屏问题"></a>解决业务白屏问题</h3><p>为了解决白屏问题，考拉目前的解决思路和上面的回退栈问题思路有些类似，通过监听touch事件分发以及onPageFinished事件来判断是否产生白屏，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">public class KaolaWebview extends BaseWebView implements DownloadListener, Lifeful, OnActivityResultListener &#123;</span><br><span class="line">    private boolean mIsBlankPageRedirect;  //是否因重定向导致的空白页面。</span><br><span class="line">    public KaolaWebview(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    public KaolaWebview(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    public KaolaWebview(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    protected void back() &#123;</span><br><span class="line">        if (mBackStep &lt; 1) &#123;</span><br><span class="line">            mJsApi.trigger2(&quot;kaolaGoback&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            realBack();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getAction() == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            mIsBlankPageRedirect = true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    private WebViewClient mWebViewClient = new WebViewClient() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">            url = WebViewUtils.removeBlank(url);</span><br><span class="line">            //允许启动第三方应用客户端</span><br><span class="line">            if (WebViewUtils.canHandleUrl(url)) &#123;</span><br><span class="line">                boolean handleByCaller = false;</span><br><span class="line">                // 如果不是用户触发的操作，就没有必要交给上层处理了，直接走url拦截规则。</span><br><span class="line">                if (null != mIWebViewClient &amp;&amp; isTouchByUser()) &#123;</span><br><span class="line">                    handleByCaller = mIWebViewClient.shouldOverrideUrlLoading(view, url);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!handleByCaller) &#123;</span><br><span class="line">                    handleByCaller = handleOverrideUrl(url);</span><br><span class="line">                &#125;</span><br><span class="line">                return handleByCaller || super.shouldOverrideUrlLoading(view, url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    notifyBeforeLoadUrl(url);</span><br><span class="line">                    Intent intent = Intent.parseUri(url, Intent.URI_INTENT_SCHEME);</span><br><span class="line">                    intent.addCategory(Intent.CATEGORY_BROWSABLE);</span><br><span class="line">                    mContext.startActivity(intent);</span><br><span class="line">                    if (!mIsBlankPageRedirect) &#123;</span><br><span class="line">                    	// 如果遇到白屏问题，手动后退</span><br><span class="line">                        back();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    ExceptionUtils.printExceptionTrace(e);</span><br><span class="line">                &#125;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        @RequiresApi(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">        @Override</span><br><span class="line">        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) &#123;</span><br><span class="line">            return shouldOverrideUrlLoading(view, request.getUrl().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        private boolean handleOverrideUrl(final String url) &#123;</span><br><span class="line">           RouterResult result =  WebActivityRouter.startFromWeb(</span><br><span class="line">                    new IntentBuilder(mContext, url).setRouterActivityResult(new RouterActivityResult() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onActivityFound() &#123;</span><br><span class="line">                            if (!mIsBlankPageRedirect) &#123;</span><br><span class="line">                    			// 路由已经拦截到跳转到native页面，但此时可能发生了</span><br><span class="line">                    			// 301/302跳转，那么执行后退动作，防止白屏。</span><br><span class="line">                                back();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onActivityNotFound() &#123;</span><br><span class="line">                            if (mIWebViewClient != null) &#123;</span><br><span class="line">                                mIWebViewClient.onActivityNotFound();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">            return result.isSuccess();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    @Override</span><br><span class="line">    public void onPageFinished(WebView view, String url) &#123;</span><br><span class="line">        mIsBlankPageRedirect = true;</span><br><span class="line">        if (null != mIWebViewClient) &#123;</span><br><span class="line">            mIWebViewClient.onPageReallyFinish(view, url);</span><br><span class="line">        &#125;</span><br><span class="line">        super.onPageFinished(view, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本来上面的两个问题可以用同一个变量控制解决的，但由于历史代码遗留问题，目前还没有时间优化测试，这也是代码暂不公布的原因之一。</p>
<h2 id="loadUrl-url-map-方法加载带hash（带-号）的url导致刷新问题或请求头缓存问题"><a href="#loadUrl-url-map-方法加载带hash（带-号）的url导致刷新问题或请求头缓存问题" class="headerlink" title="loadUrl(url,map)方法加载带hash（带#号）的url导致刷新问题或请求头缓存问题"></a>loadUrl(url,map)方法加载带hash（带#号）的url导致刷新问题或请求头缓存问题</h2><p>1.如果调用loadUrl(url,map)方法去加载资源，那么在此调用loadUrl(ur),reload,loadUrl(url,map)造成无法刷新的问题。这个现象主要出现在Android 8.0的系统中。<br>可尝试调用如下url尝试：</p>
<pre><code>https://baike.baidu.com/item/%E9%83%8E%E5%B9%B3/58857#/
https://baike.baidu.com/item/%E9%83%8E%E5%B9%B3/58857#/?a=123
https://baike.baidu.com/item/%E9%83%8E%E5%B9%B3/58857#3
</code></pre><p>2.loadUrl(url,map) 第二个参数map中传入的数据用于请求头，此外这个请求头数据会被webview缓存下来，刷新时，请求头中的数据还是原来的，因此，不适用传入需要进程变化的“状态”信息。</p>
<p>解决方法：不要使用loadUrl(url,map)，推荐使用loadUrl(url)，如果非要传输参数，还不如在url中添加参数。</p>
<h2 id="是否应该开启硬件加速"><a href="#是否应该开启硬件加速" class="headerlink" title="是否应该开启硬件加速"></a>是否应该开启硬件加速</h2><p>由于碎片化问题太多，建议保持默认状态【默认表示由系统决定，不要手动设置】，否则可能产生问题。</p>
<h2 id="Cookie同步导致的内存泄漏"><a href="#Cookie同步导致的内存泄漏" class="headerlink" title="Cookie同步导致的内存泄漏"></a>Cookie同步导致的内存泄漏</h2><p>使用CookieSyncManager同步时，会永久引用第一个acitivity的的Context，为了避免此种情况，请使用ApplicationContext<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> if (Build.VERSION.SDK_INT &lt; 21) &#123;</span><br><span class="line">        android.webkit.CookieSyncManager.createInstance(context.getApplicationContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Android5-0-WebView中Http和Https混合问题"><a href="#Android5-0-WebView中Http和Https混合问题" class="headerlink" title="Android5.0 WebView中Http和Https混合问题"></a>Android5.0 WebView中Http和Https混合问题</h2><p>在Android 5.0上 Webview 默认不允许加载 Http 与 Https 混合内容：</p>
<p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">     webView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数类型说明：<br>MIXED_CONTENT_ALWAYS_ALLOW：允许从任何来源加载内容，即使起源是不安全的；<br>MIXED_CONTENT_NEVER_ALLOW：不允许Https加载Http的内容，即不允许从安全的起源去加载一个不安全的资源；<br>MIXED_CONTENT_COMPATIBILITY_MODE：当涉及到混合式内容时，WebView 会尝试去兼容最新Web浏览器的风格。</p>
<p>在5.0以下 Android 默认是 全允许，但是到了5.0以上，就是不允许，实际情况下很我们很难确定所有的网页都是https的，所以就需要这一步的操作。</p>
<h2 id="onPageFinished被调用多次"><a href="#onPageFinished被调用多次" class="headerlink" title="onPageFinished被调用多次"></a>onPageFinished被调用多次</h2><p>使用onPageProgressChanged代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void  handleProgress(WebView view, int newProgress)&#123;</span><br><span class="line">    if(progressPending.get()!=newProgress)&#123;</span><br><span class="line">        progressPending.set(newProgress);</span><br><span class="line">        onProgressChanged(newProgress);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public final void onProgressChanged(WebView view, int newProgress) &#123;</span><br><span class="line">    super.onProgressChanged(view, newProgress);</span><br><span class="line">    handleProgress(view,newProgress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void onProgressChanged(int newProgress)&#123;</span><br><span class="line">   Log.i(&quot;WebChromeClient&quot;,&quot;progress=&quot;+newProgress+&quot;%&quot;);</span><br><span class="line">   if(newProgress==100)&#123;</span><br><span class="line">       Log.i(&quot;WebChromeClient&quot;,&quot;加载完成&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="H5优化"><a href="#H5优化" class="headerlink" title="H5优化"></a>H5优化</h2><p>Android的OnPageFinished事件会在Javascript脚本执行完成之后才会触发。如果在页面中使 用JQuery，会在处理完DOM对象，执行完$(document).ready(function() {});事件自会后才会渲染并显示页面。而同样的页面在iPhone上却是载入相当的快，因为iPhone是显示完页面才会触发脚本的执行。所以我们这边的解决方案延迟JS脚本的载入，这个方面的问题是需要Web前端工程师帮忙优化的，网上应该有比较多LazyLoad插件，这里放一个比较老的链接<a href="https://wonko.com/post/painless_javascript_lazy_loading_with_lazyload/" target="_blank" rel="noopener">Painless JavaScript lazy loading with LazyLoad</a>,同样也放上一小段前端代码，仅供参考。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;/css/j/lazyload-min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  loadComplete() &#123;</span><br><span class="line">    //instead of document.read();</span><br><span class="line">  &#125; </span><br><span class="line">  function loadscript() &#123;</span><br><span class="line">    LazyLoad.loadOnce([</span><br><span class="line">      &apos;/css/j/jquery-1.6.2.min.js&apos;,</span><br><span class="line">      &apos;/css/j/flow/jquery.flow.1.1.min.js&apos;,</span><br><span class="line">      &apos;/css/j/min.js?v=2011100852&apos;</span><br><span class="line">      ], loadComplete);</span><br><span class="line">  &#125;</span><br><span class="line">  setTimeout(loadscript,10);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/427600ca2107" target="_blank" rel="noopener">https://www.jianshu.com/p/427600ca2107</a><br><a href="https://my.oschina.net/ososchina/blog/1799575" target="_blank" rel="noopener">https://my.oschina.net/ososchina/blog/1799575</a><br><a href="https://iluhcm.com/2017/12/10/design-an-elegant-and-powerful-android-webview-part-one/" target="_blank" rel="noopener">https://iluhcm.com/2017/12/10/design-an-elegant-and-powerful-android-webview-part-one/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/05/android-listview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/05/android-listview/" itemprop="url">Android ListView原理完全解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-05T13:33:57+08:00">
                2019-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ListView的结构，如下图所示：</p>
<p><img src="/2019/09/05/android-listview/listview.png" alt></p>
<h2 id="Adapter作用"><a href="#Adapter作用" class="headerlink" title="Adapter作用"></a>Adapter作用</h2><p>Adapter是适配器的意思，它在ListView和数据源之间起到了一个桥梁的作用，ListView并不会直接和数据源打交道，而是会借助Adapter这个桥梁来去访问真正的数据源，与之前不同的是，Adapter的接口都是统一的，因此ListView不用再去担心任何适配方面的问题。而Adapter又是一个接口(interface)，它可以去实现各种各样的子类，每个子类都能通过自己的逻辑来去完成特定的功能，以及与特定数据源的适配操作，比如说ArrayAdapter可以用于数组和List类型的数据源适配，SimpleCursorAdapter可以用于游标类型的数据源适配，这样就非常巧妙地把数据源适配困难的问题解决掉了，并且还拥有相当不错的扩展性。简单的原理示意图如下所示：</p>
<p>当然Adapter的作用不仅仅只有<strong>数据源适配</strong>这一点，还有一个非常非常重要的方法也需要我们在Adapter当中去重写，就是getView()方法</p>
<h2 id="RecycleBin机制"><a href="#RecycleBin机制" class="headerlink" title="RecycleBin机制"></a>RecycleBin机制</h2><p>在开始分析ListView的源码之前，还有一个东西是我们提前需要了解的，就是RecycleBin机制，这个机制也是ListView能够实现成百上千条数据都不会OOM最重要的一个原因。其实RecycleBin的代码并不多，它是写在AbsListView中的一个内部类，所以所有继承自AbsListView的子类，也就是ListView和GridView，都可以使用这个机制。那我们来看一下RecycleBin中的主要代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The RecycleBin facilitates reuse of views across layouts. The RecycleBin</span><br><span class="line"> * has two levels of storage: ActiveViews and ScrapViews. ActiveViews are</span><br><span class="line"> * those views which were onscreen at the start of a layout. By</span><br><span class="line"> * construction, they are displaying current information. At the end of</span><br><span class="line"> * layout, all views in ActiveViews are demoted to ScrapViews. ScrapViews</span><br><span class="line"> * are old views that could potentially be used by the adapter to avoid</span><br><span class="line"> * allocating views unnecessarily.</span><br><span class="line"> * </span><br><span class="line"> * @see android.widget.AbsListView#setRecyclerListener(android.widget.AbsListView.RecyclerListener)</span><br><span class="line"> * @see android.widget.AbsListView.RecyclerListener</span><br><span class="line"> */</span><br><span class="line">class RecycleBin &#123;</span><br><span class="line">	private RecyclerListener mRecyclerListener;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * The position of the first view stored in mActiveViews.</span><br><span class="line">	 */</span><br><span class="line">	private int mFirstActivePosition;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Views that were on screen at the start of layout. This array is</span><br><span class="line">	 * populated at the start of layout, and at the end of layout all view</span><br><span class="line">	 * in mActiveViews are moved to mScrapViews. Views in mActiveViews</span><br><span class="line">	 * represent a contiguous range of Views, with position of the first</span><br><span class="line">	 * view store in mFirstActivePosition.</span><br><span class="line">	 */</span><br><span class="line">	private View[] mActiveViews = new View[0];</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Unsorted views that can be used by the adapter as a convert view.</span><br><span class="line">	 */</span><br><span class="line">	private ArrayList&lt;View&gt;[] mScrapViews;</span><br><span class="line"> </span><br><span class="line">	private int mViewTypeCount;</span><br><span class="line"> </span><br><span class="line">	private ArrayList&lt;View&gt; mCurrentScrap;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Fill ActiveViews with all of the children of the AbsListView.</span><br><span class="line">	 * </span><br><span class="line">	 * @param childCount</span><br><span class="line">	 *            The minimum number of views mActiveViews should hold</span><br><span class="line">	 * @param firstActivePosition</span><br><span class="line">	 *            The position of the first view that will be stored in</span><br><span class="line">	 *            mActiveViews</span><br><span class="line">	 */</span><br><span class="line">	void fillActiveViews(int childCount, int firstActivePosition) &#123;</span><br><span class="line">		if (mActiveViews.length &lt; childCount) &#123;</span><br><span class="line">			mActiveViews = new View[childCount];</span><br><span class="line">		&#125;</span><br><span class="line">		mFirstActivePosition = firstActivePosition;</span><br><span class="line">		final View[] activeViews = mActiveViews;</span><br><span class="line">		for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">			View child = getChildAt(i);</span><br><span class="line">			AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">			// Don&apos;t put header or footer views into the scrap heap</span><br><span class="line">			if (lp != null &amp;&amp; lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">				// Note: We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in</span><br><span class="line">				// active views.</span><br><span class="line">				// However, we will NOT place them into scrap views.</span><br><span class="line">				activeViews[i] = child;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Get the view corresponding to the specified position. The view will</span><br><span class="line">	 * be removed from mActiveViews if it is found.</span><br><span class="line">	 * </span><br><span class="line">	 * @param position</span><br><span class="line">	 *            The position to look up in mActiveViews</span><br><span class="line">	 * @return The view if it is found, null otherwise</span><br><span class="line">	 */</span><br><span class="line">	View getActiveView(int position) &#123;</span><br><span class="line">		int index = position - mFirstActivePosition;</span><br><span class="line">		final View[] activeViews = mActiveViews;</span><br><span class="line">		if (index &gt;= 0 &amp;&amp; index &lt; activeViews.length) &#123;</span><br><span class="line">			final View match = activeViews[index];</span><br><span class="line">			activeViews[index] = null;</span><br><span class="line">			return match;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * Put a view into the ScapViews list. These views are unordered.</span><br><span class="line">	 * </span><br><span class="line">	 * @param scrap</span><br><span class="line">	 *            The view to add</span><br><span class="line">	 */</span><br><span class="line">	void addScrapView(View scrap) &#123;</span><br><span class="line">		AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();</span><br><span class="line">		if (lp == null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		// Don&apos;t put header or footer views or views that should be ignored</span><br><span class="line">		// into the scrap heap</span><br><span class="line">		int viewType = lp.viewType;</span><br><span class="line">		if (!shouldRecycleViewType(viewType)) &#123;</span><br><span class="line">			if (viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">				removeDetachedView(scrap, false);</span><br><span class="line">			&#125;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (mViewTypeCount == 1) &#123;</span><br><span class="line">			dispatchFinishTemporaryDetach(scrap);</span><br><span class="line">			mCurrentScrap.add(scrap);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			dispatchFinishTemporaryDetach(scrap);</span><br><span class="line">			mScrapViews[viewType].add(scrap);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		if (mRecyclerListener != null) &#123;</span><br><span class="line">			mRecyclerListener.onMovedToScrapHeap(scrap);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * @return A view from the ScrapViews collection. These are unordered.</span><br><span class="line">	 */</span><br><span class="line">	View getScrapView(int position) &#123;</span><br><span class="line">		ArrayList&lt;View&gt; scrapViews;</span><br><span class="line">		if (mViewTypeCount == 1) &#123;</span><br><span class="line">			scrapViews = mCurrentScrap;</span><br><span class="line">			int size = scrapViews.size();</span><br><span class="line">			if (size &gt; 0) &#123;</span><br><span class="line">				return scrapViews.remove(size - 1);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return null;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			int whichScrap = mAdapter.getItemViewType(position);</span><br><span class="line">			if (whichScrap &gt;= 0 &amp;&amp; whichScrap &lt; mScrapViews.length) &#123;</span><br><span class="line">				scrapViews = mScrapViews[whichScrap];</span><br><span class="line">				int size = scrapViews.size();</span><br><span class="line">				if (size &gt; 0) &#123;</span><br><span class="line">					return scrapViews.remove(size - 1);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public void setViewTypeCount(int viewTypeCount) &#123;</span><br><span class="line">		if (viewTypeCount &lt; 1) &#123;</span><br><span class="line">			throw new IllegalArgumentException(&quot;Can&apos;t have a viewTypeCount &lt; 1&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		// noinspection unchecked</span><br><span class="line">		ArrayList&lt;View&gt;[] scrapViews = new ArrayList[viewTypeCount];</span><br><span class="line">		for (int i = 0; i &lt; viewTypeCount; i++) &#123;</span><br><span class="line">			scrapViews[i] = new ArrayList&lt;View&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		mViewTypeCount = viewTypeCount;</span><br><span class="line">		mCurrentScrap = scrapViews[0];</span><br><span class="line">		mScrapViews = scrapViews;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的RecycleBin代码并不全，只是把最主要的几个方法提了出来。那么我们先来对这几个方法进行简单解读，这对后面分析ListView的工作原理将会有很大的帮助:</p>
<ul>
<li><p><strong>fillActiveViews()</strong> 这个方法接收两个参数，第一个参数表示要存储的view的数量，第二个参数表示ListView中第一个可见元素的position值。RecycleBin当中使用mActiveViews这个数组来存储View，调用这个方法后就会根据传入的参数来将ListView中的指定元素存储到mActiveViews数组当中。</p>
</li>
<li><p><strong>getActiveView()</strong> 这个方法和fillActiveViews()是对应的，用于从mActiveViews数组当中获取数据。该方法接收一个position参数，表示元素在ListView当中的位置，方法内部会自动将position值转换成mActiveViews数组对应的下标值。需要注意的是，mActiveViews当中所存储的View，一旦被获取了之后就会从mActiveViews当中移除，下次获取同样位置的View将会返回null，也就是说mActiveViews不能被重复利用。</p>
</li>
<li><p><strong>addScrapView()</strong> 用于将一个废弃的View进行缓存，该方法接收一个View参数，当有某个View确定要废弃掉的时候(比如滚动出了屏幕)，就应该调用这个方法来对View进行缓存，RecycleBin当中使用mScrapViews和mCurrentScrap这两个List来存储废弃View。</p>
</li>
<li><p><strong>getScrapView()</strong> 用于从废弃缓存中取出一个View，这些废弃缓存中的View是没有顺序可言的，因此getScrapView()方法中的算法也非常简单，就是直接从mCurrentScrap当中获取尾部的一个scrap view进行返回。</p>
</li>
<li><p><strong>setViewTypeCount()</strong> 我们都知道Adapter当中可以重写一个getViewTypeCount()来表示ListView中有几种类型的数据项，而setViewTypeCount()方法的作用就是为每种类型的数据项都单独启用一个RecycleBin缓存机制。实际上，getViewTypeCount()方法通常情况下使用的并不是很多，所以我们只要知道RecycleBin当中有这样一个功能就行了。</p>
</li>
</ul>
<h2 id="第一次Layout"><a href="#第一次Layout" class="headerlink" title="第一次Layout"></a>第一次Layout</h2><p>不管怎么说，ListView即使再特殊最终还是继承自View的，因此它的执行流程还将会按照View的规则来执行。</p>
<p>View的执行流程无非就分为三步，onMeasure()用于测量View的大小，onLayout()用于确定View的布局，onDraw()用于将View绘制到界面上。而在ListView当中，onMeasure()并没有什么特殊的地方，因为它终归是一个View，占用的空间最多并且通常也就是整个屏幕。onDraw()在ListView当中也没有什么意义，因为ListView本身并不负责绘制，而是由ListView当中的子元素来进行绘制的。那么ListView大部分的神奇功能其实都是在onLayout()方法中进行的了，因此我们本篇文章也是主要分析的这个方法里的内容。</p>
<p>如果你到ListView源码中去找一找，你会发现ListView中是没有onLayout()这个方法的，这是因为这个方法是在ListView的父类AbsListView中实现的，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Subclasses should NOT override this method but &#123;@link #layoutChildren()&#125;</span><br><span class="line"> * instead.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">	super.onLayout(changed, l, t, r, b);</span><br><span class="line">	mInLayout = true;</span><br><span class="line">	if (changed) &#123;</span><br><span class="line">		int childCount = getChildCount();</span><br><span class="line">		for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">			getChildAt(i).forceLayout();</span><br><span class="line">		&#125;</span><br><span class="line">		mRecycler.markChildrenDirty();</span><br><span class="line">	&#125;</span><br><span class="line">	layoutChildren();</span><br><span class="line">	mInLayout = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<strong>onLayout()方法中主要就是一个判断，如果ListView的大小或者位置发生了变化，那么changed变量就会变成true，此时会要求所有的子布局都强制进行重绘</strong>。除此之外倒没有什么难理解的地方了，不过我们注意到，在第16行调用了layoutChildren()这个方法，从方法名上我们就可以猜出这个方法是用来进行子元素布局的。那么进入ListView的layoutChildren()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void layoutChildren() &#123;</span><br><span class="line">    final boolean blockLayoutRequests = mBlockLayoutRequests;</span><br><span class="line">    if (!blockLayoutRequests) &#123;</span><br><span class="line">        mBlockLayoutRequests = true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        super.layoutChildren();</span><br><span class="line">        invalidate();</span><br><span class="line">        if (mAdapter == null) &#123;</span><br><span class="line">            resetList();</span><br><span class="line">            invokeOnItemScrollListener();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int childrenTop = mListPadding.top;</span><br><span class="line">        int childrenBottom = getBottom() - getTop() - mListPadding.bottom;</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        int index = 0;</span><br><span class="line">        int delta = 0;</span><br><span class="line">        View sel;</span><br><span class="line">        View oldSel = null;</span><br><span class="line">        View oldFirst = null;</span><br><span class="line">        View newSel = null;</span><br><span class="line">        View focusLayoutRestoreView = null;</span><br><span class="line">        // Remember stuff we will need down below</span><br><span class="line">        switch (mLayoutMode) &#123;</span><br><span class="line">        case LAYOUT_SET_SELECTION:</span><br><span class="line">            index = mNextSelectedPosition - mFirstPosition;</span><br><span class="line">            if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</span><br><span class="line">                newSel = getChildAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_FORCE_TOP:</span><br><span class="line">        case LAYOUT_FORCE_BOTTOM:</span><br><span class="line">        case LAYOUT_SPECIFIC:</span><br><span class="line">        case LAYOUT_SYNC:</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_MOVE_SELECTION:</span><br><span class="line">        default:</span><br><span class="line">            // Remember the previously selected view</span><br><span class="line">            index = mSelectedPosition - mFirstPosition;</span><br><span class="line">            if (index &gt;= 0 &amp;&amp; index &lt; childCount) &#123;</span><br><span class="line">                oldSel = getChildAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">            // Remember the previous first child</span><br><span class="line">            oldFirst = getChildAt(0);</span><br><span class="line">            if (mNextSelectedPosition &gt;= 0) &#123;</span><br><span class="line">                delta = mNextSelectedPosition - mSelectedPosition;</span><br><span class="line">            &#125;</span><br><span class="line">            // Caution: newSel might be null</span><br><span class="line">            newSel = getChildAt(index + delta);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean dataChanged = mDataChanged;</span><br><span class="line">        if (dataChanged) &#123;</span><br><span class="line">            handleDataChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        // Handle the empty set by removing all views that are visible</span><br><span class="line">        // and calling it a day</span><br><span class="line">        if (mItemCount == 0) &#123;</span><br><span class="line">            resetList();</span><br><span class="line">            invokeOnItemScrollListener();</span><br><span class="line">            return;</span><br><span class="line">        &#125; else if (mItemCount != mAdapter.getCount()) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;</span><br><span class="line">                    + &quot;ListView did not receive a notification. Make sure the content of &quot;</span><br><span class="line">                    + &quot;your adapter is not modified from a background thread, but only &quot;</span><br><span class="line">                    + &quot;from the UI thread. [in ListView(&quot; + getId() + &quot;, &quot; + getClass() </span><br><span class="line">                    + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        setSelectedPositionInt(mNextSelectedPosition);</span><br><span class="line">        // Pull all children into the RecycleBin.</span><br><span class="line">        // These views will be reused if possible</span><br><span class="line">        final int firstPosition = mFirstPosition;</span><br><span class="line">        final RecycleBin recycleBin = mRecycler;</span><br><span class="line">        // reset the focus restoration</span><br><span class="line">        View focusLayoutRestoreDirectChild = null;</span><br><span class="line">        // Don&apos;t put header or footer views into the Recycler. Those are</span><br><span class="line">        // already cached in mHeaderViews;</span><br><span class="line">        if (dataChanged) &#123;</span><br><span class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">                recycleBin.addScrapView(getChildAt(i));</span><br><span class="line">                if (ViewDebug.TRACE_RECYCLER) &#123;</span><br><span class="line">                    ViewDebug.trace(getChildAt(i),</span><br><span class="line">                            ViewDebug.RecyclerTraceType.MOVE_TO_SCRAP_HEAP, index, i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            recycleBin.fillActiveViews(childCount, firstPosition);</span><br><span class="line">        &#125;</span><br><span class="line">        // take focus back to us temporarily to avoid the eventual</span><br><span class="line">        // call to clear focus when removing the focused child below</span><br><span class="line">        // from messing things up when ViewRoot assigns focus back</span><br><span class="line">        // to someone else</span><br><span class="line">        final View focusedChild = getFocusedChild();</span><br><span class="line">        if (focusedChild != null) &#123;</span><br><span class="line">            // TODO: in some cases focusedChild.getParent() == null</span><br><span class="line">            // we can remember the focused view to restore after relayout if the</span><br><span class="line">            // data hasn&apos;t changed, or if the focused position is a header or footer</span><br><span class="line">            if (!dataChanged || isDirectChildHeaderOrFooter(focusedChild)) &#123;</span><br><span class="line">                focusLayoutRestoreDirectChild = focusedChild;</span><br><span class="line">                // remember the specific view that had focus</span><br><span class="line">                focusLayoutRestoreView = findFocus();</span><br><span class="line">                if (focusLayoutRestoreView != null) &#123;</span><br><span class="line">                    // tell it we are going to mess with it</span><br><span class="line">                    focusLayoutRestoreView.onStartTemporaryDetach();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            requestFocus();</span><br><span class="line">        &#125;</span><br><span class="line">        // Clear out old views</span><br><span class="line">        detachAllViewsFromParent();</span><br><span class="line">        switch (mLayoutMode) &#123;</span><br><span class="line">        case LAYOUT_SET_SELECTION:</span><br><span class="line">            if (newSel != null) &#123;</span><br><span class="line">                sel = fillFromSelection(newSel.getTop(), childrenTop, childrenBottom);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sel = fillFromMiddle(childrenTop, childrenBottom);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_SYNC:</span><br><span class="line">            sel = fillSpecific(mSyncPosition, mSpecificTop);</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_FORCE_BOTTOM:</span><br><span class="line">            sel = fillUp(mItemCount - 1, childrenBottom);</span><br><span class="line">            adjustViewsUpOrDown();</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_FORCE_TOP:</span><br><span class="line">            mFirstPosition = 0;</span><br><span class="line">            sel = fillFromTop(childrenTop);</span><br><span class="line">            adjustViewsUpOrDown();</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_SPECIFIC:</span><br><span class="line">            sel = fillSpecific(reconcileSelectedPosition(), mSpecificTop);</span><br><span class="line">            break;</span><br><span class="line">        case LAYOUT_MOVE_SELECTION:</span><br><span class="line">            sel = moveSelection(oldSel, newSel, delta, childrenTop, childrenBottom);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            if (childCount == 0) &#123;</span><br><span class="line">                if (!mStackFromBottom) &#123;</span><br><span class="line">                    final int position = lookForSelectablePosition(0, true);</span><br><span class="line">                    setSelectedPositionInt(position);</span><br><span class="line">                    sel = fillFromTop(childrenTop);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final int position = lookForSelectablePosition(mItemCount - 1, false);</span><br><span class="line">                    setSelectedPositionInt(position);</span><br><span class="line">                    sel = fillUp(mItemCount - 1, childrenBottom);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (mSelectedPosition &gt;= 0 &amp;&amp; mSelectedPosition &lt; mItemCount) &#123;</span><br><span class="line">                    sel = fillSpecific(mSelectedPosition,</span><br><span class="line">                            oldSel == null ? childrenTop : oldSel.getTop());</span><br><span class="line">                &#125; else if (mFirstPosition &lt; mItemCount) &#123;</span><br><span class="line">                    sel = fillSpecific(mFirstPosition,</span><br><span class="line">                            oldFirst == null ? childrenTop : oldFirst.getTop());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sel = fillSpecific(0, childrenTop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // Flush any cached views that did not get reused above</span><br><span class="line">        recycleBin.scrapActiveViews();</span><br><span class="line">        if (sel != null) &#123;</span><br><span class="line">            // the current selected item should get focus if items</span><br><span class="line">            // are focusable</span><br><span class="line">            if (mItemsCanFocus &amp;&amp; hasFocus() &amp;&amp; !sel.hasFocus()) &#123;</span><br><span class="line">                final boolean focusWasTaken = (sel == focusLayoutRestoreDirectChild &amp;&amp;</span><br><span class="line">                        focusLayoutRestoreView.requestFocus()) || sel.requestFocus();</span><br><span class="line">                if (!focusWasTaken) &#123;</span><br><span class="line">                    // selected item didn&apos;t take focus, fine, but still want</span><br><span class="line">                    // to make sure something else outside of the selected view</span><br><span class="line">                    // has focus</span><br><span class="line">                    final View focused = getFocusedChild();</span><br><span class="line">                    if (focused != null) &#123;</span><br><span class="line">                        focused.clearFocus();</span><br><span class="line">                    &#125;</span><br><span class="line">                    positionSelector(sel);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sel.setSelected(false);</span><br><span class="line">                    mSelectorRect.setEmpty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                positionSelector(sel);</span><br><span class="line">            &#125;</span><br><span class="line">            mSelectedTop = sel.getTop();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (mTouchMode &gt; TOUCH_MODE_DOWN &amp;&amp; mTouchMode &lt; TOUCH_MODE_SCROLL) &#123;</span><br><span class="line">                View child = getChildAt(mMotionPosition - mFirstPosition);</span><br><span class="line">                if (child != null) positionSelector(child);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mSelectedTop = 0;</span><br><span class="line">                mSelectorRect.setEmpty();</span><br><span class="line">            &#125;</span><br><span class="line">            // even if there is not selected position, we may need to restore</span><br><span class="line">            // focus (i.e. something focusable in touch mode)</span><br><span class="line">            if (hasFocus() &amp;&amp; focusLayoutRestoreView != null) &#123;</span><br><span class="line">                focusLayoutRestoreView.requestFocus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // tell focus view we are done mucking with it, if it is still in</span><br><span class="line">        // our view hierarchy.</span><br><span class="line">        if (focusLayoutRestoreView != null</span><br><span class="line">                &amp;&amp; focusLayoutRestoreView.getWindowToken() != null) &#123;</span><br><span class="line">            focusLayoutRestoreView.onFinishTemporaryDetach();</span><br><span class="line">        &#125;</span><br><span class="line">        mLayoutMode = LAYOUT_NORMAL;</span><br><span class="line">        mDataChanged = false;</span><br><span class="line">        mNeedSync = false;</span><br><span class="line">        setNextSelectedPositionInt(mSelectedPosition);</span><br><span class="line">        updateScrollIndicators();</span><br><span class="line">        if (mItemCount &gt; 0) &#123;</span><br><span class="line">            checkSelectionChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        invokeOnItemScrollListener();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!blockLayoutRequests) &#123;</span><br><span class="line">            mBlockLayoutRequests = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码比较长，我们挑重点的看。首先可以确定的是，ListView当中目前还没有任何子View，数据都还是由Adapter管理的，并没有展示到界面上，因此第19行getChildCount()方法得到的值肯定是0。接着在第81行会根据dataChanged这个布尔型的值来判断执行逻辑，dataChanged只有在数据源发生改变的情况下才会变成true，其它情况都是false，因此这里会进入到第90行的执行逻辑，调用RecycleBin的fillActiveViews()方法。按理来说，调用fillActiveViews()方法是为了将ListView的子View进行缓存的，可是目前ListView中还没有任何的子View，因此这一行暂时还起不了任何作用。</p>
<p>接下来在第114行会根据mLayoutMode的值来决定布局模式，默认情况下都是普通模式LAYOUT_NORMAL，因此会进入到第140行的default语句当中。而下面又会紧接着进行两次if判断，childCount目前是等于0的，并且默认的布局顺序是从上往下，因此会进入到第145行的fillFromTop()方法，我们跟进去瞧一瞧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Fills the list from top to bottom, starting with mFirstPosition</span><br><span class="line"> *</span><br><span class="line"> * @param nextTop The location where the top of the first item should be</span><br><span class="line"> *        drawn</span><br><span class="line"> *</span><br><span class="line"> * @return The view that is currently selected</span><br><span class="line"> */</span><br><span class="line">private View fillFromTop(int nextTop) &#123;</span><br><span class="line">    mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);</span><br><span class="line">    mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);</span><br><span class="line">    if (mFirstPosition &lt; 0) &#123;</span><br><span class="line">        mFirstPosition = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return fillDown(mFirstPosition, nextTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这个方法的注释中可以看出，它所负责的主要任务就是从mFirstPosition开始，自顶至底去填充ListView。而这个方法本身并没有什么逻辑，就是判断了一下mFirstPosition值的合法性，然后调用fillDown()方法，那么我们就有理由可以猜测，填充ListView的操作是在fillDown()方法中完成的。进入fillDown()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Fills the list from pos down to the end of the list view.</span><br><span class="line"> *</span><br><span class="line"> * @param pos The first position to put in the list</span><br><span class="line"> *</span><br><span class="line"> * @param nextTop The location where the top of the item associated with pos</span><br><span class="line"> *        should be drawn</span><br><span class="line"> *</span><br><span class="line"> * @return The view that is currently selected, if it happens to be in the</span><br><span class="line"> *         range that we draw.</span><br><span class="line"> */</span><br><span class="line">private View fillDown(int pos, int nextTop) &#123;</span><br><span class="line">    View selectedView = null;</span><br><span class="line">    int end = (getBottom() - getTop()) - mListPadding.bottom;</span><br><span class="line">    while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) &#123;</span><br><span class="line">        // is this the selected item?</span><br><span class="line">        boolean selected = pos == mSelectedPosition;</span><br><span class="line">        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);</span><br><span class="line">        nextTop = child.getBottom() + mDividerHeight;</span><br><span class="line">        if (selected) &#123;</span><br><span class="line">            selectedView = child;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    return selectedView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里使用了一个while循环来执行重复逻辑，一开始nextTop的值是第一个子元素顶部距离整个ListView顶部的像素值，pos则是刚刚传入的mFirstPosition的值，而end是ListView底部减去顶部所得的像素值，mItemCount则是Adapter中的元素数量。因此一开始的情况下nextTop必定是小于end值的，并且pos也是小于mItemCount值的。那么每执行一次while循环，pos的值都会加1，并且nextTop也会增加，当nextTop大于等于end时，也就是子元素已经超出当前屏幕了，或者pos大于等于mItemCount时，也就是所有Adapter中的元素都被遍历结束了，就会跳出while循环。</p>
<p>那么while循环当中又做了什么事情呢？值得让人留意的就是第18行调用的makeAndAddView()方法，进入到这个方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Obtain the view and add it to our list of children. The view can be made</span><br><span class="line"> * fresh, converted from an unused view, or used as is if it was in the</span><br><span class="line"> * recycle bin.</span><br><span class="line"> *</span><br><span class="line"> * @param position Logical position in the list</span><br><span class="line"> * @param y Top or bottom edge of the view to add</span><br><span class="line"> * @param flow If flow is true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @return View that was added</span><br><span class="line"> */</span><br><span class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</span><br><span class="line">        boolean selected) &#123;</span><br><span class="line">    View child;</span><br><span class="line">    if (!mDataChanged) &#123;</span><br><span class="line">        // Try to use an exsiting view for this position</span><br><span class="line">        child = mRecycler.getActiveView(position);</span><br><span class="line">        if (child != null) &#123;</span><br><span class="line">            // Found it -- we&apos;re using an existing child</span><br><span class="line">            // This just needs to be positioned</span><br><span class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Make a new view for this position, or convert an unused view if possible</span><br><span class="line">    child = obtainView(position, mIsScrap);</span><br><span class="line">    // This needs to be positioned and measured</span><br><span class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里在第19行尝试从RecycleBin当中快速获取一个active view，不过很遗憾的是目前RecycleBin当中还没有缓存任何的View，所以这里得到的值肯定是null。那么取得了null之后就会继续向下运行，到第28行会调用obtainView()方法来再次尝试获取一个View，这次的obtainView()方法是可以保证一定返回一个View的，于是下面立刻将获取到的View传入到了setupChild()方法当中。那么obtainView()内部到底是怎么工作的呢？我们先进入到这个方法里面看一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get a view and have it show the data associated with the specified</span><br><span class="line"> * position. This is called when we have already discovered that the view is</span><br><span class="line"> * not available for reuse in the recycle bin. The only choices left are</span><br><span class="line"> * converting an old view or making a new one.</span><br><span class="line"> * </span><br><span class="line"> * @param position</span><br><span class="line"> *            The position to display</span><br><span class="line"> * @param isScrap</span><br><span class="line"> *            Array of at least 1 boolean, the first entry will become true</span><br><span class="line"> *            if the returned view was taken from the scrap heap, false if</span><br><span class="line"> *            otherwise.</span><br><span class="line"> * </span><br><span class="line"> * @return A view displaying the data associated with the specified position</span><br><span class="line"> */</span><br><span class="line">View obtainView(int position, boolean[] isScrap) &#123;</span><br><span class="line">	isScrap[0] = false;</span><br><span class="line">	View scrapView;</span><br><span class="line">	scrapView = mRecycler.getScrapView(position);</span><br><span class="line">	View child;</span><br><span class="line">	if (scrapView != null) &#123;</span><br><span class="line">		child = mAdapter.getView(position, scrapView, this);</span><br><span class="line">		if (child != scrapView) &#123;</span><br><span class="line">			mRecycler.addScrapView(scrapView);</span><br><span class="line">			if (mCacheColorHint != 0) &#123;</span><br><span class="line">				child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			isScrap[0] = true;</span><br><span class="line">			dispatchFinishTemporaryDetach(child);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		child = mAdapter.getView(position, null, this);</span><br><span class="line">		if (mCacheColorHint != 0) &#123;</span><br><span class="line">			child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>obtainView()方法中的代码并不多，但却包含了非常非常重要的逻辑，不夸张的说，整个ListView中最重要的内容可能就在这个方法里了。那么我们还是按照执行流程来看，在第19行代码中调用了RecycleBin的getScrapView()方法来尝试获取一个废弃缓存中的View，同样的道理，这里肯定是获取不到的，getScrapView()方法会返回一个null。这时该怎么办呢？没有关系，代码会执行到第33行，调用mAdapter的getView()方法来去获取一个View。那么mAdapter是什么呢？当然就是当前ListView关联的适配器了。而getView()方法又是什么呢？还用说吗，这个就是我们平时使用ListView时最最经常重写的一个方法了，这里getView()方法中传入了三个参数，分别是position，null和this。</p>
<p>那么我们平时写ListView的Adapter时，getView()方法通常会怎么写呢？这里我举个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">	Fruit fruit = getItem(position);</span><br><span class="line">	View view;</span><br><span class="line">	if (convertView == null) &#123;</span><br><span class="line">		view = LayoutInflater.from(getContext()).inflate(resourceId, null);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		view = convertView;</span><br><span class="line">	&#125;</span><br><span class="line">	ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">	TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line">	fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">	fruitName.setText(fruit.getName());</span><br><span class="line">	return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getView()方法接受的三个参数，第一个参数position代表当前子元素的的位置，我们可以通过具体的位置来获取与其相关的数据。第二个参数convertView，刚才传入的是null，说明没有convertView可以利用，因此我们会调用LayoutInflater的inflate()方法来去加载一个布局。接下来会对这个view进行一些属性和值的设定，最后将view返回。</p>
<p>那么这个View也会作为obtainView()的结果进行返回，并最终传入到setupChild()方法当中。其实也就是说，第一次layout过程当中，所有的子View都是调用LayoutInflater的inflate()方法加载出来的，这样就会相对比较耗时，但是不用担心，后面就不会再有这种情况了，那么我们继续往下看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a view as a child and make sure it is measured (if necessary) and</span><br><span class="line"> * positioned properly.</span><br><span class="line"> *</span><br><span class="line"> * @param child The view to add</span><br><span class="line"> * @param position The position of this child</span><br><span class="line"> * @param y The y position relative to which this view will be positioned</span><br><span class="line"> * @param flowDown If true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @param recycled Has this view been pulled from the recycle bin? If so it</span><br><span class="line"> *        does not need to be remeasured.</span><br><span class="line"> */</span><br><span class="line">private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,</span><br><span class="line">        boolean selected, boolean recycled) &#123;</span><br><span class="line">    final boolean isSelected = selected &amp;&amp; shouldShowSelector();</span><br><span class="line">    final boolean updateChildSelected = isSelected != child.isSelected();</span><br><span class="line">    final int mode = mTouchMode;</span><br><span class="line">    final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp;</span><br><span class="line">            mMotionPosition == position;</span><br><span class="line">    final boolean updateChildPressed = isPressed != child.isPressed();</span><br><span class="line">    final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();</span><br><span class="line">    // Respect layout params that are already in the view. Otherwise make some up...</span><br><span class="line">    // noinspection unchecked</span><br><span class="line">    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">    if (p == null) &#123;</span><br><span class="line">        p = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    p.viewType = mAdapter.getItemViewType(position);</span><br><span class="line">    if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp;</span><br><span class="line">            p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</span><br><span class="line">        attachViewToParent(child, flowDown ? -1 : 0, p);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p.forceAdd = false;</span><br><span class="line">        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">            p.recycledHeaderFooter = true;</span><br><span class="line">        &#125;</span><br><span class="line">        addViewInLayout(child, flowDown ? -1 : 0, p, true);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildSelected) &#123;</span><br><span class="line">        child.setSelected(isSelected);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildPressed) &#123;</span><br><span class="line">        child.setPressed(isPressed);</span><br><span class="line">    &#125;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</span><br><span class="line">                mListPadding.left + mListPadding.right, p.width);</span><br><span class="line">        int lpHeight = p.height;</span><br><span class="line">        int childHeightSpec;</span><br><span class="line">        if (lpHeight &gt; 0) &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        child.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cleanupLayoutState(child);</span><br><span class="line">    &#125;</span><br><span class="line">    final int w = child.getMeasuredWidth();</span><br><span class="line">    final int h = child.getMeasuredHeight();</span><br><span class="line">    final int childTop = flowDown ? y : y - h;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        final int childRight = childrenLeft + w;</span><br><span class="line">        final int childBottom = childTop + h;</span><br><span class="line">        child.layout(childrenLeft, childTop, childRight, childBottom);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        child.offsetLeftAndRight(childrenLeft - child.getLeft());</span><br><span class="line">        child.offsetTopAndBottom(childTop - child.getTop());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</span><br><span class="line">        child.setDrawingCacheEnabled(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>setupChild()方法当中的代码虽然比较多，但是我们只看核心代码的话就非常简单了，刚才调用obtainView()方法获取到的子元素View，这里在第40行调用了addViewInLayout()方法将它添加到了ListView当中。那么根据fillDown()方法中的while循环，会让子元素View将整个ListView控件填满然后就跳出，也就是说即使我们的Adapter中有一千条数据，ListView也只会加载第一屏的数据，剩下的数据反正目前在屏幕上也看不到，所以不会去做多余的加载工作，这样就可以保证ListView中的内容能够迅速展示到屏幕上。</p>
<p>那么到此为止，第一次Layout过程结束。</p>
<h2 id="第二次Layout"><a href="#第二次Layout" class="headerlink" title="第二次Layout"></a>第二次Layout</h2><p>虽然我在源码中并没有找出具体的原因，但如果你自己做一下实验的话就会发现，<strong>即使是一个再简单的View，在展示到界面上之前都会经历至少两次onMeasure()和两次onLayout()的过程</strong>。其实这只是一个很小的细节，平时对我们影响并不大，因为不管是onMeasure()或者onLayout()几次，反正都是执行的相同的逻辑，我们并不需要进行过多关心。但是在ListView中情况就不一样了，因为这就意味着layoutChildren()过程会执行两次，而这个过程当中涉及到向ListView中添加子元素，如果相同的逻辑执行两遍的话，那么ListView中就会存在一份重复的数据了。因此ListView在layoutChildren()过程当中做了第二次Layout的逻辑处理，非常巧妙地解决了这个问题，下面我们就来分析一下第二次Layout的过程。</p>
<p>其实第二次Layout和第一次Layout的基本流程是差不多的，那么我们还是从layoutChildren()方法开始看起：</p>
<p>同样还是在第19行，调用getChildCount()方法来获取子View的数量，只不过现在得到的值不会再是0了，而是ListView中一屏可以显示的子View数量，因为我们刚刚在第一次Layout过程当中向ListView添加了这么多的子View。下面在第90行调用了RecycleBin的fillActiveViews()方法，这次效果可就不一样了，因为目前ListView中已经有子View了，这样所有的子View都会被缓存到RecycleBin的mActiveViews数组当中，后面将会用到它们。</p>
<p>接下来将会是非常非常重要的一个操作，<strong>在第113行调用了detachAllViewsFromParent()方法。这个方法会将所有ListView当中的子View全部清除掉，从而保证第二次Layout过程不会产生一份重复的数据。那有的朋友可能会问了，这样把已经加载好的View又清除掉，待会还要再重新加载一遍，这不是严重影响效率吗？不用担心，还记得我们刚刚调用了RecycleBin的fillActiveViews()方法来缓存子View吗，待会儿将会直接使用这些缓存好的View来进行加载，而并不会重新执行一遍inflate过程，因此效率方面并不会有什么明显的影响。</strong></p>
<p>那么我们接着看，在第141行的判断逻辑当中，由于不再等于0了，因此会进入到else语句当中。而else语句中又有三个逻辑判断，第一个逻辑判断不成立，因为默认情况下我们没有选中任何子元素，mSelectedPosition应该等于-1。第二个逻辑判断通常是成立的，因为mFirstPosition的值一开始是等于0的，只要adapter中的数据大于0条件就成立。那么进入到fillSpecific()方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Put a specific item at a specific location on the screen and then build</span><br><span class="line"> * up and down from there.</span><br><span class="line"> *</span><br><span class="line"> * @param position The reference view to use as the starting point</span><br><span class="line"> * @param top Pixel offset from the top of this view to the top of the</span><br><span class="line"> *        reference view.</span><br><span class="line"> *</span><br><span class="line"> * @return The selected view, or null if the selected view is outside the</span><br><span class="line"> *         visible area.</span><br><span class="line"> */</span><br><span class="line">private View fillSpecific(int position, int top) &#123;</span><br><span class="line">    boolean tempIsSelected = position == mSelectedPosition;</span><br><span class="line">    View temp = makeAndAddView(position, top, true, mListPadding.left, tempIsSelected);</span><br><span class="line">    // Possibly changed again in fillUp if we add rows above this one.</span><br><span class="line">    mFirstPosition = position;</span><br><span class="line">    View above;</span><br><span class="line">    View below;</span><br><span class="line">    final int dividerHeight = mDividerHeight;</span><br><span class="line">    if (!mStackFromBottom) &#123;</span><br><span class="line">        above = fillUp(position - 1, temp.getTop() - dividerHeight);</span><br><span class="line">        // This will correct for the top of the first view not touching the top of the list</span><br><span class="line">        adjustViewsUpOrDown();</span><br><span class="line">        below = fillDown(position + 1, temp.getBottom() + dividerHeight);</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        if (childCount &gt; 0) &#123;</span><br><span class="line">            correctTooHigh(childCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        below = fillDown(position + 1, temp.getBottom() + dividerHeight);</span><br><span class="line">        // This will correct for the bottom of the last view not touching the bottom of the list</span><br><span class="line">        adjustViewsUpOrDown();</span><br><span class="line">        above = fillUp(position - 1, temp.getTop() - dividerHeight);</span><br><span class="line">        int childCount = getChildCount();</span><br><span class="line">        if (childCount &gt; 0) &#123;</span><br><span class="line">             correctTooLow(childCount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (tempIsSelected) &#123;</span><br><span class="line">        return temp;</span><br><span class="line">    &#125; else if (above != null) &#123;</span><br><span class="line">        return above;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return below;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>fillSpecific()这算是一个新方法了，不过其实它和fillUp()、fillDown()方法功能也是差不多的，主要的区别在于，fillSpecific()方法会优先将指定位置的子View先加载到屏幕上，然后再加载该子View往上以及往下的其它子View。那么由于这里我们传入的position就是第一个子View的位置，于是fillSpecific()方法的作用就基本上和fillDown()方法是差不多的了，这里我们就不去关注太多它的细节，而是将精力放在makeAndAddView()方法上面。再次回到makeAndAddView()方法，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Obtain the view and add it to our list of children. The view can be made</span><br><span class="line"> * fresh, converted from an unused view, or used as is if it was in the</span><br><span class="line"> * recycle bin.</span><br><span class="line"> *</span><br><span class="line"> * @param position Logical position in the list</span><br><span class="line"> * @param y Top or bottom edge of the view to add</span><br><span class="line"> * @param flow If flow is true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @return View that was added</span><br><span class="line"> */</span><br><span class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</span><br><span class="line">        boolean selected) &#123;</span><br><span class="line">    View child;</span><br><span class="line">    if (!mDataChanged) &#123;</span><br><span class="line">        // Try to use an exsiting view for this position</span><br><span class="line">        child = mRecycler.getActiveView(position);</span><br><span class="line">        if (child != null) &#123;</span><br><span class="line">            // Found it -- we&apos;re using an existing child</span><br><span class="line">            // This just needs to be positioned</span><br><span class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Make a new view for this position, or convert an unused view if possible</span><br><span class="line">    child = obtainView(position, mIsScrap);</span><br><span class="line">    // This needs to be positioned and measured</span><br><span class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仍然还是在第19行尝试从RecycleBin当中获取Active View，然而这次就一定可以获取到了，因为前面我们调用了RecycleBin的fillActiveViews()方法来缓存子View。那么既然如此，就不会再进入到第28行的obtainView()方法，而是会直接进入setupChild()方法当中，这样也省去了很多时间，因为如果在obtainView()方法中又要去infalte布局的话，那么ListView的初始加载效率就大大降低了。</p>
<p>注意在第23行，setupChild()方法的最后一个参数传入的是true，这个参数表明当前的View是之前被回收过的，那么我们再次回到setupChild()方法当中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Add a view as a child and make sure it is measured (if necessary) and</span><br><span class="line"> * positioned properly.</span><br><span class="line"> *</span><br><span class="line"> * @param child The view to add</span><br><span class="line"> * @param position The position of this child</span><br><span class="line"> * @param y The y position relative to which this view will be positioned</span><br><span class="line"> * @param flowDown If true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @param recycled Has this view been pulled from the recycle bin? If so it</span><br><span class="line"> *        does not need to be remeasured.</span><br><span class="line"> */</span><br><span class="line">private void setupChild(View child, int position, int y, boolean flowDown, int childrenLeft,</span><br><span class="line">        boolean selected, boolean recycled) &#123;</span><br><span class="line">    final boolean isSelected = selected &amp;&amp; shouldShowSelector();</span><br><span class="line">    final boolean updateChildSelected = isSelected != child.isSelected();</span><br><span class="line">    final int mode = mTouchMode;</span><br><span class="line">    final boolean isPressed = mode &gt; TOUCH_MODE_DOWN &amp;&amp; mode &lt; TOUCH_MODE_SCROLL &amp;&amp;</span><br><span class="line">            mMotionPosition == position;</span><br><span class="line">    final boolean updateChildPressed = isPressed != child.isPressed();</span><br><span class="line">    final boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();</span><br><span class="line">    // Respect layout params that are already in the view. Otherwise make some up...</span><br><span class="line">    // noinspection unchecked</span><br><span class="line">    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();</span><br><span class="line">    if (p == null) &#123;</span><br><span class="line">        p = new AbsListView.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                ViewGroup.LayoutParams.WRAP_CONTENT, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    p.viewType = mAdapter.getItemViewType(position);</span><br><span class="line">    if ((recycled &amp;&amp; !p.forceAdd) || (p.recycledHeaderFooter &amp;&amp;</span><br><span class="line">            p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER)) &#123;</span><br><span class="line">        attachViewToParent(child, flowDown ? -1 : 0, p);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p.forceAdd = false;</span><br><span class="line">        if (p.viewType == AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER) &#123;</span><br><span class="line">            p.recycledHeaderFooter = true;</span><br><span class="line">        &#125;</span><br><span class="line">        addViewInLayout(child, flowDown ? -1 : 0, p, true);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildSelected) &#123;</span><br><span class="line">        child.setSelected(isSelected);</span><br><span class="line">    &#125;</span><br><span class="line">    if (updateChildPressed) &#123;</span><br><span class="line">        child.setPressed(isPressed);</span><br><span class="line">    &#125;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec,</span><br><span class="line">                mListPadding.left + mListPadding.right, p.width);</span><br><span class="line">        int lpHeight = p.height;</span><br><span class="line">        int childHeightSpec;</span><br><span class="line">        if (lpHeight &gt; 0) &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);</span><br><span class="line">        &#125;</span><br><span class="line">        child.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cleanupLayoutState(child);</span><br><span class="line">    &#125;</span><br><span class="line">    final int w = child.getMeasuredWidth();</span><br><span class="line">    final int h = child.getMeasuredHeight();</span><br><span class="line">    final int childTop = flowDown ? y : y - h;</span><br><span class="line">    if (needToMeasure) &#123;</span><br><span class="line">        final int childRight = childrenLeft + w;</span><br><span class="line">        final int childBottom = childTop + h;</span><br><span class="line">        child.layout(childrenLeft, childTop, childRight, childBottom);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        child.offsetLeftAndRight(childrenLeft - child.getLeft());</span><br><span class="line">        child.offsetTopAndBottom(childTop - child.getTop());</span><br><span class="line">    &#125;</span><br><span class="line">    if (mCachingStarted &amp;&amp; !child.isDrawingCacheEnabled()) &#123;</span><br><span class="line">        child.setDrawingCacheEnabled(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，setupChild()方法的最后一个参数是recycled，然后在第32行会对这个变量进行判断，由于recycled现在是true，所以会执行attachViewToParent()方法，而第一次Layout过程则是执行的else语句中的addViewInLayout()方法。<strong>这两个方法最大的区别在于，如果我们需要向ViewGroup中添加一个新的子View，应该调用addViewInLayout()方法，而如果是想要将一个之前detach的View重新attach到ViewGroup上，就应该调用attachViewToParent()方法。</strong>那么由于前面在layoutChildren()方法当中调用了detachAllViewsFromParent()方法，这样ListView中所有的子View都是处于detach状态的，所以这里attachViewToParent()方法是正确的选择。</p>
<p>经历了这样一个detach又attach的过程，ListView中所有的子View又都可以正常显示出来了，那么第二次Layout过程结束。</p>
<h2 id="滑动加载更多数据"><a href="#滑动加载更多数据" class="headerlink" title="滑动加载更多数据"></a>滑动加载更多数据</h2><p>经历了两次Layout过程，虽说我们已经可以在ListView中看到内容了，然而关于ListView最神奇的部分我们却还没有接触到，因为目前ListView中只是加载并显示了第一屏的数据而已。比如说我们的Adapter当中有1000条数据，但是第一屏只显示了10条，ListView中也只有10个子View而已，那么剩下的990是怎样工作并显示到界面上的呢？这就要看一下ListView滑动部分的源码了，因为我们是通过手指滑动来显示更多数据的。</p>
<p>由于滑动部分的机制是属于通用型的，即ListView和GridView都会使用同样的机制，因此这部分代码就肯定是写在AbsListView当中的了。那么监听触控事件是在onTouchEvent()方法当中进行的，我们就来看一下AbsListView中的这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">	if (!isEnabled()) &#123;</span><br><span class="line">		// A disabled view that is clickable still consumes the touch</span><br><span class="line">		// events, it just doesn&apos;t respond to them.</span><br><span class="line">		return isClickable() || isLongClickable();</span><br><span class="line">	&#125;</span><br><span class="line">	final int action = ev.getAction();</span><br><span class="line">	View v;</span><br><span class="line">	int deltaY;</span><br><span class="line">	if (mVelocityTracker == null) &#123;</span><br><span class="line">		mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">	&#125;</span><br><span class="line">	mVelocityTracker.addMovement(ev);</span><br><span class="line">	switch (action &amp; MotionEvent.ACTION_MASK) &#123;</span><br><span class="line">	case MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">		mActivePointerId = ev.getPointerId(0);</span><br><span class="line">		final int x = (int) ev.getX();</span><br><span class="line">		final int y = (int) ev.getY();</span><br><span class="line">		int motionPosition = pointToPosition(x, y);</span><br><span class="line">		if (!mDataChanged) &#123;</span><br><span class="line">			if ((mTouchMode != TOUCH_MODE_FLING) &amp;&amp; (motionPosition &gt;= 0)</span><br><span class="line">					&amp;&amp; (getAdapter().isEnabled(motionPosition))) &#123;</span><br><span class="line">				// User clicked on an actual view (and was not stopping a</span><br><span class="line">				// fling). It might be a</span><br><span class="line">				// click or a scroll. Assume it is a click until proven</span><br><span class="line">				// otherwise</span><br><span class="line">				mTouchMode = TOUCH_MODE_DOWN;</span><br><span class="line">				// FIXME Debounce</span><br><span class="line">				if (mPendingCheckForTap == null) &#123;</span><br><span class="line">					mPendingCheckForTap = new CheckForTap();</span><br><span class="line">				&#125;</span><br><span class="line">				postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				if (ev.getEdgeFlags() != 0 &amp;&amp; motionPosition &lt; 0) &#123;</span><br><span class="line">					// If we couldn&apos;t find a view to click on, but the down</span><br><span class="line">					// event was touching</span><br><span class="line">					// the edge, we will bail out and try again. This allows</span><br><span class="line">					// the edge correcting</span><br><span class="line">					// code in ViewRoot to try to find a nearby view to</span><br><span class="line">					// select</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line"> </span><br><span class="line">				if (mTouchMode == TOUCH_MODE_FLING) &#123;</span><br><span class="line">					// Stopped a fling. It is a scroll.</span><br><span class="line">					createScrollingCache();</span><br><span class="line">					mTouchMode = TOUCH_MODE_SCROLL;</span><br><span class="line">					mMotionCorrection = 0;</span><br><span class="line">					motionPosition = findMotionRow(y);</span><br><span class="line">					reportScrollStateChange(OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (motionPosition &gt;= 0) &#123;</span><br><span class="line">			// Remember where the motion event started</span><br><span class="line">			v = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">			mMotionViewOriginalTop = v.getTop();</span><br><span class="line">		&#125;</span><br><span class="line">		mMotionX = x;</span><br><span class="line">		mMotionY = y;</span><br><span class="line">		mMotionPosition = motionPosition;</span><br><span class="line">		mLastY = Integer.MIN_VALUE;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">		final int pointerIndex = ev.findPointerIndex(mActivePointerId);</span><br><span class="line">		final int y = (int) ev.getY(pointerIndex);</span><br><span class="line">		deltaY = y - mMotionY;</span><br><span class="line">		switch (mTouchMode) &#123;</span><br><span class="line">		case TOUCH_MODE_DOWN:</span><br><span class="line">		case TOUCH_MODE_TAP:</span><br><span class="line">		case TOUCH_MODE_DONE_WAITING:</span><br><span class="line">			// Check if we have moved far enough that it looks more like a</span><br><span class="line">			// scroll than a tap</span><br><span class="line">			startScrollIfNeeded(deltaY);</span><br><span class="line">			break;</span><br><span class="line">		case TOUCH_MODE_SCROLL:</span><br><span class="line">			if (PROFILE_SCROLLING) &#123;</span><br><span class="line">				if (!mScrollProfilingStarted) &#123;</span><br><span class="line">					Debug.startMethodTracing(&quot;AbsListViewScroll&quot;);</span><br><span class="line">					mScrollProfilingStarted = true;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (y != mLastY) &#123;</span><br><span class="line">				deltaY -= mMotionCorrection;</span><br><span class="line">				int incrementalDeltaY = mLastY != Integer.MIN_VALUE ? y - mLastY : deltaY;</span><br><span class="line">				// No need to do all this work if we&apos;re not going to move</span><br><span class="line">				// anyway</span><br><span class="line">				boolean atEdge = false;</span><br><span class="line">				if (incrementalDeltaY != 0) &#123;</span><br><span class="line">					atEdge = trackMotionScroll(deltaY, incrementalDeltaY);</span><br><span class="line">				&#125;</span><br><span class="line">				// Check to see if we have bumped into the scroll limit</span><br><span class="line">				if (atEdge &amp;&amp; getChildCount() &gt; 0) &#123;</span><br><span class="line">					// Treat this like we&apos;re starting a new scroll from the</span><br><span class="line">					// current</span><br><span class="line">					// position. This will let the user start scrolling back</span><br><span class="line">					// into</span><br><span class="line">					// content immediately rather than needing to scroll</span><br><span class="line">					// back to the</span><br><span class="line">					// point where they hit the limit first.</span><br><span class="line">					int motionPosition = findMotionRow(y);</span><br><span class="line">					if (motionPosition &gt;= 0) &#123;</span><br><span class="line">						final View motionView = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">						mMotionViewOriginalTop = motionView.getTop();</span><br><span class="line">					&#125;</span><br><span class="line">					mMotionY = y;</span><br><span class="line">					mMotionPosition = motionPosition;</span><br><span class="line">					invalidate();</span><br><span class="line">				&#125;</span><br><span class="line">				mLastY = y;</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case MotionEvent.ACTION_UP: &#123;</span><br><span class="line">		switch (mTouchMode) &#123;</span><br><span class="line">		case TOUCH_MODE_DOWN:</span><br><span class="line">		case TOUCH_MODE_TAP:</span><br><span class="line">		case TOUCH_MODE_DONE_WAITING:</span><br><span class="line">			final int motionPosition = mMotionPosition;</span><br><span class="line">			final View child = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">			if (child != null &amp;&amp; !child.hasFocusable()) &#123;</span><br><span class="line">				if (mTouchMode != TOUCH_MODE_DOWN) &#123;</span><br><span class="line">					child.setPressed(false);</span><br><span class="line">				&#125;</span><br><span class="line">				if (mPerformClick == null) &#123;</span><br><span class="line">					mPerformClick = new PerformClick();</span><br><span class="line">				&#125;</span><br><span class="line">				final AbsListView.PerformClick performClick = mPerformClick;</span><br><span class="line">				performClick.mChild = child;</span><br><span class="line">				performClick.mClickMotionPosition = motionPosition;</span><br><span class="line">				performClick.rememberWindowAttachCount();</span><br><span class="line">				mResurrectToPosition = motionPosition;</span><br><span class="line">				if (mTouchMode == TOUCH_MODE_DOWN || mTouchMode == TOUCH_MODE_TAP) &#123;</span><br><span class="line">					final Handler handler = getHandler();</span><br><span class="line">					if (handler != null) &#123;</span><br><span class="line">						handler.removeCallbacks(mTouchMode == TOUCH_MODE_DOWN ? mPendingCheckForTap</span><br><span class="line">								: mPendingCheckForLongPress);</span><br><span class="line">					&#125;</span><br><span class="line">					mLayoutMode = LAYOUT_NORMAL;</span><br><span class="line">					if (!mDataChanged &amp;&amp; mAdapter.isEnabled(motionPosition)) &#123;</span><br><span class="line">						mTouchMode = TOUCH_MODE_TAP;</span><br><span class="line">						setSelectedPositionInt(mMotionPosition);</span><br><span class="line">						layoutChildren();</span><br><span class="line">						child.setPressed(true);</span><br><span class="line">						positionSelector(child);</span><br><span class="line">						setPressed(true);</span><br><span class="line">						if (mSelector != null) &#123;</span><br><span class="line">							Drawable d = mSelector.getCurrent();</span><br><span class="line">							if (d != null &amp;&amp; d instanceof TransitionDrawable) &#123;</span><br><span class="line">								((TransitionDrawable) d).resetTransition();</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						postDelayed(new Runnable() &#123;</span><br><span class="line">							public void run() &#123;</span><br><span class="line">								child.setPressed(false);</span><br><span class="line">								setPressed(false);</span><br><span class="line">								if (!mDataChanged) &#123;</span><br><span class="line">									post(performClick);</span><br><span class="line">								&#125;</span><br><span class="line">								mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;, ViewConfiguration.getPressedStateDuration());</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">					&#125;</span><br><span class="line">					return true;</span><br><span class="line">				&#125; else if (!mDataChanged &amp;&amp; mAdapter.isEnabled(motionPosition)) &#123;</span><br><span class="line">					post(performClick);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">			break;</span><br><span class="line">		case TOUCH_MODE_SCROLL:</span><br><span class="line">			final int childCount = getChildCount();</span><br><span class="line">			if (childCount &gt; 0) &#123;</span><br><span class="line">				if (mFirstPosition == 0</span><br><span class="line">						&amp;&amp; getChildAt(0).getTop() &gt;= mListPadding.top</span><br><span class="line">						&amp;&amp; mFirstPosition + childCount &lt; mItemCount</span><br><span class="line">						&amp;&amp; getChildAt(childCount - 1).getBottom() &lt;= getHeight()</span><br><span class="line">								- mListPadding.bottom) &#123;</span><br><span class="line">					mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">					reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					final VelocityTracker velocityTracker = mVelocityTracker;</span><br><span class="line">					velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);</span><br><span class="line">					final int initialVelocity = (int) velocityTracker</span><br><span class="line">							.getYVelocity(mActivePointerId);</span><br><span class="line">					if (Math.abs(initialVelocity) &gt; mMinimumVelocity) &#123;</span><br><span class="line">						if (mFlingRunnable == null) &#123;</span><br><span class="line">							mFlingRunnable = new FlingRunnable();</span><br><span class="line">						&#125;</span><br><span class="line">						reportScrollStateChange(OnScrollListener.SCROLL_STATE_FLING);</span><br><span class="line">						mFlingRunnable.start(-initialVelocity);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">						reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">				reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		setPressed(false);</span><br><span class="line">		// Need to redraw since we probably aren&apos;t drawing the selector</span><br><span class="line">		// anymore</span><br><span class="line">		invalidate();</span><br><span class="line">		final Handler handler = getHandler();</span><br><span class="line">		if (handler != null) &#123;</span><br><span class="line">			handler.removeCallbacks(mPendingCheckForLongPress);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mVelocityTracker != null) &#123;</span><br><span class="line">			mVelocityTracker.recycle();</span><br><span class="line">			mVelocityTracker = null;</span><br><span class="line">		&#125;</span><br><span class="line">		mActivePointerId = INVALID_POINTER;</span><br><span class="line">		if (PROFILE_SCROLLING) &#123;</span><br><span class="line">			if (mScrollProfilingStarted) &#123;</span><br><span class="line">				Debug.stopMethodTracing();</span><br><span class="line">				mScrollProfilingStarted = false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">		mTouchMode = TOUCH_MODE_REST;</span><br><span class="line">		setPressed(false);</span><br><span class="line">		View motionView = this.getChildAt(mMotionPosition - mFirstPosition);</span><br><span class="line">		if (motionView != null) &#123;</span><br><span class="line">			motionView.setPressed(false);</span><br><span class="line">		&#125;</span><br><span class="line">		clearScrollingCache();</span><br><span class="line">		final Handler handler = getHandler();</span><br><span class="line">		if (handler != null) &#123;</span><br><span class="line">			handler.removeCallbacks(mPendingCheckForLongPress);</span><br><span class="line">		&#125;</span><br><span class="line">		if (mVelocityTracker != null) &#123;</span><br><span class="line">			mVelocityTracker.recycle();</span><br><span class="line">			mVelocityTracker = null;</span><br><span class="line">		&#125;</span><br><span class="line">		mActivePointerId = INVALID_POINTER;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	case MotionEvent.ACTION_POINTER_UP: &#123;</span><br><span class="line">		onSecondaryPointerUp(ev);</span><br><span class="line">		final int x = mMotionX;</span><br><span class="line">		final int y = mMotionY;</span><br><span class="line">		final int motionPosition = pointToPosition(x, y);</span><br><span class="line">		if (motionPosition &gt;= 0) &#123;</span><br><span class="line">			// Remember where the motion event started</span><br><span class="line">			v = getChildAt(motionPosition - mFirstPosition);</span><br><span class="line">			mMotionViewOriginalTop = v.getTop();</span><br><span class="line">			mMotionPosition = motionPosition;</span><br><span class="line">		&#125;</span><br><span class="line">		mLastY = y;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法中的代码就非常多了，因为它所处理的逻辑也非常多，要监听各种各样的触屏事件。但是我们目前所关心的就只有手指在屏幕上滑动这一个事件而已，对应的是ACTION_MOVE这个动作，那么我们就只看这部分代码就可以了。可以看到，ACTION_MOVE这个case里面又嵌套了一个switch语句，是根据当前的TouchMode来选择的。那这里我可以直接告诉大家，当手指在屏幕上滑动时，TouchMode是等于TOUCH_MODE_SCROLL这个值的。</p>
<p>这样的话，代码就应该会走到第78行的这个case里面去了，在这个case当中并没有什么太多需要注意的东西，唯一一点非常重要的就是第92行调用的trackMotionScroll()方法，相当于我们手指只要在屏幕上稍微有一点点移动，这个方法就会被调用，而如果是正常在屏幕上滑动的话，那么这个方法就会被调用很多次。那么我们进入到这个方法中瞧一瞧，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">boolean trackMotionScroll(int deltaY, int incrementalDeltaY) &#123;</span><br><span class="line">	final int childCount = getChildCount();</span><br><span class="line">	if (childCount == 0) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	final int firstTop = getChildAt(0).getTop();</span><br><span class="line">	final int lastBottom = getChildAt(childCount - 1).getBottom();</span><br><span class="line">	final Rect listPadding = mListPadding;</span><br><span class="line">	final int spaceAbove = listPadding.top - firstTop;</span><br><span class="line">	final int end = getHeight() - listPadding.bottom;</span><br><span class="line">	final int spaceBelow = lastBottom - end;</span><br><span class="line">	final int height = getHeight() - getPaddingBottom() - getPaddingTop();</span><br><span class="line">	if (deltaY &lt; 0) &#123;</span><br><span class="line">		deltaY = Math.max(-(height - 1), deltaY);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		deltaY = Math.min(height - 1, deltaY);</span><br><span class="line">	&#125;</span><br><span class="line">	if (incrementalDeltaY &lt; 0) &#123;</span><br><span class="line">		incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);</span><br><span class="line">	&#125;</span><br><span class="line">	final int firstPosition = mFirstPosition;</span><br><span class="line">	if (firstPosition == 0 &amp;&amp; firstTop &gt;= listPadding.top &amp;&amp; deltaY &gt;= 0) &#123;</span><br><span class="line">		// Don&apos;t need to move views down if the top of the first position</span><br><span class="line">		// is already visible</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	if (firstPosition + childCount == mItemCount &amp;&amp; lastBottom &lt;= end &amp;&amp; deltaY &lt;= 0) &#123;</span><br><span class="line">		// Don&apos;t need to move views up if the bottom of the last position</span><br><span class="line">		// is already visible</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	final boolean down = incrementalDeltaY &lt; 0;</span><br><span class="line">	final boolean inTouchMode = isInTouchMode();</span><br><span class="line">	if (inTouchMode) &#123;</span><br><span class="line">		hideSelector();</span><br><span class="line">	&#125;</span><br><span class="line">	final int headerViewsCount = getHeaderViewsCount();</span><br><span class="line">	final int footerViewsStart = mItemCount - getFooterViewsCount();</span><br><span class="line">	int start = 0;</span><br><span class="line">	int count = 0;</span><br><span class="line">	if (down) &#123;</span><br><span class="line">		final int top = listPadding.top - incrementalDeltaY;</span><br><span class="line">		for (int i = 0; i &lt; childCount; i++) &#123;</span><br><span class="line">			final View child = getChildAt(i);</span><br><span class="line">			if (child.getBottom() &gt;= top) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				count++;</span><br><span class="line">				int position = firstPosition + i;</span><br><span class="line">				if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</span><br><span class="line">					mRecycler.addScrapView(child);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		final int bottom = getHeight() - listPadding.bottom - incrementalDeltaY;</span><br><span class="line">		for (int i = childCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">			final View child = getChildAt(i);</span><br><span class="line">			if (child.getTop() &lt;= bottom) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				start = i;</span><br><span class="line">				count++;</span><br><span class="line">				int position = firstPosition + i;</span><br><span class="line">				if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) &#123;</span><br><span class="line">					mRecycler.addScrapView(child);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mMotionViewNewTop = mMotionViewOriginalTop + deltaY;</span><br><span class="line">	mBlockLayoutRequests = true;</span><br><span class="line">	if (count &gt; 0) &#123;</span><br><span class="line">		detachViewsFromParent(start, count);</span><br><span class="line">	&#125;</span><br><span class="line">	offsetChildrenTopAndBottom(incrementalDeltaY);</span><br><span class="line">	if (down) &#123;</span><br><span class="line">		mFirstPosition += count;</span><br><span class="line">	&#125;</span><br><span class="line">	invalidate();</span><br><span class="line">	final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);</span><br><span class="line">	if (spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) &#123;</span><br><span class="line">		fillGap(down);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!inTouchMode &amp;&amp; mSelectedPosition != INVALID_POSITION) &#123;</span><br><span class="line">		final int childIndex = mSelectedPosition - mFirstPosition;</span><br><span class="line">		if (childIndex &gt;= 0 &amp;&amp; childIndex &lt; getChildCount()) &#123;</span><br><span class="line">			positionSelector(getChildAt(childIndex));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mBlockLayoutRequests = false;</span><br><span class="line">	invokeOnItemScrollListener();</span><br><span class="line">	awakenScrollBars();</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法接收两个参数，deltaY表示从手指按下时的位置到当前手指位置的距离，incrementalDeltaY则表示据上次触发event事件手指在Y方向上位置的改变量，那么其实我们就可以通过incrementalDeltaY的正负值情况来判断用户是向上还是向下滑动的了。如第34行代码所示，如果incrementalDeltaY小于0，说明是向下滑动，否则就是向上滑动。</p>
<p>下面将会进行一个边界值检测的过程，可以看到，从第43行开始，当ListView向下滑动的时候，就会进入一个for循环当中，从上往下依次获取子View，第47行当中，如果该子View的bottom值已经小于top值了，就说明这个子View已经移出屏幕了，所以会调用RecycleBin的addScrapView()方法将这个View加入到废弃缓存当中，并将count计数器加1，计数器用于记录有多少个子View被移出了屏幕。那么如果是ListView向上滑动的话，其实过程是基本相同的，只不过变成了从下往上依次获取子View，然后判断该子View的top值是不是大于bottom值了，如果大于的话说明子View已经移出了屏幕，同样把它加入到废弃缓存中，并将计数器加1。</p>
<p>接下来在第76行，会根据当前计数器的值来进行一个detach操作，它的作用就是把所有移出屏幕的子View全部detach掉，在ListView的概念当中，所有看不到的View就没有必要为它进行保存，因为屏幕外还有成百上千条数据等着显示呢，一个好的回收策略才能保证ListView的高性能和高效率。<strong>紧接着在第78行调用了offsetChildrenTopAndBottom()方法，并将incrementalDeltaY作为参数传入，这个方法的作用是让ListView中所有的子View都按照传入的参数值进行相应的偏移，这样就实现了随着手指的拖动，ListView的内容也会随着滚动的效果。</strong></p>
<p>然后在第84行会进行判断，如果ListView中最后一个View的底部已经移入了屏幕，或者ListView中第一个View的顶部移入了屏幕，就会调用fillGap()方法，那么因此我们就可以猜出fillGap()方法是用来加载屏幕外数据的，进入到这个方法中瞧一瞧，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Fills the gap left open by a touch-scroll. During a touch scroll,</span><br><span class="line"> * children that remain on screen are shifted and the other ones are</span><br><span class="line"> * discarded. The role of this method is to fill the gap thus created by</span><br><span class="line"> * performing a partial layout in the empty space.</span><br><span class="line"> * </span><br><span class="line"> * @param down</span><br><span class="line"> *            true if the scroll is going down, false if it is going up</span><br><span class="line"> */</span><br><span class="line">abstract void fillGap(boolean down);</span><br><span class="line">OK，AbsListView中的fillGap()是一个抽象方法，那么我们立刻就能够想到，它的具体实现肯定是在ListView中完成的了。回到ListView当中，fillGap()方法的代码如下所示：</span><br><span class="line">void fillGap(boolean down) &#123;</span><br><span class="line">    final int count = getChildCount();</span><br><span class="line">    if (down) &#123;</span><br><span class="line">        final int startOffset = count &gt; 0 ? getChildAt(count - 1).getBottom() + mDividerHeight :</span><br><span class="line">                getListPaddingTop();</span><br><span class="line">        fillDown(mFirstPosition + count, startOffset);</span><br><span class="line">        correctTooHigh(getChildCount());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final int startOffset = count &gt; 0 ? getChildAt(0).getTop() - mDividerHeight :</span><br><span class="line">                getHeight() - getListPaddingBottom();</span><br><span class="line">        fillUp(mFirstPosition - 1, startOffset);</span><br><span class="line">        correctTooLow(getChildCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>down参数用于表示ListView是向下滑动还是向上滑动的，可以看到，如果是向下滑动的话就会调用fillDown()方法，而如果是向上滑动的话就会调用fillUp()方法。那么这两个方法我们都已经非常熟悉了，内部都是通过一个循环来去对ListView进行填充，所以这两个方法我们就不看了，但是填充ListView会通过调用makeAndAddView()方法来完成，又是makeAndAddView()方法，但这次的逻辑再次不同了，所以我们还是回到这个方法瞧一瞧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Obtain the view and add it to our list of children. The view can be made</span><br><span class="line"> * fresh, converted from an unused view, or used as is if it was in the</span><br><span class="line"> * recycle bin.</span><br><span class="line"> *</span><br><span class="line"> * @param position Logical position in the list</span><br><span class="line"> * @param y Top or bottom edge of the view to add</span><br><span class="line"> * @param flow If flow is true, align top edge to y. If false, align bottom</span><br><span class="line"> *        edge to y.</span><br><span class="line"> * @param childrenLeft Left edge where children should be positioned</span><br><span class="line"> * @param selected Is this position selected?</span><br><span class="line"> * @return View that was added</span><br><span class="line"> */</span><br><span class="line">private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,</span><br><span class="line">        boolean selected) &#123;</span><br><span class="line">    View child;</span><br><span class="line">    if (!mDataChanged) &#123;</span><br><span class="line">        // Try to use an exsiting view for this position</span><br><span class="line">        child = mRecycler.getActiveView(position);</span><br><span class="line">        if (child != null) &#123;</span><br><span class="line">            // Found it -- we&apos;re using an existing child</span><br><span class="line">            // This just needs to be positioned</span><br><span class="line">            setupChild(child, position, y, flow, childrenLeft, selected, true);</span><br><span class="line">            return child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Make a new view for this position, or convert an unused view if possible</span><br><span class="line">    child = obtainView(position, mIsScrap);</span><br><span class="line">    // This needs to be positioned and measured</span><br><span class="line">    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不管怎么说，这里首先仍然是会尝试调用RecycleBin的getActiveView()方法来获取子布局，只不过肯定是获取不到的了，因为在第二次Layout过程中我们已经从mActiveViews中获取过了数据，而根据RecycleBin的机制，mActiveViews是不能够重复利用的，因此这里返回的值肯定是null。</p>
<p>既然getActiveView()方法返回的值是null，那么就还是会走到第28行的obtainView()方法当中，代码如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Get a view and have it show the data associated with the specified</span><br><span class="line"> * position. This is called when we have already discovered that the view is</span><br><span class="line"> * not available for reuse in the recycle bin. The only choices left are</span><br><span class="line"> * converting an old view or making a new one.</span><br><span class="line"> * </span><br><span class="line"> * @param position</span><br><span class="line"> *            The position to display</span><br><span class="line"> * @param isScrap</span><br><span class="line"> *            Array of at least 1 boolean, the first entry will become true</span><br><span class="line"> *            if the returned view was taken from the scrap heap, false if</span><br><span class="line"> *            otherwise.</span><br><span class="line"> * </span><br><span class="line"> * @return A view displaying the data associated with the specified position</span><br><span class="line"> */</span><br><span class="line">View obtainView(int position, boolean[] isScrap) &#123;</span><br><span class="line">	isScrap[0] = false;</span><br><span class="line">	View scrapView;</span><br><span class="line">	scrapView = mRecycler.getScrapView(position);</span><br><span class="line">	View child;</span><br><span class="line">	if (scrapView != null) &#123;</span><br><span class="line">		child = mAdapter.getView(position, scrapView, this);</span><br><span class="line">		if (child != scrapView) &#123;</span><br><span class="line">			mRecycler.addScrapView(scrapView);</span><br><span class="line">			if (mCacheColorHint != 0) &#123;</span><br><span class="line">				child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			isScrap[0] = true;</span><br><span class="line">			dispatchFinishTemporaryDetach(child);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		child = mAdapter.getView(position, null, this);</span><br><span class="line">		if (mCacheColorHint != 0) &#123;</span><br><span class="line">			child.setDrawingCacheBackgroundColor(mCacheColorHint);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这里在第19行会调用RecyleBin的getScrapView()方法来尝试从废弃缓存中获取一个View，那么废弃缓存有没有View呢？当然有，因为刚才在trackMotionScroll()方法中我们就已经看到了，一旦有任何子View被移出了屏幕，就会将它加入到废弃缓存中，而从obtainView()方法中的逻辑来看，一旦有新的数据需要显示到屏幕上，就会尝试从废弃缓存中获取View。所以它们之间就形成了一个生产者和消费者的模式，那么ListView神奇的地方也就在这里体现出来了，不管你有任意多条数据需要显示，ListView中的子View其实来来回回就那么几个，移出屏幕的子View会很快被移入屏幕的数据重新利用起来，因而不管我们加载多少数据都不会出现OOM的情况，甚至内存都不会有所增加。</strong></p>
<p>那么另外还有一点是需要大家留意的，这里获取到了一个scrapView，然后我们在第22行将它作为第二个参数传入到了Adapter的getView()方法当中。那么第二个参数是什么意思呢？我们再次看一下一个简单的getView()方法示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">	Fruit fruit = getItem(position);</span><br><span class="line">	View view;</span><br><span class="line">	if (convertView == null) &#123;</span><br><span class="line">		view = LayoutInflater.from(getContext()).inflate(resourceId, null);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		view = convertView;</span><br><span class="line">	&#125;</span><br><span class="line">	ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image);</span><br><span class="line">	TextView fruitName = (TextView) view.findViewById(R.id.fruit_name);</span><br><span class="line">	fruitImage.setImageResource(fruit.getImageId());</span><br><span class="line">	fruitName.setText(fruit.getName());</span><br><span class="line">	return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个参数就是我们最熟悉的convertView呀，难怪平时我们在写getView()方法是要判断一下convertView是不是等于null，如果等于null才调用inflate()方法来加载布局，不等于null就可以直接利用convertView，因为convertView就是我们之间利用过的View，只不过被移出屏幕后进入到了废弃缓存中，现在又重新拿出来使用而已。然后我们只需要把convertView中的数据更新成当前位置上应该显示的数据，那么看起来就好像是全新加载出来的一个布局一样，这背后的道理你是不是已经完全搞明白了？</p>
<p>之后的代码又都是我们熟悉的流程了，从缓存中拿到子View之后再调用setupChild()方法将它重新attach到ListView当中，因为缓存中的View也是之前从ListView中detach掉的，这部分代码就不再重复进行分析了。</p>
<p>为了方便大家理解，这里我再附上一张图解说明：<br><img src="/2019/09/05/android-listview/recycle_bin.png" alt></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/guolin_blog/article/details/44996879" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/44996879</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/16/android-ndk-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/android-ndk-knowledge/" itemprop="url">NDK之CMake</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T09:42:27+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android-NDK/" itemprop="url" rel="index">
                    <span itemprop="name">Android NDK</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>JNI（Java Native Interface），是方便Java调用C、C++等Native代码所封装的一层接口，相当于一座桥梁。通过JNI可以操作一些Java无法完成的与系统相关的特性，尤其在图像和视频处理中大量用到。</p>
<p>NDK（native development kit）提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。NDK集成了<strong>交叉编译器</strong>，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so，该动态库可以兼容各个平台。</p>
<h2 id="2、CMake"><a href="#2、CMake" class="headerlink" title="2、CMake"></a>2、CMake</h2><p>CMake是一个跨平台的安装(编译)工具，通过编写CMakeLists.txt，可以生成对应的makefile或project文件，再调用底层的编译。AS 2.2之后工具中增加了对CMake的支持，官方也推荐用CMake+CMakeLists.txt的方式，代替ndk-build+Android.mk+Application.mk的方式去构建JNI项目.</p>
<h3 id="创建使用CMake构建的项目"><a href="#创建使用CMake构建的项目" class="headerlink" title="创建使用CMake构建的项目"></a>创建使用CMake构建的项目</h3><p>开始前AS要先在SDK Manager中安装SDK Tools-&gt;CMake，只要勾选Include C++ Support。其中会提示配置C++支持的功能.</p>
<p>一般默认就可以了，各个选项的具体含义:</p>
<blockquote>
<p>C++ Standard：指定编译库的环境。<br>Exception Support:当前项目支持C++异常处理<br>Runtime Type Information Support：除异常处理外，还支持动态转类型(dynamic casting) 、模块集成、以及对象I/O</p>
</blockquote>
<h3 id="工程的目录结构"><a href="#工程的目录结构" class="headerlink" title="工程的目录结构"></a>工程的目录结构</h3><p>创建好的工程主Module下直接就有.externalNativeBuild，多出一个CMakeLists.txt，相当于以前的配置文件。并且在src/main目录下多了一个cpp文件夹，里面存放的是C++文件，相当于以前的jni文件夹。这个是工程创建后AS生成的示例JNI方法，返回了一个字符串。后面开发JNI就可以按照这个目录结构。</p>
<p>相应的，build.gradle下也增加了一些配置:</p>
<pre><code>android {
    ...
    defaultConfig {
        ...
        externalNativeBuild {
            cmake {
                cppFlags &quot;-std=c++14 -frtti -fexceptions&quot;
                abiFilters &quot;x86&quot;, &quot;arm64-v8a&quot;, &quot;armeabi-v7a&quot;
            }
        }
    }
    buildTypes {
        ...
    }
    externalNativeBuild {
        cmake {
            path &quot;CMakeLists.txt&quot;
        }
    }
}
</code></pre><p>defaultConfig中的externalNativeBuild各项属性和前面创建项目时的选项配置有关，外部的externalNativeBuild则定义了CMakeLists.txt的存放路径。<br>如果只是在自己的项目中使用，CMake的方式在打包APK的时候会自动将cpp文件编译成so文件拷贝进去。如果要提供给外部使用时，Make Project，之后在libs目录下就可以看到生成的对应配置的相关CPU平台的.so文件。</p>
<h3 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h3><p>CMakeLists.txt可以自定义命令、查找文件、头文件包含、设置变量，具体可见 官方文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 编译本地库时我们需要的最小的cmake版本</span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line">#设置生成的so动态库最后输出的路径，一定要在add_library之前设置，否则不会生效</span><br><span class="line">set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/libs/$&#123;ANDROID_ABI&#125;)</span><br><span class="line"></span><br><span class="line"># 相当于Android.mk。如果是多次使用add_library，则会生成多个so库；</span><br><span class="line"># 如果想将多个本地文件编译到一个so库中，只要最后一个参数添加多个C/C++文件的相对路径就可以</span><br><span class="line">add_library( # Sets the name of the library.设置编译生成本地库的名字</span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             # Sets the library as a shared library.库的类型</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).编译文件的路径</span><br><span class="line">             src/main/cpp/native-lib.cpp )</span><br><span class="line"></span><br><span class="line"># 添加一些我们在编译我们的本地库的时候需要依赖的一些库，这里是用来打log的库。可以写多个find_library</span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line"># 关联自己生成的库和一些第三方库或者系统库</span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       # Links the target library to the log library</span><br><span class="line">                       # included in the NDK.</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br><span class="line"></span><br><span class="line">#设置头文件搜索路径（和此txt同个路径的头文件无需设置），可选</span><br><span class="line">#INCLUDE_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/common)</span><br><span class="line"></span><br><span class="line">#指定用到的系统库或者NDK库或者第三方库的搜索路径，可选。</span><br><span class="line">#LINK_DIRECTORIES(/usr/local/lib)</span><br><span class="line"></span><br><span class="line">#添加子目录,将会调用子目录中的CMakeLists.txt</span><br><span class="line">ADD_SUBDIRECTORY(one)</span><br><span class="line">ADD_SUBDIRECTORY(two)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>cmake_minimum_required(VERSION 3.4.1)：指定CMake的最小版本</li>
<li>add_library：创建一个静态或者动态库，并提供其关联的源文件路径，开发者可以定义多个库，CMake会自动去构建它们。Gradle可以自动将它们打包进APK中。<br>第一个参数——native-lib：是库的名称<br>第二个参数——SHARED：是库的类别，是动态的还是静态的<br>第三个参数——src/main/cpp/native-lib.cpp：是库的源文件的路径</li>
<li>find_library：找到一个预编译的库，并作为一个变量保存起来。由于CMake在搜索库路径的时候会包含系统库，并且CMake会检查它自己之前编译的库的名字，所以开发者需要保证开发者自行添加的库的名字的独特性。<br>第一个参数——log-lib：设置路径变量的名称<br>第一个参数—— log：指定NDK库的名子，这样CMake就可以找到这个库</li>
<li>target_link_libraries：指定CMake链接到目标库。开发者可以链接多个库，比如开发者可以在此定义库的构建脚本，并且预编译第三方库或者系统库。<br>第一个参数——native-lib：指定的目标库<br>第一个参数——${log-lib}：将目标库链接到NDK中的日志库，</li>
</ul>
<p>如果想要配置so库的目标CPU平台，可以在build.gradle中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ...</span><br><span class="line">        ndk&#123;</span><br><span class="line">            abiFilters &quot;x86&quot;,&quot;armeabi&quot;,&quot;armeabi-v7a&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="set-target-properties"><a href="#set-target-properties" class="headerlink" title="set_target_properties"></a>set_target_properties</h4><p>设置目标的一些属性来改变它们构建的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(target1 target2 ...</span><br><span class="line">                      PROPERTIES prop1 value1</span><br><span class="line">                      prop2 value2 ...)</span><br></pre></td></tr></table></figure></p>
<p>使用示例为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(cocos2d</span><br><span class="line">    PROPERTIES</span><br><span class="line">    ARCHIVE_OUTPUT_DIRECTORY &quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span><br><span class="line">    LIBRARY_OUTPUT_DIRECTORY &quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span><br><span class="line">    VERSION &quot;$&#123;COCOS2D_X_VERSION&#125;&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>为一个目标设置属性。该命令的语法是列出所有你想要变更的文件，然后提供你想要设置的值。你能够使用任何你想要的属性/值对，并且在随后的代码中调用GET_TARGET_PROPERTY命令取出属性的值。</p>
<p>大家在用cmake时，应该经常会用到第三方so库，导入第三方so库中需要使用到set_target_properties,例如这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(</span><br><span class="line"></span><br><span class="line">Thirdlib</span><br><span class="line"></span><br><span class="line">PROPERTIES IMPORTED_LOCATION</span><br><span class="line"></span><br><span class="line">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/jniLibs/libThirdlib.so</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>CMAKE_CURRENT_SOURCE_DIR 这个变量是系统自定义的，表示CMakeLists.txt文件的绝对路径</p>
<h3 id="包含其他-CMake-项目"><a href="#包含其他-CMake-项目" class="headerlink" title="包含其他 CMake 项目"></a>包含其他 CMake 项目</h3><p>如果想要编译多个 CMake 项目并在 Android 项目中包含它们的输出，您可以使用一个 CMakeLists.txt 文件（即您关联到 Gradle 的那个文件）作为顶级 CMake 编译脚本，并添加其他 CMake 项目作为此编译脚本的依赖项。以下顶级 CMake 编译脚本使用 add_subdirectory() 命令将另一个 CMakeLists.txt 文件指定为编译依赖项，然后关联其输出，就像处理任何其他预编译库一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Sets lib_src_DIR to the path of the target CMake project.</span><br><span class="line">set( lib_src_DIR ../gmath )</span><br><span class="line"></span><br><span class="line"># Sets lib_build_DIR to the path of the desired output directory.</span><br><span class="line">set( lib_build_DIR ../gmath/outputs )</span><br><span class="line">file(MAKE_DIRECTORY $&#123;lib_build_DIR&#125;)</span><br><span class="line"></span><br><span class="line"># Adds the CMakeLists.txt file located in the specified directory</span><br><span class="line"># as a build dependency.</span><br><span class="line">add_subdirectory( # Specifies the directory of the CMakeLists.txt file.</span><br><span class="line">                  $&#123;lib_src_DIR&#125;</span><br><span class="line"></span><br><span class="line">                  # Specifies the directory for the build outputs.</span><br><span class="line">                  $&#123;lib_build_DIR&#125; )</span><br><span class="line"></span><br><span class="line"># Adds the output of the additional CMake build as a prebuilt static</span><br><span class="line"># library and names it lib_gmath.</span><br><span class="line">add_library( lib_gmath STATIC IMPORTED )</span><br><span class="line">set_target_properties( lib_gmath PROPERTIES IMPORTED_LOCATION</span><br><span class="line">                       $&#123;lib_build_DIR&#125;/$&#123;ANDROID_ABI&#125;/lib_gmath.a )</span><br><span class="line">include_directories( $&#123;lib_src_DIR&#125;/include )</span><br><span class="line"></span><br><span class="line"># Links the top-level CMake build output against lib_gmath.</span><br><span class="line">target_link_libraries( native-lib ... lib_gmath )</span><br></pre></td></tr></table></figure></p>
<h2 id="3、Android-mk"><a href="#3、Android-mk" class="headerlink" title="3、Android.mk"></a>3、Android.mk</h2><p>Android.mk内容示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE    := ndkdemotest-jni</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES := ndkdemotest.c</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>LOCAL_PATH := $(call my-dir)：每个Android.mk文件必须以定义开始。它用于在开发tree中查找源文件。宏my-dir则由Build System 提供。返回包含Android.mk目录路径。</p>
</li>
<li><p>include $(CLEAR_VARS) ：CLEAR_VARS变量由Build System提供。并指向一个指定的GNU Makefile，由它负责清理很多LOCAL_xxx。例如LOCAL_MODULE，LOCAL_SRC_FILES，LOCAL_STATIC_LIBRARIES等等。但不是清理LOCAL_PATH。这个清理是必须的，因为所有的编译控制文件由同一个GNU Make解析和执行，其变量是全局的。所以清理后才能便面相互影响。</p>
</li>
<li><p>LOCAL_MODULE := ndkdemotest-jni：LOCAL_MODULE模块必须定义，以表示Android.mk中的每一个模块。名字必须唯一且不包含空格。Build System 会自动添加适当的前缀和后缀。例如，demo，要生成动态库，则生成libdemo.so。但请注意：如果模块名字被定义为libabd，则生成libabc.so。不再添加前缀。</p>
</li>
<li><p>LOCAL_SRC_FILES := ndkdemotest.c：这行代码表示将要打包的C/C++源码。不必列出头文件，build System 会自动帮我们找出依赖文件。缺省的C++ 源码的扩展名为.cpp。</p>
</li>
<li><p>include $(BUILD_SHARED_LIBRARY)：BUILD_SHARED_LIBRARY是Build System提供的一个变量，指向一个GUN Makefile Script。它负责收集自从上次调用include $(CLEAR_VARS)后的所有LOCAL_xxxxinx。并决定编译什么类型：<br>1）BUILD_STATIC_LIBRARY：编译为静态库<br>2）BUILD_SHARED_LIBRARY：编译为动态库<br>3）BUILD_EXECUTABLE：编译为Native C 可执行程序<br>4）BUILD_PREBUILT：该模块已经预先编译</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/wzhseu/article/details/79683045" target="_blank" rel="noopener">https://blog.csdn.net/wzhseu/article/details/79683045</a><br><a href="https://www.cnblogs.com/alphagl/p/6280061.html" target="_blank" rel="noopener">CMake学习</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/12/android-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/android-note/" itemprop="url">Android小知识点笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T09:22:55+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="λ表达式"><a href="#λ表达式" class="headerlink" title="λ表达式"></a>λ表达式</h2><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。</p>
<p>lambda 表达式的语法格式如下：</p>
<blockquote>
<p>(parameters) -&gt; expression<br>或<br>(parameters) -&gt;{ statements; }</p>
</blockquote>
<p>以下是lambda表达式的重要特征:</p>
<ul>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
<p><strong>λ表达式主要用于替换以前广泛使用的内部匿名类，各种回调，比如事件响应器、传入Thread类的Runnable等。</strong>Java8有一个短期目标和一个长期目标。<strong>短期目标是：配合“集合类批处理操作”的内部迭代和并行处理；长期目标是将Java向函数式编程语言这个方向引导</strong>（并不是要完全变成一门函数式编程语言，只是让它有更多的函数式编程语言的特性）。</p>
<p>Java8为集合类引入了另一个重要概念：流（stream）。一个流通常以一个集合类实例为其数据源，然后在其上定义各种操作。流的API设计使用了管道（pipelines）模式。对流的一次操作会返回另一个流。你可能会觉得List 被迭代了好多次，map，filter，distinct都分别是一次循环，效率会不好。实际并非如此。这些返回另一个Stream的方法都是“懒（lazy）”的，而最后返回最终结果的方法则是“急（eager）”的。在遇到eager方法之前，lazy的方法不会执行。</p>
<p><strong>内部类总是持有一个其外部类对象的引用。而λ表达式呢，除非在它内部用到了其外部类（包围类）对象的方法或者成员，否则它就不持有这个对象的引用。</strong>在Java8以前，如果要在内部类访问外部对象的一个本地变量，那么这个变量必须声明为final才行。在Java8中，这种限制被去掉了，代之以一个新的概念，“effectively final”。它的意思是你可以声明为final，也可以不声明final但是按照final来用，也就是一次赋值永不改变。</p>
<p><strong>任何一个λ表达式都可以代表某个函数接口的唯一方法的匿名描述符。我们也可以使用某个类的某个具体方法来代表这个描述符，叫做方法引用。</strong></p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>外部类创建匿名内部类后，有可能匿名内部类还在使用，而外部类实例（或者创建内部类的方法）已经被回收了。如果此时匿名内部类用到了外部类的成员变量，那么就会出现匿名内部类要去访问一个不存在的变量的这种荒唐情况，为了延长局部变量的生命周期，于是匿名内部类使用的局部变量会被复制一份，从而使得局部变量的生命周期看起来变长了。但是这样又会引出另一个问题：<strong>数据一致性的问题！为了保证局部变量和 内部类中复制品 的数据一致性，于是要求内部类使用的局部变量是final的</strong>。</p>
<h2 id="String-amp-StringBuffer-amp-StringBuilder"><a href="#String-amp-StringBuffer-amp-StringBuilder" class="headerlink" title="String &amp; StringBuffer &amp; StringBuilder"></a>String &amp; StringBuffer &amp; StringBuilder</h2><p>1、长度是否可变<br>String 是被 final 修饰的，他的长度是不可变的，就算调用 String 的concat 方法，那也是把字符串拼接起来并重新创建一个对象，把拼接后的 String 的值赋给新创建的对象<br>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象，StringBuffer 与 StringBuilder 中的方法和功能完全是等价的。调用StringBuffer 的 append 方法，来改变 StringBuffer 的长度，并且，相比较于 StringBuffer，String 一旦发生长度变化，是非常耗费内存的！</p>
<p>2、执行效率<br>三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String</p>
<p>3、应用场景<br>如果要操作少量的数据用 = String<br>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder<br>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</p>
<p>StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。</p>
<h2 id="Java中Vector和ArrayList的区别"><a href="#Java中Vector和ArrayList的区别" class="headerlink" title="Java中Vector和ArrayList的区别"></a>Java中Vector和ArrayList的区别</h2><p>首先看这两类都实现List接口，而List接口一共有三个实现类，分别是ArrayList、Vector和LinkedList。List用于存放多个元素，能够维护元素的次序，并且允许元素的重复。3个具体实现类的相关区别如下：</p>
<ol>
<li>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li>
<li>Vector与ArrayList一样，<strong>也是通过数组实现的，不同的是它支持线程的同步</strong>，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</li>
<li><strong>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢</strong>。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</li>
</ol>
<h2 id="View绘制与事件"><a href="#View绘制与事件" class="headerlink" title="View绘制与事件"></a>View绘制与事件</h2><p><img src="/2019/08/12/android-note/view.webp" alt title="UI 管理系统的层级"></p>
<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>onMeasure()、onLayout()：<br>measure是测量的意思，那么onMeasure()方法顾名思义就是用于测量视图的大小的。<strong>View系统的绘制流程会从ViewRoot的performTraversals()方法中开始</strong>，在其内部调用View的measure()方法。<br><strong>getMeasureWidth()方法在measure()过程结束后就可以获取到了，而getWidth()方法要在layout()过程结束后才能获取到。</strong>另外，getMeasureWidth()方法中的值是通过setMeasuredDimension()方法来进行设置的，而getWidth()方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p>
<p>onDraw()步骤:<br>1.第一步是从第9行代码开始的，这一步的作用是对视图的背景进行绘制<br>2.第三步是在第34行执行的，这一步的作用是对视图的内容进行绘制<br>3.第四步的作用是对当前视图的所有子视图进行绘制<br>4.第六步的作用是对视图的滚动条进行绘制。其实不管是Button也好，TextView也好，任何一个视图都是有滚动条的，只是一般情况下我们都没有让它显示出来而已。<br>部分源代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void draw(Canvas canvas) &#123;</span><br><span class="line">	if (ViewDebug.TRACE_HIERARCHY) &#123;</span><br><span class="line">	    ViewDebug.trace(this, ViewDebug.HierarchyTraceType.DRAW);</span><br><span class="line">	&#125;</span><br><span class="line">	final int privateFlags = mPrivateFlags;</span><br><span class="line">	final boolean dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">	        (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">	mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN;</span><br><span class="line">	// Step 1, draw the background, if needed</span><br><span class="line">	int saveCount;</span><br><span class="line">	if (!dirtyOpaque) &#123;</span><br><span class="line">	    final Drawable background = mBGDrawable;</span><br><span class="line">	    if (background != null) &#123;</span><br><span class="line">	        final int scrollX = mScrollX;</span><br><span class="line">	        final int scrollY = mScrollY;</span><br><span class="line">	        if (mBackgroundSizeChanged) &#123;</span><br><span class="line">	            background.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);</span><br><span class="line">	            mBackgroundSizeChanged = false;</span><br><span class="line">	        &#125;</span><br><span class="line">	        if ((scrollX | scrollY) == 0) &#123;</span><br><span class="line">	            background.draw(canvas);</span><br><span class="line">	        &#125; else &#123;</span><br><span class="line">	            canvas.translate(scrollX, scrollY);</span><br><span class="line">	            background.draw(canvas);</span><br><span class="line">	            canvas.translate(-scrollX, -scrollY);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	final int viewFlags = mViewFlags;</span><br><span class="line">	boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;</span><br><span class="line">	boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;</span><br><span class="line">	if (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">	    // Step 3, draw the content</span><br><span class="line">	    if (!dirtyOpaque) onDraw(canvas);</span><br><span class="line">	    // Step 4, draw the children</span><br><span class="line">	    dispatchDraw(canvas);</span><br><span class="line">	    // Step 6, draw decorations (scrollbars)</span><br><span class="line">	    onDrawScrollBars(canvas);</span><br><span class="line">	    // we&apos;re done...</span><br><span class="line">	    return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>调用视图的setVisibility()、setEnabled()、setSelected()等方法时都会导致视图重绘，而如果我们想要手动地强制让视图进行重绘，可以调用invalidate()方法来实现。当然了，setVisibility()、setEnabled()、setSelected()等方法的内部其实也是通过调用invalidate()方法来实现的。</p>
<p>invalidate()方法中，当ViewParent不等于空的时候就会一直循环下去。在这个while循环当中会不断地获取当前布局的父布局，并调用它的invalidateChildInParent()方法，<strong>在ViewGroup的invalidateChildInParent()方法中主要是来计算需要重绘的矩形区域</strong>，当循环到最外层的根布局后，就会调用ViewRoot的invalidateChildInParent()方法了, 最终会调用到performTraversals()方法。<br>invalidate()方法虽然最终会调用到performTraversals()方法中，但这时measure和layout流程是不会重新执行的，因为视图没有强制重新测量的标志位，而且大小也没有发生过变化，所以这时只有draw流程可以得到执行。而如果你希望视图的绘制流程可以完完整整地重新走一遍，就不能使用invalidate()方法，而应该调用requestLayout()了。</p>
<p>参考：<a href="https://blog.csdn.net/guolin_blog/article/details/17045157" target="_blank" rel="noopener">https://blog.csdn.net/guolin_blog/article/details/17045157</a></p>
<h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>Android中触摸事件传递过程中最重要的是dispatchTouchEvent()、onInterceptTouchEvent()和onTouchEvent()方法。这里记录一下他们的处理过程，以供记忆：<br>1.dispatchTouchEvent是处理触摸事件分发,事件(多数情况)是从Activity的dispatchTouchEvent开始的。执行super.dispatchTouchEvent(ev)，事件向下分发。dispatchTouchEvent()返回true，后续事件（ACTION_MOVE、ACTION_UP）会再传递，如果返回false，dispatchTouchEvent()就接收不到ACTION_UP、ACTION_MOVE。<br>2.onInterceptTouchEvent是ViewGroup提供的方法，默认返回false，返回true表示拦截。<br>3.onTouchEvent是View中提供的方法，ViewGroup也有这个方法，view中不提供onInterceptTouchEvent。view中默认返回true，表示消费了这个事件。</p>
<p>事件传递流程如下：<br>1.ACTION_DOWN首先会传递到onInterceptTouchEvent()方法<br>2.如果该ViewGroup的onInterceptTouchEvent()在接收到down事件处理完成之后return false，那么后续的move, up等事件将继续会先传递给该ViewGroup，之后才和down事件一样传递给最终的目标view的onTouchEvent()处理。<br>3.如果该ViewGroup的onInterceptTouchEvent()在接收到down事件处理完成之后return true，那么后续的move, up等事件将不再传递给onInterceptTouchEvent()，而是和down事件一样传递给该ViewGroup的onTouchEvent()处理，注意，目标view将接收不到任何事件。<br>4.如果最终需要处理事件的view的onTouchEvent()返回了false，那么该事件将被传递至其上一层次的view的onTouchEvent()处理。<br>5.如果最终需要处理事件的view的onTouchEvent()返回了true，那么后续事件将可以继续传递给该view的onTouchEvent()处理。</p>
<p><img src="/2019/08/12/android-note/view-touchevent.jpg" alt><br>当触摸事件ACTION_DOWN发生之后，先调用Activity中的dispatchTouchEvent函数进行处理，紧接着ACTION_DOWN事件传递给ViewGroup中的dispatchTouchEvent函数，接着viewGroup中的dispatchTouchEvent中的ACTION_DOWN事件传递到调用ViewGroup中的onInterceptTouchEvent函数，此函数负责拦截ACTION_DOWN事件。由于viewGroup下还包含子View，所以默认返回值为false，即不拦截此ACTION_DOWN事件。如果返回false，则ACTION_DOWN事件继续传递给其子view。由于子view不是viewGroup的控件，所以ACTION_DOWN事件接着传递到onTouchEvent进行处理事件。此时消息的传递基本上结束。从上可以分析，motionEvent事件的传递是采用隧道方式传递。隧道方式，即从根元素依次往下传递直到最内层子元素或在中间某一元素中由于某一条件停止传递。</p>
<p>参考：<a href="https://blog.csdn.net/qiushuiqifei/article/details/9918527" target="_blank" rel="noopener">https://blog.csdn.net/qiushuiqifei/article/details/9918527</a></p>
<h2 id="Android属性动画优化"><a href="#Android属性动画优化" class="headerlink" title="Android属性动画优化"></a>Android属性动画优化</h2><p>android的三种动画：</p>
<ul>
<li>View Animation（视图动画，平移、缩放、透明等）View的属性没有改变，其位置与大小都不变</li>
<li>Drawable Animation（帧动画）</li>
<li>Property Animation（属性动画）对象自己的属性会被真的改变，而且属性动画不止用于View，还可以用于任何对象。</li>
</ul>
<p>现在项目的动画问题最主要出在动画部分临时变量多，GC触发频繁，内存泄漏。属性动画优化思路：</p>
<ol>
<li>硬件加速<br>在开始动画时调用View.setLayerType(View.LAYER_TYPE_HARDWARE, null)<br>运行动画<br>动画结束时调用View.setLayerType(View.LAYER_TYPE_NONE, null).</li>
<li>减少临时变量,使用PropertyValuesHolder(可以用在多属性动画同时工作管理) ,一个view同时发生多种属性效果时，建议这种写法。</li>
<li>使用Keyframe<br>Keyframe是PropertyValuesHolder的成员，用来管理每一个关键帧的出现时间。一个view的单个属性先后发生一系列变化时，建议使用Keyframe达到效果。<br>总的来说就是：ObjectAnimator把属性值的更新委托给PropertyValuesHolder执行，PropertyValuesHolder再把关键帧的时序性计算委托给Keyframe。<br>最后，不同的view再用不同的ObjectAnimator管理。</li>
<li>内存泄漏: animator.setRepeatCount(ValueAnimator.INFINITE)及时cancel（）</li>
<li>动画卡顿，可以考虑使用自定义控件实现，如果一个自定义不行，那就是两个</li>
</ol>
<h2 id="ART和Dalvik"><a href="#ART和Dalvik" class="headerlink" title="ART和Dalvik"></a>ART和Dalvik</h2><p>Android4.4版本以前是Dalvik虚拟机，4.4版本开始引入ART虚拟机（Android Runtime）。在4.4版本上，两种运行时环境共存，可以相互切换，但是在5.0版本以后，Dalvik虚拟机则被彻底的丢弃，全部采用ART。</p>
<h3 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h3><p>ART 是一种执行效率更高且更省电的运行机制，执行的是本地机器码，这些本地机器码是从dex字节码转换而来。<strong>ART采用的是AOT（Ahead-Of-Time）编译</strong>，应用在第一次安装的时候，字节码就会预先编译成机器码存储在本地。在App运行时，ART模式就较Dalvik模式少了解释字节码的过程，所以App的运行效率会有所提高，占用内存也会相应减少。</p>
<h3 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h3><p>Dalvik 虚拟机采用的是JIT（Just-In-Time）编译模式，意思为即时编译，我们知道apk被安装到手机中时，对应目录会有dex或odex和apk文件，apk文件存储的是资源文件，而dex或odex（经过优化后的dex文件内部存储class文件）内部存储class文件，每次运行app时虚拟机会将dex文件解释翻译成机器码，这样才算是本地可执行代码，之后被系统运行。</p>
<p>Dalvik虚拟机可以看做是一个Java VM，他负责解释dex文件为机器码，如果我们不做处理的话，每次执行代码，都需要Dalvik将dex代码翻译为微处理器指令，然后交给系统处理，这样效率不高。为了解决这个问题，<strong>Google在2.2版本添加了JIT编译器，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。</strong>JIT代表运行时编译策略，也可以理解成一种运行时编译器，是为了加快Dalvik虚拟机解释dex速度提出的一种技术方案，来缓存频繁使用的本地机器码。</p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p><strong>Dalvik每次都要编译再运行，Art只会安装时启动编译</strong><br>Art占用空间比Dalvik大（原生代码占用的存储空间更大），就是用<strong>“空间换时间”</strong><br>Art减少编译，减少了CPU使用频率，使用明显改善电池续航<br>Art应用启动更快、运行更快、体验更流畅、触感反馈更及时</p>
<h2 id="UncaughtExceptionHandler"><a href="#UncaughtExceptionHandler" class="headerlink" title="UncaughtExceptionHandler"></a>UncaughtExceptionHandler</h2><p>如果给一个线程设置了UncaughtExceptionHandler 这个接口：<br>1、这个线程中，所有未处理或者说未捕获的异常都将会由这个接口处理，也就说被这个接口给try…catch了。<br>2、在这个线程中抛出异常时，java虚拟机将会忽略，也就是说，java虚拟机不会让程序崩溃了。<br>3、如果没有设置，那么最终会调用getDefaultUncaughtExceptionHandler 获取默认的UncaughtExceptionHandler 来处理异常。</p>
<h2 id="aar"><a href="#aar" class="headerlink" title="@aar"></a>@aar</h2><p>@aar的方式关闭传递依赖</p>
<pre><code>// 只下载该库，其他所依赖的所有库不下载
compile &apos;io.reactivex.rxjava2:rxandroid:2.0.1@aar&apos;
// 在使用@aar的前提下还能下载其他依赖库，则需要添加transitive=true的条件
compile (&quot;io.reactivex.rxjava2:rxandroid::2.0.1@aar&quot;) {
    transitive=true
}
</code></pre><h2 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h2><p>Groovy语言=<strong>Java语言的扩展+众多脚本语言的语法。运行在JVM虚拟机上。Gradle项目构框架使用groovy语言实现。</strong> 基于Gradle框架为我们实现了一些项目构件框架。</p>
<p>Groovy是一门jvm语言，它最终是要编译成class文件然后在jvm上执行，所以<strong>Java语言的特性Groovy都支持，我们完全可以混写Java和Groovy。</strong></p>
<p>在Groovy中，数据类型有：<br>1) Java中的基本数据类型<br>2) Java中的对象<br>3) Closure（闭包）<br>4) 加强的List、Map等集合类型<br>5) 加强的File、Stream等IO类型</p>
<p>类型可以显示声明，也可以用 def 来声明，用 def 声明的类型Groovy将会进行类型推断。</p>
<h2 id="gradle插件"><a href="#gradle插件" class="headerlink" title="gradle插件"></a>gradle插件</h2><p>插件会扩展项目的功能，帮助我们在项目的构建的过程中做很多事情：</p>
<ul>
<li>可以添加任务到项目中，帮助完成诸如 测试、编译、打包等事情。</li>
<li>可以添加依赖配置到项目中，通过它们来配置我们在构建过程中的依赖。</li>
<li>可以向项目中现有的对象类型添加新的扩展属性、方法等，可以使用它们来配置优化构建。例如：android{}这个配置块就是Android Gradle插件为Project对象添加的一个扩展。</li>
<li>可以对项目进行一些约定，比如应用Java插件后，可以约定src/main/java目录下是我们的源代码的存放地址，在编译的时候也是编译这个目录下的Java源代码文件。</li>
</ul>
<p>这就是插件，我们只需要按照它约定的方式，使用它提供的任务、方法或者扩展，就可以对我们的项目进行构建。</p>
<p>因为是基于groovy开发，所有代码文件要以.groovy结尾</p>
<p>1.定义插件入口： implements Plugin<project></project></p>
<p>2.XXXTask必须要继承DefautTask,并使用@TaskAction来定义Task的入口函数。</p>
<p>3.gradle配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//bulid.gradle</span><br><span class="line">buildscript &#123;</span><br><span class="line">    </span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &apos;file:///Users/xinyu/work/maven-lib/&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.1.2&apos;</span><br><span class="line">        classpath &apos;com.zxy.plugin:plugin:1.0.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//plugin gradle</span><br><span class="line">apply plugin: &apos;groovy&apos;</span><br><span class="line">apply plugin: &apos;maven&apos;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    // gradle sdk</span><br><span class="line">    compile gradleApi()</span><br><span class="line">    // groovy sdk</span><br><span class="line">    compile localGroovy()</span><br><span class="line">    // 可以引用其它库</span><br><span class="line">    compile fileTree(dir: &apos;libs&apos;2 include: [&apos;*.jar&apos;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            //本地的Maven地址</span><br><span class="line">            repository(url: &apos;file:///Users/xinyu/work/maven-lib/&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group=&apos;com.zxy.plugin&apos;</span><br><span class="line">version=&apos;1.0.0&apos;</span><br></pre></td></tr></table></figure></p>
<p>参考资料：<a href="https://www.jianshu.com/p/eda0bfd692e6" target="_blank" rel="noopener">https://www.jianshu.com/p/eda0bfd692e6</a></p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（Aspect Oriented Programming 面向切面编程）则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</p>
<p><strong>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。能将同一个关注点聚焦到同一个方法中解决。</strong></p>
<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><p>由于AndroidStudio默认是没有ajc编译器的，所以在Android中使用@AspectJ来编写（包括SpringAOP也是如此）。它在代码的编译期间扫描目标程序，根据切点（PointCut）匹配,将开发者编写的Aspect程序编织（Weave）到目标程序的.class文件中，对目标程序作了重构（重构单位是JoinPoint），目的就是建立目标程序与Aspect程序的连接（获得执行的对象、方法、参数等上下文信息），从而达到AOP的目的。</p>
<p>AspectJ是通过对目标工程的.class文件进行代码注入的方式将通知(Advise)插入到目标代码中：<br>第一步：根据pointCut切点规则匹配的joinPoint；<br>第二步：将Advise插入到目标JoinPoint中。<br>这样在程序运行时被重构的连接点将会回调Advise方法，就实现了AspectJ代码与目标代码之间的连接。<br><img src="/2019/08/12/android-note/aspectj.png" alt></p>
<h3 id="Gradle-Transform"><a href="#Gradle-Transform" class="headerlink" title="Gradle Transform"></a>Gradle Transform</h3><p>Gradle Transform是Android官方提供给开发者在项目构建阶段即由class到dex转换期间修改class文件的一套api。目前比较经典的应用是字节码插桩、代码注入技术。Gradle Transform更多的是提供一种可以让开发者参与项目构建的机制，而诸如修改字节码等更加具体的细节则需要开发者去实现。</p>
<h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><p>代理Hook:如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。</p>
<p>hook，又叫钩子，通常是指对一些方法进行拦截。这样当这些方法被调用时，也能够执行我们自己的代码，这也是面向切面编程的思想（AOP）。</p>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>大致思路：<br>1.找到需要Hook方法的系统类<br>2.利用代理模式来代理系统类的运行拦截我们需要拦截的方法<br>3.使用反射的方法把这个系统类替换成你的代理类</p>
<p>案例可参考：<br><a href="https://blog.csdn.net/yulong0809/article/details/56842027" target="_blank" rel="noopener">https://blog.csdn.net/yulong0809/article/details/56842027</a></p>
<h2 id="应用的启动过程"><a href="#应用的启动过程" class="headerlink" title="应用的启动过程"></a>应用的启动过程</h2><p>1.首先我们要启动的Activity会去ActivityManagerService中去校检是否合法</p>
<p>2.通过回调ActivityThread中内部类ApplicationThread的scheduleLaunchActivity去发送一个消息到ActivityThread中的内部类H中，H继承于Handler</p>
<p>3.然后会通过反射创建Activity对象及Application对象，并回调响应生命周期方法</p>
<p>这里说一点ActivityManagerService和我们应用间沟通几乎都是ActivityThread，ApplicationThread，H这几个类之间来回调用，而且不只是Activity，我们Android的四大组件几乎都用了这种模式</p>
<p>参考：<br><a href="https://blog.csdn.net/yulong0809/article/details/58589715" target="_blank" rel="noopener">https://blog.csdn.net/yulong0809/article/details/58589715</a></p>
<h2 id="Watchdog"><a href="#Watchdog" class="headerlink" title="Watchdog"></a>Watchdog</h2><p>能通过关闭FinalizerWatchdogDaemon来减少TimeoutException的触发。需要注意的是，此种方法并不是去解决问题，而是为了避免上报异常采取的一种 hack 方案，并没有真正的解决引起 finialize() 超时的问题。</p>
<pre><code>// Android P 以后不能反射FinalizerWatchdogDaemon
if (Build.VERSION.SDK_INT &gt;= 28) {
    Log.w(TAG, &quot;stopWatchDog, do not support after Android P, just return&quot;);
    return;
}

try {
    final Class clazz = Class.forName(&quot;java.lang.Daemons$FinalizerWatchdogDaemon&quot;);
    final Field field = clazz.getDeclaredField(&quot;INSTANCE&quot;);
    field.setAccessible(true);
    final Object watchdog = field.get(null);
    try {
        final Field thread = clazz.getSuperclass().getDeclaredField(&quot;thread&quot;);
        thread.setAccessible(true);
        thread.set(watchdog, null);
    } catch (final Throwable t) {
        Log.e(TAG, &quot;stopWatchDog, set null occur error:&quot; + t);

        t.printStackTrace();
        try {
            // 直接调用stop方法，在Android 6.0之前会有线程安全问题
            final Method method = clazz.getSuperclass().getDeclaredMethod(&quot;stop&quot;);
            method.setAccessible(true);
            method.invoke(watchdog);
        } catch (final Throwable e) {
            Log.e(TAG, &quot;stopWatchDog, stop occur error:&quot; + t);
            t.printStackTrace();
        }
    }
} catch (final Throwable t) {
    Log.e(TAG, &quot;stopWatchDog, get object occur error:&quot; + t);
    t.printStackTrace();
}
</code></pre><h2 id="NFC"><a href="#NFC" class="headerlink" title="NFC"></a>NFC</h2><p>Near Field Communication (NFC) 为<strong>一短距离无线通信技术，通常有效通讯距离为4厘米以内。NFC工作频率为13.65 兆赫兹，通信速率为106 kbit/秒到 848kbit/秒</strong>。</p>
<p>NFC支持如下3种工作模式：<br>读卡器模式（Reader/writer mode）、<br>仿真卡模式(Card Emulation Mode)、<br>点对点模式（P2P mode）。</p>
<p>Android SDK API主要支持NFC论坛标准（Forum Standard），这种标准被称为NDEF（NFC Data Exchange Format，NFC数据交换格式），类似传感器。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池使用的好处：<br>1：对多个线程进行统一地管理，避免资源竞争中出现的问题。<br>2：（重点）：对线程进行复用，线程在执行完任务后不会立刻销毁，而会等待另外的任务，这样就不会频繁地创建、销毁线程和调用GC。<br>3：JAVA提供了一套完整的ExecutorService线程池创建的api，可创建多种功能不一的线程池，使用起来很方便。</p>
<p>创建线程池，主要是利用ThreadPoolExecutor这个类，而这个类有几种构造方法，其中参数最多的一种构造方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                             int maximumPoolSize,</span><br><span class="line">                             long keepAliveTime,</span><br><span class="line">                             TimeUnit unit,</span><br><span class="line">                             BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                             ThreadFactory threadFactory) &#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>corePoolSize: 该线程池中核心线程的数量。<br>maximumPoolSize：该线程池中最大线程数量。(区别于corePoolSize)<br>keepAliveTime:从字面上就可以理解，是非核心线程空闲时要等待下一个任务到来的时间，当任务很多，每个任务执行时间很短的情况下调大该值有助于提高线程利用率。注意：当allowCoreThreadTimeOut属性设为true时，该属性也可用于核心线程。<br>unit:上面时间属性的单位<br>workQueue:任务队列<br>threadFactory:线程工厂，可用于设置线程名字等等，一般无须设置该参数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/09/android-rxjava-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/09/android-rxjava-principle/" itemprop="url">RxJava2原理解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-09T15:03:10+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇主要对以下三个方面进行讲解：</p>
<ul>
<li>RxJava是流式编程，在每一条流中，都至少包含三个要素：源头/被订阅者(Observable或Flowable)、订阅者(Observer或subscriber)、触发时机(subscribe()方法)；</li>
<li>其次就是线程切换（subscribeOn()和observeOn()）；</li>
<li>最后就是数据操作(如map()、flatMap()等)。</li>
</ul>
<h2 id="1、订阅（subscribe）"><a href="#1、订阅（subscribe）" class="headerlink" title="1、订阅（subscribe）"></a>1、订阅（subscribe）</h2><p>首先看下最简单的情况：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {
        // doSomething, eg: 
        // emitter.onNext(&quot;onNext&quot;);
        // emitter.onComplete();
    }
}).subscribe();
</code></pre><p>一条RxJava流若是没有调用subscribe()方法，该流便无法执行，即<strong>必须由subscribe()确定了订阅关系后这条流才能生效</strong>，原因如下：</p>
<pre><code>// Observable.java
public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) {
    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);
    // 可以直接忽略RxJavaPlugins的相关方法，不影响我们理解原理
    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source)); 
 }
// 无论调用subscribe的哪个重载方法，最终都会走到这个方法
public final void subscribe(Observer&lt;? super T&gt; observer) {
    ... // 省去不重要代码
    subscribeActual(observer);
    ...
}
protected abstract void subscribeActual(Observer&lt;? super T&gt; observer);
</code></pre><p>可以看到subscribe()里面主要是调用了subscribeActual，而subscribeActual是一个抽象方法，所以具体实现在子类中，这里的子类便是ObservableCreate，再来看它的实现：</p>
<pre><code>// ObservableCreate.java
public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) {
    this.source = source;
}
protected void subscribeActual(Observer&lt;? super T&gt; observer) {
    CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);
    observer.onSubscribe(parent);
    try {
        source.subscribe(parent);
    } catch (Throwable ex) {
        Exceptions.throwIfFatal(ex);
        parent.onError(ex);
    }
}
</code></pre><p><strong>ObservableCreate中subscribeActual的实现就是将我们的observer封装成CreateEmitter（ObservableEmitter的实现类），再执行observer.onSubscribe，确保onSubscribe总能在onNext等其他订阅行为之前执行，接着就是我们的核心代码：source.subscribe(parent)，source便是我们一开始创建流时新建的ObservableOnSubscribe对象，而parent则是封装后的CreateEmitter，所以其实此时执行的便是在创建ObservableOnSubscribe时实现的public void subscribe(ObservableEmitter<string> emitter) throws Exception方法，此时整条流的订阅关系便成立了。</string></strong></p>
<p>现在我们知道，事件流的执行实际上是由子类实现的subscribeActual控制的，所以其他的Observable创建方式也是一样的道理，这里再以fromIterable为例看一下：</p>
<pre><code>// Observable.java
public static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source) {
    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);
    return RxJavaPlugins.onAssembly(new ObservableFromIterable&lt;T&gt;(source));
}

// ObservableFromIterable.java
public ObservableFromIterable(Iterable&lt;? extends T&gt; source) {
    this.source = source;
}
@Override
public void subscribeActual(Observer&lt;? super T&gt; s) {
    Iterator&lt;? extends T&gt; it;
    try {
        it = source.iterator();
    } catch (Throwable e) {
        Exceptions.throwIfFatal(e);
        EmptyDisposable.error(e, s);
        return;
    }
    boolean hasNext;
    try {
        hasNext = it.hasNext();
    } catch (Throwable e) {
        Exceptions.throwIfFatal(e);
        EmptyDisposable.error(e, s);
        return;
    }
    if (!hasNext) {
        EmptyDisposable.complete(s);
        return;
    }
    FromIterableDisposable&lt;T&gt; d = new FromIterableDisposable&lt;T&gt;(s, it);
    s.onSubscribe(d);
    if (!d.fusionMode) {
        d.run();
    }
}    
</code></pre><p>可以看到，这里是将observer和我们的数据源列表封装为FromIterableDisposable，然后执行d.run()，下面看下run的实现：</p>
<pre><code>// FromIterableDisposable.java
FromIterableDisposable(Observer&lt;? super T&gt; actual, Iterator&lt;? extends T&gt; it) {
    this.actual = actual;
    this.it = it;
}
void run() {
    boolean hasNext;
    do {
        if (isDisposed()) {
            return;
        }
        T v;
        try {
            v = ObjectHelper.requireNonNull(it.next(), &quot;The iterator returned a null value&quot;);
        } catch (Throwable e) {
            Exceptions.throwIfFatal(e);
            actual.onError(e);
            return;
        }
        actual.onNext(v);
        if (isDisposed()) {
            return;
        }
        try {
            hasNext = it.hasNext();
        } catch (Throwable e) {
            Exceptions.throwIfFatal(e);
            actual.onError(e);
            return;
        }
    } while (hasNext);
    if (!isDisposed()) {
        actual.onComplete();
    }
}
</code></pre><p>在run方法中不停地遍历数据源列表，然后根据实际情况执行对应的事件处理方法(actual.onNext(v);等，actual即为我们传进来的observer)，这便完成了RxJava流的处理。</p>
<p>总结：<strong>RxJava2的订阅原理其实便是在subcribe时执行子类中实现的subscribeActual方法，该方法最终会去调用observer相关的订阅方法，可理解为观察者模式的一种变形。</strong></p>
<h2 id="2、线程切换"><a href="#2、线程切换" class="headerlink" title="2、线程切换"></a>2、线程切换</h2><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h3><pre><code>// Observable.java
public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) {
    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);
    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));
    }
</code></pre><p>subscribeOn时其实也是创建了一个Observable子类去实现subscribeActual方法：</p>
<pre><code>// ObservableSubscribeOn.java
public void subscribeActual(final Observer&lt;? super T&gt; s) {
    final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s);
    s.onSubscribe(parent);
    parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));
}
</code></pre><p>这里将下游的Observer s封装成SubscribeOnObserver后又封装成Runnable的实现类SubscribeTask，在run方法中source.subscribe(parent)：</p>
<pre><code>// ObservableSubscribeOn.java
final class SubscribeTask implements Runnable {
    private final SubscribeOnObserver&lt;T&gt; parent;
    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) {
        this.parent = parent;
    }
    @Override
    public void run() {
        source.subscribe(parent);
    }
}
</code></pre><p>然后通过scheduler.scheduleDirect(new SubscribeTask(parent))将这个Task放到Worker中：</p>
<pre><code>// Scheduler.java
public Disposable scheduleDirect(@NonNull Runnable run) {
    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);
}
public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {
    final Worker w = createWorker();
    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
    DisposeTask task = new DisposeTask(decoratedRun, w);
    w.schedule(task, delay, unit);
    return task;
}
public abstract Worker createWorker();
</code></pre><p>而createWorker由Scheduler子类实现，即我们执行的线程类型，如AndroidSchedulers.mainThread()、Schedulers.io()，这里以mainThread()为例，</p>
<pre><code>// AndroidSchedulers.java
public static Scheduler mainThread() {
    return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);
}
private static final Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(new Callable&lt;Scheduler&gt;() {
    @Override 
    public Scheduler call() throws Exception {
        return MainHolder.DEFAULT;
    }
});
private static final class MainHolder {
    static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper()));
}
</code></pre><p>RxAndroidPlugins里面的非常简单，这里最终返回的就是HandlerScheduler，因此来看下它实现的createWorker和schedule方法：</p>
<pre><code>// HandlerScheduler.java
public Worker createWorker() { return new HandlerWorker(handler); }
</code></pre><p>在HandlerWorker中实现schedule(task, delay, unit)：</p>
<pre><code>// HandlerWorker.java
public Disposable schedule(Runnable run, long delay, TimeUnit unit) {
    ...
    ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);
    Message message = Message.obtain(handler, scheduled);
    message.obj = this; // Used as token for batch disposal of this worker&apos;s runnables.
    handler.sendMessageDelayed(message, unit.toMillis(delay));
    ....
    return scheduled;
}
</code></pre><p>这里将handler（由上面创建DEFAULT Scheduler时可知，该handler为UI线程的handler）和run又再次封装为ScheduledRunnable，然后通过handler发送到主线程处理，因此便保证了订阅操作（source.subscribe(parent)）执行在主线程。</p>
<p>同时，由上面可知，rx流由subscribe开始触发，然后执行source.subscribe(observer)，然而source可能也是上游操作后的产物（如map），因此便会触发上游内部的subscribe，直到源头，即<strong>rx流由subscribe开始触发，然后逆向向上寻找直到源头，才开始真正的执行</strong>。因此，若是有多个subscribeOn，最终的subscribe也是被放到最上面的subscribeOn（即第一个）指定的线程中执行，<strong>这便是指定多个subscribeOn只有第一个生效的原因</strong>。</p>
<p>总结：<strong>其实就是将订阅操作放到Runnable中执行，并结合handler机制将Runnable发送到主线程，对于其他线程（不同的线程模式会创建不同的Scheduler，并持有对应的线程池）则是将Runnable交给指定线程池处理。这便保证了在指定线程获取/处理数据源（observable）。</strong></p>
<h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h3><pre><code>// Observable.java
public final Observable&lt;T&gt; observeOn(Scheduler scheduler) {
    return observeOn(scheduler, false, bufferSize());
}
public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {
    ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);
    ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);
    return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));
}
</code></pre><p>observeOn的线程切换则是在ObservableObserveOn中处理的：</p>
<pre><code>// ObservableObserveOn.java
protected void subscribeActual(Observer&lt;? super T&gt; observer) {
    if (scheduler instanceof TrampolineScheduler) {
         source.subscribe(observer);
    } else {
        Scheduler.Worker w = scheduler.createWorker();
        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));
    }
}
</code></pre><p>这里也是根据指定线程类型创建Worker（可参考上面subscribeOn原理），并将observer和w一同放到ObserveOnObserver中：</p>
<pre><code>// ObserveOnObserver.java
public void onNext(T t) {
    ....
    schedule();
}
void schedule() {
    if (getAndIncrement() == 0) {
        worker.schedule(this);
    }
}
public void run() {
    if (outputFused) {
        drainFused();
    } else {
         drainNormal();
    }
}
void drainNormal() {
    ...
    for (;;) {
        ...
        for (;;) {
            ...
            a.onNext(v);
        }
        ...
    }
}
</code></pre><p>可以看到，onNext执行的是schedule，而schedule则是将该对象直接放到指定线程的Worker中，然后在run中去执行对应的事件处理方法（onNext等），因此便实现了将下游的observer放到指定线程执行的目的，当然，这里只是将其直接下游的observer放到指定线程而已，对于其下游的下游则不一定。<strong>也就是说，observeOn可以有多个，每个都是对其直接下游做线程切换，若是下游不再切换，则所有下游都在该指定线程中执行。</strong></p>
<p>总结:<strong>observeOn其实就是将下游的observer放到指定线程里面去执行。</strong></p>
<h2 id="3、数据变换"><a href="#3、数据变换" class="headerlink" title="3、数据变换"></a>3、数据变换</h2><p>在事件从源头流到最终观察者的过程中，我们可以对事件进行操作转换，这里以map和flatMap为例进行解析。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><pre><code>// Observable.java
public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {
    ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);
    return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper));
}
</code></pre><p>执行map操作时其实是<strong>将上游的observable和我们自己实现的mapper封住成一个ObservableMap</strong>，所以具体实现就是在ObservableMap的subscribeActual中：</p>
<pre><code>// ObservableMap.java
public void subscribeActual(Observer&lt;? super U&gt; t) {
    source.subscribe(new MapObserver&lt;T, U&gt;(t, function));
}
</code></pre><p>看到这句是不是很熟悉，从上面的订阅原理可知，到这里其实真正执行的便是MapObserver中的onNext等方法了，而其onNext里便是先执行map转换，再将转换结果交给下游的observer执行：</p>
<pre><code>// MapObserver.java
@Override
public void onNext(T t) {
    if (done) { // error or complete
        return;
    }
    if (sourceMode != NONE) {
        actual.onNext(null);
        return;
    }
    U v;
    try {
    v = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper function returned a null value.&quot;);
    } catch (Throwable ex) {
        fail(ex);
    return;
    }
    actual.onNext(v);
}
</code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>我们调用的flatMap最终执行的是该重载方法：</p>
<pre><code>// Observable.java
public final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, boolean delayErrors, int maxConcurrency, int bufferSize) {
     ...
     return RxJavaPlugins.onAssembly(new ObservableFlatMap&lt;T, R&gt;(this, mapper, delayErrors, maxConcurrency, bufferSize));
}
</code></pre><p>因此看下ObservableFlatMap：</p>
<pre><code>// ObservableFlatMap.java
public ObservableFlatMap(ObservableSource&lt;T&gt; source, Function&lt;? super T, ? extends ObservableSource&lt;? extends U&gt;&gt; mapper, boolean delayErrors, int maxConcurrency, int bufferSize) {
    super(source);
    this.mapper = mapper;
    this.delayErrors = delayErrors;
    this.maxConcurrency = maxConcurrency;
    this.bufferSize = bufferSize;
}
@Override
public void subscribeActual(Observer&lt;? super U&gt; t) {
    if (ObservableScalarXMap.tryScalarXMapSubscribe(source, t, mapper)) {
    return;
    }
    source.subscribe(new MergeObserver&lt;T, U&gt;(t, mapper, delayErrors, maxConcurrency, bufferSize));
}
</code></pre><p>所以实际的操作是在MergeObserver，这里我们就看下onNext就好了：</p>
<pre><code>// MergeObserver.java
public void onNext(T t) {
    // safeguard against misbehaving sources
    if (done) {
        return;
    }
    ObservableSource&lt;? extends U&gt; p;
    try {
        p = ObjectHelper.requireNonNull(mapper.apply(t), &quot;The mapper returned a null ObservableSource&quot;);
    } catch (Throwable e) {
        Exceptions.throwIfFatal(e);
        s.dispose();
        onError(e);
        return;
    }
    if (maxConcurrency != Integer.MAX_VALUE) {
        synchronized (this) {
            if (wip == maxConcurrency) {
                sources.offer(p);
                return;
            }
            wip++;
        }
    }
    subscribeInner(p);
}
</code></pre><p>可以看到，这里是想<strong>将上游传进来的对象通过我们自己实现的mapper进行转换，然后再执行subscribeInner(p)</strong>（maxConcurrency默认就是Integer.MAX_VALUE），因此看下subscribeInner(p)：</p>
<pre><code>// MergeObserver.java
void subscribeInner(ObservableSource&lt;? extends U&gt; p) {
    for (;;) {
        if (p instanceof Callable) {
            if (tryEmitScalar(((Callable&lt;? extends U&gt;)p)) &amp;&amp; maxConcurrency != Integer.MAX_VALUE) {
                boolean empty = false;
                synchronized (this) {
                    p = sources.poll();
                    if (p == null) {
                        wip--;
                        empty = true;
                    }
                }
                if (empty) {
                    drain();
                    break;
                }
            } else {
                break;
            }
        } else {
            InnerObserver&lt;T, U&gt; inner = new InnerObserver&lt;T, U&gt;(this, uniqueId++);
            if (addInner(inner)) {
                p.subscribe(inner);
            }
            break;
        }
    }
}
</code></pre><p>这里是个无线循环，根据是否为Callable类型执行不同的逻辑，一般Observable.just为Callable，而from类型的则不是。这里看下from的逻辑，毕竟Callable类型又没指定maxConcurrency的话，是直接break，所以没什么好看的。而非Callable类型的，可以看到这里又封装成了InnerObserver，而for循环并没有什么用。</p>
<p>总结：<strong>在执行操作符方法(如map、flatMap等)时，会生成对应的Observable对象，在该对象中实现具体业务逻辑，对上游流下来的数据进行操作，再将处理后的结果交给下游的的订阅者继续处理。</strong></p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>RxJava2事件流的产生由subscribe方法调用subscribeActual(observer)触发，而subscribeActual由Observable子类实现，每个子类里的实现逻辑不同，可能会先执行自己的操作（如map或flatMap等 ），但最终都会调用source.subscribe，source即为该节点的上游数据源，因此需要上游操作执行完才能拿到source，最终便形成逐级逆向向上获取数据源（Observable或Flowable），即形成了从最开始的源头发射数据一路向下经过各个节点的操作后交给最终观察者的链式模型。</p>
<p>而对于线程切换，subscribeOn即是将订阅操作（observer）放到Runnable中执行，并将Runnable放到指定线程里操作；observeOn则是将下游的observer放到指定线程里面去执行。</p>
<h2 id="5、参考资料"><a href="#5、参考资料" class="headerlink" title="5、参考资料"></a>5、参考资料</h2><p><a href="https://blog.csdn.net/reakingf/article/details/84845705" target="_blank" rel="noopener">https://blog.csdn.net/reakingf/article/details/84845705</a><br><a href="https://github.com/ReactiveX/RxJava/wiki/What&#39;s-different-in-3.0" target="_blank" rel="noopener">What’s different in 3.0</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/07/android-rxjava-role/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/07/android-rxjava-role/" itemprop="url">RxJava2五种被观察者及背压</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-07T13:17:26+08:00">
                2019-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RxJava五种被观察者为Flowable, Observable，Single, Completable, Maybe。</p>
<p>五种被观察者可通过toFlowable, toObservable，toSingle, toCompletable, toMaybe相互转换。</p>
<h2 id="1、Flowable"><a href="#1、Flowable" class="headerlink" title="1、Flowable"></a>1、Flowable</h2><h3 id="1-1、Flowable简介"><a href="#1-1、Flowable简介" class="headerlink" title="1.1、Flowable简介"></a>1.1、Flowable简介</h3><p>Flowable类，用于实现Reactive-Streams模式，并提供工厂方法，中间运算符以及使用反应式数据流的能力。</p>
<p>Reactive-Streams使用Flowable运行，Flowable实现了Publishers。因此，许多运算符直接接受Publishers，并允许与其他Reactive-Streams的实现进行直接交互操作</p>
<pre><code>public abstract class Flowable&lt;T&gt; implements Publisher&lt;T&gt;
</code></pre><p><strong>Flowable为操作符提供128个元素的默认缓冲区大小，可通过bufferSize() 方法获取，可通过系统参数rx2.buffer-size全局覆盖</strong>。但是大多数运算符都有重载，允许显式设置其内部缓冲区大小。</p>
<pre><code>/** The default buffer size. */
static final int BUFFER_SIZE;
static {
    BUFFER_SIZE = Math.max(16, Integer.getInteger(&quot;rx2.buffer-size&quot;, 128));
}

/**
 * Returns the default internal buffer size used by most async operators.
 * &lt;p&gt;The value can be overridden via system parameter {@code rx2.buffer-size}
 * &lt;em&gt;before&lt;/em&gt; the Flowable class is loaded.
 * @return the default internal buffer size.
 */
public static int bufferSize() {
    return BUFFER_SIZE;
}
</code></pre><h3 id="1-2、Flowable官方图解"><a href="#1-2、Flowable官方图解" class="headerlink" title="1.2、Flowable官方图解"></a>1.2、Flowable官方图解</h3><p><img src="/2019/08/07/android-rxjava-role/rxjava-flowable.jpg" alt><br>1）看到上图有点疑问，不是在说Flowable嘛，怎么图解里的说明是Observable呢？</p>
<p>2）其实在官方文档里面Flowable和Observable都使用的是上面这个图解，因此这两个类肯定是提供相似功能，既然是相似，那么这幅图就是他们的共性，那不同的地方是什么呢？</p>
<p>不同之处是：<strong>Flowable支持Backpressure，Observable不支持Backpressure；只有在需要处理背压问题时，才需要使用Flowable</strong>。</p>
<p>由于<strong>只有在上下游运行在不同的线程中，且上游发射数据的速度大于下游接收处理数据的速度时，才会产生背压问题</strong>；<br>所以，如果能够确定：<br>1、上下游运行在同一个线程中，<br>2、上下游工作在不同的线程中，但是下游处理数据的速度不慢于上游发射数据的速度，<br>3、上下游工作在不同的线程中，但是数据流中只有一条数据<br>则不会产生背压问题，就没有必要使用Flowable，以免影响性能。</p>
<p>类似于Observable,在使用Flowable时，也可以通过create操作符创建发射数据流，代码如下：</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
                e.onNext(1);
                e.onNext(2);
                e.onNext(3);
                e.onComplete();
            }
        }, BackpressureStrategy.BUFFER) //create方法中多了一个BackpressureStrategy类型的参数
        .subscribeOn(Schedulers.newThread())//为上下游分别指定各自的线程
        .observeOn(Schedulers.newThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Subscription s) {   //onSubscribe回调的参数不是Disposable而是Subscription
                s.request(Long.MAX_VALUE);            //注意此处，暂时先这么设置
            }

            @Override
            public void onNext(Integer integer) {
                System.out.println(&quot;接收----&gt; &quot; + integer);
            }

            @Override
            public void onError(Throwable t) {
            }

            @Override
            public void onComplete() {
                System.out.println(&quot;接收----&gt; 完成&quot;);
            }
        });
</code></pre><p>运行结果如下：</p>
<pre><code>System.out: 接收----&gt; 1
System.out: 接收----&gt; 2
System.out: 接收----&gt; 3
System.out: 接收----&gt; 完成
</code></pre><p>发射与处理数据流在形式上与Observable大同小异，发射器中均有onNext，onError，onComplete方法，订阅器中也均有onSubscribe，onNext，onError，onComplete方法。<br>但是在细节方面还是有三点不同：<br>一、create方法中多了一个BackpressureStrategy类型的参数。<br>二、订阅器Subscriber中，方法onSubscribe回调的参数不是Disposable而是Subscription，多了行代码：s.request(Long.MAX_VALUE);<br>三、Flowable发射数据时，使用特有的发射器FlowableEmitter，不同于Observable的ObservableEmitter</p>
<h3 id="1-3、Backpressure"><a href="#1-3、Backpressure" class="headerlink" title="1.3、Backpressure"></a>1.3、Backpressure</h3><p>在通过create操作符创建Flowable时，多了一个BackpressureStrategy类型的参数，BackpressureStrategy是个枚举，源码如下：</p>
<pre><code>/**
 * Represents the options for applying backpressure to a source sequence.
 */
public enum BackpressureStrategy {
    /**
     * OnNext events are written without any buffering or dropping.
     * Downstream has to deal with any overflow.
     * &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators.
     */
    MISSING,
    /**
     * Signals a MissingBackpressureException in case the downstream can&apos;t keep up.
     */
    ERROR,
    /**
     * Buffers &lt;em&gt;all&lt;/em&gt; onNext values until the downstream consumes it.
     */
    BUFFER,
    /**
     * Drops the most recent onNext value if the downstream can&apos;t keep up.
     */
    DROP,
    /**
     * Keeps only the latest onNext value, overwriting any previous value if the
     * downstream can&apos;t keep up.
     */
    LATEST
}
</code></pre><p><strong>当上游发送数据的速度快于下游接收数据的速度，且运行在不同的线程中时，Flowable通过自身特有的异步缓存池，来缓存没来得及处理的数据，缓存池的容量上限为128</strong></p>
<p>BackpressureStrategy的作用便是用来设置Flowable通过异步缓存池缓存数据的策略。在源码FlowableCreate类中，可以看到五个泛型分别对应五个java类，通过代理模式对原始的发射器进行了包装：</p>
<pre><code>Override
public void subscribeActual(Subscriber&lt;? super T&gt; t) {
    BaseEmitter&lt;T&gt; emitter;

    switch (backpressure) {
        case MISSING: {
            emitter = new MissingEmitter&lt;T&gt;(t);
            break;
        }
        case ERROR: {
            emitter = new ErrorAsyncEmitter&lt;T&gt;(t);
            break;
        }
        case DROP: {
            emitter = new DropAsyncEmitter&lt;T&gt;(t);
            break;
        }
        case LATEST: {
            emitter = new LatestAsyncEmitter&lt;T&gt;(t);
            break;
        }
        default: {
            emitter = new BufferAsyncEmitter&lt;T&gt;(t, bufferSize());
            break;
        }
    }

    t.onSubscribe(emitter);
    try {
        source.subscribe(emitter);
    } catch (Throwable ex) {
        Exceptions.throwIfFatal(ex);
        emitter.onError(ex);
    }
}
</code></pre><h4 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h4><p>对应于ErrorAsyncEmitter<t>类，在其源码</t></p>
<pre><code>static final class ErrorAsyncEmitter&lt;T&gt; extends NoOverflowBaseAsyncEmitter&lt;T&gt; {
        private static final long serialVersionUID = 338953216916120960L;

        ErrorAsyncEmitter(Subscriber&lt;? super T&gt; actual) {
            super(actual);
        }

        @Override
        void onOverflow() {
            onError(new MissingBackpressureException(&quot;create: could not emit value due to lack of requests&quot;));
        }

    }

abstract static class NoOverflowBaseAsyncEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; {

        private static final long serialVersionUID = 4127754106204442833L;

        NoOverflowBaseAsyncEmitter(Subscriber&lt;? super T&gt; actual) {
            super(actual);
        }

        @Override
        public final void onNext(T t) {
            if (isCancelled()) {
                return;
            }

            if (t == null) {
                onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));
                return;
            }

            if (get() != 0) {
                actual.onNext(t);
                BackpressureHelper.produced(this, 1);
            } else {
                onOverflow();
            }
        }

        abstract void onOverflow();
    }
</code></pre><p>onOverflow方法中可以看到，<strong>在此策略下，如果放入Flowable的异步缓存池中的数据超限了，则会抛出MissingBackpressureException异常。父类的onNext中，在判断get() != 0，即缓存池未满的情况下，才会让被代理类调用onNext方法</strong>。运行如下代码：</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
                for (int i = 1; i &lt;= 129; i++) {
                    e.onNext(i);
                }
                e.onComplete();
            }
        }, BackpressureStrategy.ERROR)
        .subscribeOn(Schedulers.newThread())
        .observeOn(Schedulers.newThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Subscription s) {
                s.request(Long.MAX_VALUE);            //注意此处，暂时先这么设置
            }

            @Override
            public void onNext(Integer integer) {
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException ignore) {
                }
                System.out.println(integer);
            }

            @Override
            public void onError(Throwable t) {
                t.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println(&quot;接收----&gt; 完成&quot;);
            }
        });
</code></pre><p>创建并通过Flowable发射129条数据，Subscriber的onNext方法睡10秒之后再开始接收，运行后会发现控制台打印如下异常：</p>
<pre><code>W/System.err: io.reactivex.exceptions.MissingBackpressureException: create: could not emit value due to lack of requests
W/System.err:     at io.reactivex.internal.operators.flowable.FlowableCreate$ErrorAsyncEmitter.onOverflow(FlowableCreate.java:411)
W/System.err:     at io.reactivex.internal.operators.flowable.FlowableCreate$NoOverflowBaseAsyncEmitter.onNext(FlowableCreate.java:377)
</code></pre><p>如果将Flowable发射数据的条数改为128，则不会出现此异常。</p>
<h4 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h4><p>对应于DropAsyncEmitter<t>类，通过DropAsyncEmitter类和它父类NoOverflowBaseAsyncEmitter的源码</t></p>
<pre><code>static final class DropAsyncEmitter&lt;T&gt; extends NoOverflowBaseAsyncEmitter&lt;T&gt; {
    private static final long serialVersionUID = 8360058422307496563L;

    DropAsyncEmitter(Subscriber&lt;? super T&gt; actual) {
        super(actual);
    }

    @Override
    void onOverflow() {
        // nothing to do
    }
}
</code></pre><p>可以看到，DropAsyncEmitter的onOverflow是个空方法，没有执行任何操作。所以<strong>在此策略下，如果Flowable的异步缓存池满了，会丢掉上游发送的数据</strong>。</p>
<p>存池中数据的清理，并不是Subscriber接收一条，便清理一条，而是存在一个延迟，等累积一段时间后统一清理一次。也就是Subscriber接收到第96条数据时，缓存池才开始清理数据，之后Flowable发射的数据才得以放入。如果数据处于缓存池存满的状态时，则被丢弃。</p>
<h4 id="LATEST"><a href="#LATEST" class="headerlink" title="LATEST"></a>LATEST</h4><p>对应于LatestAsyncEmitter<t>类<br>与Drop策略一样，如果缓存池满了，会丢掉将要放入缓存池中的数据，不同的是，不管缓存池的状态如何，<strong>LATEST都会将最后一条数据强行放入缓存池中</strong>，来保证观察者在接收到完成通知之前，能够接收到Flowable最新发射的一条数据。</t></p>
<h4 id="BUFFER"><a href="#BUFFER" class="headerlink" title="BUFFER"></a>BUFFER</h4><p>Flowable处理背压的默认策略，对应于BufferAsyncEmitter<t>类</t></p>
<p>其部分源码为：</p>
<pre><code>static final class BufferAsyncEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; {
        private static final long serialVersionUID = 2427151001689639875L;
        final SpscLinkedArrayQueue&lt;T&gt; queue;
        . . . . . .
        final AtomicInteger wip;
        BufferAsyncEmitter(Subscriber&lt;? super T&gt; actual, int capacityHint) {
            super(actual);
            this.queue = new SpscLinkedArrayQueue&lt;T&gt;(capacityHint);
            this.wip = new AtomicInteger();
        }
        . . . . . .
}
</code></pre><p>在其构造方法中可以发现，其内部维护了一个缓存池SpscLinkedArrayQueue，其大小不限，此策略下，<strong>如果Flowable默认的异步缓存池满了，会通过此缓存池暂存数据，它与Observable的异步缓存池一样，可以无限制向里添加数据，不会抛出MissingBackpressureException异常，但会导致OOM</strong>。</p>
<p>和使用Observable时一样，都会导致内存剧增，最后导致OOM,不同的是使用Flowable内存增长的速度要慢得多，那是因为基于Flowable发射的数据流，以及对数据加工处理的各操作符都添加了背压支持，附加了额外的逻辑，其运行效率要比Observable低得多。</p>
<h4 id="MISSING"><a href="#MISSING" class="headerlink" title="MISSING"></a>MISSING</h4><p>对应于MissingEmitter<t>类，通过其源码：</t></p>
<pre><code>static final class MissingEmitter&lt;T&gt; extends BaseEmitter&lt;T&gt; {


        private static final long serialVersionUID = 3776720187248809713L;

        MissingEmitter(Subscriber&lt;? super T&gt; actual) {
            super(actual);
        }

        @Override
        public void onNext(T t) {
            if (isCancelled()) {
                return;
            }

            if (t != null) {
                actual.onNext(t);
            } else {
                onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));
                return;
            }

            for (;;) {
                long r = get();
                if (r == 0L || compareAndSet(r, r - 1)) {
                    return;
                }
            }
        }

    }
</code></pre><p>可以发现，在传递数据时</p>
<pre><code>actual.onNext(t);
</code></pre><p>并没有对缓存池的状态进行判断，所以在此策略下，通过Create方法创建的Flowable相当于没有指定背压策略，不会对通过onNext发射的数据做缓存或丢弃处理，需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）指定背压策略。</p>
<p>onBackpressureXXX背压操作符：<strong>Flowable除了通过create创建的时候指定背压策略，也可以在通过其它创建操作符just，fromArray等创建后通过背压操作符指定背压策略</strong>。</p>
<blockquote>
<p>onBackpressureBuffer()对应BackpressureStrategy.BUFFER<br>onBackpressureDrop()对应BackpressureStrategy.DROP<br>onBackpressureLatest()对应BackpressureStrategy.LATEST</p>
</blockquote>
<p>例如代码</p>
<pre><code>Flowable.range(0, 500)
        .onBackpressureDrop()
        .subscribeOn(Schedulers.newThread())
        .observeOn(Schedulers.newThread())
        .subscribe(new Consumer&lt;Integer&gt;() {
            @Override
            public void accept(@NonNull Integer integer) throws Exception {
                System.out.println(integer);
            }
        });
</code></pre><h4 id="Subscription"><a href="#Subscription" class="headerlink" title="Subscription"></a>Subscription</h4><p>Subscription与Disposable均是观察者与可观察对象建立订阅状态后回调回来的参数，如同<strong>通过Disposable的dispose()方法可以取消Observer与Oberverable的订阅关系一样，通过Subscription的cancel()方法也可以取消Subscriber与Flowable的订阅关系</strong>。<br>不同的是接口Subscription中多了一个方法request(long n)，如上面代码中的：</p>
<pre><code>s.request(Long.MAX_VALUE);   
</code></pre><p>Flowable在设计的时候，采用了一种新的思路——<strong>响应式拉取</strong>方式，来<strong>设置下游对数据的请求数量，上游可以根据下游的需求量，按需发送数据。如果不显示调用request则默认下游的需求量为零，上游Flowable发射的数据不会交给下游Subscriber处理。</strong></p>
<p>多次调用request，数字会累积。</p>
<p>上游并没有根据下游的实际需求，发送数据，而是能发送多少，就发送多少，不管下游是否需要。而且超出下游需求之外的数据，仍然放到了异步缓存池中。这点我们可以通过以下代码来验证：</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
                for (int i = 1; i &lt; 130; i++) {
                    System.out.println(&quot;发射----&gt;&quot; + i);
                    e.onNext(i);
                }
                e.onComplete();
            }
        }, BackpressureStrategy.ERROR)
        .subscribeOn(Schedulers.newThread())
        .observeOn(Schedulers.newThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {
            @Override
            public void onSubscribe(Subscription s) {
                s.request(1);
            }

            @Override
            public void onNext(Integer integer) {
                System.out.println(&quot;接收------&gt;&quot; + integer);
            }

            @Override
            public void onError(Throwable t) {
                t.printStackTrace();
            }

            @Override
            public void onComplete() {
                System.out.println(&quot;接收------&gt;完成&quot;);
            }
        });
</code></pre><p>通过Flowable发射130条数据，通过s.request(1)设置下游的数据请求量为1条，设置缓存策略为BackpressureStrategy.ERROR，如果异步缓存池超限，会导致MissingBackpressureException异常。久违的异常出现了，所以超出下游需求之外的数据，仍然放到了异步缓存池中，并导致缓存池溢出。</p>
<p>那么上游如何才能按照下游的请求数量发送数据呢，虽然通过request可以设置下游的请求数量，但是上游并没有获取到这个数量，如何获取呢？这便需要用到Flowable与Observable的第三点区别，Flowable特有的发射器FlowableEmitter</p>
<h4 id="FlowableEmitter"><a href="#FlowableEmitter" class="headerlink" title="FlowableEmitter"></a>FlowableEmitter</h4><p>flowable的发射器FlowableEmitter与observable的发射器ObservableEmitter均继承自Emitter<br>比较两者源码可以发现：</p>
<pre><code>public interface ObservableEmitter&lt;T&gt; extends Emitter&lt;T&gt; {

    void setDisposable(Disposable d);

    void setCancellable(Cancellable c);

    boolean isDisposed();

    ObservableEmitter&lt;T&gt; serialize();
}
</code></pre><p>与</p>
<pre><code>public interface FlowableEmitter&lt;T&gt; extends Emitter&lt;T&gt; {

    void setDisposable(Disposable s);

    void setCancellable(Cancellable c);

    long requested();

    boolean isCancelled();

    FlowableEmitter&lt;T&gt; serialize();
}
</code></pre><p>接口FlowableEmitter中多了一个方法</p>
<pre><code>long requested();
</code></pre><p>上游在发送数据的时候并不需要考虑下游需不需要，而只需要考虑异步缓存池中是否放得下，放得下便发，放不下便暂停。所以，通过e.requested()获取到的值，并不是下游真正的数据请求数量，而是异步缓存池中可放入数据的数量。数据放入缓存池中后，再由缓存池按照下游的数据请求量向下传递，待到传递完的数据累积到95条之后，将其清除，腾出空间存放新的数据。如果下游处理数据缓慢，则缓存池向下游传递数据的速度也相应变慢，进而没有传递完的数据可清除，也就没有足够的空间存放新的数据，上游通过e.requested()获取的值也就变成了0，如果此时，再发送数据的话，则会根据BackpressureStrategy背压策略的不同，抛出MissingBackpressureException异常，或者丢掉这条数据。</p>
<p>我们<strong>可以通过这个方法来获取当前未完成的请求数量，上游只需要在e.requested()等于0时，暂停发射数据，便可解决背压问题。</strong></p>
<h4 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a>最终方案</h4><p>下面，对其通过Flowable做些改进，让其既不会产生背压问题，也不会引起异常或者数据丢失。<br>代码如下：</p>
<pre><code>Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() {
            @Override
            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception {
                int i = 0;
                while (true) {
                    if (e.requested() == 0) continue;//此处添加代码，让flowable按需发送数据
                    System.out.println(&quot;发射----&gt;&quot; + i);
                    i++;
                    e.onNext(i);
                }
            }
        }, BackpressureStrategy.MISSING)
        .subscribeOn(Schedulers.newThread())
        .observeOn(Schedulers.newThread())
        .subscribe(new Subscriber&lt;Integer&gt;() {
            private Subscription mSubscription;

            @Override
            public void onSubscribe(Subscription s) {
                s.request(1);            //设置初始请求数据量为1
                mSubscription = s;
            }

            @Override
            public void onNext(Integer integer) {
                try {
                    Thread.sleep(50);
                    System.out.println(&quot;接收------&gt;&quot; + integer);
                    mSubscription.request(1);//每接收到一条数据增加一条请求量
                } catch (InterruptedException ignore) {
                }
            }

            @Override
            public void onError(Throwable t) {
            }

            @Override
            public void onComplete() {
            }
        });
</code></pre><p>下游处理数据的速度Thread.sleep(50)赶不上上游发射数据的速度，不同的是，我们在下游onNext(Integer integer) 方法中，每接收一条数据增加一条请求量，</p>
<pre><code>mSubscription.request(1)
</code></pre><p>在上游添加代码</p>
<pre><code>if(e.requested()==0)continue;
</code></pre><p>让上游按需发送数据，上游严格按照下游的需求量发送数据，不会产生MissingBackpressureException异常，或者丢失数据。</p>
<h2 id="2、Observable"><a href="#2、Observable" class="headerlink" title="2、Observable"></a>2、Observable</h2><h3 id="2-1、Observable简介"><a href="#2-1、Observable简介" class="headerlink" title="2.1、Observable简介"></a>2.1、Observable简介</h3><p>Observable类是不支持背压的，Observable是Reactive的一个抽象基类，Observable提供工厂方法，中间运算符以及消费同步和/或异步数据流的功能。</p>
<p>Observable类中的多数运算符接受一个或者多个ObservableSource，ObservableSource是非背压的基本接口，Observable实现了这个接口。</p>
<p>public abstract class Observable<t> implements ObservableSource<t><br>默认情况下，Observable的为其运算符提供128个元素的缓冲区大小运行，可看考Flowable.bufferSize()，可以通过系统参数rx2.buffer-size全局覆盖。但是，大多数运算符都有重载，允许设置其内部缓冲区大小。</t></t></p>
<h3 id="2-2、Flowable和Observable对比"><a href="#2-2、Flowable和Observable对比" class="headerlink" title="2.2、Flowable和Observable对比"></a>2.2、Flowable和Observable对比</h3><p>在上面已经说明了二者最大的区别。</p>
<p>官方也给出的解释是：</p>
<blockquote>
<p>The design of this class was derived from the Reactive-Streams design and specification by removing any backpressure-related infrastructure and implementation detail, replacing the org.reactivestreams.Subscription with Disposable as the primary means to dispose of a flow.</p>
</blockquote>
<p>中文翻译：</p>
<blockquote>
<p>该类的设计源自Reactive-Streams设计和规范，通过删除任何与背压相关的基本结构和实现细节，将Disposable替换为org.reactivestreams.Subscription作为处理流的主要方式。</p>
</blockquote>
<p>从代码层面上做简单的说明,Flowable实现了Publisher接口，Publisher源码如下:</p>
<pre><code>public interface Publisher&lt;T&gt; {

    /**
     * Request {@link Publisher} to start streaming data.
     * &lt;p&gt;
     * This is a &quot;factory method&quot; and can be called multiple times, each time starting a new {@link Subscription}.
     * &lt;p&gt;
     * Each {@link Subscription} will work for only a single {@link Subscriber}.
     * &lt;p&gt;
     * A {@link Subscriber} should only subscribe once to a single {@link Publisher}.
     * &lt;p&gt;
     * If the {@link Publisher} rejects the subscription attempt or otherwise fails it will
     * signal the error via {@link Subscriber#onError}.
     *
     * @param s the {@link Subscriber} that will consume signals from this {@link Publisher}
     */
    public void subscribe(Subscriber&lt;? super T&gt; s);
}
</code></pre><p>Observable实现了ObservableSource接口，ObservableSource源码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface ObservableSource&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Subscribes the given Observer to this ObservableSource instance.</span><br><span class="line">     * @param observer the Observer, not null</span><br><span class="line">     * @throws NullPointerException if &#123;@code observer&#125; is null</span><br><span class="line">     */</span><br><span class="line">    void subscribe(Observer&lt;? super T&gt; observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对比ObservableSource和Publisher，都有一个同名的接口subscribe()</p>
<h3 id="2-4、形象理解ObservableSource和Publisher有何异同"><a href="#2-4、形象理解ObservableSource和Publisher有何异同" class="headerlink" title="2.4、形象理解ObservableSource和Publisher有何异同"></a>2.4、形象理解ObservableSource和Publisher有何异同</h3><p>ObservableSource：可观察源</p>
<p>Publisher：发布者</p>
<p>subscribe：订阅</p>
<p>Subscriber：订阅者</p>
<p>Observer：观察者</p>
<p>对于ObservableSource，可以将subscribe(Observer observer)理解为Observer通过subscribe订阅了ObservableSource</p>
<p>对于Publisher，可以将subscribe(Subscriber s)理解为Subscriber通过subscribe订阅了Publisher</p>
<p>上面的解释可能比较抽象，通俗的举个例子，来个角色扮演</p>
<p>第一组：报刊（ObservableSource）、报刊订阅者（Observer）、订阅报刊的行为（subscribe)</p>
<p>第二组：报刊发布人(Publisher)、报刊订阅者（Subscriber）、订阅报刊的行为（subscribe)</p>
<p>把这个场景串起来讲就是：报刊订阅者订阅了报刊，或者说报刊订阅者在报刊发布人手中订阅了报刊。</p>
<p><strong>这其实是典型的观察者模式，所不同的是信息的发布者是ObservableSource还是Publisher，信息的订阅者是Observer还是Subscriber，统一的行为都是subscribe。</strong></p>
<h2 id="3、Single"><a href="#3、Single" class="headerlink" title="3、Single"></a>3、Single</h2><h3 id="3-1、Single简介"><a href="#3-1、Single简介" class="headerlink" title="3.1、Single简介"></a>3.1、Single简介</h3><pre><code>public abstract class Single&lt;T&gt; implements SingleSource&lt;T&gt; 
</code></pre><p>Single实现了SingleSource</p>
<pre><code>/**
 * Represents a basic {@link Single} source base interface,
 * consumable via an {@link SingleObserver}.
 * &lt;p&gt;
 * This class also serves the base type for custom operators wrapped into
 * Single via {@link Single#create(SingleOnSubscribe)}.
 *
 * @param &lt;T&gt; the element type
 * @since 2.0
 */
public interface SingleSource&lt;T&gt; {

    /**
     * Subscribes the given SingleObserver to this SingleSource instance.
     * @param observer the SingleObserver, not null
     * @throws NullPointerException if {@code observer} is null
     */
    void subscribe(SingleObserver&lt;? super T&gt; observer);
}
</code></pre><p>Single类为单个值响应实现Reactive Pattern。</p>
<p><strong>Single和Observable类似，所不同的是Single只能发出一个值，要么发射成功要么发射失败，也没有“onComplete”作为完成时的回调</strong></p>
<p>Single类实现了基类SingleSource的接口，SingleObserver作为Single发出来的消息的默认消费者，SingleObserver通过subscribe(SingleObserver&lt;? super T&gt; observer)在Single中订阅消息</p>
<pre><code>public interface SingleObserver&lt;T&gt; {

    /**
     * Provides the SingleObserver with the means of cancelling (disposing) the
     * connection (channel) with the Single in both
     * synchronous (from within {@code onSubscribe(Disposable)} itself) and asynchronous manner.
     * @param d the Disposable instance whose {@link Disposable#dispose()} can
     * be called anytime to cancel the connection
     * @since 2.0
     */
    void onSubscribe(Disposable d);

    /**
     * Notifies the SingleObserver with a single item and that the {@link Single} has finished sending
     * push-based notifications.
     * &lt;p&gt;
     * The {@link Single} will not call this method if it calls {@link #onError}.
     *
     * @param value
     *          the item emitted by the Single
     */
    void onSuccess(T value);

    /**
     * Notifies the SingleObserver that the {@link Single} has experienced an error condition.
     * &lt;p&gt;
     * If the {@link Single} calls this method, it will not thereafter call {@link #onSuccess}.
     *
     * @param e
     *          the exception encountered by the Single
     */
    void onError(Throwable e);
}
</code></pre><h3 id="3-2、Single与Observable的区别"><a href="#3-2、Single与Observable的区别" class="headerlink" title="3.2、Single与Observable的区别"></a>3.2、Single与Observable的区别</h3><p>Single只能发送单个消息，不能发送消息流，而且观察者接收到消息也只有两种情况，要么接收成功，要么接收失败</p>
<h3 id="3-3、Single官方图解"><a href="#3-3、Single官方图解" class="headerlink" title="3.3、Single官方图解"></a>3.3、Single官方图解</h3><p><img src="/2019/08/07/android-rxjava-role/rxjava-single.jpg" alt></p>
<h2 id="4、Completable"><a href="#4、Completable" class="headerlink" title="4、Completable"></a>4、Completable</h2><h3 id="4-1、Completable简介"><a href="#4-1、Completable简介" class="headerlink" title="4.1、Completable简介"></a>4.1、Completable简介</h3><p>Completable类<strong>表示延迟计算，没有任何值，只表示完成或异常</strong>。</p>
<p>Completable的行为类似于Observable，在计算完成后只能发出完成或错误信号，由onComplete或onError接口来处理，没有onNext或onSuccess等回调接口</p>
<p>Completable实现了基类CompletableSource的接口，CompletableObserver通过subscribe()方法在Completable处订阅消息。</p>
<p>Completable遵循协议：onSubscribe (onComplete | onError)</p>
<pre><code>public abstract class Completable implements CompletableSource


public interface CompletableSource {

    /**
     * Subscribes the given CompletableObserver to this CompletableSource instance.
     * @param cs the CompletableObserver, not null
     * @throws NullPointerException if {@code cs} is null
     */
    void subscribe(CompletableObserver cs);
}


public interface CompletableObserver {

    void onSubscribe(Disposable d);

    void onComplete();

    void onError(Throwable e);
}
</code></pre><p>从源码中我们可以看到CompletableObserver里面有三个接口：</p>
<p>1）onSubscribe中传入参数Disposable，由Completable调用一次，在CompletableObserver实例上设置Disposable，然后可以随时取消订阅。</p>
<p>2）onComplete一旦延迟计算正常完成将会被调用</p>
<p>3）onError 一旦延迟计算抛出异常将会被调用</p>
<h3 id="4-3、Completable示例"><a href="#4-3、Completable示例" class="headerlink" title="4.3、Completable示例"></a>4.3、Completable示例</h3><p>注意：<strong> 通过Disposable调用dispose()取消订阅，后面的消息无法接收。</strong></p>
<p>运行下面的例子，可以看到在调用dispose后，onStart被回调后，后续的消息就收不到了；去掉dispose，onStart回调后，三秒后onComplete将会被回调</p>
<pre><code> private void doCompletable() {
        Disposable d = Completable.complete()
                .delay(3, TimeUnit.SECONDS, Schedulers.io())
                .subscribeWith(new DisposableCompletableObserver() {
                    @Override
                    public void onStart() {
                        System.out.println(&quot;Started&quot;);
                    }

                    @Override
                    public void onError(Throwable error) {
                        error.printStackTrace();
                    }

                    @Override
                    public void onComplete() {
                        System.out.println(&quot;onComplete!&quot;);
                    }
                });


        d.dispose();

    }

运行完毕的结果是：
10-02 11:10:34.797 15565-15565/hq.demo.net I/System.out: Started

注释d.dispose()后在运行结果是：
10-02 14:34:19.490 23232-23232/hq.demo.net I/System.out: Started
10-02 14:34:22.492 23232-23483/hq.demo.net I/System.out: Done!
</code></pre><p>上面使用的是DisposableCompletableObserver通过subscribeWith来订阅消息，返回一个Disposable可以通过dispose来取消订阅关系，DisposableCompletableObserver是CompletableObserve的子类，只是增加了可取消订阅的功能。当然也能通过CompletableObserve方法操作，但是无法取消订阅关系，除此外没什么本质区别。</p>
<h2 id="5、Maybe"><a href="#5、Maybe" class="headerlink" title="5、Maybe"></a>5、Maybe</h2><h3 id="5-1、Maybe简介"><a href="#5-1、Maybe简介" class="headerlink" title="5.1、Maybe简介"></a>5.1、Maybe简介</h3><p>Maybe类<strong>表示延迟计算和单个值的发射，这个值可能根本没有或异常。</strong></p>
<p>Maybe类实现MaybeSource的接口，MaybeObserver通过subscribe(MaybeObserver)在Maybe处订阅消息</p>
<p>Maybe遵循协议：onSubscribe (onSuccess | onError | onComplete)，也就是Maybe发射消息后，可能会回调的接口是onSuccess | onError | onComplete</p>
<pre><code>public abstract class Maybe&lt;T&gt; implements MaybeSource&lt;T&gt;

public interface MaybeSource&lt;T&gt; {

    /**
     * Subscribes the given MaybeObserver to this MaybeSource instance.
     * @param observer the MaybeObserver, not null
     * @throws NullPointerException if {@code observer} is null
     */
    void subscribe(MaybeObserver&lt;? super T&gt; observer);
}


public interface MaybeObserver&lt;T&gt; {
    void onSubscribe(Disposable d);
    void onSuccess(T value);
    void onError(Throwable e);
    void onComplete();
}
</code></pre><h3 id="5-3、Maybe示例"><a href="#5-3、Maybe示例" class="headerlink" title="5.3、Maybe示例"></a>5.3、Maybe示例</h3><p>下面是个例子，注意让线程睡多少秒可以修改测试dispose，与Completable类似，但是<strong>无论怎么onStart()都会被回调</strong>，为什么onStart()都会被回调呢？可以看DisposableMaybeObserver源码，在订阅消息的时候就会首先回调onSubscribe，这个时候dispose还没有运行了，这个动作发生在订阅的时候，没有订阅何来取消订阅呢。</p>
<pre><code>public abstract class DisposableMaybeObserver&lt;T&gt; implements MaybeObserver&lt;T&gt;, Disposable {
    final AtomicReference&lt;Disposable&gt; s = new AtomicReference&lt;Disposable&gt;();

    @Override
    public final void onSubscribe(Disposable s) {
        if (DisposableHelper.setOnce(this.s, s)) {
            onStart();
        }
    }

    /**
     * Called once the single upstream Disposable is set via onSubscribe.
     */
    protected void onStart() {
    }

    @Override
    public final boolean isDisposed() {
        return s.get() == DisposableHelper.DISPOSED;
    }

    @Override
    public final void dispose() {
        DisposableHelper.dispose(s);
    }
}
</code></pre><p>下面是实例的运行和结果</p>
<pre><code>private void doMaybe() {

        new Thread(new Runnable() {
            @Override
            public void run() {
                Disposable d = Maybe.just(&quot;Hello World&quot;)
                        .delay(3, TimeUnit.SECONDS, Schedulers.io())
                        .subscribeWith(new DisposableMaybeObserver&lt;String&gt;() {
                            @Override
                            public void onStart() {
                                System.out.println(&quot;Started&quot;);
                            }

                            @Override
                            public void onSuccess(String value) {
                                System.out.println(&quot;Success: &quot; + value);
                            }

                            @Override
                            public void onError(Throwable error) {
                                error.printStackTrace();
                            }

                            @Override
                            public void onComplete() {
                                System.out.println(&quot;Done!&quot;);
                            }
                        });

                try {
                    Thread.sleep(4000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                d.dispose();
            }
        }).start();

    }


运行结果是：
10-02 15:01:53.320 25573-25649/hq.demo.net I/System.out: Started
10-02 15:01:56.324 25573-25654/hq.demo.net I/System.out: Success: Hello World

如果把Thread.sleep(4000)修改为Thread.sleep(2000)运行结果是：
10-02 15:05:34.362 25840-25872/hq.demo.net I/System.out: Started
</code></pre><p>上面例子使用DisposableMaybeObserver通过subscribeWith在Maybe处订阅，并返回一个Disposable，可以通过Disposable调用dispose来取消订阅。当然我们也可以通过下面的方式来完成，但是无法取消订阅关系：</p>
<pre><code>private void doMaybe() {
    Maybe.just(&quot;Hello World&quot;)
            .delay(3, TimeUnit.SECONDS, Schedulers.io())
            .subscribe(new MaybeObserver&lt;String&gt;() {
                @Override
                public void onSubscribe(Disposable d) {
                    System.out.println(&quot;Started&quot;);
                }

                @Override
                public void onSuccess(String value) {
                    System.out.println(&quot;Success: &quot; + value);
                }

                @Override
                public void onError(Throwable e) {
                    e.printStackTrace();
                }

                @Override
                public void onComplete() {
                    System.out.println(&quot;Done!&quot;);
                }
            });

    }
</code></pre><h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>Single、Completable、Maybe是简化的Observable，只是具有少部分功能：</p>
<blockquote>
<p><strong>Single：只能发射一条单一数据或者一条异常通知，不能发射完成通知，数据与通知只能发射一个，二选一<br>Completable：只能发射一条完成通知或者一条异常通知，不能发射数据，要么发射完成通知要么发射异常通知，二选一<br>Maybe：只能发射一条单一数据，和发射一条完成通知，或者一条异常通知，完成通知和异常通知二选一，只能在发射完成通知或异常通知之前发射数据，否则发射数据无效</strong></p>
</blockquote>
<h2 id="7、参考资料"><a href="#7、参考资料" class="headerlink" title="7、参考资料"></a>7、参考资料</h2><p><a href="https://blog.csdn.net/weixin_36709064/article/details/82911270" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36709064/article/details/82911270</a><br><a href="https://www.jianshu.com/p/ff8167c1d191/" target="_blank" rel="noopener">Flowable背压支持</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/06/android-rxjava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/06/android-rxjava/" itemprop="url">RxJava2操作符汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-06T17:04:12+08:00">
                2019-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android知识点/" itemprop="url" rel="index">
                    <span itemprop="name">Android知识点</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>RxJava是一个在Java VM上使用可观测的序列来组成异步的、基于事件的程序的库</strong>(a library for composing asynchronous and event-based programs using observable sequences for the Java VM)。</p>
<p>RxJava能帮助我们在实现异步执行的前提下保持代码的清晰。它的原理就是创建一个Observable来完成异步任务，组合使用各种不同的链式操作，来实现各种复杂的操作，最终将任务的执行结果发射给Observer进行处理。</p>
<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>RxJava 有以下三个基本的元素：<br>1.被观察者（Observable）<br>2.观察者（Observer）<br>3.订阅（subscribe）</p>
<p>1.创建被观察者：</p>
<pre><code>Observable observable = Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        Log.d(TAG, &quot;=========================currentThread name: &quot; + Thread.currentThread().getName());
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
});
</code></pre><p>2.创建观察者：</p>
<pre><code>Observer observer = new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;======================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
};
</code></pre><p>3.订阅</p>
<pre><code>observable.subscribe(observer);
</code></pre><p>也可以链式调用</p>
<h3 id="RxJava-中的调度器"><a href="#RxJava-中的调度器" class="headerlink" title="RxJava 中的调度器"></a>RxJava 中的调度器</h3><table>
<thead>
<tr>
<th>调度器</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Schedulers.computation( )</td>
<td>用于使用计算任务，如事件循环和回调处理</td>
</tr>
<tr>
<td>Schedulers.immediate( )</td>
<td>当前线程</td>
</tr>
<tr>
<td>Schedulers.io( )</td>
<td>用于 IO 密集型任务，如果异步阻塞 IO 操作</td>
</tr>
<tr>
<td>Schedulers.newThread( )</td>
<td>创建一个新的线程</td>
</tr>
<tr>
<td>AndroidSchedulers.mainThread()</td>
<td>Android 的 UI 线程，用于操作 UI</td>
</tr>
</tbody>
</table>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ul>
<li>每次掉用过onError或onComplete其中一个方法后，就会掉用dispose()方法解除订阅</li>
<li>CompositeDisposable可以容纳多个disposable，每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可快速解除所有添加的Disposable类.</li>
</ul>
<h2 id="2、创建操作符"><a href="#2、创建操作符" class="headerlink" title="2、创建操作符"></a>2、创建操作符</h2><h3 id="create"><a href="#create" class="headerlink" title="create()"></a>create()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source)
</code></pre><p>作用：创建一个被观察者</p>
<h3 id="just"><a href="#just" class="headerlink" title="just()"></a>just()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; just(T item) 
......
public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2, T item3, T item4, T item5, T item6, T item7, T item8, T item9, T item10)
</code></pre><p>作用：创建一个被观察者，并发送事件，发送的事件不可以超过10个以上。</p>
<p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=================onSubscribe&quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;=================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=================onComplete &quot;);
    }
});

看看打印结果：
=================onSubscribe
=================onNext 1
=================onNext 2
=================onNext 3
=================onComplete 
</code></pre><h3 id="fromArray"><a href="#fromArray" class="headerlink" title="fromArray()"></a>fromArray()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items)
</code></pre><p>作用：这个方法和 just() 类似，只不过 fromArray 可以传入多于10个的变量，并且可以传入一个数组。</p>
<h3 id="fromIterable"><a href="#fromIterable" class="headerlink" title="fromIterable()"></a>fromIterable()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromIterable(Iterable&lt;? extends T&gt; source)
</code></pre><p>作用：这个方法和 fromArray() 类似，直接发送一个 List 集合数据给观察者</p>
<h3 id="fromCallable-amp-fromRunnalbe"><a href="#fromCallable-amp-fromRunnalbe" class="headerlink" title="fromCallable() &amp; fromRunnalbe()"></a>fromCallable() &amp; fromRunnalbe()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromCallable(Callable&lt;? extends T&gt; supplier)
</code></pre><p>作用：这里的 Callable 是 java.util.concurrent 中的 Callable，Callable 和 Runnable 的用法基本一致，只是它会返回一个结果值，这个结果值就是发给观察者的。</p>
<p>Observable.fromCallable()类似于:</p>
<pre><code>Observable.defer {
    try {
        Observable.just(...)
    } catch(e: Throwable) {
        Observable.error(e)
    }
}
</code></pre><p>因此，just为运行同步，而fromCallable可以被推迟到另一个Scheduler与subscribeOn（“后”和执行）。</p>
<p>示例如下：</p>
<pre><code>Observable.fromCallable(new Callable &lt; Integer &gt; () {

    @Override
    public Integer call() throws Exception {
        return 1;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + integer);
    }
});
</code></pre><h3 id="fromAction"><a href="#fromAction" class="headerlink" title="fromAction()"></a>fromAction()</h3><p>rxjava-async模块还包含一个fromAction操作符，它接受一个Action作为参数，返回一个Observable，一旦Action终止，它发射这个你传递给fromAction的数据。</p>
<p>Maybe、Completable 专用，相当于执行完成 Action 中的代码并且调用 onComplete，很方便。</p>
<h3 id="fromFuture"><a href="#fromFuture" class="headerlink" title="fromFuture()"></a>fromFuture()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; fromFuture(Future&lt;? extends T&gt; future)
</code></pre><p>作用：参数中的 Future 是 java.util.concurrent 中的 Future，Future 的作用是增加了 cancel() 等方法操作 Callable，它可以通过 get() 方法来获取 Callable 返回的值。</p>
<p>示例如下：</p>
<pre><code>FutureTask &lt; String &gt; futureTask = new FutureTask &lt; &gt; (new Callable &lt; String &gt; () {
    @Override
    public String call() throws Exception {
        Log.d(TAG, &quot;CallableDemo is Running&quot;);
        return &quot;返回结果&quot;;
    }
});

Observable.fromFuture(futureTask)
    .doOnSubscribe(new Consumer &lt; Disposable &gt; () {
    @Override
    public void accept(Disposable disposable) throws Exception {
        futureTask.run();
    }
})
.subscribe(new Consumer &lt; String &gt; () {
    @Override
    public void accept(String s) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + s);
    }
});
</code></pre><p>doOnSubscribe() 的作用就是只有订阅时才会发送事件。</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer()"></a>defer()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; defer(Callable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; supplier)
</code></pre><p>作用：这个方法的作用就是直到被观察者被订阅后才会创建被观察者。</p>
<p>示例如下：</p>
<pre><code>// i 要定义为成员变量
Integer i = 100;

Observable&lt;Integer&gt; observable = Observable.defer(new Callable&lt;ObservableSource&lt;? extends Integer&gt;&gt;() {
    @Override
    public ObservableSource&lt;? extends Integer&gt; call() throws Exception {
        return Observable.just(i);
    }
});

i = 200;

Observer observer = new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
};

observable.subscribe(observer);

i = 300;

observable.subscribe(observer);

打印结果如下：

================onNext 200
================onNext 300
</code></pre><p>因为 defer() 只有观察者订阅的时候才会创建新的被观察者，所以每订阅一次就会打印一次，并且都是打印 i 最新的值。</p>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer()"></a>timer()</h3><pre><code>public static Observable&lt;Long&gt; timer(long delay, TimeUnit unit) 
</code></pre><p>作用：当到指定时间后就会发送一个 0L 的值给观察者。</p>
<p>示例如下：</p>
<pre><code>Observable.timer(2, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;===============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><h3 id="interval"><a href="#interval" class="headerlink" title="interval()"></a>interval()</h3><pre><code>public static Observable&lt;Long&gt; interval(long period, TimeUnit unit)
public static Observable&lt;Long&gt; interval(long initialDelay, long period, TimeUnit unit)
</code></pre><p>作用：每隔一段时间就会发送一个事件，这个事件是从0开始，不断增1的数字。</p>
<p>示例如下：</p>
<pre><code>Observable.interval(4, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});

打印结果：
05-20 20:48:10.321 28723-28723/com.example.louder.rxjavademo D/chan: ==============onSubscribe 
05-20 20:48:14.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 0
05-20 20:48:18.324 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 1
05-20 20:48:22.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 2
05-20 20:48:26.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 3
05-20 20:48:30.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 4
05-20 20:48:34.323 28723-28746/com.example.louder.rxjavademo D/chan: ==============onNext 5
</code></pre><p>从时间就可以看出每隔4秒就会发出一次数字递增1的事件。这里说下 interval() 第三个方法的 initialDelay 参数，这个参数的意思就是 onSubscribe 回调之后，再次回调 onNext 的间隔时间。</p>
<h3 id="intervalRange"><a href="#intervalRange" class="headerlink" title="intervalRange()"></a>intervalRange()</h3><pre><code>public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit)
public static Observable&lt;Long&gt; intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler)
</code></pre><p>作用：可以指定发送事件的开始值和数量，其他与 interval() 的功能一样。</p>
<p>示例如下：</p>
<pre><code>Observable.intervalRange(2, 5, 2, 1, TimeUnit.SECONDS)
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Long aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
打印结果：
05-21 00:03:01.672 2504-2504/com.example.louder.rxjavademo D/chan: ==============onSubscribe 
05-21 00:03:03.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 2
05-21 00:03:04.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 3
05-21 00:03:05.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 4
05-21 00:03:06.673 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 5
05-21 00:03:07.674 2504-2537/com.example.louder.rxjavademo D/chan: ==============onNext 6
</code></pre><p>可以看出收到5次 onNext 事件，并且是从 2 开始的。</p>
<h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><pre><code>public static Observable&lt;Integer&gt; range(final int start, final int count)
</code></pre><p>作用：同时发送一定范围的事件序列。</p>
<p>示例如下：</p>
<pre><code>Observable.range(2, 5)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==============onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer aLong) {
        Log.d(TAG, &quot;==============onNext &quot; + aLong);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});

打印结果：
==============onSubscribe 
==============onNext 2
==============onNext 3
==============onNext 4
==============onNext 5
==============onNext 6
</code></pre><h3 id="rangeLong"><a href="#rangeLong" class="headerlink" title="rangeLong()"></a>rangeLong()</h3><pre><code>public static Observable&lt;Long&gt; rangeLong(long start, long count)
</code></pre><p>作用：与 range() 一样，只是数据类型为 Long</p>
<h3 id="empty-amp-never-amp-error"><a href="#empty-amp-never-amp-error" class="headerlink" title="empty() &amp; never() &amp; error()"></a>empty() &amp; never() &amp; error()</h3><pre><code>public static &lt;T&gt; Observable&lt;T&gt; empty()
public static &lt;T&gt; Observable&lt;T&gt; never()
public static &lt;T&gt; Observable&lt;T&gt; error(final Throwable exception)
</code></pre><p>作用：<br>1.empty() ： 直接发送 onComplete() 事件<br>2.never()：不发送任何事件<br>3.error()：发送 onError() 事件</p>
<p>示例如下：</p>
<pre><code>Observable.empty()
.subscribe(new Observer &lt; Object &gt; () {

    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe&quot;);
    }

    @Override
    public void onNext(Object o) {
        Log.d(TAG, &quot;==================onNext&quot;);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot; + e);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete&quot;);
    }
});
</code></pre><p>打印结果：</p>
<pre><code>==================onSubscribe
==================onComplete
</code></pre><p>换成 never() 的打印结果：</p>
<pre><code>==================onSubscribe
</code></pre><p>换成 error() 的打印结果：</p>
<pre><code>==================onSubscribe
==================onError java.lang.NullPointerException
</code></pre><h3 id="amb"><a href="#amb" class="headerlink" title="amb()"></a>amb()</h3><p>public static <t> Observable<t> amb(Iterable&lt;? extends ObservableSource&lt;? extends T&gt;&gt; sources)</t></t></p>
<p>作用：amb() 要传入一个 Observable 集合，但是<strong>只会发送最先发送事件的 Observable 中的事件，其余 Observable 将会被丢弃</strong>。</p>
<p>示例如下：</p>
<pre><code>ArrayList &lt; Observable &lt; Long &gt;&gt; list = new ArrayList &lt; &gt; ();
list.add(Observable.intervalRange(1, 5, 2, 1, TimeUnit.SECONDS));
list.add(Observable.intervalRange(6, 5, 0, 1, TimeUnit.SECONDS));
Observable.amb(list)
.subscribe(new Consumer &lt; Long &gt; () {
    @Override
    public void accept(Long aLong) throws Exception {
        Log.d(TAG, &quot;========================aLong &quot; + aLong);
    }
});
打印结果：
05-26 10:21:29.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 6
05-26 10:21:30.580 17185-17219/com.example.rxjavademo D/chan: ========================aLong 7
05-26 10:21:31.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 8
05-26 10:21:32.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 9
05-26 10:21:33.579 17185-17219/com.example.rxjavademo D/chan: ========================aLong 10
</code></pre><h2 id="3、转换操作符"><a href="#3、转换操作符" class="headerlink" title="3、转换操作符"></a>3、转换操作符</h2><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map可以将被观察者发送的数据类型转变成其他的类型</p>
<pre><code>public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)
</code></pre><p>以下代码将 Integer 类型的数据转换成 String：</p>
<pre><code>Observable.just(1, 2, 3)
.map(new Function &lt; Integer, String &gt; () {
    @Override
    public String apply(Integer integer) throws Exception {
        return &quot;I&apos;m &quot; + integer;
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.e(TAG, &quot;===================onSubscribe&quot;);
    }

    @Override
    public void onNext(String s) {
        Log.e(TAG, &quot;===================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});

打印结果：
===================onSubscribe
===================onNext I&apos;m 1
===================onNext I&apos;m 2
===================onNext I&apos;m 3
</code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><p>这个方法可以将事件序列中的元素进行整合加工，返回一个新的被观察者。flatMap() 其实与 map() 类似，但是 flatMap() 返回的是一个 Observerable。</p>
<pre><code>public final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)
</code></pre><p>现在有一个需求就是要将 Person 集合中的每个元素中的 Plan 的 action 打印出来。首先用 map() 来实现这个需求看看：</p>
<pre><code>Observable.fromIterable(personList)
.map(new Function &lt; Person, List &lt; Plan &gt;&gt; () {
    @Override
    public List &lt; Plan &gt; apply(Person person) throws Exception {
        return person.getPlanList();
    }
})
.subscribe(new Observer &lt; List &lt; Plan &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(List &lt; Plan &gt; plans) {
        for (Plan plan: plans) {
            List &lt; String &gt; planActionList = plan.getActionList();
            for (String action: planActionList) {
                Log.d(TAG, &quot;==================action &quot; + action);
            }
        }
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>可以看到 onNext() 用了嵌套 for 循环来实现，如果代码逻辑复杂起来的话，可能需要多重循环才可以实现。现在看下使用 flatMap() 实现：</p>
<pre><code>Observable.fromIterable(personList)
.flatMap(new Function &lt; Person, ObservableSource &lt; Plan &gt;&gt; () {
    @Override
    public ObservableSource &lt; Plan &gt; apply(Person person) {
        return Observable.fromIterable(person.getPlanList());
    }
})
.flatMap(new Function &lt; Plan, ObservableSource &lt; String &gt;&gt; () {
    @Override
    public ObservableSource &lt; String &gt; apply(Plan plan) throws Exception {
        return Observable.fromIterable(plan.getActionList());
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;==================action: &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
</code></pre><p>从代码可以看出，只需要两个 flatMap() 就可以完成需求，并且代码逻辑非常清晰。</p>
<h3 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap()"></a>concatMap()</h3><p>concatMap() 和 flatMap() 基本上是一样的，只不过 <strong>concatMap() 转发出来的事件是有序的</strong>，不管是否延时，而 flatMap() 是无序的。</p>
<pre><code>public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)
public final &lt;R&gt; Observable&lt;R&gt; concatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, int prefetch)
</code></pre><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer()"></a>buffer()</h3><p>从需要发送的事件当中获取一定数量的事件，并将这些事件放到缓冲区当中一并发出。</p>
<pre><code>public final Observable&lt;List&lt;T&gt;&gt; buffer(int count, int skip)
</code></pre><p>buffer 有两个参数，一个是 count，另一个 skip。<strong>count 缓冲区元素的数量，skip 就代表缓冲区满了之后，发送下一次事件序列的时候要跳过多少元素</strong>。这样说可能还是有点抽象，直接看代码：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.buffer(2, 1)
.subscribe(new Observer &lt; List &lt; Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(List &lt; Integer &gt; integers) {
        Log.d(TAG, &quot;================缓冲区大小： &quot; + integers.size());
        for (Integer i: integers) {
            Log.d(TAG, &quot;================元素： &quot; + i);
        }
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
打印结果：
================缓冲区大小： 2
================元素： 1
================元素： 2
================缓冲区大小： 2
================元素： 2
================元素： 3
================缓冲区大小： 2
================元素： 3
================元素： 4
================缓冲区大小： 2
================元素： 4
================元素： 5
================缓冲区大小： 1
================元素： 5
</code></pre><p>从结果可以看出，每次发送事件，指针都会往后移动一个元素再取值，直到指针移动到没有元素的时候就会停止取值。</p>
<h3 id="scan"><a href="#scan" class="headerlink" title="scan()"></a>scan()</h3><p>将数据以一定的逻辑聚合起来。</p>
<pre><code>public final Observable&lt;T&gt; scan(BiFunction&lt;T, T, T&gt; accumulator)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.scan(new BiFunction &lt; Integer, Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer, Integer integer2) throws Exception {
        Log.d(TAG, &quot;====================apply &quot;);
        Log.d(TAG, &quot;====================integer &quot; + integer);
        Log.d(TAG, &quot;====================integer2 &quot; + integer2);
        return integer + integer2;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
打印结果：
====================accept 1
====================apply 
====================integer 1
====================integer2 2
====================accept 3
====================apply 
====================integer 3
====================integer2 3
====================accept 6
====================apply 
====================integer 6
====================integer2 4
====================accept 10
====================apply 
====================integer 10
====================integer2 5
====================accept 15
</code></pre><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy()"></a>groupBy()</h3><p>将发送的数据进行分组，每个分组都会返回一个被观察者。</p>
<pre><code>public final &lt;K&gt; Observable&lt;GroupedObservable&lt;K, T&gt;&gt; groupBy(Function&lt;? super T, ? extends K&gt; keySelector)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(5, 2, 3, 4, 1, 6, 8, 9, 7, 10)
.groupBy(new Function &lt; Integer, Integer &gt; () {
    @Override
    public Integer apply(Integer integer) throws Exception {
        return integer % 3;
    }
})
.subscribe(new Observer &lt; GroupedObservable &lt; Integer, Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;====================onSubscribe &quot;);
    }

    @Override
    public void onNext(GroupedObservable &lt; Integer, Integer &gt; integerIntegerGroupedObservable) {
        Log.d(TAG, &quot;====================onNext &quot;);
        integerIntegerGroupedObservable.subscribe(new Observer &lt; Integer &gt; () {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;====================GroupedObservable onSubscribe &quot;);
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(TAG, &quot;====================GroupedObservable onNext  groupName: &quot; + integerIntegerGroupedObservable.getKey() + &quot; value: &quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;====================GroupedObservable onError &quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;====================GroupedObservable onComplete &quot;);
            }
        });
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;====================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;====================onComplete &quot;);
    }
});
</code></pre><h3 id="window"><a href="#window" class="headerlink" title="window()"></a>window()</h3><p>发送指定数量的事件时，就将这些事件分为一组。window 中的 count 的参数就是代表指定的数量，例如将 count 指定为2，那么每发2个数据就会将这2个数据分成一组。</p>
<pre><code>public final Observable&lt;Observable&lt;T&gt;&gt; window(long count)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.window(2)
.subscribe(new Observer &lt; Observable &lt; Integer &gt;&gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;=====================onSubscribe &quot;);
    }

    @Override
    public void onNext(Observable &lt; Integer &gt; integerObservable) {
        integerObservable.subscribe(new Observer &lt; Integer &gt; () {
            @Override
            public void onSubscribe(Disposable d) {
                Log.d(TAG, &quot;=====================integerObservable onSubscribe &quot;);
            }

            @Override
            public void onNext(Integer integer) {
                Log.d(TAG, &quot;=====================integerObservable onNext &quot; + integer);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;=====================integerObservable onError &quot;);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;=====================integerObservable onComplete &quot;);
            }
        });
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;=====================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;=====================onComplete &quot;);
    }
});
打印结果：
=====================onSubscribe 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 1
=====================integerObservable onNext 2
=====================integerObservable onComplete 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 3
=====================integerObservable onNext 4
=====================integerObservable onComplete 
=====================integerObservable onSubscribe 
=====================integerObservable onNext 5
=====================integerObservable onComplete 
=====================onComplete 
</code></pre><p>从结果可以发现，window() 将 1~5 的事件分成了3组。</p>
<h3 id="compose"><a href="#compose" class="headerlink" title="compose()"></a>compose()</h3><p>对Observable进行变换，加工处理。</p>
<pre><code>public final &lt;R&gt; Observable&lt;R&gt; compose(ObservableTransformer&lt;? super T, ? extends R&gt; composer)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
          .compose(new ObservableTransformer&lt;T, T&gt;() {
            @Override
            public ObservableSource&lt;T&gt; apply(Observable&lt;T&gt; observable) { //比如给observable添加subscribeOn、observeOn
                return observable.subscribeOn(Schedulers.io())
                        .observeOn(AndroidSchedulers.mainThread());
            })
　　　　　　.subscribe();
</code></pre><h2 id="4、功能操作符"><a href="#4、功能操作符" class="headerlink" title="4、功能操作符"></a>4、功能操作符</h2><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn()"></a>subscribeOn()</h3><p>指定被观察者的线程，要注意的时，如果多次调用此方法，只有第一次有效。如果不指定，则默认为主线程。</p>
<pre><code>public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler)
</code></pre><h3 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn()"></a>observeOn()</h3><p>指定观察者的线程，可以切换线程，每指定一次就会生效一次。</p>
<pre><code>public final Observable&lt;T&gt; observeOn(Scheduler scheduler)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3)
.observeOn(Schedulers.newThread())
.flatMap(new Function &lt; Integer, ObservableSource &lt; String &gt;&gt; () {
    @Override
    public ObservableSource &lt; String &gt; apply(Integer integer) throws Exception {
        Log.d(TAG, &quot;======================flatMap Thread name &quot; + Thread.currentThread().getName());
        return Observable.just(&quot;chan&quot; + integer);
    }
})
.observeOn(AndroidSchedulers.mainThread())
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;======================onSubscribe&quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;======================onNext Thread name &quot; + Thread.currentThread().getName());
        Log.d(TAG, &quot;======================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;======================onError&quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;======================onComplete&quot;);
    }
});
打印结果：
======================onSubscribe
======================flatMap Thread name RxNewThreadScheduler-1
======================flatMap Thread name RxNewThreadScheduler-1
======================flatMap Thread name RxNewThreadScheduler-1
======================onNext Thread name main
======================onNext chan1
======================onNext Thread name main
======================onNext chan2
======================onNext Thread name main
======================onNext chan3
======================onComplete
</code></pre><p>从打印结果可以知道，observeOn 成功切换了线程。</p>
<h3 id="delay"><a href="#delay" class="headerlink" title="delay()"></a>delay()</h3><p>延迟一段事件发送事件， onSubscribe 回调之后 onNext 延时后才会回调。</p>
<pre><code>public final Observable&lt;T&gt; delay(long delay, TimeUnit unit)
</code></pre><h3 id="doOnEach"><a href="#doOnEach" class="headerlink" title="doOnEach()"></a>doOnEach()</h3><p>Observable 每发送一件事件之前都会先回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnEach(final Consumer&lt;? super Notification&lt;T&gt;&gt; onNotification)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        //      e.onError(new NumberFormatException());
        e.onComplete();
    }
})
.doOnEach(new Consumer &lt; Notification &lt; Integer &gt;&gt; () {
    @Override
    public void accept(Notification &lt; Integer &gt; integerNotification) throws Exception {
        Log.d(TAG, &quot;==================doOnEach &quot; + integerNotification.getValue());
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================doOnEach 1
==================onNext 1
==================doOnEach 2
==================onNext 2
==================doOnEach 3
==================onNext 3
==================doOnEach null
==================onComplete 
</code></pre><p>从结果就可以看出每发送一个事件之前都会回调 doOnEach 方法，并且可以取出 onNext() 发送的值。</p>
<h3 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext()"></a>doOnNext()</h3><p>Observable 每发送 onNext() 之前都会先回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext)
</code></pre><h3 id="doAfterNext"><a href="#doAfterNext" class="headerlink" title="doAfterNext()"></a>doAfterNext()</h3><p>Observable 每发送 onNext() 之后都会回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doAfterNext(Consumer&lt;? super T&gt; onAfterNext)
</code></pre><h3 id="doOnComplete"><a href="#doOnComplete" class="headerlink" title="doOnComplete()"></a>doOnComplete()</h3><p>Observable 每发送 onComplete() 之前都会回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnComplete(Action onComplete)
</code></pre><h3 id="doOnError"><a href="#doOnError" class="headerlink" title="doOnError()"></a>doOnError()</h3><p>Observable 每发送 onError() 之前都会回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError)
</code></pre><h3 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe()"></a>doOnSubscribe()</h3><p>Observable 每发送 onSubscribe() 之前都会回调这个方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnSubscribe(Consumer&lt;? super Disposable&gt; onSubscribe)
</code></pre><h3 id="doOnDispose"><a href="#doOnDispose" class="headerlink" title="doOnDispose()"></a>doOnDispose()</h3><p>当调用 Disposable 的 dispose() 之后回调该方法。</p>
<pre><code>public final Observable&lt;T&gt; doOnDispose(Action onDispose)
</code></pre><h3 id="doOnLifecycle"><a href="#doOnLifecycle" class="headerlink" title="doOnLifecycle()"></a>doOnLifecycle()</h3><p>在回调 onSubscribe 之前回调该方法的第一个参数的回调方法，可以使用该回调方法决定是否取消订阅。第二个参数的回调方法的作用与 doOnDispose() 是一样的。</p>
<pre><code>public final Observable&lt;T&gt; doOnLifecycle(final Consumer&lt;? super Disposable&gt; onSubscribe, final Action onDispose)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onComplete();
    }
})
.doOnLifecycle(new Consumer&lt;Disposable&gt;() {
    @Override
    public void accept(Disposable disposable) throws Exception {
        Log.d(TAG, &quot;==================doOnLifecycle accept&quot;);
    }
}, new Action() {
    @Override
    public void run() throws Exception {
        Log.d(TAG, &quot;==================doOnLifecycle Action&quot;);
    }
})
.doOnDispose(
    new Action() {
        @Override
        public void run() throws Exception {
            Log.d(TAG, &quot;==================doOnDispose Action&quot;);
        }
})
.subscribe(new Observer&lt;Integer&gt;() {
    private Disposable d;
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
        this.d = d;
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
        d.dispose();
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }

});
打印结果：
 ==================doOnLifecycle accept
==================onSubscribe 
==================onNext 1
==================doOnDispose Action
==================doOnLifecycle Action
</code></pre><p>可以看到当在 onNext() 方法进行取消订阅操作后，doOnDispose() 和 doOnLifecycle() 都会被回调。<br>如果使用 doOnLifecycle 进行取消订阅，来看看打印结果：</p>
<pre><code>==================doOnLifecycle accept
==================onSubscribe 
</code></pre><p>可以发现 doOnDispose Action 和 doOnLifecycle Action 都没有被回调。</p>
<h3 id="doOnTerminate-amp-doAfterTerminate"><a href="#doOnTerminate-amp-doAfterTerminate" class="headerlink" title="doOnTerminate() &amp; doAfterTerminate()"></a>doOnTerminate() &amp; doAfterTerminate()</h3><p>doOnTerminate 是在 onError 或者 onComplete 发送之前回调，而 doAfterTerminate 则是 onError 或者 onComplete 发送之后回调。</p>
<pre><code>public final Observable&lt;T&gt; doOnTerminate(final Action onTerminate)
public final Observable&lt;T&gt; doAfterTerminate(Action onFinally)
</code></pre><h3 id="doFinally"><a href="#doFinally" class="headerlink" title="doFinally()"></a>doFinally()</h3><p>在所有事件发送完毕之后回调该方法。</p>
<pre><code>public final Observable&lt;T&gt; doFinally(Action onFinally)
</code></pre><p>这里可能你会有个问题，那就是 doFinally() 和 doAfterTerminate() 到底有什么区别？区别就是在于取消订阅，如果取消订阅之后 doAfterTerminate() 就不会被回调，而 <strong>doFinally() 无论怎么样都会被回调，且都会在事件序列的最后</strong>。</p>
<h3 id="onErrorReturn"><a href="#onErrorReturn" class="headerlink" title="onErrorReturn()"></a>onErrorReturn()</h3><p>当接受到一个 onError() 事件之后回调，返回的值会回调 onNext() 方法，并正常结束该事件序列。</p>
<pre><code>public final Observable&lt;T&gt; onErrorReturn(Function&lt;? super Throwable, ? extends T&gt; valueSupplier)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.onErrorReturn(new Function&lt;Throwable, Integer&gt;() {
    @Override
    public Integer apply(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================onErrorReturn &quot; + throwable);
        return 404;
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onErrorReturn java.lang.NullPointerException
==================onNext 404
==================onComplete 
</code></pre><h3 id="onErrorResumeNext"><a href="#onErrorResumeNext" class="headerlink" title="onErrorResumeNext()"></a>onErrorResumeNext()</h3><p>当接收到 onError() 事件时，返回一个新的 Observable，并正常结束事件序列。</p>
<pre><code>public final Observable&lt;T&gt; onErrorResumeNext(Function&lt;? super Throwable, ? extends ObservableSource&lt;? extends T&gt;&gt; resumeFunction)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() {
    @Override
    public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new NullPointerException());
    }
})
.onErrorResumeNext(new Function&lt;Throwable, ObservableSource&lt;? extends Integer&gt;&gt;() {
    @Override
    public ObservableSource&lt;? extends Integer&gt; apply(Throwable throwable) throws Exception {
        Log.d(TAG, &quot;==================onErrorResumeNext &quot; + throwable);
        return Observable.just(4, 5, 6);
    }
})
.subscribe(new Observer&lt;Integer&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onErrorResumeNext java.lang.NullPointerException
==================onNext 4
==================onNext 5
==================onNext 6
==================onComplete 
</code></pre><h3 id="onExceptionResumeNext"><a href="#onExceptionResumeNext" class="headerlink" title="onExceptionResumeNext()"></a>onExceptionResumeNext()</h3><p>与 onErrorResumeNext() 作用基本一致，但是这个方法只能捕捉 Exception。</p>
<pre><code>public final Observable&lt;T&gt; onExceptionResumeNext(final ObservableSource&lt;? extends T&gt; next)
</code></pre><h3 id="retry"><a href="#retry" class="headerlink" title="retry()"></a>retry()</h3><p>如果出现错误事件，则会重新发送所有事件序列。times 是代表重新发的次数。</p>
<pre><code>public final Observable&lt;T&gt; retry(long times)
</code></pre><h3 id="retryUntil"><a href="#retryUntil" class="headerlink" title="retryUntil()"></a>retryUntil()</h3><p>出现错误事件之后，可以通过此方法判断是否继续发送事件。指示Observable遇到错误时，是否让Observable重新订阅。</p>
<pre><code>public final Observable&lt;T&gt; retryUntil(final BooleanSupplier stop)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onNext(2);
        e.onNext(3);
        e.onError(new Exception(&quot;404&quot;));
    }
})
.retryUntil(new BooleanSupplier() {
    @Override
    public boolean getAsBoolean() throws Exception {
        if (i == 6) {
            return true;
        }
        return false;
    }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onError 
</code></pre><h3 id="retryWhen"><a href="#retryWhen" class="headerlink" title="retryWhen()"></a>retryWhen()</h3><p>当被观察者接收到异常或者错误事件时会回调该方法，这个方法会返回一个新的被观察者。<strong>如果返回的被观察者发送 Error 事件则之前的被观察者不会继续发送事件，如果发送正常事件则之前的被观察者会继续不断重试发送事件。</strong></p>
<pre><code>public final void safeSubscribe(Observer&lt;? super T&gt; s)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; String &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; String &gt; e) throws Exception {
        e.onNext(&quot;chan&quot;);
        e.onNext(&quot;ze&quot;);
        e.onNext(&quot;de&quot;);
        e.onError(new Exception(&quot;404&quot;));
        e.onNext(&quot;haha&quot;);
    }
})
.retryWhen(new Function &lt; Observable &lt; Throwable &gt; , ObservableSource &lt;? &gt;&gt; () {
    @Override
    public ObservableSource &lt;? &gt; apply(Observable &lt; Throwable &gt; throwableObservable) throws Exception {
        return throwableObservable.flatMap(new Function &lt; Throwable, ObservableSource &lt;? &gt;&gt; () {
            @Override
            public ObservableSource &lt;? &gt; apply(Throwable throwable) throws Exception {
                if(!throwable.toString().equals(&quot;java.lang.Exception: 404&quot;)) {
                    return Observable.just(&quot;可以忽略的异常&quot;);
                } else {
                    return Observable.error(new Throwable(&quot;终止啦&quot;));
                }
            }
        });
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;==================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot; + e.toString());
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext chan
==================onNext ze
==================onNext de
==================onError java.lang.Throwable: 终止啦

将 onError(new Exception(&quot;404&quot;)) 改为 onError(new Exception(&quot;303&quot;)) 看看打印结果：
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
==================onNext ze
==================onNext de
==================onNext chan
......
从结果可以看出，会不断重复发送消息。
</code></pre><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>重复发送被观察者的事件，times 为发送次数。</p>
<pre><code>public final Observable&lt;T&gt; repeat(long times)
</code></pre><h3 id="repeatWhen"><a href="#repeatWhen" class="headerlink" title="repeatWhen()"></a>repeatWhen()</h3><p>这个方法可以会返回一个新的被观察者设定一定逻辑来决定是否重复发送事件。</p>
<pre><code>public final Observable&lt;T&gt; repeatWhen(final Function&lt;? super Observable&lt;Object&gt;, ? extends ObservableSource&lt;?&gt;&gt; handler)
</code></pre><p>repeatWhen可以实现重订阅功能，而触发重订阅两个关键因素:<br>1.Obervable完成一次订阅，就是Observable调用onComplete<br>2.当Observable调用onComplete就会进入到repeatWhen方法里面，是否要触发重订阅，就需要通过repeatWhen的Function方法所返回的ObservableSource确定，如果返回的是onNext则触发重订阅，而返回的是onComplete/onError则不会触发重订阅</p>
<pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {
            @Override
            public void subscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {
                emitter.onComplete();
            }
        }).doOnComplete(new Action() {
            @Override
            public void run() throws Exception {
                Log.d(TAG, &quot;触发重订阅&quot;);
            }
        }).repeatWhen(new Function&lt;Observable&lt;Object&gt;, ObservableSource&lt;?&gt;&gt;() {

            private int n = 0;

            @Override
            public ObservableSource&lt;?&gt; apply(Observable&lt;Object&gt; objectObservable) throws Exception {
                return objectObservable.flatMap(new Function&lt;Object, ObservableSource&lt;?&gt;&gt;() {
                    @Override
                    public ObservableSource&lt;?&gt; apply(Object o) throws Exception {
                        if (n != 3) {
                            n++;
                            return Observable.timer(3, TimeUnit.SECONDS);
                        } else {
                            return Observable.empty();
                        }
                    }
                });
            }
        }).subscribe(new Observer&lt;String&gt;() {
            @Override
            public void onSubscribe(Disposable d) {

            }

            @Override
            public void onNext(String s) {
                Log.d(TAG, &quot;onNext: &quot; + s);
            }

            @Override
            public void onError(Throwable e) {
                Log.d(TAG, &quot;onError: &quot; + e);
            }

            @Override
            public void onComplete() {
                Log.d(TAG, &quot;onComplete: &quot;);
            }
        });

运行结果:
08-02 10:26:13.187 D/MainActivity-vv: 触发重订阅
08-02 10:26:16.196 D/MainActivity-vv: 触发重订阅
08-02 10:26:19.204 D/MainActivity-vv: 触发重订阅
08-02 10:26:22.206 D/MainActivity-vv: 触发重订阅
</code></pre><p>repeatWhen可以用于延时轮询，在doOnComplete进行操作</p>
<h2 id="5、组合操作符"><a href="#5、组合操作符" class="headerlink" title="5、组合操作符"></a>5、组合操作符</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>可以将多个观察者组合在一起，然后按照之前发送顺序发送事件。需要注意的是，concat() 最多只可以发送4个事件。</p>
<pre><code>public static &lt;T&gt; Observable&lt;T&gt; concat(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)
</code></pre><p>示例如下：</p>
<pre><code>Observable.concat(Observable.just(1, 2),
Observable.just(3, 4),
Observable.just(5, 6),
Observable.just(7, 8))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
打印如下：
================onNext 1
================onNext 2
================onNext 3
================onNext 4
================onNext 5
================onNext 6
================onNext 7
================onNext 8
</code></pre><h3 id="concatArray"><a href="#concatArray" class="headerlink" title="concatArray()"></a>concatArray()</h3><p>与 concat()  作用一样，不过 concatArray() 可以发送多于 4 个被观察者。</p>
<pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArray(ObservableSource&lt;? extends T&gt;... sources)
</code></pre><h3 id="merge-amp-mergeArray"><a href="#merge-amp-mergeArray" class="headerlink" title="merge() &amp; mergeArray()"></a>merge() &amp; mergeArray()</h3><p>这个方法与 concat() 作用基本一样，只是 concat() 是串行发送事件，而<strong> merge() 并行发送事件</strong>。</p>
<pre><code>public static &lt;T&gt; Observable&lt;T&gt; merge(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2, ObservableSource&lt;? extends T&gt; source3, ObservableSource&lt;? extends T&gt; source4)
</code></pre><p>现在来演示 concat() 和 merge() 的区别:</p>
<pre><code>Observable.merge(
Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {
    @Override
    public String apply(Long aLong) throws Exception {
        return &quot;A&quot; + aLong;
    }
}),
Observable.interval(1, TimeUnit.SECONDS).map(new Function &lt; Long, String &gt; () {
    @Override
    public String apply(Long aLong) throws Exception {
        return &quot;B&quot; + aLong;
    }
}))
    .subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;=====================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {

    }

    @Override
    public void onComplete() {

    }
});
打印结果如下：
05-21 16:10:31.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B0
05-21 16:10:31.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A0
05-21 16:10:32.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A1
05-21 16:10:32.126 12801-12850/com.example.rxjavademo D/chan: =====================onNext B1
05-21 16:10:33.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A2
05-21 16:10:33.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B2
05-21 16:10:34.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A3
05-21 16:10:34.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B3
05-21 16:10:35.124 12801-12849/com.example.rxjavademo D/chan: =====================onNext A4
05-21 16:10:35.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B4
05-21 16:10:36.125 12801-12849/com.example.rxjavademo D/chan: =====================onNext A5
05-21 16:10:36.125 12801-12850/com.example.rxjavademo D/chan: =====================onNext B5
......
从结果可以看出，A 和 B 的事件序列都可以发出，将以上的代码换成 concat() 看看打印结果：
05-21 16:17:52.352 14597-14621/com.example.rxjavademo D/chan: =====================onNext A0
05-21 16:17:53.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A1
05-21 16:17:54.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A2
05-21 16:17:55.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A3
05-21 16:17:56.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A4
05-21 16:17:57.351 14597-14621/com.example.rxjavademo D/chan: =====================onNext A5
......
从结果可以知道，只有等到第一个被观察者发送完事件之后，第二个被观察者才会发送事件。
</code></pre><p>mergeArray() 与 merge() 的作用是一样的，只是它可以发送4个以上的被观察者。</p>
<h3 id="concatArrayDelayError-amp-mergeArrayDelayError"><a href="#concatArrayDelayError-amp-mergeArrayDelayError" class="headerlink" title="concatArrayDelayError() &amp; mergeArrayDelayError()"></a>concatArrayDelayError() &amp; mergeArrayDelayError()</h3><p>在 concatArray() 和 mergeArray() 两个方法当中，如果其中有一个被观察者发送了一个 Error 事件，那么就会停止发送事件，如果你想 <strong>onError() 事件延迟到所有被观察者都发送完事件后再执行</strong>的话，就可以使用  concatArrayDelayError() 和 mergeArrayDelayError()</p>
<pre><code>public static &lt;T&gt; Observable&lt;T&gt; concatArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)
public static &lt;T&gt; Observable&lt;T&gt; mergeArrayDelayError(ObservableSource&lt;? extends T&gt;... sources)
</code></pre><p>示例如下：</p>
<pre><code>Observable.concatArrayDelayError(
Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {
    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onNext(1);
        e.onError(new NumberFormatException());
    }
}), Observable.just(2, 3, 4))
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {

    }

    @Override
    public void onNext(Integer integer) {
        Log.d(TAG, &quot;===================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {

    }
});
打印结果如下：
===================onNext 1
===================onNext 2
===================onNext 3
===================onNext 4
===================onError 
</code></pre><p>从结果可以看到，onError 事件是在所有被观察者发送完事件才发送的。mergeArrayDelayError() 也是有同样的作用。</p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h3><p>会将多个被观察者合并，根据各个被观察者发送事件的顺序一个个结合起来，最终发送的事件数量会与源 Observable 中最少事件的数量一样。</p>
<pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; zip(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; zipper)
</code></pre><p>示例如下：</p>
<pre><code>Observable.zip(Observable.intervalRange(1, 5, 1, 1, TimeUnit.SECONDS)
    .map(new Function&lt;Long, String&gt;() {
        @Override
        public String apply(Long aLong) throws Exception {
            String s1 = &quot;A&quot; + aLong;
            Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);
            return s1;
        }}),
        Observable.intervalRange(1, 6, 1, 1, TimeUnit.SECONDS)
            .map(new Function&lt;Long, String&gt;() {
            @Override
            public String apply(Long aLong) throws Exception {
                String s2 = &quot;B&quot; + aLong;
                Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);
                return s2;
            }
        }),
        new BiFunction&lt;String, String, String&gt;() {
            @Override
            public String apply(String s, String s2) throws Exception {
                String res = s + s2;
                return res;
            }
        })
.subscribe(new Observer&lt;String&gt;() {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;===================onNext &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
上面代码中有两个 Observable，第一个发送事件的数量为5个，第二个发送事件的数量为6个。现在来看下打印结果：
05-22 09:10:39.952 5338-5338/com.example.rxjavademo D/chan: ===================onSubscribe 
05-22 09:10:40.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A1
05-22 09:10:40.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B1
===================onNext A1B1
05-22 09:10:41.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A2
05-22 09:10:41.954 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B2
===================onNext A2B2
05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A3
05-22 09:10:42.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B3
05-22 09:10:42.953 5338-5362/com.example.rxjavademo D/chan: ===================onNext A3B3
05-22 09:10:43.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A4
05-22 09:10:43.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B4
05-22 09:10:43.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A4B4
05-22 09:10:44.953 5338-5362/com.example.rxjavademo D/chan: ===================A 发送的事件 A5
05-22 09:10:44.953 5338-5363/com.example.rxjavademo D/chan: ===================B 发送的事件 B5
05-22 09:10:44.954 5338-5363/com.example.rxjavademo D/chan: ===================onNext A5B5
===================onComplete 
</code></pre><p>可以发现最终接收到的事件数量是5，那么为什么第二个 Observable 没有发送第6个事件呢？因为在这之前第一个 Observable 已经发送了 onComplete 事件，所以第二个 Observable 不会再发送事件。</p>
<h3 id="combineLatest-amp-combineLatestDelayError"><a href="#combineLatest-amp-combineLatestDelayError" class="headerlink" title="combineLatest() &amp;  combineLatestDelayError()"></a>combineLatest() &amp;  combineLatestDelayError()</h3><pre><code>public static &lt;T1, T2, R&gt; Observable&lt;R&gt; combineLatest(ObservableSource&lt;? extends T1&gt; source1, ObservableSource&lt;? extends T2&gt; source2, BiFunction&lt;? super T1, ? super T2, ? extends R&gt; combiner)
</code></pre><p>combineLatest() 的作用与 zip() 类似，但是 combineLatest() 发送事件的序列是与发送的时间线有关的，当 combineLatest() 中所有的 Observable 都发送了事件，<strong>只要其中有一个 Observable 发送事件，这个事件就会和其他 Observable 最近发送的事件结合起来发送</strong>，这样可能还是比较抽象，看看以下例子代码：</p>
<pre><code>Observable.combineLatest(
Observable.intervalRange(1, 4, 1, 1, TimeUnit.SECONDS)
    .map(new Function &lt; Long, String &gt; () {@Override
    public String apply(Long aLong) throws Exception {
        String s1 = &quot;A&quot; + aLong;
        Log.d(TAG, &quot;===================A 发送的事件 &quot; + s1);
        return s1;
    }
}),
Observable.intervalRange(1, 5, 2, 2, TimeUnit.SECONDS)
    .map(new Function &lt; Long, String &gt; () {@Override
    public String apply(Long aLong) throws Exception {
        String s2 = &quot;B&quot; + aLong;
        Log.d(TAG, &quot;===================B 发送的事件 &quot; + s2);
        return s2;
    }
}),
new BiFunction &lt; String, String, String &gt; () {@Override
    public String apply(String s, String s2) throws Exception {
        String res = s + s2;
        return res;
    }
})
.subscribe(new Observer &lt; String &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;===================onSubscribe &quot;);
    }

    @Override
    public void onNext(String s) {
        Log.d(TAG, &quot;===================最终接收到的事件 &quot; + s);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;===================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;===================onComplete &quot;);
    }
});
分析上面的代码，Observable A 会每隔1秒就发送一次事件，Observable B 会隔2秒发送一次事件。来看看打印结果：
05-22 11:41:20.859 15104-15104/? D/chan: ===================onSubscribe 
05-22 11:41:21.859 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A1
05-22 11:41:22.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A2
05-22 11:41:22.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B1
05-22 11:41:22.862 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A2B1
05-22 11:41:23.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A3
===================最终接收到的事件 A3B1
05-22 11:41:24.860 15104-15128/com.example.rxjavademo D/chan: ===================A 发送的事件 A4
05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B2
05-22 11:41:24.861 15104-15128/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B1
05-22 11:41:24.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B2
05-22 11:41:26.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B3
05-22 11:41:26.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B3
05-22 11:41:28.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B4
05-22 11:41:28.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B4
05-22 11:41:30.860 15104-15129/com.example.rxjavademo D/chan: ===================B 发送的事件 B5
05-22 11:41:30.861 15104-15129/com.example.rxjavademo D/chan: ===================最终接收到的事件 A4B5
===================onComplete 
</code></pre><p>分析上述结果可以知道，当发送 A1 事件之后，因为 B 并没有发送任何事件，所以根本不会发生结合。当 B 发送了 B1 事件之后，就会与 A 最近发送的事件 A2 结合成 A2B1，这样只有后面一有被观察者发送事件，这个事件就会与其他被观察者最近发送的事件结合起来了。</p>
<p>因为 combineLatestDelayError() 就是多了延迟发送 onError() 功能，这里就不再赘述了。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>与 scan() 操作符的作用也是将发送数据以一定逻辑聚合起来，这两个的区别在于 <strong>scan() 每处理一次数据就会将事件发送给观察者，而 reduce() 会将所有数据聚合在一起才会发送事件给观察者。</strong></p>
<pre><code>public final Maybe&lt;T&gt; reduce(BiFunction&lt;T, T, T&gt; reducer)
</code></pre><p>示例如下：<br>    Observable.just(0, 1, 2, 3)<br>    .reduce(new BiFunction &lt; Integer, Integer, Integer &gt; () {<br>        @Override<br>        public Integer apply(Integer integer, Integer integer2) throws Exception {<br>            int res = integer + integer2;<br>            Log.d(TAG, “====================integer “ + integer);<br>            Log.d(TAG, “====================integer2 “ + integer2);<br>            Log.d(TAG, “====================res “ + res);<br>            return res;<br>        }<br>    })<br>    .subscribe(new Consumer &lt; Integer &gt; () {<br>        @Override<br>        public void accept(Integer integer) throws Exception {<br>            Log.d(TAG, “==================accept “ + integer);<br>        }<br>    });<br>    打印结果：<br>    ====================integer 0<br>    ====================integer2 1<br>    ====================res 1<br>    ====================integer 1<br>    ====================integer2 2<br>    ====================res 3<br>    ====================integer 3<br>    ====================integer2 3<br>    ====================res 6<br>    ==================accept 6<br>从结果可以看到，其实就是前2个数据聚合之后，然后再与后1个数据进行聚合，一直到没有数据为止。</p>
<h3 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h3><p>将数据收集到数据结构当中。</p>
<pre><code>public final &lt;U&gt; Single&lt;U&gt; collect(Callable&lt;? extends U&gt; initialValueSupplier, BiConsumer&lt;? super U, ? super T&gt; collector)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.collect(new Callable &lt; ArrayList &lt; Integer &gt;&gt; () {
    @Override
    public ArrayList &lt; Integer &gt; call() throws Exception {
        return new ArrayList &lt; &gt; ();
    }
},
new BiConsumer &lt; ArrayList &lt; Integer &gt; , Integer &gt; () {
    @Override
    public void accept(ArrayList &lt; Integer &gt; integers, Integer integer) throws Exception {
        integers.add(integer);
    }
})
.subscribe(new Consumer &lt; ArrayList &lt; Integer &gt;&gt; () {
    @Override
    public void accept(ArrayList &lt; Integer &gt; integers) throws Exception {
        Log.d(TAG, &quot;===============accept &quot; + integers);
    }
});
打印结果：
===============accept [1, 2, 3, 4]
</code></pre><h3 id="startWith-amp-startWithArray"><a href="#startWith-amp-startWithArray" class="headerlink" title="startWith() &amp; startWithArray()"></a>startWith() &amp; startWithArray()</h3><p>在发送事件之前追加事件，startWith() 追加一个事件，startWithArray() 可以追加多个事件。追加的事件会先发出。</p>
<pre><code>public final Observable&lt;T&gt; startWith(T item)
public final Observable&lt;T&gt; startWithArray(T... items)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(5, 6, 7)
.startWithArray(2, 3, 4)
.startWith(1)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;================accept &quot; + integer);
    }
});
打印结果：
================accept 1
================accept 2
================accept 3
================accept 4
================accept 5
================accept 6
================accept 7
</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h3><p>返回被观察者发送事件的数量。</p>
<pre><code>public final Single&lt;Long&gt; count()
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3)
.count()
.subscribe(new Consumer &lt; Long &gt; () {
    @Override
    public void accept(Long aLong) throws Exception {
        Log.d(TAG, &quot;=======================aLong &quot; + aLong);
    }
});
打印结果：
=======================aLong 3
</code></pre><h2 id="6、过滤操作符"><a href="#6、过滤操作符" class="headerlink" title="6、过滤操作符"></a>6、过滤操作符</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>通过一定逻辑来过滤被观察者发送的事件，如果返回 true 则会发送事件，否则不会发送。<br>    public final Observable<t> filter(Predicate&lt;? super T&gt; predicate)</t></p>
<p>示例如下：</p>
<pre><code> Observable.just(1, 2, 3)
    .filter(new Predicate &lt; Integer &gt; () {
        @Override
        public boolean test(Integer integer) throws Exception {
            return integer &lt; 2;
        }
})
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
以上代码只有小于2的事件才会发送，来看看打印结果：
==================onSubscribe 
==================onNext 1
==================onComplete 
</code></pre><h3 id="ofType"><a href="#ofType" class="headerlink" title="ofType()"></a>ofType()</h3><p>过滤不符合该类型事件</p>
<pre><code>public final &lt;U&gt; Observable&lt;U&gt; ofType(final Class&lt;U&gt; clazz)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, &quot;chan&quot;, &quot;zhide&quot;)
.ofType(Integer.class)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre><h3 id="skip-amp-skipLast"><a href="#skip-amp-skipLast" class="headerlink" title="skip() &amp; skipLast()"></a>skip() &amp; skipLast()</h3><p>跳过正序某些事件，count 代表跳过事件的数量</p>
<pre><code>public final Observable&lt;T&gt; skip(long count)
</code></pre><p>skipLast() 作用也是跳过某些事件，不过它是用来跳过正序的后面的事件。</p>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p>过滤事件序列中的重复事件。</p>
<pre><code>public final Observable&lt;T&gt; distinct() 
</code></pre><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged()"></a>distinctUntilChanged()</h3><p>过滤掉连续重复的事件</p>
<pre><code>public final Observable&lt;T&gt; distinctUntilChanged()
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 3, 2, 1)
.distinctUntilChanged()
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果:
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onNext 2
==================onNext 1
==================onComplete 
</code></pre><p>因为事件序列中连续出现两次3，所以第二次3并不会发出。</p>
<h3 id="take-amp-takeLast"><a href="#take-amp-takeLast" class="headerlink" title="take() &amp; takeLast()"></a>take() &amp; takeLast()</h3><p>控制观察者接收的事件的数量。</p>
<pre><code>public final Observable&lt;T&gt; take(long count)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5)
.take(3)
.subscribe(new Observer &lt; Integer &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;==================onSubscribe &quot;);
    }

    @Override
    public void onNext(Integer integer) {
        i += integer;
        Log.d(TAG, &quot;==================onNext &quot; + integer);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;==================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;==================onComplete &quot;);
    }
});
打印结果：
==================onSubscribe 
==================onNext 1
==================onNext 2
==================onNext 3
==================onComplete 
</code></pre><p>takeLast() 的作用就是控制观察者只能接受事件序列的后面几件事情。</p>
<h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce()"></a>debounce()</h3><p>如果两件事件发送的时间间隔小于设定的时间间隔则前一件事件就不会发送给观察者。</p>
<pre><code>public final Observable&lt;T&gt; debounce(long timeout, TimeUnit unit)
</code></pre><p>throttleWithTimeout() 与此方法的作用一样。</p>
<h3 id="firstElement-amp-amp-lastElement"><a href="#firstElement-amp-amp-lastElement" class="headerlink" title="firstElement() &amp;&amp; lastElement()"></a>firstElement() &amp;&amp; lastElement()</h3><p>firstElement() 取事件序列的第一个元素，lastElement() 取事件序列的最后一个元素。</p>
<pre><code>public final Maybe&lt;T&gt; firstElement()
public final Maybe&lt;T&gt; lastElement()
</code></pre><h3 id="elementAt-amp-elementAtOrError"><a href="#elementAt-amp-elementAtOrError" class="headerlink" title="elementAt() &amp; elementAtOrError()"></a>elementAt() &amp; elementAtOrError()</h3><p>elementAt() 可以指定取出事件序列中事件，但是输入的 index 超出事件序列的总数的话就不会出现任何结果。这种情况下，你想发出异常信息的话就用 elementAtOrError() 。</p>
<pre><code>public final Maybe&lt;T&gt; elementAt(long index)
public final Single&lt;T&gt; elementAtOrError(long index)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.elementAt(0)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
打印结果：
====================accept 1
</code></pre><p>将 elementAt() 的值改为5，这时是没有打印结果的，因为没有满足条件的元素。<br>替换 elementAt() 为 elementAtOrError()，代码如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.elementAtOrError(5)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;====================accept &quot; + integer);
    }
});
</code></pre><p>这时候会抛出 NoSuchElementException 异常。</p>
<h2 id="7、条件操作符"><a href="#7、条件操作符" class="headerlink" title="7、条件操作符"></a>7、条件操作符</h2><h3 id="all"><a href="#all" class="headerlink" title="all()"></a>all()</h3><p>判断事件序列是否全部满足某个事件，如果都满足则返回 true，反之则返回 false。</p>
<pre><code>public final Single&lt;Boolean&gt; all(Predicate&lt;? super T&gt; predicate)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.all(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 5;
    }
})
.subscribe(new Consumer &lt; Boolean &gt; () {
    @Override
    public void accept(Boolean aBoolean) throws Exception {
        Log.d(TAG, &quot;==================aBoolean &quot; + aBoolean);
    }
});
打印结果：
==================aBoolean true
</code></pre><h3 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile()"></a>takeWhile()</h3><p>可以设置条件，当某个数据满足条件时就会发送该数据，反之则不发送</p>
<pre><code>public final Observable&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4)
.takeWhile(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &lt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
打印结果：
========================integer 1
========================integer 2
</code></pre><h3 id="skipWhile"><a href="#skipWhile" class="headerlink" title="skipWhile()"></a>skipWhile()</h3><p>可以设置条件，当某个数据满足条件时不发送该数据，反之则发送。</p>
<pre><code>public final Observable&lt;T&gt; skipWhile(Predicate&lt;? super T&gt; predicate)
</code></pre><h3 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil()"></a>takeUntil()</h3><p>可以设置条件，当事件满足此条件时，下一次的事件就不会被发送了。</p>
<pre><code>public final Observable&lt;T&gt; takeUntil(Predicate&lt;? super T&gt; stopPredicate
</code></pre><p>示例如下：</p>
<pre><code>Observable.just(1, 2, 3, 4, 5, 6)
.takeUntil(new Predicate &lt; Integer &gt; () {
    @Override
    public boolean test(Integer integer) throws Exception {
        return integer &gt; 3;
    }
})
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================integer &quot; + integer);
    }
});
打印结果：
========================integer 1
========================integer 2
========================integer 3
========================integer 4
</code></pre><h3 id="skipUntil"><a href="#skipUntil" class="headerlink" title="skipUntil()"></a>skipUntil()</h3><p>当 <strong>skipUntil() 中的 Observable 发送事件了，原来的 Observable 才会发送事件给观察者。skipUntil() 里的 Observable 并不会发送事件给观察者。</strong></p>
<pre><code>public final &lt;U&gt; Observable&lt;T&gt; skipUntil(ObservableSource&lt;U&gt; other)
</code></pre><p>示例如下：</p>
<pre><code>Observable.intervalRange(1, 5, 0, 1, TimeUnit.SECONDS)
.skipUntil(Observable.intervalRange(6, 5, 3, 1, TimeUnit.SECONDS))
.subscribe(new Observer &lt; Long &gt; () {
    @Override
    public void onSubscribe(Disposable d) {
        Log.d(TAG, &quot;========================onSubscribe &quot;);
    }

    @Override
    public void onNext(Long along) {
        Log.d(TAG, &quot;========================onNext &quot; + along);
    }

    @Override
    public void onError(Throwable e) {
        Log.d(TAG, &quot;========================onError &quot;);
    }

    @Override
    public void onComplete() {
        Log.d(TAG, &quot;========================onComplete &quot;);
    }
});
打印结果：
05-26 10:08:50.574 13023-13023/com.example.rxjavademo D/chan: ========================onSubscribe 
05-26 10:08:53.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 4
05-26 10:08:54.576 13023-13054/com.example.rxjavademo D/chan: ========================onNext 5
========================onComplete 
</code></pre><h3 id="sequenceEqual"><a href="#sequenceEqual" class="headerlink" title="sequenceEqual()"></a>sequenceEqual()</h3><p>判断两个  Observable 发送的事件是否相同。</p>
<pre><code>public static &lt;T&gt; Single&lt;Boolean&gt; sequenceEqual(ObservableSource&lt;? extends T&gt; source1, ObservableSource&lt;? extends T&gt; source2)
</code></pre><h3 id="contains"><a href="#contains" class="headerlink" title="contains()"></a>contains()</h3><p>判断事件序列中是否含有某个元素，如果有则返回 true，如果没有则返回 false。</p>
<pre><code>public final Single&lt;Boolean&gt; contains(final Object element)
</code></pre><h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h3><p>判断事件序列是否为空。</p>
<pre><code>public final Single&lt;Boolean&gt; isEmpty()
</code></pre><h3 id="defaultIfEmpty"><a href="#defaultIfEmpty" class="headerlink" title="defaultIfEmpty()"></a>defaultIfEmpty()</h3><p>如果观察者只发送一个 onComplete() 事件，这个方法会发送一个值。</p>
<pre><code>public final Observable&lt;T&gt; defaultIfEmpty(T defaultItem)
</code></pre><p>示例如下：</p>
<pre><code>Observable.create(new ObservableOnSubscribe &lt; Integer &gt; () {

    @Override
    public void subscribe(ObservableEmitter &lt; Integer &gt; e) throws Exception {
        e.onComplete();
    }
})
.defaultIfEmpty(666)
.subscribe(new Consumer &lt; Integer &gt; () {
    @Override
    public void accept(Integer integer) throws Exception {
        Log.d(TAG, &quot;========================onNext &quot; + integer);
    }
});
打印结果：
========================onNext 666
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/post/5b17560e6fb9a01e2862246f" target="_blank" rel="noopener">https://juejin.im/post/5b17560e6fb9a01e2862246f</a><br><a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">https://gank.io/post/560e15be2dca930e00da1083</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/28/flutter-integration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/28/flutter-integration/" itemprop="url">Flutter集成Android项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-28T16:31:43+08:00">
                2019-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hybrid-Develop/" itemprop="url" rel="index">
                    <span itemprop="name">Hybrid Develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在现有项目上集成Flutter"><a href="#在现有项目上集成Flutter" class="headerlink" title="在现有项目上集成Flutter"></a>在现有项目上集成Flutter</h2><p>1.在andorid工程目录上级目录下执行命令:</p>
<pre><code>flutter create -t module xxxx(想要创建的flutter项目名)
</code></pre><p>执行完后，一个和Android项目平级的flutter项目就已经创建好了。</p>
<p>2.添加flutter到当前Android项目：<br>在Android项目根目录下的settings.gradle文件中，添加如下代码：</p>
<pre><code>setBinding(new Binding([gradle: this]))
evaluate(new File(
        settingsDir.parentFile,
        &quot;flutter_hybrid/.android/include_flutter.groovy&quot;
))
</code></pre><p>然后，在项目的app目录下，build.gradle文件中，添加如下dependency:</p>
<pre><code>implementation project(&apos;:flutter&apos;)
</code></pre><p>如上，添加完之后，准备工作就完成了。</p>
<h2 id="集成Flutter页面跳转"><a href="#集成Flutter页面跳转" class="headerlink" title="集成Flutter页面跳转"></a>集成Flutter页面跳转</h2><h3 id="通过继承FlutterActivity跳到默认页面"><a href="#通过继承FlutterActivity跳到默认页面" class="headerlink" title="通过继承FlutterActivity跳到默认页面"></a>通过继承FlutterActivity跳到默认页面</h3><p>1.Application：初始化Flutter</p>
<pre><code>public class App extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
        FlutterMain.startInitialization(this);
    }
}
</code></pre><p>2.Activity：继承FlutterActivity</p>
<pre><code>/**
 * debug模式原生跳转到flutter界面会出现白屏，release包就不会出现白屏了
 */
public class MainFlutterActivity extends FlutterActivity {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    GeneratedPluginRegistrant.registerWith(this);
  }
</code></pre><p>这样以后，我们就可以跳转这个MainFlutterActivity，实现在Android工程里面进入Flutter工程的默认页面了。</p>
<h3 id="通过FlutterView跳到指定页面"><a href="#通过FlutterView跳到指定页面" class="headerlink" title="通过FlutterView跳到指定页面"></a>通过FlutterView跳到指定页面</h3><p>首先通过Flutter.createFlutterView方法来创建一个FlutterView类型的View。它有三个构造参数：</p>
<pre><code>public static FlutterView createView(Activity activity, Lifecycle lifecycle, String initialRoute)
</code></pre><p>三个参数分别是：<br>1.Activity，即当前附着的Activity</p>
<p>2.LifeCycle，且是不能为空(NonNull)的，这也就要求我们必须用AppCompatActivity来承载FlutterView了，如果我们的Activity继承自android.app.Activity是没有getLifeCycle()这个方法的。</p>
<pre><code>public class FlutterViewActivity extends AppCompatActivity 复制代码
</code></pre><p>3.initialRoute这是一个String类型的变量，根据不同的标识跳转不同的Flutter页面：</p>
<pre><code>Widget _widgetForRoute(String route) {
  switch (route) {
    case &apos;route1&apos;:
      return  MyHomePage(title: &apos;Flutter Demo Home Page1&apos;);
    case &apos;route2&apos;:
      return  MyHomePage(title: &apos;Flutter Demo Home Page2&apos;);
    default:
        return  MyHomePage(title: &apos;Flutter Demo Home Page2&apos;);
  }
}
</code></pre><p>然后在当前Activity的OnCreate方法中，执行：</p>
<pre><code>FlutterView flutterView = Flutter.createView(this, getLifecycle(), &quot;route1&quot;);    
setContentView(flutterView);

//或者：

setContentView(R.layout.activity_flutter);
rlContainer = findViewById(R.id.rl_container);
rlContainer.addView(flutterView)
</code></pre><h2 id="集成到现有项目遇到的坑"><a href="#集成到现有项目遇到的坑" class="headerlink" title="集成到现有项目遇到的坑"></a>集成到现有项目遇到的坑</h2><p>Check failed: vm. Must be able to initialize the VM：</p>
<pre><code>E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.
    [ERROR:flutter/runtime/dart_vm.cc(241)] Could not setup VM data to bootstrap the VM from.
    [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance.
 A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.

SIGABRT
    0x146b
    #00    pc 0002210c    /system/lib/libc.so (tgkill+12) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #01    pc 00013165    /system/lib/libc.so (pthread_kill+48) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #02    pc 00013379    /system/lib/libc.so (raise+10) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #03    pc 000120a3    /system/lib/libc.so [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #04    pc 000219c0    /system/lib/libc.so (abort+4) [armeabi-v7a::ac712d92afdda143205c7d7c8befc336]
    #05    pc 00af85ab    /data/app-lib/xxx.debug-1/libflutter.so [armeabi-v7a::a12434e0b53806a35730000001000000]
</code></pre><p>经github上<a href="https://github.com/flutter/flutter/issues/24679" target="_blank" rel="noopener">#24679</a>及其他issue参考，得出以下解决方案：</p>
<blockquote>
<p>Import flutter module to your HOST app(set binding, implementation, and instantiate view/fragment)<br>When you clean/rebuild from HOST app, flutter module does not generate properly<br>You need to open your flutter module in a separate AS<br>flutter clean<br>cd .android<br>./gradlew clean<br>./gradlew assembleDebug<br>Return to host app and run app(do not sync or rebuild) :)</p>
</blockquote>
<p>翻译过来就是：</p>
<blockquote>
<p>本项目执行清理命令。./gradlew clean<br>进入 flutter module 项目执行清理命令。flutter packages get;flutter clean<br>进入 flutter module 的 .android 项目执行清理命令和打包操作。./gradlew clean;./gradlew assemble<br>回到本项目执行打包命令。./gradlew assemble</p>
</blockquote>
<p>直接执行下面命令即可：</p>
<pre><code>$ ./gradlew clean;cd ../flutter_module;flutter packages get;flutter clean;cd .android/;./gradlew clean;./gradlew assemble;cd /d/workspace/app_proj/;./gradlew installDebug
</code></pre><p>后续假设你 flutter module 没有更新过，那么以后修改本地项目之后，就直接执行./gradlew installDebug。 注意不要用studio工具运行、rebuild或clean。</p>
<h3 id="flutter-assets"><a href="#flutter-assets" class="headerlink" title="flutter_assets"></a>flutter_assets</h3><p>assets下缺少flutter_assets也有可能造成此问题。具体可以参考：<a href="https://www.jianshu.com/p/2d0bba84e57e" target="_blank" rel="noopener">https://www.jianshu.com/p/2d0bba84e57e</a></p>
<h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><p>按照上述方式，debug版本没问题，release却报错。需加以下混淆：</p>
<pre><code>-keep class io.flutter.app.** { *; }
-keep class io.flutter.plugin.** { *; }
-keep class io.flutter.util.** { *; }
-keep class io.flutter.view.** { *; }
-keep class io.flutter.** { *; }
-keep class io.flutter.plugins.** { *; }
-keep class myapp.flutter.** { *; }
</code></pre><h2 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h2><h3 id="Flutter-调用Android"><a href="#Flutter-调用Android" class="headerlink" title="Flutter 调用Android"></a>Flutter 调用Android</h3><p>java</p>
<pre><code>new MethodChannel(flutterView, FlutterToAndroidCHANNEL).setMethodCallHandler(new MethodChannel.MethodCallHandler() {
    @Override
    public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) {

        //接收来自flutter的指令withoutParams
        if (methodCall.method.equals(&quot;withoutParams&quot;)) {

            //跳转到指定Activity
            Intent intent = new Intent(NativeActivity.this, NativeActivity.class);
            startActivity(intent);

            //返回给flutter的参数
            result.success(&quot;success&quot;);
        }
        //接收来自flutter的指令withParams
        else if (methodCall.method.equals(&quot;withParams&quot;)) {

            //解析参数
            String text = methodCall.argument(&quot;flutter&quot;);

            //带参数跳转到指定Activity
            Intent intent = new Intent(NativeActivity.this, NativeActivity.class);
            intent.putExtra(&quot;test&quot;, text);
            startActivity(intent);

            //返回给flutter的参数
            result.success(&quot;success&quot;);
        } else {
            result.notImplemented();
        }
    }
});
</code></pre><p>dart</p>
<pre><code>Future&lt;Null&gt; _jumpToNative() async {
  String result = await toAndroidPlugin.invokeMethod(&apos;withoutParams&apos;);

  print(result);
}


Future&lt;Null&gt; _jumpToNativeWithParams() async {

  Map&lt;String, String&gt; map = { &quot;flutter&quot;: &quot;这是一条来自flutter的参数&quot; };

  String result = await toAndroidPlugin.invokeMethod(&apos;withParams&apos;, map);

  print(result);
}
</code></pre><h3 id="Android-向-Flutter-传参"><a href="#Android-向-Flutter-传参" class="headerlink" title="Android 向 Flutter 传参"></a>Android 向 Flutter 传参</h3><p>java</p>
<pre><code>new EventChannel(flutterView, AndroidToFlutterCHANNEL)
            .setStreamHandler(new EventChannel.StreamHandler() {
                @Override
                public void onListen(Object o, EventChannel.EventSink eventSink) {
                    String androidParmas = &quot;来自android原生的参数&quot;;
                    eventSink.success(androidParmas);
                }

                @Override
                public void onCancel(Object o) {

                }
            });
</code></pre><p>dart</p>
<pre><code> void _startfromAndroiPlugin(){
   if(_fromAndroiSub == null){
     _fromAndroiSub =  fromAndroiPlugin.receiveBroadcastStream()
     .listen(_onfromAndroiEvent,onError: _onfromAndroiError);
   }
 }

void _onfromAndroiEvent(Object event) {
   setState(() {
     _nativeParams = event;
   });
 }

 void _onfromAndroiError(Object error) {
   setState(() {
     _nativeParams = &quot;error&quot;;
     print(error);
   });
 }
</code></pre><p>有几处 要注意一一对应：</p>
<pre><code>public static final String FlutterToAndroidCHANNEL = &quot;com.litngzhe.toandroid/plugin&quot;; 
public static final String AndroidToFlutterCHANNEL= &quot;com.litngzhe.toflutter/plugin&quot;;

new MethodChannel(flutterView, FlutterToAndroidCHANNEL)
new EventChannel(flutterView, AndroidToFlutterCHANNEL) 


//dart中 获取到插件与原生的交互通道 MethodChannel 中 涉及到的方法名要要统一
static const toAndroidPlugin = const MethodChannel(&apos;com.litngzhe.toandroid/plugin&apos;);
static const fromAndroiPlugin = const EventChannel(&apos;com.litngzhe.toflutter/plugin&apos;); 
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/chinaltz/FlutterDemo" target="_blank" rel="noopener">FlutterDemo</a><br><a href="https://juejin.im/post/5c74dbeee51d45708f2a20c6" target="_blank" rel="noopener">https://juejin.im/post/5c74dbeee51d45708f2a20c6</a><br><a href="https://github.com/flutter/flutter/issues/24679" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/24679</a><br><a href="https://github.com/flutter/flutter/issues/25147" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/25147</a><br><a href="https://mp.weixin.qq.com/s/OGbH3G3wHVTUt-0EJit8RA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OGbH3G3wHVTUt-0EJit8RA</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/25/dart-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shuming Zhao">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/25/dart-knowledge/" itemprop="url">Dart语言基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-25T18:31:42+08:00">
                2019-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hybrid-Develop/" itemprop="url" rel="index">
                    <span itemprop="name">Hybrid Develop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>在Dart中，一切都是对象，一切对象都是class的实例，哪怕是数字类型、方法甚至null都是对象，所有的对象都是继承自Object</li>
<li>虽然Dart是强类型语言，但变量类型是可选的，因为Dart可以自动推断变量类型</li>
<li>Dart支持范型，List&lt;int&gt;表示一个整型的数据列表，List&lt;dynamic&gt;则是一个对象的列表，其中可以装任意对象</li>
<li>Dart支持顶层方法（如main方法），也支持类方法或对象方法，同时你也可以在方法内部创建方法</li>
<li>Dart支持顶层变量，也支持类变量或对象变量</li>
<li>跟Java不同的是，Dart没有public protected private等关键字，如果某个变量以下划线（_）开头，代表这个变量在库中是私有的</li>
<li>Dart中变量可以以字母或下划线开头，后面跟着任意组合的字符或数字</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>以下代码是Dart中定义变量的方法：</p>
<pre><code>main() {
  var a = 1;
  int b = 10;
  String s = &quot;hello&quot;;
  dynamic c = 0.5;

  var count = 10; 
  final Num = count;  // final 只能赋值一次
  const Num1 = 10; // const赋值必须是编译时常量
}
</code></pre><p>你<strong>可以明确指定某个变量的类型，如int bool String，也可以用var或 dynamic来声明一个变量，Dart会自动推断其数据类型</strong>。</p>
<p>使用final或const，不要使用var或其他类型，一个被final修饰的变量只能被赋值一次，一个被const修饰的变量是一个编译时常量（const常量毫无疑问也是final常量）。final 要求变量只能初始化一次，并不要求赋的值一定是编译时常量；而 const 要求在声明时初始化，并且赋值必需为编译时常量。</p>
<p>注意：<strong>没有赋初值的变量都会有默认值null</strong><br>注意：实例变量可以是final的但不能是const的</p>
<h3 id="内建数据类型"><a href="#内建数据类型" class="headerlink" title="内建数据类型"></a>内建数据类型</h3><p>Dart有如下几种内建的数据类型：</p>
<ul>
<li>numbers</li>
<li>strings</li>
<li>booleans</li>
<li>lists(或者是arrays)</li>
<li>maps</li>
<li>runes（UTF-32字符集的字符）</li>
<li><p>symbols<br>下面用一段代码来演示以上各类数据类型：</p>
<pre><code>main() {
  // numbers
  var a = 0;
  int b = 1;
  double c = 0.1;

  // strings
  var s1 = &apos;hello&apos;;
  String s2 = &quot;world&quot;;

  // booleans
  var real = true;
  bool isReal = false;

  // lists
  var arr = [1, 2, 3, 4, 5];
  List&lt;String&gt; arr2 = [&apos;hello&apos;, &apos;world&apos;, &quot;123&quot;, &quot;456&quot;];
  List&lt;dynamic&gt; arr3 = [1, true, &apos;haha&apos;, 1.0];

  // maps
  var map = new Map();
  map[&apos;name&apos;] = &apos;zhangsan&apos;;
  map[&apos;age&apos;] = 10;
  Map m = new Map();
  m[&apos;a&apos;] = &apos;a&apos;;

  //runes，Dart 中 使用runes 来获取UTF-32字符集的字符。String的 codeUnitAt and codeUnit属性可以获取UTF-16字符集的字符
  var clapping = &apos;\u{1f44f}&apos;;
  print(clapping); // 打印的是拍手emoji的表情

  // symbols
  print(#s == new Symbol(&quot;s&quot;)); // true
}
</code></pre></li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Dart是一个面向对象的编程语言，所以即使是<strong>函数也是一个对象</strong>，也有一种类型Function，这就意味着函数可以赋值给某个变量或者作为参数传给另外的函数。虽然Dart推荐你给函数加上返回值，但是不加返回值的函数同样可以正常工作，另外你还可以用=&gt;代替return语句，比如下面的代码：</p>
<pre><code>// 声明返回值
int add(int a, int b) {
  return a + b;
}

// 不声明返回值
add2(int a, int b) {
  return a + b;
}

// =&gt;是return语句的简写
add3(a, b) =&gt; a + b; 

main() {
  print(add(1, 2)); // 3
  print(add2(2, 3)); // 5
  print(add3(1, 2)); // 3
}
</code></pre><h4 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h4><pre><code>sayHello({String name}) {
  print(&quot;hello, my name is $name&quot;);
}

sayHello2({name: String}) {
  print(&quot;hello, my name is $name&quot;);
}

main() {
  // 打印 hello, my name is zhangsan
  sayHello(name: &apos;zhangsan&apos;);

  // 打印 hello, my name is wangwu
  sayHello2(name: &apos;wangwu&apos;);
}
</code></pre><p>可以看到，定义命名参数时，你<strong>可以以 {type paramName} 或者 {paramName: type} 两种方式声明参数</strong>，而调用命名参数时，需要以 funcName(paramName: paramValue) 的形式调用。</p>
<p>命名参数的<strong>参数并不是必须的</strong>，所以上面的代码中，如果调用sayHello()不带任何参数，也是可以的，只不过最后打印出来的结果是：hello, my name is null，在Flutter开发中，你<strong>可以使用@required注解来标识一个命名参数，这代表该参数是必须的</strong>，你不传则会报错，比如下面的代码：</p>
<pre><code>const Scrollbar({Key key, @required Widget child})
</code></pre><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>使用<strong>中括号[]括起来的参数是函数的位置参数，代表该参数可传可不传，位置参数只能放在函数的参数列表的最后面</strong>，如下代码所示：</p>
<pre><code>sayHello(String name, int age, [String hobby]) { // 位置参数可以有多个，比如[String a, int b]
  StringBuffer sb = new StringBuffer();
  sb.write(&quot;hello, this is $name and I am $age years old&quot;);
  if (hobby != null) {
    sb.write(&quot;, my hobby is $hobby&quot;);
  }
  print(sb.toString());
}

main() {
  // hello, this is zhangsan and I am 20 years old
  sayHello(&quot;zhangsan&quot;, 20);
  // hello, this is zhangsan and I am 20 years old, my hobby is play football
  sayHello(&quot;zhangsan&quot;, 20, &quot;play football&quot;);
}
</code></pre><h4 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h4><p>你可以为命名参数或者位置参数设置默认值，如下代码所示：</p>
<pre><code>// 命名参数的默认值
int add({int a, int b = 3}) { // 不能写成：int add({a: int, b: int = 3})
  return a + b;
}

// 位置参数的默认值
int sum(int a, int b, [int c = 3]) {
  return a + b + c;
}
</code></pre><h4 id="main-函数"><a href="#main-函数" class="headerlink" title="main()函数"></a>main()函数</h4><p>不论在Dart还是Flutter中，必须都需要一个顶层的main()函数，它<strong>是整个应用的入口函数，main()函数的返回值是void，还有一个可选的参数，参数类型是List&lt;String&gt;</strong>。</p>
<h4 id="函数作为一类对象"><a href="#函数作为一类对象" class="headerlink" title="函数作为一类对象"></a>函数作为一类对象</h4><p>你可以将一个函数作为参数传给另一个函数，比如下面的代码：</p>
<pre><code>printNum(int a) {
  print(&quot;$a&quot;);
}

main() {
  //  依次打印：
  //  1
  //  2
  //  3
  var arr = [1, 2, 3];
  arr.forEach(printNum);
}
</code></pre><p>你也可以将一个函数赋值给某个变量，比如下面的代码：</p>
<pre><code>printNum(int a) {
  print(&quot;$a&quot;);
}

main() {
  var f1 = printNum;
  Function f2 = printNum;
  var f3 = (int a) =&gt; print(&quot;a = $a&quot;);
  f1(1);
  f2(2);
  f3(6);
}
</code></pre><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><p>大多数函数都是有名称的，比如main() printName()等，但是你也可以写匿名函数，如果你对Java比较熟悉，那下面的Dart代码你肯定也不会陌生：</p>
<pre><code>test(Function callback) {
  callback(&quot;hello&quot;);
}

main() {
  test((param) {
    // 打印hello
    print(param);
  });
}
</code></pre><p>匿名函数类似于Java中的接口，往往在某个函数的参数为函数时使用到。</p>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p><strong>所有的函数都有返回值，如果没有指定return语句，那么该函数的返回值为null</strong></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Dart中的运算符与Java中的类似，比如++a a == b b ? a : b，但是也有一些与Java不太一样的运算符，下面用代码说明：</p>
<pre><code>main() {
  // 与Java相同的运算符操作

  int a = 1;
  ++a;
  a++;
  var b = 1;
  print(a == b);  // false
  print(a * b); // 3
  bool real = false;
  real ? print(&apos;real&apos;) : print(&apos;not real&apos;); // not real
  print(real &amp;&amp; a == b); // false
  print(real || a == 3); // true
  print(a != 2); // true
  print(a &lt;= b); // false
  var c = 9;
  c += 10;
  print(&quot;c = $c&quot;); // c = 19
  print(1&lt;&lt;2); // 4

  // 与Java不太一样的运算符操作

  // is运算符用于判断一个变量是不是某个类型的数据
  // is!则是判断变量不是某个类型的数据
  var s = &quot;hello&quot;;
  print(s is String); // true
  var num = 6;
  print(num is! String); // true

  // ~/才是取整运算符，如果使用/则是除法运算，不取整
  int k = 1;
  int j = 2;
  print(k / j); // 0.5
  print(k ~/ j); // 0

  // as运算符类似于Java中的cast操作，将一个对象强制类型转换
  (emp as Person).teach();

  // ??=运算符 如果 ??= 运算符前面的变量为null，则赋值，否则不赋值
  var param1 = &quot;hello&quot;, param2 = null;
  param1 ??= &quot;world&quot;;
  param2 ??= &quot;world&quot;;
  print(&quot;param1 = $param1&quot;); // param1 = hello
  print(&quot;param2 = $param2&quot;); // param2 = world

  // ?.运算符
  var str1 = &quot;hello world&quot;;
  var str2 = null;
  print(str1?.length); // 11
  print(str2?.length); // null 
  print(str2.length); // 报错
}
</code></pre><h4 id="运算符（级联操作）"><a href="#运算符（级联操作）" class="headerlink" title="..运算符（级联操作）"></a>..运算符（级联操作）</h4><p>如果你对Java中的建造者模式比较熟悉的话，Dart中的..运算符也很好理解，先看下面的代码：</p>
<pre><code>class Person {
  eat() {
    print(&quot;I am eating...&quot;);
  }

  sleep() {
    print(&quot;I am sleeping...&quot;);
  }

  study() {
    print(&quot;I am studying...&quot;);
  }
}

main() {
  // 依次打印
  //  I am eating...
  //  I am sleeping...
  //  I am studying...
  new Person()..eat()
      ..sleep()
      ..study();
}
</code></pre><p>可以看到，使用<strong>..调用某个对象的方法（或者成员变量）时，返回值是这个对象本身</strong>，所以你可以接着使用..调用这个对象的其他方法，这不就类似于Java中的建造者模式，每次build某个属性时，都返回一个this对象吗。</p>
<h3 id="typedefs"><a href="#typedefs" class="headerlink" title="typedefs"></a>typedefs</h3><p>typedef 本质上为 一个方法签名提供了一个别名。官网上介绍TypeDef的时候有一句话说道：<br>“If we change the code to use explicit names and retain type information”<br>使用typedef会保留方法的类型信息。</p>
<p>考虑下面的代码，哪一个没有使用 typedef。</p>
<pre><code>class SortedCollection {
  Function compare;

  SortedCollection(int f(Object a, Object b)) {
    compare = f;
  }
}

 // Initial, broken implementation.
 int sort(Object a, Object b) =&gt; 0;

main() {
  SortedCollection coll = new SortedCollection(sort);

  // All we know is that compare is a function,
  // but what type of function?
  assert(coll.compare is Function);
}
</code></pre><p>当 f 分配到 compare 的时候类型信息丢失了。f的类型是 (Object, Object) → int(→ 意味着返回的)，然而compare 的类型是方法。如果我们使用显式的名字更改代码并保留类型信息，则开发者和工具都可以使用这些信息。</p>
<pre><code>typedef int Compare(Object a, Object b);

class SortedCollection {
  Compare compare;

  SortedCollection(this.compare);
}

 // Initial, broken implementation.
 int sort(Object a, Object b) =&gt; 0;

main() {
  SortedCollection coll = new SortedCollection(sort);
  assert(coll.compare is Function);
  assert(coll.compare is Compare);
}
</code></pre><p>请注意目前 typedefs 仅限于函数类型。</p>
<p>因为 typedefs 是简单的别名，所以它提供了一种方法来检查任何函数的类型。比如：</p>
<pre><code>typedef int Compare(int a, int b);

int sort(int a, int b) =&gt; a - b;

main() {
  assert(sort is Compare); // True!
}
</code></pre><h3 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h3><p>if / else switch for /while try / catch语句跟Java中都类似，<strong>try / catch语句可能稍有不同</strong>，下面用一段代码说明：</p>
<blockquote>
<p>Dart中规定，if中当且仅当参数为bool类型true时，为真，其他全部都为假。</p>
</blockquote>
<pre><code>main() {
  // if else语句
  int score = 80;
  if (score &lt; 60) {
    print(&quot;so bad!&quot;);
  } else if (score &gt;= 60 &amp;&amp; score &lt; 80) {
    print(&quot;just so so!&quot;);
  } else if (score &gt;= 80) {
    print(&quot;good job!&quot;);
  }

  // switch语句
  String a = &quot;hello&quot;;
  // case语句中的数据类型必须是跟switch中的类型一致
  switch (a) {
    case &quot;hello&quot;:
      print(&quot;haha&quot;);
      break;
    case &quot;world&quot;:
      print(&quot;heihei&quot;);
      break;
    default:
      print(&quot;WTF&quot;);
  }

  // for语句
  List&lt;String&gt; list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];
  for (int i = 0; i &lt; list.length; i++) {
    print(list[i]);
  }
  for (var i in list) {
    print(i);
  }
  // 这里的箭头函数参数必须用圆括号扩起来
  list.forEach((item) =&gt; print(item));

  // while语句
  int start = 1;
  int sum = 0;
  while (start &lt;= 100) {
    sum += start;
    start++;
  }
  print(sum);

  // try catch语句
  try {
    print(1 ~/ 0);
  } catch (e) {
    // IntegerDivisionByZeroException
    print(e);
  }
  try {
    1 ~/ 0;
  } on IntegerDivisionByZeroException { // 捕获指定类型的异常
    print(&quot;error&quot;); // 打印出error
  } finally {
    print(&quot;over&quot;); // 打印出over
  }
}
</code></pre><h4 id="rethrow"><a href="#rethrow" class="headerlink" title="rethrow"></a>rethrow</h4><p>rethrow语句用来处理一个异常，同时<strong>希望这个异常能够被其它调用的部分使用</strong>:</p>
<pre><code>final foo = &apos;&apos;;

void misbehave() {
   try {
     foo = &quot;1&quot;;
   } catch (e) {
     print(&apos;2&apos;);
     rethrow;// 如果不重新抛出异常，main函数中的catch语句执行不到
   }
}

void main() {
   try {
     misbehave();
   } catch (e) {
     print(&apos;3&apos;);
   }
}
</code></pre><h3 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h3><h4 id="类的定义与构造方法"><a href="#类的定义与构造方法" class="headerlink" title="类的定义与构造方法"></a>类的定义与构造方法</h4><p>Dart中的类没有访问控制，所以你不需要用private, protected, public等修饰成员变量或成员函数，一个简单的类如下代码所示：</p>
<pre><code>class Person {
  String name;
  int age;
  String gender;
  Person(this.name, this.age, this.gender);
  sayHello() {
    print(&quot;hello, this is $name, I am $age years old, I am a $gender&quot;);
  }
}
</code></pre><p>上面的Person类中有3个成员变量，一个构造方法和一个成员方法，看起来<strong>比较奇怪的是Person的构造方法，里面传入的3个参数都是this.xxx，而且没有大括号{}包裹的方法体</strong>，这种语法是Dart比较独特而简洁的构造方法声明方式，它等同于下面的代码：</p>
<pre><code>Person(String name, int age, String gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
}
</code></pre><p>要调用Person类的成员变量或成员方法，可以用下面的代码：</p>
<pre><code>var p = new Person(&quot;zhangsan&quot;, 20, &quot;male&quot;);
p.sayHello(); // hello, this is zhangsan, I am 20 years old, I am a male
p.age = 50;
p.gender = &quot;female&quot;;
p.sayHello(); // hello, this is zhangsan, I am 50 years old, I am a female
</code></pre><p>类除了有跟类名相同的构造方法外，<strong>还可以添加命名的构造方法</strong>，如下代码所示：</p>
<pre><code>class Point {
  num x, y;
  Point(this.x, this.y);
  // 类的命名构造方法
  Point.origin() {
    x = 0;
    y = 0;
  }
}

main() {
  // 调用Point类的命名构造方法origin()
  var p = new Point.origin();
  var p2 = new Point(1, 2);
}
</code></pre><p>Dart中使用extends关键字做类的继承，如果一个类只有命名的构造方法，在继承时需要注意，如下代码：</p>
<pre><code>class Human {
  String name;
  Human.fromJson(Map data) {
    print(&quot;Human&apos;s fromJson constructor&quot;);
  }
}

class Man extends Human {
  Man.fromJson(Map data) : super.fromJson(data) {
    print(&quot;Man&apos;s fromJson constructor&quot;);
  }
}
</code></pre><p>由于<strong>Human类没有默认构造方法，只有一个命名构造方法fromJson，所以在Man类继承Human类时，需要调用父类的fromJson方法做初始化，而且必须使用Man.fromJson(Map data) : super.fromJson(data)这种写法</strong>，而不是像Java那样将super写到花括号中。Dart语言中，<strong>子类不会继承父类的命名构造函数</strong>。如果不显式提供子类的构造函数，系统就提供默认的构造函数。</p>
<p>有时候你仅仅只是在某个类的构造方法中，调用这个类的另一个构造方法，你可以这么写：</p>
<pre><code>class Point {
  num x, y;
  Point(this.x, this.y);
  // 命名构造方法调用了默认的构造方法
  Point.alongXAxis(num x) : this(x, 0);
}
</code></pre><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>除了调用父类的构造函数，也可以通过初始化列表<strong>在子类的构造函数体前（大括号前）来初始化实例的变量值，使用逗号,分隔</strong>。如下所示：</p>
<pre><code>class Point {
   num x;
   num y;

   Point(this.x, this.y);

   // 初始化列表在构造函数运行前设置实例变量。
   Point.fromJson(Map jsonMap)
   : x = jsonMap[&apos;x&apos;],
     y = jsonMap[&apos;y&apos;] {
      print(&apos;In Point.fromJson(): ($x, $y)&apos;);
   }
 }
</code></pre><p>注意：上述代码，初始化程序无法访问 this 关键字。</p>
<h4 id="类的成员方法"><a href="#类的成员方法" class="headerlink" title="类的成员方法"></a>类的成员方法</h4><p>一个类的成员方法是一个函数，为这个类提供某些行为。上面的代码中已经有了一些类的成员方法的定义，这些定义方式跟Java很类似，你可以为某个类的成员变量提供getter/setter方法，如下代码：</p>
<pre><code>class Rectangle {
  num left, top, width, height;

  // 构造方法传入left, top, width, height几个参数
  Rectangle(this.left, this.top, this.width, this.height);

  // right, bottom两个成员变量提供getter/setter方法
  num get right =&gt; left + width;
  set right(num value) =&gt; left = value - width;
  num get bottom =&gt; top + height;
  set bottom(num value) =&gt; top = value - height;
}
</code></pre><h4 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h4><p>使用abstract修饰一个类，则这个类是抽象类，抽象类中可以有抽象方法和非抽象方法，抽象方法没有方法体，需要子类去实现，如下代码：</p>
<pre><code>abstract class Doer {
  // 抽象方法，没有方法体，需要子类去实现
  void doSomething();
  // 普通的方法
  void greet() {
    print(&quot;hello world!&quot;);
  }
}

class EffectiveDoer extends Doer {
  // 实现了父类的抽象方法
  void doSomething() {
    print(&quot;I&apos;m doing something...&quot;);
  }
}
</code></pre><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>Dart中有类似于C++中的运算符重载语法，比如下面的代码定义了一个向量类，重载了向量的+ -运算：</p>
<pre><code>class Vector {
  num x, y;
  Vector(this.x, this.y);
  Vector operator +(Vector v) =&gt; new Vector(x + v.x, y + v.y);
  Vector operator -(Vector v) =&gt; new Vector(x - v.x, y - v.y);
  printVec() {
    print(&quot;x: $x, y: $y&quot;);
  }
}

main() {
  Vector v1 = new Vector(1, 2);
  Vector v2 = new Vector(3, 4);
  (v1 - v2).printVec(); // -2, -2
  (v1 + v2).printVec(); // 4, 6
}
</code></pre><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><p>使用enum关键字定义一个枚举类，这个语法跟Java类似，如下代码：</p>
<pre><code>enum Color { red, green, blue }
</code></pre><h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p>mixins是一个重复使用类中代码的方式，比如下面的代码：</p>
<pre><code>class A {
  a() {
    print(&quot;A&apos;s a()&quot;);
  }
}

class B {
  b() {
    print(&quot;B&apos;s b()&quot;);
  }
}

// 使用with关键字，表示类C是由类A和类B混合而构成
class C = A with B;

main() {
  C c = new C();
  c.a(); // A&apos;s a()
  c.b(); // B&apos;s b()
}
</code></pre><p>Dart和Java一样只支持单继承。而且Dart中没有和Java一样提供Interface字段去声明一个接口。如果想使用和Java接口一样的功能可以使用Mixins和implements两种方式，分别解释下两种方式：</p>
<ul>
<li><strong>Mixins : 指能够将另一个或多个类的功能添加到您自己的类中，而无需继承这些类</strong></li>
<li><p><strong>implements : 将一个类作为接口使用</strong></p>
<pre><code>class A {
  void a() {
    print(&apos;a&apos;);
  }
}

class B implements A {
  @override
  void a() {
    print(&apos;override a&apos;);
  }
}

class C {
  void c() {
    print(&apos;c&apos;);
  }
}

class E {
  String e = &apos;eeee&apos;;
}

class D extends A with C, E {
  void c() {
    print(&apos;c is D&apos;);
  }

  void d() {
    c();
  }
}
</code></pre></li>
</ul>
<p>首先看B implements A，所以此时A相对于B来说就是一个接口，所以他要实现B中的方法。换句话说，<strong>Dart每个类都是接口</strong></p>
<h4 id="静态成员变量和静态成员方法"><a href="#静态成员变量和静态成员方法" class="headerlink" title="静态成员变量和静态成员方法"></a>静态成员变量和静态成员方法</h4><pre><code>// 类的静态成员变量和静态成员方法
class Cons {
  static const name = &quot;zhangsan&quot;;
  static sayHello() {
    print(&quot;hello, this is ${Cons.name}&quot;);
  }
}

main() {
  Cons.sayHello(); // hello, this is zhangsan
  print(Cons.name); // zhangsan
}
</code></pre><h3 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h3><p>Java和C++语言都有泛型，Dart语言也不例外，使用泛型有很多好处，比如：<br>正确指定泛型类型会产生更好的生成代码。<br>泛型可以减小代码的复杂度<br>Dart内置的数据类型List就是一个泛型数据类型，你可以往List中塞任何你想的数据类型比如整型、字符串、布尔值等</p>
<h3 id="Dart库（Libraries）"><a href="#Dart库（Libraries）" class="headerlink" title="Dart库（Libraries）"></a>Dart库（Libraries）</h3><p>Dart目前已经有很多的库提供给开发者，许多功能不需要开发者自己去实现，只需要导入对应的包即可，使用import语句来导入某个包，比如下面的代码：</p>
<pre><code>import &apos;dart:html&apos;;
</code></pre><p>如果你想导入自己写的某个代码文件，使用相对路径即可，例如当前有一个demo.dart文件，跟该文件同级目录下有个util.dart文件，文件代码如下：</p>
<pre><code>// util.dart文件内容

int add(int a, int b) {
  return a + b;
}
</code></pre><p>在demo.dart文件中如果要引用util.dart文件，使用下面的方式导入：</p>
<pre><code>import &apos;./util.dart&apos;;

main() {
  print(add(1, 2));
}
</code></pre><p>你可以<strong>使用as关键字为导入的某个包设置一个前缀，或者说别名</strong>，比如下面的代码：</p>
<pre><code>import &apos;package:lib1/lib1.dart&apos;;
import &apos;package:lib2/lib2.dart&apos; as lib2;

// Uses Element from lib1.
Element element1 = Element();

// Uses Element from lib2.
lib2.Element element2 = lib2.Element();
</code></pre><p>你也可以在导入包时<strong>使用show hide关键字来导入某个包中的部分功能</strong>，比如下面的代码：</p>
<pre><code>// 只导入foo
import &apos;package:lib1/lib1.dart&apos; show foo;

// 导入除了foo的所有其他部分
import &apos;package:lib2/lib2.dart&apos; hide foo;
</code></pre><p>导入包时使用<strong>deferred as可以让这个包懒加载</strong>，懒加载的包只会在该包被使用时得到加载，而不是一开始就加载，比如下面的代码：</p>
<pre><code>import &apos;package:greetings/hello.dart&apos; deferred as hello;
</code></pre><p>利用<strong>library identifier（库标识符）声明库</strong>：</p>
<pre><code>// 声明库，名ballgame
library ballgame;

// 导入html库
import &apos;dart:html&apos;;

// ...代码从这里开始... 
</code></pre><h4 id="关联文件与库"><a href="#关联文件与库" class="headerlink" title="关联文件与库"></a>关联文件与库</h4><p>添加实现文件，把<strong>part fileUri</strong>放在有库的文件，其中fileURI是实现文件的路径。然后在实现文件中，添加部分标识符（<strong>part of identifier</strong>），其中标识符是库的名称。下面的示例使用的一部分，在三个文件来实现部分库。</p>
<p>第一个文件，ballgame.dart，声明球赛库，导入其他需要的库，并指定ball.dart和util.dart是此库的部分：</p>
<pre><code>library ballgame;

import &apos;dart:html&apos;;
// ...其他导入在这里...

part &apos;ball.dart&apos;;
part &apos;util.dart&apos;;

// ...代码从这里开始...
</code></pre><p>第二、三个文件ball.dart、util.dart，实现了球赛库的一部分：</p>
<pre><code>part of ballgame;

// ...代码从这里开始...
</code></pre><h4 id="重新导出库-Re-exporting-libraries"><a href="#重新导出库-Re-exporting-libraries" class="headerlink" title="重新导出库(Re-exporting libraries)"></a>重新导出库(Re-exporting libraries)</h4><p>可以通过重新导出部分库或者全部库来组合或重新打包库。例如，你可能有实现为一组较小的库集成为一个较大库。或者你可以创建一个库，提供了从另一个库方法的子集:</p>
<pre><code>// In french.dart:
library french;

hello() =&gt; print(&apos;Bonjour!&apos;);
goodbye() =&gt; print(&apos;Au Revoir!&apos;);


// In togo.dart:
library togo;

import &apos;french.dart&apos;;
export &apos;french.dart&apos; show hello;


// In another .dart file:
import &apos;togo.dart&apos;;

void main() {
    hello();   //print bonjour
    goodbye(); //FAIL
}
</code></pre><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>Dart是单线程模型，也就没有了所谓的主线程/子线程之分。</p>
<p>Dart提供了类似ES7中的async await等异步操作，Dart库大多方法返回 Future 和 Stream 对象。这些方法是异步的：它们在设置一个可能的耗时操作（比如 I/O 操作）之后返回，而无需等待操作完成。</p>
<p>async和await往往是成对出现的，如果一个方法中有耗时的操作，你需要将这个方法设置成async，并给其中的耗时操作加上await关键字，如果这个方法有返回值，你需要将返回值塞到Future中并返回，如下代码所示：</p>
<pre><code>Future checkVersion() async {
  var version = await lookUpVersion();
  // Do something with version
}
</code></pre><p>下面的代码使用Dart从网络获取数据并打印出来：</p>
<pre><code>import &apos;dart:async&apos;;
import &apos;package:http/http.dart&apos; as http;

Future&lt;String&gt; getNetData() async{
  http.Response res = await http.get(&quot;https://www.baidu.com&quot;);
  return res.body;
}

main() {
  getNetData().then((str) {
    print(str);
  });
}
</code></pre><h4 id="Even-Looper"><a href="#Even-Looper" class="headerlink" title="Even-Looper"></a>Even-Looper</h4><p>Dart是单线程模型，也就没有了所谓的主线程/子线程之分。<br>Dart也是Event-Looper以及Event-Queue的模型，所有的事件都是通过EventLooper的依次执行。而Dart的Event Loop就是：</p>
<ul>
<li>从EventQueue中获取Event</li>
<li>处理Event</li>
<li>直到EventQueue为空</li>
</ul>
<p><img src="/2019/06/25/dart-knowledge/event-loop.png" alt><br>而这些Event包括了用户输入，点击，Timer，文件IO等</p>
<h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>一旦某个Dart的函数开始执行，它将执行到这个函数结束，也就是<strong>Dart的函数不会被其他Dart代码打断</strong>。</p>
<p>Dart中没有线程的概念，只有isolate，每个isolate都是隔离的，并不会共享内存。而一个Dart程序是在Main isolate的main函数开始，而<strong>在Main函数结束后，Main isolate线程开始一个一个（one by one）的开始处理Event Queue中的每一个Event</strong>。</p>
<p><img src="/2019/06/25/dart-knowledge/event-loop-and-main.png" alt title="Main isolate"></p>
<h4 id="Event-Queue以及Microtask-Queue"><a href="#Event-Queue以及Microtask-Queue" class="headerlink" title="Event Queue以及Microtask Queue"></a>Event Queue以及Microtask Queue</h4><p>Dart中的Main Isolate只有一个Event Looper，但是存在两个Event Queue:Event Queue以及Microtask Queue。</p>
<p><strong><em>Microtask Queue存在的意义是：希望通过这个Queue来处理稍晚一些的事情，但是在下一个消息到来之前需要处理完的事情。</em></strong></p>
<p>当<strong>Event Looper正在处理Microtask Queue中的Event时候，Event Queue中的Event就停止了处理了</strong>，此时App不能绘制任何图形，不能处理任何鼠标点击，不能处理文件IO等等</p>
<p>Event-Looper挑选Task的执行顺序为：1.优先全部执行完Microtask Queue中的Event；2.直到Microtask Queue为空时，才会执行Event Queue中的Event：</p>
<p><img src="/2019/06/25/dart-knowledge/both-queues.png" alt title="both-queues"><br><strong>Dart中只能知道Event处理的先后顺序，但是并不知道某个Event执行的具体时间点，因为它的处理模型是一个单线程循环</strong>，而不是基于时钟调度（即它的执行只是按照Event处理完，就开始循环下一个Event，而与Java中的Thread调度不一样，没有时间调度的概念），也就是我们既是指定另一个Delay Time的Task，希望它在预期的时间后开始执行，它有可能不会在那个时间执行，需要看是否前面的Event是否已经Dequeue。</p>
<h4 id="异步任务调度"><a href="#异步任务调度" class="headerlink" title="异步任务调度"></a>异步任务调度</h4><p>当有代码可以在后续任务执行的时候，有两种方式，通过dart:async这个Lib中的API即可：</p>
<ul>
<li>使用Future类，可以将任务加入到Event Queue的队尾</li>
<li>使用scheduleMicrotask函数，将任务加入到Microtask Queue队尾</li>
</ul>
<p>当使用EventQueue时，需要考虑清楚，<strong>尽量避免microtask queue过于庞大，否则会阻塞其他事件的处理</strong>：</p>
<p><img src="/2019/06/25/dart-knowledge/scheduling-tasks.png" alt title="scheduling-tasks"></p>
<h4 id="使用Future"><a href="#使用Future" class="headerlink" title="使用Future"></a>使用Future</h4><p>一般常用的Future构造函数：</p>
<pre><code>new Future((){
    //  doing something
});
</code></pre><p>而一般常用的还有当有分治任务时，需要将一个大任务拆成很多小任务一步步执行时，就需要使用到Future.then函数来拆解任务</p>
<pre><code>void main(){
new Future(() =&gt; futureTask)  //  异步任务的函数
        .then((m) =&gt; &quot;futueTask execute result:$m&quot;)  //   任务执行完后的子任务
        .then((m) =&gt; m.length)  //  其中m为上个任务执行完后的返回的结果
        .then((m) =&gt; printLength(m))
        .whenComplete(() =&gt; whenTaskCompelete);  //  当所有任务完成后的回调函数
}

int futureTask() {
    return 21; 
}

void printLength(int length) {
    print(&quot;Text Length:$length&quot;);
}

void whenTaskCompelete() {
    print(&quot;Task Complete&quot;);
}
</code></pre><p>当任务需要延迟执行时，可以使用new Future.delay来将任务延迟执行，而如上所述，只有当Main isolate的Event Queue处于Idle的状态时，才会延迟1s执行，否则等待的时间会比1s长很多</p>
<pre><code>new Future.delayed(const Duration(seconds: 1), () =&gt; futureTask);
</code></pre><p>当需要做动画的时候，不要使用Future，而需要使用<a href="https://api.dartlang.org/stable/1.24.3/dart-html/Window/animationFrame.html" target="_blank" rel="noopener">animateFrame</a></p>
<p>PS:</p>
<ul>
<li>Future中的then并没有创建新的Event丢到Event Queue中，而只是一个普通的Function Call，在FutureTask执行完后，立即开始执行</li>
<li>当Future在then函数之前已经执行完成了，则会创建一个task，将该task的添加到microtask queue中，并且该任务将会执行通过then传入的函数</li>
<li>Future只是创建了一个Event，将Event插入到了Event Queue的队尾</li>
<li>使用Future.value构造函数的时候，就会和第二条一样，创建Task丢到microtask Queue中执行then传入的函数</li>
<li>Future.sync构造函数执行了它传入的函数之后，也会立即创建Task丢到microtask Queue中执行</li>
</ul>
<h4 id="使用scheduleMicrotask"><a href="#使用scheduleMicrotask" class="headerlink" title="使用scheduleMicrotask"></a>使用scheduleMicrotask</h4><p>在最顶层的调用关系中，使用该函数即可：</p>
<pre><code>async.scheduleMicrotask(() =&gt; microtask());

void microtask(){
  //  doing something
}
</code></pre><h4 id="使用isolate以及Worker"><a href="#使用isolate以及Worker" class="headerlink" title="使用isolate以及Worker"></a>使用isolate以及Worker</h4><p>当有计算很繁重的任务时，则需要使用isolate或者Worker来执行，以保持App对用户操作的及时响应。Isolate的实现可能是一个单独的线程，或者一个单独的进程，需要看Dart VM是如何实现的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/06aebcad0543" target="_blank" rel="noopener">https://www.jianshu.com/p/06aebcad0543</a><br><a href="https://www.jianshu.com/p/9e5f4c81cc7d" target="_blank" rel="noopener">https://www.jianshu.com/p/9e5f4c81cc7d</a><br><a href="https://www.jianshu.com/p/a4affde4c8ca" target="_blank" rel="noopener">Flutter–Dart中的异步</a><br><a href="https://dart.dev/articles/archive/event-loop" target="_blank" rel="noopener">https://dart.dev/articles/archive/event-loop</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Shuming Zhao">
            
              <p class="site-author-name" itemprop="name">Shuming Zhao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        ﻿<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shuming Zhao</span>

  
</div>

<div class="powered-by"><i class="fa fa-user-md"></i>
<span id="busuanzi_container_site_uv">访客数<span id="busuanzi_value_site_uv"></span>人，
<span id="busuanzi_container_site_pv">访问量<span id="busuanzi_value_site_pv"></span>次</span>
<span class="post-meta-divider">|</span>
</span>
</div>



  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
